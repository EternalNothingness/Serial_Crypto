
zephyr.elf:     file format elf64-x86-64


Disassembly of section .init:

0000000000002000 <_init>:
    2000:	f3 0f 1e fa          	endbr64 
    2004:	48 83 ec 08          	sub    $0x8,%rsp
    2008:	48 8b 05 c1 9f 00 00 	mov    0x9fc1(%rip),%rax        # bfd0 <__gmon_start__>
    200f:	48 85 c0             	test   %rax,%rax
    2012:	74 02                	je     2016 <_init+0x16>
    2014:	ff d0                	callq  *%rax
    2016:	48 83 c4 08          	add    $0x8,%rsp
    201a:	c3                   	retq   

Disassembly of section .plt:

0000000000002020 <.plt>:
    2020:	ff 35 ba 9d 00 00    	pushq  0x9dba(%rip)        # bde0 <_GLOBAL_OFFSET_TABLE_+0x8>
    2026:	f2 ff 25 bb 9d 00 00 	bnd jmpq *0x9dbb(%rip)        # bde8 <_GLOBAL_OFFSET_TABLE_+0x10>
    202d:	0f 1f 00             	nopl   (%rax)
    2030:	f3 0f 1e fa          	endbr64 
    2034:	68 00 00 00 00       	pushq  $0x0
    2039:	f2 e9 e1 ff ff ff    	bnd jmpq 2020 <.plt>
    203f:	90                   	nop
    2040:	f3 0f 1e fa          	endbr64 
    2044:	68 01 00 00 00       	pushq  $0x1
    2049:	f2 e9 d1 ff ff ff    	bnd jmpq 2020 <.plt>
    204f:	90                   	nop
    2050:	f3 0f 1e fa          	endbr64 
    2054:	68 02 00 00 00       	pushq  $0x2
    2059:	f2 e9 c1 ff ff ff    	bnd jmpq 2020 <.plt>
    205f:	90                   	nop
    2060:	f3 0f 1e fa          	endbr64 
    2064:	68 03 00 00 00       	pushq  $0x3
    2069:	f2 e9 b1 ff ff ff    	bnd jmpq 2020 <.plt>
    206f:	90                   	nop
    2070:	f3 0f 1e fa          	endbr64 
    2074:	68 04 00 00 00       	pushq  $0x4
    2079:	f2 e9 a1 ff ff ff    	bnd jmpq 2020 <.plt>
    207f:	90                   	nop
    2080:	f3 0f 1e fa          	endbr64 
    2084:	68 05 00 00 00       	pushq  $0x5
    2089:	f2 e9 91 ff ff ff    	bnd jmpq 2020 <.plt>
    208f:	90                   	nop
    2090:	f3 0f 1e fa          	endbr64 
    2094:	68 06 00 00 00       	pushq  $0x6
    2099:	f2 e9 81 ff ff ff    	bnd jmpq 2020 <.plt>
    209f:	90                   	nop
    20a0:	f3 0f 1e fa          	endbr64 
    20a4:	68 07 00 00 00       	pushq  $0x7
    20a9:	f2 e9 71 ff ff ff    	bnd jmpq 2020 <.plt>
    20af:	90                   	nop
    20b0:	f3 0f 1e fa          	endbr64 
    20b4:	68 08 00 00 00       	pushq  $0x8
    20b9:	f2 e9 61 ff ff ff    	bnd jmpq 2020 <.plt>
    20bf:	90                   	nop
    20c0:	f3 0f 1e fa          	endbr64 
    20c4:	68 09 00 00 00       	pushq  $0x9
    20c9:	f2 e9 51 ff ff ff    	bnd jmpq 2020 <.plt>
    20cf:	90                   	nop
    20d0:	f3 0f 1e fa          	endbr64 
    20d4:	68 0a 00 00 00       	pushq  $0xa
    20d9:	f2 e9 41 ff ff ff    	bnd jmpq 2020 <.plt>
    20df:	90                   	nop
    20e0:	f3 0f 1e fa          	endbr64 
    20e4:	68 0b 00 00 00       	pushq  $0xb
    20e9:	f2 e9 31 ff ff ff    	bnd jmpq 2020 <.plt>
    20ef:	90                   	nop
    20f0:	f3 0f 1e fa          	endbr64 
    20f4:	68 0c 00 00 00       	pushq  $0xc
    20f9:	f2 e9 21 ff ff ff    	bnd jmpq 2020 <.plt>
    20ff:	90                   	nop
    2100:	f3 0f 1e fa          	endbr64 
    2104:	68 0d 00 00 00       	pushq  $0xd
    2109:	f2 e9 11 ff ff ff    	bnd jmpq 2020 <.plt>
    210f:	90                   	nop
    2110:	f3 0f 1e fa          	endbr64 
    2114:	68 0e 00 00 00       	pushq  $0xe
    2119:	f2 e9 01 ff ff ff    	bnd jmpq 2020 <.plt>
    211f:	90                   	nop
    2120:	f3 0f 1e fa          	endbr64 
    2124:	68 0f 00 00 00       	pushq  $0xf
    2129:	f2 e9 f1 fe ff ff    	bnd jmpq 2020 <.plt>
    212f:	90                   	nop
    2130:	f3 0f 1e fa          	endbr64 
    2134:	68 10 00 00 00       	pushq  $0x10
    2139:	f2 e9 e1 fe ff ff    	bnd jmpq 2020 <.plt>
    213f:	90                   	nop
    2140:	f3 0f 1e fa          	endbr64 
    2144:	68 11 00 00 00       	pushq  $0x11
    2149:	f2 e9 d1 fe ff ff    	bnd jmpq 2020 <.plt>
    214f:	90                   	nop
    2150:	f3 0f 1e fa          	endbr64 
    2154:	68 12 00 00 00       	pushq  $0x12
    2159:	f2 e9 c1 fe ff ff    	bnd jmpq 2020 <.plt>
    215f:	90                   	nop
    2160:	f3 0f 1e fa          	endbr64 
    2164:	68 13 00 00 00       	pushq  $0x13
    2169:	f2 e9 b1 fe ff ff    	bnd jmpq 2020 <.plt>
    216f:	90                   	nop
    2170:	f3 0f 1e fa          	endbr64 
    2174:	68 14 00 00 00       	pushq  $0x14
    2179:	f2 e9 a1 fe ff ff    	bnd jmpq 2020 <.plt>
    217f:	90                   	nop
    2180:	f3 0f 1e fa          	endbr64 
    2184:	68 15 00 00 00       	pushq  $0x15
    2189:	f2 e9 91 fe ff ff    	bnd jmpq 2020 <.plt>
    218f:	90                   	nop
    2190:	f3 0f 1e fa          	endbr64 
    2194:	68 16 00 00 00       	pushq  $0x16
    2199:	f2 e9 81 fe ff ff    	bnd jmpq 2020 <.plt>
    219f:	90                   	nop
    21a0:	f3 0f 1e fa          	endbr64 
    21a4:	68 17 00 00 00       	pushq  $0x17
    21a9:	f2 e9 71 fe ff ff    	bnd jmpq 2020 <.plt>
    21af:	90                   	nop
    21b0:	f3 0f 1e fa          	endbr64 
    21b4:	68 18 00 00 00       	pushq  $0x18
    21b9:	f2 e9 61 fe ff ff    	bnd jmpq 2020 <.plt>
    21bf:	90                   	nop
    21c0:	f3 0f 1e fa          	endbr64 
    21c4:	68 19 00 00 00       	pushq  $0x19
    21c9:	f2 e9 51 fe ff ff    	bnd jmpq 2020 <.plt>
    21cf:	90                   	nop
    21d0:	f3 0f 1e fa          	endbr64 
    21d4:	68 1a 00 00 00       	pushq  $0x1a
    21d9:	f2 e9 41 fe ff ff    	bnd jmpq 2020 <.plt>
    21df:	90                   	nop
    21e0:	f3 0f 1e fa          	endbr64 
    21e4:	68 1b 00 00 00       	pushq  $0x1b
    21e9:	f2 e9 31 fe ff ff    	bnd jmpq 2020 <.plt>
    21ef:	90                   	nop
    21f0:	f3 0f 1e fa          	endbr64 
    21f4:	68 1c 00 00 00       	pushq  $0x1c
    21f9:	f2 e9 21 fe ff ff    	bnd jmpq 2020 <.plt>
    21ff:	90                   	nop
    2200:	f3 0f 1e fa          	endbr64 
    2204:	68 1d 00 00 00       	pushq  $0x1d
    2209:	f2 e9 11 fe ff ff    	bnd jmpq 2020 <.plt>
    220f:	90                   	nop
    2210:	f3 0f 1e fa          	endbr64 
    2214:	68 1e 00 00 00       	pushq  $0x1e
    2219:	f2 e9 01 fe ff ff    	bnd jmpq 2020 <.plt>
    221f:	90                   	nop
    2220:	f3 0f 1e fa          	endbr64 
    2224:	68 1f 00 00 00       	pushq  $0x1f
    2229:	f2 e9 f1 fd ff ff    	bnd jmpq 2020 <.plt>
    222f:	90                   	nop
    2230:	f3 0f 1e fa          	endbr64 
    2234:	68 20 00 00 00       	pushq  $0x20
    2239:	f2 e9 e1 fd ff ff    	bnd jmpq 2020 <.plt>
    223f:	90                   	nop
    2240:	f3 0f 1e fa          	endbr64 
    2244:	68 21 00 00 00       	pushq  $0x21
    2249:	f2 e9 d1 fd ff ff    	bnd jmpq 2020 <.plt>
    224f:	90                   	nop
    2250:	f3 0f 1e fa          	endbr64 
    2254:	68 22 00 00 00       	pushq  $0x22
    2259:	f2 e9 c1 fd ff ff    	bnd jmpq 2020 <.plt>
    225f:	90                   	nop
    2260:	f3 0f 1e fa          	endbr64 
    2264:	68 23 00 00 00       	pushq  $0x23
    2269:	f2 e9 b1 fd ff ff    	bnd jmpq 2020 <.plt>
    226f:	90                   	nop
    2270:	f3 0f 1e fa          	endbr64 
    2274:	68 24 00 00 00       	pushq  $0x24
    2279:	f2 e9 a1 fd ff ff    	bnd jmpq 2020 <.plt>
    227f:	90                   	nop
    2280:	f3 0f 1e fa          	endbr64 
    2284:	68 25 00 00 00       	pushq  $0x25
    2289:	f2 e9 91 fd ff ff    	bnd jmpq 2020 <.plt>
    228f:	90                   	nop
    2290:	f3 0f 1e fa          	endbr64 
    2294:	68 26 00 00 00       	pushq  $0x26
    2299:	f2 e9 81 fd ff ff    	bnd jmpq 2020 <.plt>
    229f:	90                   	nop
    22a0:	f3 0f 1e fa          	endbr64 
    22a4:	68 27 00 00 00       	pushq  $0x27
    22a9:	f2 e9 71 fd ff ff    	bnd jmpq 2020 <.plt>
    22af:	90                   	nop
    22b0:	f3 0f 1e fa          	endbr64 
    22b4:	68 28 00 00 00       	pushq  $0x28
    22b9:	f2 e9 61 fd ff ff    	bnd jmpq 2020 <.plt>
    22bf:	90                   	nop
    22c0:	f3 0f 1e fa          	endbr64 
    22c4:	68 29 00 00 00       	pushq  $0x29
    22c9:	f2 e9 51 fd ff ff    	bnd jmpq 2020 <.plt>
    22cf:	90                   	nop
    22d0:	f3 0f 1e fa          	endbr64 
    22d4:	68 2a 00 00 00       	pushq  $0x2a
    22d9:	f2 e9 41 fd ff ff    	bnd jmpq 2020 <.plt>
    22df:	90                   	nop
    22e0:	f3 0f 1e fa          	endbr64 
    22e4:	68 2b 00 00 00       	pushq  $0x2b
    22e9:	f2 e9 31 fd ff ff    	bnd jmpq 2020 <.plt>
    22ef:	90                   	nop
    22f0:	f3 0f 1e fa          	endbr64 
    22f4:	68 2c 00 00 00       	pushq  $0x2c
    22f9:	f2 e9 21 fd ff ff    	bnd jmpq 2020 <.plt>
    22ff:	90                   	nop
    2300:	f3 0f 1e fa          	endbr64 
    2304:	68 2d 00 00 00       	pushq  $0x2d
    2309:	f2 e9 11 fd ff ff    	bnd jmpq 2020 <.plt>
    230f:	90                   	nop
    2310:	f3 0f 1e fa          	endbr64 
    2314:	68 2e 00 00 00       	pushq  $0x2e
    2319:	f2 e9 01 fd ff ff    	bnd jmpq 2020 <.plt>
    231f:	90                   	nop
    2320:	f3 0f 1e fa          	endbr64 
    2324:	68 2f 00 00 00       	pushq  $0x2f
    2329:	f2 e9 f1 fc ff ff    	bnd jmpq 2020 <.plt>
    232f:	90                   	nop
    2330:	f3 0f 1e fa          	endbr64 
    2334:	68 30 00 00 00       	pushq  $0x30
    2339:	f2 e9 e1 fc ff ff    	bnd jmpq 2020 <.plt>
    233f:	90                   	nop
    2340:	f3 0f 1e fa          	endbr64 
    2344:	68 31 00 00 00       	pushq  $0x31
    2349:	f2 e9 d1 fc ff ff    	bnd jmpq 2020 <.plt>
    234f:	90                   	nop
    2350:	f3 0f 1e fa          	endbr64 
    2354:	68 32 00 00 00       	pushq  $0x32
    2359:	f2 e9 c1 fc ff ff    	bnd jmpq 2020 <.plt>
    235f:	90                   	nop
    2360:	f3 0f 1e fa          	endbr64 
    2364:	68 33 00 00 00       	pushq  $0x33
    2369:	f2 e9 b1 fc ff ff    	bnd jmpq 2020 <.plt>
    236f:	90                   	nop
    2370:	f3 0f 1e fa          	endbr64 
    2374:	68 34 00 00 00       	pushq  $0x34
    2379:	f2 e9 a1 fc ff ff    	bnd jmpq 2020 <.plt>
    237f:	90                   	nop

Disassembly of section .plt.got:

0000000000002380 <__cxa_finalize@plt>:
    2380:	f3 0f 1e fa          	endbr64 
    2384:	f2 ff 25 5d 9c 00 00 	bnd jmpq *0x9c5d(%rip)        # bfe8 <__cxa_finalize@GLIBC_2.2.5>
    238b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .plt.sec:

0000000000002390 <ptsname@plt>:
    2390:	f3 0f 1e fa          	endbr64 
    2394:	f2 ff 25 55 9a 00 00 	bnd jmpq *0x9a55(%rip)        # bdf0 <ptsname@GLIBC_2.2.5>
    239b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023a0 <__snprintf_chk@plt>:
    23a0:	f3 0f 1e fa          	endbr64 
    23a4:	f2 ff 25 4d 9a 00 00 	bnd jmpq *0x9a4d(%rip)        # bdf8 <__snprintf_chk@GLIBC_2.3.4>
    23ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023b0 <free@plt>:
    23b0:	f3 0f 1e fa          	endbr64 
    23b4:	f2 ff 25 45 9a 00 00 	bnd jmpq *0x9a45(%rip)        # be00 <free@GLIBC_2.2.5>
    23bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023c0 <pthread_create@plt>:
    23c0:	f3 0f 1e fa          	endbr64 
    23c4:	f2 ff 25 3d 9a 00 00 	bnd jmpq *0x9a3d(%rip)        # be08 <pthread_create@GLIBC_2.2.5>
    23cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023d0 <strcasecmp@plt>:
    23d0:	f3 0f 1e fa          	endbr64 
    23d4:	f2 ff 25 35 9a 00 00 	bnd jmpq *0x9a35(%rip)        # be10 <strcasecmp@GLIBC_2.2.5>
    23db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023e0 <pthread_detach@plt>:
    23e0:	f3 0f 1e fa          	endbr64 
    23e4:	f2 ff 25 2d 9a 00 00 	bnd jmpq *0x9a2d(%rip)        # be18 <pthread_detach@GLIBC_2.2.5>
    23eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023f0 <__vfprintf_chk@plt>:
    23f0:	f3 0f 1e fa          	endbr64 
    23f4:	f2 ff 25 25 9a 00 00 	bnd jmpq *0x9a25(%rip)        # be20 <__vfprintf_chk@GLIBC_2.3.4>
    23fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002400 <__errno_location@plt>:
    2400:	f3 0f 1e fa          	endbr64 
    2404:	f2 ff 25 1d 9a 00 00 	bnd jmpq *0x9a1d(%rip)        # be28 <__errno_location@GLIBC_2.2.5>
    240b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002410 <pthread_cond_broadcast@plt>:
    2410:	f3 0f 1e fa          	endbr64 
    2414:	f2 ff 25 15 9a 00 00 	bnd jmpq *0x9a15(%rip)        # be30 <pthread_cond_broadcast@GLIBC_2.3.2>
    241b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002420 <pthread_cancel@plt>:
    2420:	f3 0f 1e fa          	endbr64 
    2424:	f2 ff 25 0d 9a 00 00 	bnd jmpq *0x9a0d(%rip)        # be38 <pthread_cancel@GLIBC_2.2.5>
    242b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002430 <isatty@plt>:
    2430:	f3 0f 1e fa          	endbr64 
    2434:	f2 ff 25 05 9a 00 00 	bnd jmpq *0x9a05(%rip)        # be40 <isatty@GLIBC_2.2.5>
    243b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002440 <sigaction@plt>:
    2440:	f3 0f 1e fa          	endbr64 
    2444:	f2 ff 25 fd 99 00 00 	bnd jmpq *0x99fd(%rip)        # be48 <sigaction@GLIBC_2.2.5>
    244b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002450 <__pthread_register_cancel@plt>:
    2450:	f3 0f 1e fa          	endbr64 
    2454:	f2 ff 25 f5 99 00 00 	bnd jmpq *0x99f5(%rip)        # be50 <__pthread_register_cancel@GLIBC_2.3.3>
    245b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002460 <strtod@plt>:
    2460:	f3 0f 1e fa          	endbr64 
    2464:	f2 ff 25 ed 99 00 00 	bnd jmpq *0x99ed(%rip)        # be58 <strtod@GLIBC_2.2.5>
    246b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002470 <fcntl@plt>:
    2470:	f3 0f 1e fa          	endbr64 
    2474:	f2 ff 25 e5 99 00 00 	bnd jmpq *0x99e5(%rip)        # be60 <fcntl@GLIBC_2.2.5>
    247b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002480 <clock_gettime@plt>:
    2480:	f3 0f 1e fa          	endbr64 
    2484:	f2 ff 25 dd 99 00 00 	bnd jmpq *0x99dd(%rip)        # be68 <clock_gettime@GLIBC_2.17>
    248b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002490 <write@plt>:
    2490:	f3 0f 1e fa          	endbr64 
    2494:	f2 ff 25 d5 99 00 00 	bnd jmpq *0x99d5(%rip)        # be70 <write@GLIBC_2.2.5>
    249b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024a0 <pthread_cond_wait@plt>:
    24a0:	f3 0f 1e fa          	endbr64 
    24a4:	f2 ff 25 cd 99 00 00 	bnd jmpq *0x99cd(%rip)        # be78 <pthread_cond_wait@GLIBC_2.3.2>
    24ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024b0 <__stack_chk_fail@plt>:
    24b0:	f3 0f 1e fa          	endbr64 
    24b4:	f2 ff 25 c5 99 00 00 	bnd jmpq *0x99c5(%rip)        # be80 <__stack_chk_fail@GLIBC_2.4>
    24bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024c0 <system@plt>:
    24c0:	f3 0f 1e fa          	endbr64 
    24c4:	f2 ff 25 bd 99 00 00 	bnd jmpq *0x99bd(%rip)        # be88 <system@GLIBC_2.2.5>
    24cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024d0 <snprintf@plt>:
    24d0:	f3 0f 1e fa          	endbr64 
    24d4:	f2 ff 25 b5 99 00 00 	bnd jmpq *0x99b5(%rip)        # be90 <snprintf@GLIBC_2.2.5>
    24db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024e0 <nanosleep@plt>:
    24e0:	f3 0f 1e fa          	endbr64 
    24e4:	f2 ff 25 ad 99 00 00 	bnd jmpq *0x99ad(%rip)        # be98 <nanosleep@GLIBC_2.2.5>
    24eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024f0 <strnlen@plt>:
    24f0:	f3 0f 1e fa          	endbr64 
    24f4:	f2 ff 25 a5 99 00 00 	bnd jmpq *0x99a5(%rip)        # bea0 <strnlen@GLIBC_2.2.5>
    24fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002500 <close@plt>:
    2500:	f3 0f 1e fa          	endbr64 
    2504:	f2 ff 25 9d 99 00 00 	bnd jmpq *0x999d(%rip)        # bea8 <close@GLIBC_2.2.5>
    250b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002510 <read@plt>:
    2510:	f3 0f 1e fa          	endbr64 
    2514:	f2 ff 25 95 99 00 00 	bnd jmpq *0x9995(%rip)        # beb0 <read@GLIBC_2.2.5>
    251b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002520 <strtoull@plt>:
    2520:	f3 0f 1e fa          	endbr64 
    2524:	f2 ff 25 8d 99 00 00 	bnd jmpq *0x998d(%rip)        # beb8 <strtoull@GLIBC_2.2.5>
    252b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002530 <calloc@plt>:
    2530:	f3 0f 1e fa          	endbr64 
    2534:	f2 ff 25 85 99 00 00 	bnd jmpq *0x9985(%rip)        # bec0 <calloc@GLIBC_2.2.5>
    253b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002540 <strcmp@plt>:
    2540:	f3 0f 1e fa          	endbr64 
    2544:	f2 ff 25 7d 99 00 00 	bnd jmpq *0x997d(%rip)        # bec8 <strcmp@GLIBC_2.2.5>
    254b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002550 <strtoll@plt>:
    2550:	f3 0f 1e fa          	endbr64 
    2554:	f2 ff 25 75 99 00 00 	bnd jmpq *0x9975(%rip)        # bed0 <strtoll@GLIBC_2.2.5>
    255b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002560 <unlockpt@plt>:
    2560:	f3 0f 1e fa          	endbr64 
    2564:	f2 ff 25 6d 99 00 00 	bnd jmpq *0x996d(%rip)        # bed8 <unlockpt@GLIBC_2.2.5>
    256b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002570 <__memcpy_chk@plt>:
    2570:	f3 0f 1e fa          	endbr64 
    2574:	f2 ff 25 65 99 00 00 	bnd jmpq *0x9965(%rip)        # bee0 <__memcpy_chk@GLIBC_2.3.4>
    257b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002580 <sigemptyset@plt>:
    2580:	f3 0f 1e fa          	endbr64 
    2584:	f2 ff 25 5d 99 00 00 	bnd jmpq *0x995d(%rip)        # bee8 <sigemptyset@GLIBC_2.2.5>
    258b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002590 <strtol@plt>:
    2590:	f3 0f 1e fa          	endbr64 
    2594:	f2 ff 25 55 99 00 00 	bnd jmpq *0x9955(%rip)        # bef0 <strtol@GLIBC_2.2.5>
    259b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025a0 <pthread_mutex_unlock@plt>:
    25a0:	f3 0f 1e fa          	endbr64 
    25a4:	f2 ff 25 4d 99 00 00 	bnd jmpq *0x994d(%rip)        # bef8 <pthread_mutex_unlock@GLIBC_2.2.5>
    25ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025b0 <pthread_exit@plt>:
    25b0:	f3 0f 1e fa          	endbr64 
    25b4:	f2 ff 25 45 99 00 00 	bnd jmpq *0x9945(%rip)        # bf00 <pthread_exit@GLIBC_2.2.5>
    25bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025c0 <malloc@plt>:
    25c0:	f3 0f 1e fa          	endbr64 
    25c4:	f2 ff 25 3d 99 00 00 	bnd jmpq *0x993d(%rip)        # bf08 <malloc@GLIBC_2.2.5>
    25cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025d0 <realloc@plt>:
    25d0:	f3 0f 1e fa          	endbr64 
    25d4:	f2 ff 25 35 99 00 00 	bnd jmpq *0x9935(%rip)        # bf10 <realloc@GLIBC_2.2.5>
    25db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025e0 <setvbuf@plt>:
    25e0:	f3 0f 1e fa          	endbr64 
    25e4:	f2 ff 25 2d 99 00 00 	bnd jmpq *0x992d(%rip)        # bf18 <setvbuf@GLIBC_2.2.5>
    25eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025f0 <pthread_self@plt>:
    25f0:	f3 0f 1e fa          	endbr64 
    25f4:	f2 ff 25 25 99 00 00 	bnd jmpq *0x9925(%rip)        # bf20 <pthread_self@GLIBC_2.2.5>
    25fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002600 <tcgetattr@plt>:
    2600:	f3 0f 1e fa          	endbr64 
    2604:	f2 ff 25 1d 99 00 00 	bnd jmpq *0x991d(%rip)        # bf28 <tcgetattr@GLIBC_2.2.5>
    260b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002610 <tcsetattr@plt>:
    2610:	f3 0f 1e fa          	endbr64 
    2614:	f2 ff 25 15 99 00 00 	bnd jmpq *0x9915(%rip)        # bf30 <tcsetattr@GLIBC_2.2.5>
    261b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002620 <strtoul@plt>:
    2620:	f3 0f 1e fa          	endbr64 
    2624:	f2 ff 25 0d 99 00 00 	bnd jmpq *0x990d(%rip)        # bf38 <strtoul@GLIBC_2.2.5>
    262b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002630 <grantpt@plt>:
    2630:	f3 0f 1e fa          	endbr64 
    2634:	f2 ff 25 05 99 00 00 	bnd jmpq *0x9905(%rip)        # bf40 <grantpt@GLIBC_2.2.5>
    263b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002640 <__memset_chk@plt>:
    2640:	f3 0f 1e fa          	endbr64 
    2644:	f2 ff 25 fd 98 00 00 	bnd jmpq *0x98fd(%rip)        # bf48 <__memset_chk@GLIBC_2.3.4>
    264b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002650 <__pthread_unwind_next@plt>:
    2650:	f3 0f 1e fa          	endbr64 
    2654:	f2 ff 25 f5 98 00 00 	bnd jmpq *0x98f5(%rip)        # bf50 <__pthread_unwind_next@GLIBC_2.3.3>
    265b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002660 <exit@plt>:
    2660:	f3 0f 1e fa          	endbr64 
    2664:	f2 ff 25 ed 98 00 00 	bnd jmpq *0x98ed(%rip)        # bf58 <exit@GLIBC_2.2.5>
    266b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002670 <__fprintf_chk@plt>:
    2670:	f3 0f 1e fa          	endbr64 
    2674:	f2 ff 25 e5 98 00 00 	bnd jmpq *0x98e5(%rip)        # bf60 <__fprintf_chk@GLIBC_2.3.4>
    267b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002680 <__sigsetjmp@plt>:
    2680:	f3 0f 1e fa          	endbr64 
    2684:	f2 ff 25 dd 98 00 00 	bnd jmpq *0x98dd(%rip)        # bf68 <__sigsetjmp@GLIBC_2.2.5>
    268b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002690 <posix_openpt@plt>:
    2690:	f3 0f 1e fa          	endbr64 
    2694:	f2 ff 25 d5 98 00 00 	bnd jmpq *0x98d5(%rip)        # bf70 <posix_openpt@GLIBC_2.2.5>
    269b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026a0 <sleep@plt>:
    26a0:	f3 0f 1e fa          	endbr64 
    26a4:	f2 ff 25 cd 98 00 00 	bnd jmpq *0x98cd(%rip)        # bf78 <sleep@GLIBC_2.2.5>
    26ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026b0 <pthread_mutex_lock@plt>:
    26b0:	f3 0f 1e fa          	endbr64 
    26b4:	f2 ff 25 c5 98 00 00 	bnd jmpq *0x98c5(%rip)        # bf80 <pthread_mutex_lock@GLIBC_2.2.5>
    26bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026c0 <__ctype_b_loc@plt>:
    26c0:	f3 0f 1e fa          	endbr64 
    26c4:	f2 ff 25 bd 98 00 00 	bnd jmpq *0x98bd(%rip)        # bf88 <__ctype_b_loc@GLIBC_2.3>
    26cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026d0 <__sprintf_chk@plt>:
    26d0:	f3 0f 1e fa          	endbr64 
    26d4:	f2 ff 25 b5 98 00 00 	bnd jmpq *0x98b5(%rip)        # bf90 <__sprintf_chk@GLIBC_2.3.4>
    26db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .text:

00000000000026e0 <_start>:
    26e0:	f3 0f 1e fa          	endbr64 
    26e4:	31 ed                	xor    %ebp,%ebp
    26e6:	49 89 d1             	mov    %rdx,%r9
    26e9:	5e                   	pop    %rsi
    26ea:	48 89 e2             	mov    %rsp,%rdx
    26ed:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    26f1:	50                   	push   %rax
    26f2:	54                   	push   %rsp
    26f3:	4c 8d 05 46 01 00 00 	lea    0x146(%rip),%r8        # 2840 <__libc_csu_fini>
    26fa:	48 8d 0d cf 00 00 00 	lea    0xcf(%rip),%rcx        # 27d0 <__libc_csu_init>
    2701:	48 8d 3d 6b 3f 00 00 	lea    0x3f6b(%rip),%rdi        # 6673 <main>
    2708:	ff 15 ba 98 00 00    	callq  *0x98ba(%rip)        # bfc8 <__libc_start_main@GLIBC_2.2.5>
    270e:	f4                   	hlt    
    270f:	90                   	nop

0000000000002710 <deregister_tm_clones>:
    2710:	48 8d 3d 69 9d 00 00 	lea    0x9d69(%rip),%rdi        # c480 <__TMC_END__>
    2717:	48 8d 05 62 9d 00 00 	lea    0x9d62(%rip),%rax        # c480 <__TMC_END__>
    271e:	48 39 f8             	cmp    %rdi,%rax
    2721:	74 15                	je     2738 <deregister_tm_clones+0x28>
    2723:	48 8b 05 76 98 00 00 	mov    0x9876(%rip),%rax        # bfa0 <_ITM_deregisterTMCloneTable>
    272a:	48 85 c0             	test   %rax,%rax
    272d:	74 09                	je     2738 <deregister_tm_clones+0x28>
    272f:	ff e0                	jmpq   *%rax
    2731:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2738:	c3                   	retq   
    2739:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002740 <register_tm_clones>:
    2740:	48 8d 3d 39 9d 00 00 	lea    0x9d39(%rip),%rdi        # c480 <__TMC_END__>
    2747:	48 8d 35 32 9d 00 00 	lea    0x9d32(%rip),%rsi        # c480 <__TMC_END__>
    274e:	48 29 fe             	sub    %rdi,%rsi
    2751:	48 89 f0             	mov    %rsi,%rax
    2754:	48 c1 ee 3f          	shr    $0x3f,%rsi
    2758:	48 c1 f8 03          	sar    $0x3,%rax
    275c:	48 01 c6             	add    %rax,%rsi
    275f:	48 d1 fe             	sar    %rsi
    2762:	74 14                	je     2778 <register_tm_clones+0x38>
    2764:	48 8b 05 75 98 00 00 	mov    0x9875(%rip),%rax        # bfe0 <_ITM_registerTMCloneTable>
    276b:	48 85 c0             	test   %rax,%rax
    276e:	74 08                	je     2778 <register_tm_clones+0x38>
    2770:	ff e0                	jmpq   *%rax
    2772:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2778:	c3                   	retq   
    2779:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002780 <__do_global_dtors_aux>:
    2780:	f3 0f 1e fa          	endbr64 
    2784:	80 3d 21 ce 00 00 00 	cmpb   $0x0,0xce21(%rip)        # f5ac <completed.8060>
    278b:	75 2b                	jne    27b8 <__do_global_dtors_aux+0x38>
    278d:	55                   	push   %rbp
    278e:	48 83 3d 52 98 00 00 	cmpq   $0x0,0x9852(%rip)        # bfe8 <__cxa_finalize@GLIBC_2.2.5>
    2795:	00 
    2796:	48 89 e5             	mov    %rsp,%rbp
    2799:	74 0c                	je     27a7 <__do_global_dtors_aux+0x27>
    279b:	48 8b 3d 9e 9c 00 00 	mov    0x9c9e(%rip),%rdi        # c440 <__dso_handle>
    27a2:	e8 d9 fb ff ff       	callq  2380 <__cxa_finalize@plt>
    27a7:	e8 64 ff ff ff       	callq  2710 <deregister_tm_clones>
    27ac:	c6 05 f9 cd 00 00 01 	movb   $0x1,0xcdf9(%rip)        # f5ac <completed.8060>
    27b3:	5d                   	pop    %rbp
    27b4:	c3                   	retq   
    27b5:	0f 1f 00             	nopl   (%rax)
    27b8:	c3                   	retq   
    27b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000027c0 <frame_dummy>:
    27c0:	f3 0f 1e fa          	endbr64 
    27c4:	e9 77 ff ff ff       	jmpq   2740 <register_tm_clones>
    27c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000027d0 <__libc_csu_init>:
    27d0:	f3 0f 1e fa          	endbr64 
    27d4:	41 57                	push   %r15
    27d6:	4c 8d 3d 73 93 00 00 	lea    0x9373(%rip),%r15        # bb50 <__frame_dummy_init_array_entry>
    27dd:	41 56                	push   %r14
    27df:	49 89 d6             	mov    %rdx,%r14
    27e2:	41 55                	push   %r13
    27e4:	49 89 f5             	mov    %rsi,%r13
    27e7:	41 54                	push   %r12
    27e9:	41 89 fc             	mov    %edi,%r12d
    27ec:	55                   	push   %rbp
    27ed:	48 8d 2d 64 93 00 00 	lea    0x9364(%rip),%rbp        # bb58 <__do_global_dtors_aux_fini_array_entry>
    27f4:	53                   	push   %rbx
    27f5:	4c 29 fd             	sub    %r15,%rbp
    27f8:	48 83 ec 08          	sub    $0x8,%rsp
    27fc:	e8 ff f7 ff ff       	callq  2000 <_init>
    2801:	48 c1 fd 03          	sar    $0x3,%rbp
    2805:	74 1f                	je     2826 <__libc_csu_init+0x56>
    2807:	31 db                	xor    %ebx,%ebx
    2809:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2810:	4c 89 f2             	mov    %r14,%rdx
    2813:	4c 89 ee             	mov    %r13,%rsi
    2816:	44 89 e7             	mov    %r12d,%edi
    2819:	41 ff 14 df          	callq  *(%r15,%rbx,8)
    281d:	48 83 c3 01          	add    $0x1,%rbx
    2821:	48 39 dd             	cmp    %rbx,%rbp
    2824:	75 ea                	jne    2810 <__libc_csu_init+0x40>
    2826:	48 83 c4 08          	add    $0x8,%rsp
    282a:	5b                   	pop    %rbx
    282b:	5d                   	pop    %rbp
    282c:	41 5c                	pop    %r12
    282e:	41 5d                	pop    %r13
    2830:	41 5e                	pop    %r14
    2832:	41 5f                	pop    %r15
    2834:	c3                   	retq   
    2835:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    283c:	00 00 00 00 

0000000000002840 <__libc_csu_fini>:
    2840:	f3 0f 1e fa          	endbr64 
    2844:	c3                   	retq   

0000000000002845 <z_impl_uart_poll_in>:
				      unsigned char *p_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	return api->poll_in(dev, p_char);
    2845:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2849:	ff 20                	jmpq   *(%rax)

000000000000284b <k_msgq_put.constprop.0>:
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_PUT);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_put(msgq, data, timeout);
    284b:	e9 cd 54 00 00       	jmpq   7d1d <z_impl_k_msgq_put>

0000000000002850 <k_usleep.constprop.0>:
	return z_impl_k_usleep(us);
    2850:	bf 01 00 00 00       	mov    $0x1,%edi
    2855:	e9 b6 5e 00 00       	jmpq   8710 <z_impl_k_usleep>

000000000000285a <uart_out>:
	}

	return; // sollte nie geschehen
}

void uart_out(void *ptr1, void *ptr2, void *ptr3){
    285a:	f3 0f 1e fa          	endbr64 
    285e:	41 57                	push   %r15
	// ## setup area ##
	ARG_UNUSED(ptr1);
	ARG_UNUSED(ptr2);
	ARG_UNUSED(ptr3);

	char *output=malloc(DATA_SIZE_MAX*sizeof(char));
    2860:	bf ff 00 00 00       	mov    $0xff,%edi
void uart_out(void *ptr1, void *ptr2, void *ptr3){
    2865:	41 56                	push   %r14
    2867:	41 55                	push   %r13
    2869:	41 54                	push   %r12
    286b:	55                   	push   %rbp
    286c:	53                   	push   %rbx
    286d:	50                   	push   %rax
	char *output=malloc(DATA_SIZE_MAX*sizeof(char));
    286e:	e8 4d fd ff ff       	callq  25c0 <malloc@plt>
    2873:	48 89 c5             	mov    %rax,%rbp

	// ## main loop ##
	for(;;){
		memset(output, 0, strlen(output)); // Inhalt resetten
    2876:	31 c0                	xor    %eax,%eax
    2878:	48 89 ef             	mov    %rbp,%rdi
    287b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    287f:	31 f6                	xor    %esi,%esi
    2881:	f2 ae                	repnz scas %es:(%rdi),%al
    2883:	48 89 ef             	mov    %rbp,%rdi
    2886:	48 89 c8             	mov    %rcx,%rax
    2889:	b9 ff 00 00 00       	mov    $0xff,%ecx
    288e:	48 f7 d0             	not    %rax
    2891:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    2895:	e8 a6 fd ff ff       	callq  2640 <__memset_chk@plt>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
    289a:	48 8d 3d 2f c2 00 00 	lea    0xc22f(%rip),%rdi        # ead0 <uart_msgq>
    28a1:	31 d2                	xor    %edx,%edx
    28a3:	48 89 ee             	mov    %rbp,%rsi
    28a6:	e8 69 55 00 00       	callq  7e14 <z_impl_k_msgq_get>
    28ab:	41 89 c5             	mov    %eax,%r13d
		if(k_msgq_get(&uart_msgq, output, K_NO_WAIT)==0){ // Abfrage der uart message queue
    28ae:	85 c0                	test   %eax,%eax
    28b0:	0f 85 b6 00 00 00    	jne    296c <uart_out+0x112>
			printk("Going to send data to the uart: <%s>\n", output);
    28b6:	48 89 ee             	mov    %rbp,%rsi
    28b9:	48 8d 3d ec 6a 00 00 	lea    0x6aec(%rip),%rdi        # 93ac <default_cmd+0x14c>
    28c0:	31 c0                	xor    %eax,%eax
    28c2:	e8 af 07 00 00       	callq  3076 <printk>
			for(int i=0; i<strlen(output); i++){ // Send data byte by byte
    28c7:	31 db                	xor    %ebx,%ebx
    28c9:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    28cd:	48 89 ef             	mov    %rbp,%rdi
    28d0:	4d 63 fd             	movslq %r13d,%r15
    28d3:	89 d8                	mov    %ebx,%eax
    28d5:	f2 ae                	repnz scas %es:(%rdi),%al
    28d7:	48 f7 d1             	not    %rcx
    28da:	48 ff c9             	dec    %rcx
    28dd:	49 39 cf             	cmp    %rcx,%r15
    28e0:	73 7e                	jae    2960 <uart_out+0x106>
				uart_poll_out(uart_dev, *(output+i));
    28e2:	4c 8d 35 97 cb 00 00 	lea    0xcb97(%rip),%r14        # f480 <uart_dev>
    28e9:	4e 8d 64 3d 00       	lea    0x0(%rbp,%r15,1),%r12
    28ee:	41 0f b6 34 24       	movzbl (%r12),%esi
    28f3:	49 8b 3e             	mov    (%r14),%rdi
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    28f6:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    28fa:	ff 52 08             	callq  *0x8(%rdx)
				printk("Sent byte: <0x%x>\n", *(output+i));
    28fd:	41 0f be 34 24       	movsbl (%r12),%esi
    2902:	48 8d 3d c9 6a 00 00 	lea    0x6ac9(%rip),%rdi        # 93d2 <default_cmd+0x172>
    2909:	31 c0                	xor    %eax,%eax
    290b:	e8 66 07 00 00       	callq  3076 <printk>
				if(i==strlen(output)-1 && send_termination==true){
    2910:	89 d8                	mov    %ebx,%eax
    2912:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    2916:	48 89 ef             	mov    %rbp,%rdi
    2919:	f2 ae                	repnz scas %es:(%rdi),%al
    291b:	48 89 cb             	mov    %rcx,%rbx
    291e:	48 f7 d3             	not    %rbx
    2921:	48 83 eb 02          	sub    $0x2,%rbx
    2925:	4c 39 fb             	cmp    %r15,%rbx
    2928:	75 29                	jne    2953 <uart_out+0xf9>
    292a:	48 8d 1d 7d cc 00 00 	lea    0xcc7d(%rip),%rbx        # f5ae <send_termination>
    2931:	80 3b 00             	cmpb   $0x0,(%rbx)
    2934:	74 1d                	je     2953 <uart_out+0xf9>
					uart_poll_out(uart_dev, 0);
    2936:	49 8b 3e             	mov    (%r14),%rdi
    2939:	48 8b 47 10          	mov    0x10(%rdi),%rax
    293d:	31 f6                	xor    %esi,%esi
    293f:	ff 50 08             	callq  *0x8(%rax)
					printk("Sent 0-termination\n");
    2942:	48 8d 3d 9c 6a 00 00 	lea    0x6a9c(%rip),%rdi        # 93e5 <default_cmd+0x185>
    2949:	31 c0                	xor    %eax,%eax
    294b:	e8 26 07 00 00       	callq  3076 <printk>
					send_termination = false;
    2950:	c6 03 00             	movb   $0x0,(%rbx)
				}
				k_usleep(1); // Abgeben des Prozessors
    2953:	e8 f8 fe ff ff       	callq  2850 <k_usleep.constprop.0>
			for(int i=0; i<strlen(output); i++){ // Send data byte by byte
    2958:	41 ff c5             	inc    %r13d
    295b:	e9 67 ff ff ff       	jmpq   28c7 <uart_out+0x6d>
			}
			printk("Finished transmission\n\n");
    2960:	48 8d 3d 92 6a 00 00 	lea    0x6a92(%rip),%rdi        # 93f9 <default_cmd+0x199>
    2967:	e8 0a 07 00 00       	callq  3076 <printk>
		}
		k_usleep(1); // Abgeben des Prozessors
    296c:	e8 df fe ff ff       	callq  2850 <k_usleep.constprop.0>
		memset(output, 0, strlen(output)); // Inhalt resetten
    2971:	e9 00 ff ff ff       	jmpq   2876 <uart_out+0x1c>

0000000000002976 <uart_in>:
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    2976:	f3 0f 1e fa          	endbr64 
    297a:	41 57                	push   %r15
	uint8_t *data = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    297c:	bf ff 00 00 00       	mov    $0xff,%edi
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    2981:	41 56                	push   %r14
    2983:	41 55                	push   %r13
    2985:	41 54                	push   %r12
    2987:	55                   	push   %rbp
    2988:	53                   	push   %rbx
	uint8_t len = 0;
    2989:	31 db                	xor    %ebx,%ebx
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    298b:	48 83 ec 18          	sub    $0x18,%rsp
    298f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2996:	00 00 
    2998:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    299d:	31 c0                	xor    %eax,%eax
	uint8_t *data = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    299f:	e8 1c fc ff ff       	callq  25c0 <malloc@plt>
		switch(state){
    29a4:	4c 8d 25 b9 cb 00 00 	lea    0xcbb9(%rip),%r12        # f564 <state>
	uint8_t *data = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    29ab:	48 89 c5             	mov    %rax,%rbp
		switch(state){
    29ae:	41 8b 04 24          	mov    (%r12),%eax
    29b2:	83 f8 02             	cmp    $0x2,%eax
    29b5:	0f 84 b2 00 00 00    	je     2a6d <uart_in+0xf7>
    29bb:	83 f8 03             	cmp    $0x3,%eax
    29be:	0f 84 02 01 00 00    	je     2ac6 <uart_in+0x150>
    29c4:	85 c0                	test   %eax,%eax
    29c6:	0f 85 ea 01 00 00    	jne    2bb6 <uart_in+0x240>
				if(!uart_poll_in(uart_dev, &input)){
    29cc:	48 8d 05 ad ca 00 00 	lea    0xcaad(%rip),%rax        # f480 <uart_dev>
    29d3:	48 8b 38             	mov    (%rax),%rdi
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&p_char, K_SYSCALL_UART_POLL_IN);
	}
#endif
	compiler_barrier();
	return z_impl_uart_poll_in(dev, p_char);
    29d6:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
    29db:	e8 65 fe ff ff       	callq  2845 <z_impl_uart_poll_in>
    29e0:	85 c0                	test   %eax,%eax
    29e2:	0f 85 ce 01 00 00    	jne    2bb6 <uart_in+0x240>
					printk("received command: %c\n", (char)input);
    29e8:	0f be 74 24 07       	movsbl 0x7(%rsp),%esi
    29ed:	48 8d 3d 1d 6a 00 00 	lea    0x6a1d(%rip),%rdi        # 9411 <default_cmd+0x1b1>
    29f4:	e8 7d 06 00 00       	callq  3076 <printk>
					switch(input){
    29f9:	8a 44 24 07          	mov    0x7(%rsp),%al
    29fd:	3c 44                	cmp    $0x44,%al
    29ff:	74 51                	je     2a52 <uart_in+0xdc>
    2a01:	3c 50                	cmp    $0x50,%al
    2a03:	74 32                	je     2a37 <uart_in+0xc1>
    2a05:	3c 2e                	cmp    $0x2e,%al
    2a07:	0f 85 a9 01 00 00    	jne    2bb6 <uart_in+0x240>
							printk("Sending '.' back\n\n");
    2a0d:	48 8d 3d 13 6a 00 00 	lea    0x6a13(%rip),%rdi        # 9427 <default_cmd+0x1c7>
    2a14:	31 c0                	xor    %eax,%eax
    2a16:	e8 5b 06 00 00       	callq  3076 <printk>
							k_msgq_put(&uart_msgq, ".\n", K_FOREVER);
    2a1b:	48 8d 3d ae c0 00 00 	lea    0xc0ae(%rip),%rdi        # ead0 <uart_msgq>
    2a22:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    2a26:	48 8d 35 0d 6a 00 00 	lea    0x6a0d(%rip),%rsi        # 943a <default_cmd+0x1da>
    2a2d:	e8 19 fe ff ff       	callq  284b <k_msgq_put.constprop.0>
							break;
    2a32:	e9 7f 01 00 00       	jmpq   2bb6 <uart_in+0x240>
							printk("Changing state to st_avail\n\n");
    2a37:	48 8d 3d ff 69 00 00 	lea    0x69ff(%rip),%rdi        # 943d <default_cmd+0x1dd>
    2a3e:	31 c0                	xor    %eax,%eax
    2a40:	e8 31 06 00 00       	callq  3076 <printk>
							state = st_avail;
    2a45:	41 c7 04 24 01 00 00 	movl   $0x1,(%r12)
    2a4c:	00 
							break;
    2a4d:	e9 64 01 00 00       	jmpq   2bb6 <uart_in+0x240>
							printk("Changing state to st_decrypt\n\n");
    2a52:	48 8d 3d 01 6a 00 00 	lea    0x6a01(%rip),%rdi        # 945a <default_cmd+0x1fa>
    2a59:	31 c0                	xor    %eax,%eax
    2a5b:	e8 16 06 00 00       	callq  3076 <printk>
							state = st_decrypt;
    2a60:	41 c7 04 24 02 00 00 	movl   $0x2,(%r12)
    2a67:	00 
							break;
    2a68:	e9 49 01 00 00       	jmpq   2bb6 <uart_in+0x240>
				if(!uart_poll_in(uart_dev, &input)){
    2a6d:	48 8d 05 0c ca 00 00 	lea    0xca0c(%rip),%rax        # f480 <uart_dev>
    2a74:	48 8b 38             	mov    (%rax),%rdi
    2a77:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
    2a7c:	e8 c4 fd ff ff       	callq  2845 <z_impl_uart_poll_in>
    2a81:	85 c0                	test   %eax,%eax
    2a83:	0f 85 2d 01 00 00    	jne    2bb6 <uart_in+0x240>
					op = op_decrypt;
    2a89:	48 8d 05 d0 ca 00 00 	lea    0xcad0(%rip),%rax        # f560 <op>
					len = input;
    2a90:	0f b6 74 24 07       	movzbl 0x7(%rsp),%esi
					printk("Length of incoming ciphertext is %i\n", len);
    2a95:	48 8d 3d dd 69 00 00 	lea    0x69dd(%rip),%rdi        # 9479 <default_cmd+0x219>
					op = op_decrypt;
    2a9c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
					printk("Length of incoming ciphertext is %i\n", len);
    2aa2:	31 c0                	xor    %eax,%eax
					len = input;
    2aa4:	89 f3                	mov    %esi,%ebx
					printk("Length of incoming ciphertext is %i\n", len);
    2aa6:	e8 cb 05 00 00       	callq  3076 <printk>
					printk("Changing state to st_data\n\n");
    2aab:	48 8d 3d ec 69 00 00 	lea    0x69ec(%rip),%rdi        # 949e <default_cmd+0x23e>
    2ab2:	31 c0                	xor    %eax,%eax
    2ab4:	e8 bd 05 00 00       	callq  3076 <printk>
					state = st_data;
    2ab9:	41 c7 04 24 03 00 00 	movl   $0x3,(%r12)
    2ac0:	00 
    2ac1:	e9 f0 00 00 00       	jmpq   2bb6 <uart_in+0x240>
				memset(data, 0, strlen(data));
    2ac6:	31 c0                	xor    %eax,%eax
    2ac8:	48 89 ef             	mov    %rbp,%rdi
    2acb:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    2acf:	31 f6                	xor    %esi,%esi
    2ad1:	f2 ae                	repnz scas %es:(%rdi),%al
    2ad3:	48 89 ef             	mov    %rbp,%rdi
				for(uint8_t i=0; len!=0; len--){
    2ad6:	45 31 ed             	xor    %r13d,%r13d
				memset(data, 0, strlen(data));
    2ad9:	48 f7 d1             	not    %rcx
    2adc:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    2ae0:	b9 ff 00 00 00       	mov    $0xff,%ecx
    2ae5:	e8 56 fb ff ff       	callq  2640 <__memset_chk@plt>
				for(uint8_t i=0; len!=0; len--){
    2aea:	4c 8d 35 8f c9 00 00 	lea    0xc98f(%rip),%r14        # f480 <uart_dev>
    2af1:	84 db                	test   %bl,%bl
    2af3:	49 8b 3e             	mov    (%r14),%rdi
    2af6:	4c 8d 7c 24 07       	lea    0x7(%rsp),%r15
    2afb:	74 3e                	je     2b3b <uart_in+0x1c5>
    2afd:	4c 89 fe             	mov    %r15,%rsi
    2b00:	e8 40 fd ff ff       	callq  2845 <z_impl_uart_poll_in>
					if(!uart_poll_in(uart_dev, &input)){
    2b05:	85 c0                	test   %eax,%eax
    2b07:	75 22                	jne    2b2b <uart_in+0x1b5>
						printk("received data: <0x%x>\n", input);
    2b09:	0f b6 74 24 07       	movzbl 0x7(%rsp),%esi
    2b0e:	48 8d 3d a5 69 00 00 	lea    0x69a5(%rip),%rdi        # 94ba <default_cmd+0x25a>
    2b15:	e8 5c 05 00 00       	callq  3076 <printk>
						*(data+i) = input;
    2b1a:	8a 54 24 07          	mov    0x7(%rsp),%dl
    2b1e:	41 0f b6 c5          	movzbl %r13b,%eax
						i++;
    2b22:	41 ff c5             	inc    %r13d
						*(data+i) = input;
    2b25:	88 54 05 00          	mov    %dl,0x0(%rbp,%rax,1)
						i++;
    2b29:	eb 02                	jmp    2b2d <uart_in+0x1b7>
						len++;
    2b2b:	ff c3                	inc    %ebx
					k_usleep(1); //  Prozessor abgeben
    2b2d:	e8 1e fd ff ff       	callq  2850 <k_usleep.constprop.0>
				for(uint8_t i=0; len!=0; len--){
    2b32:	ff cb                	dec    %ebx
    2b34:	eb bb                	jmp    2af1 <uart_in+0x17b>
					k_usleep(1); // Prozessor abgeben
    2b36:	e8 15 fd ff ff       	callq  2850 <k_usleep.constprop.0>
					if(!uart_poll_in(uart_dev, &input)){
    2b3b:	49 8b 3e             	mov    (%r14),%rdi
    2b3e:	4c 89 fe             	mov    %r15,%rsi
    2b41:	e8 ff fc ff ff       	callq  2845 <z_impl_uart_poll_in>
    2b46:	85 c0                	test   %eax,%eax
    2b48:	75 ec                	jne    2b36 <uart_in+0x1c0>
						switch(op){
    2b4a:	48 8d 05 0f ca 00 00 	lea    0xca0f(%rip),%rax        # f560 <op>
    2b51:	83 38 00             	cmpl   $0x0,(%rax)
    2b54:	75 3c                	jne    2b92 <uart_in+0x21c>
								printk("Sending data <%s> to processing thread\n", data);
    2b56:	48 89 ee             	mov    %rbp,%rsi
    2b59:	48 8d 3d 71 69 00 00 	lea    0x6971(%rip),%rdi        # 94d1 <default_cmd+0x271>
    2b60:	31 c0                	xor    %eax,%eax
    2b62:	e8 0f 05 00 00       	callq  3076 <printk>
								k_msgq_put(&processing_msgq, data, K_FOREVER);
    2b67:	48 8d 3d 1a bf 00 00 	lea    0xbf1a(%rip),%rdi        # ea88 <processing_msgq>
    2b6e:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    2b72:	48 89 ee             	mov    %rbp,%rsi
    2b75:	e8 d1 fc ff ff       	callq  284b <k_msgq_put.constprop.0>
								printk("Changing state to st_op_decrypt\n\n");
    2b7a:	48 8d 3d 78 69 00 00 	lea    0x6978(%rip),%rdi        # 94f9 <default_cmd+0x299>
    2b81:	31 c0                	xor    %eax,%eax
    2b83:	e8 ee 04 00 00       	callq  3076 <printk>
								state = st_op_decrypt;
    2b88:	41 c7 04 24 04 00 00 	movl   $0x4,(%r12)
    2b8f:	00 
								break;
    2b90:	eb 24                	jmp    2bb6 <uart_in+0x240>
								printk("Error: unknwown operand!\n");
    2b92:	48 8d 3d 82 69 00 00 	lea    0x6982(%rip),%rdi        # 951b <default_cmd+0x2bb>
    2b99:	31 c0                	xor    %eax,%eax
    2b9b:	e8 d6 04 00 00       	callq  3076 <printk>
								printk("Changing state to st_init\n\n");
    2ba0:	48 8d 3d 8e 69 00 00 	lea    0x698e(%rip),%rdi        # 9535 <default_cmd+0x2d5>
    2ba7:	31 c0                	xor    %eax,%eax
    2ba9:	e8 c8 04 00 00       	callq  3076 <printk>
								state = st_init;
    2bae:	41 c7 04 24 00 00 00 	movl   $0x0,(%r12)
    2bb5:	00 
		k_usleep(1); // Prozessor abgeben
    2bb6:	e8 95 fc ff ff       	callq  2850 <k_usleep.constprop.0>
		switch(state){
    2bbb:	e9 ee fd ff ff       	jmpq   29ae <uart_in+0x38>

0000000000002bc0 <validate_hw_compatibility>:
	return;
}

int validate_hw_compatibility(void)
// ubernommen aus Krypto-Sample von Zephyr
{
    2bc0:	f3 0f 1e fa          	endbr64 
    2bc4:	51                   	push   %rcx
        uint32_t flags = 0U;

        flags = cipher_query_hwcaps(crypto_dev);
    2bc5:	48 8d 05 a4 c8 00 00 	lea    0xc8a4(%rip),%rax        # f470 <crypto_dev>
    2bcc:	48 8b 38             	mov    (%rax),%rdi
	struct crypto_driver_api *api;
	int tmp;

	api = (struct crypto_driver_api *) dev->api;

	tmp = api->query_hw_caps(dev);
    2bcf:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2bd3:	ff 10                	callq  *(%rax)
        if ((flags & CAP_RAW_KEY) == 0U) {
                return -1;
        }

        if ((flags & CAP_SYNC_OPS) == 0U) {
                return -1;
    2bd5:	41 83 c8 ff          	or     $0xffffffff,%r8d
        if ((flags & CAP_SYNC_OPS) == 0U) {
    2bd9:	89 c2                	mov    %eax,%edx
    2bdb:	83 e2 22             	and    $0x22,%edx
    2bde:	83 fa 22             	cmp    $0x22,%edx
    2be1:	75 14                	jne    2bf7 <validate_hw_compatibility+0x37>
        }

        if ((flags & CAP_SEPARATE_IO_BUFS) == 0U) {
    2be3:	a8 10                	test   $0x10,%al
    2be5:	74 10                	je     2bf7 <validate_hw_compatibility+0x37>
                return -1;
        }

        cap_flags = CAP_RAW_KEY | CAP_SYNC_OPS | CAP_SEPARATE_IO_BUFS;
    2be7:	48 8d 05 7a c9 00 00 	lea    0xc97a(%rip),%rax        # f568 <cap_flags>

        return 0;
    2bee:	45 31 c0             	xor    %r8d,%r8d
        cap_flags = CAP_RAW_KEY | CAP_SYNC_OPS | CAP_SEPARATE_IO_BUFS;
    2bf1:	c7 00 32 00 00 00    	movl   $0x32,(%rax)
}
    2bf7:	44 89 c0             	mov    %r8d,%eax
    2bfa:	5a                   	pop    %rdx
    2bfb:	c3                   	retq   

0000000000002bfc <zephyr_app_main>:
void main(void){
    2bfc:	f3 0f 1e fa          	endbr64 
    2c00:	53                   	push   %rbx
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    2c01:	48 8d 3d 49 69 00 00 	lea    0x6949(%rip),%rdi        # 9551 <default_cmd+0x2f1>
    2c08:	e8 2a 4f 00 00       	callq  7b37 <z_impl_device_get_binding>
	uart_dev = device_get_binding(DT_LABEL(UART_DEVICE));
    2c0d:	48 8d 1d 6c c8 00 00 	lea    0xc86c(%rip),%rbx        # f480 <uart_dev>
		printk("UART not found\n");
    2c14:	48 8d 3d 3d 69 00 00 	lea    0x693d(%rip),%rdi        # 9558 <default_cmd+0x2f8>
	uart_dev = device_get_binding(DT_LABEL(UART_DEVICE));
    2c1b:	48 89 03             	mov    %rax,(%rbx)
	if(!uart_dev){
    2c1e:	48 85 c0             	test   %rax,%rax
    2c21:	74 75                	je     2c98 <zephyr_app_main+0x9c>
	printk("UART found\n");
    2c23:	31 c0                	xor    %eax,%eax
    2c25:	48 8d 3d 3c 69 00 00 	lea    0x693c(%rip),%rdi        # 9568 <default_cmd+0x308>
    2c2c:	e8 45 04 00 00       	callq  3076 <printk>
	uartconf.baudrate = 9600;
    2c31:	48 8d 35 40 c8 00 00 	lea    0xc840(%rip),%rsi        # f478 <uartconf>
	if(!uart_configure(uart_dev, &uartconf)){
    2c38:	48 8b 3b             	mov    (%rbx),%rdi
	uartconf.baudrate = 9600;
    2c3b:	48 b8 80 25 00 00 00 	movabs $0x3010000002580,%rax
    2c42:	01 03 00 
    2c45:	48 89 06             	mov    %rax,(%rsi)
					const struct uart_config *cfg)
{
	const struct uart_driver_api *api =
				(const struct uart_driver_api *)dev->api;

	if (api->configure == NULL) {
    2c48:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2c4c:	48 8b 40 18          	mov    0x18(%rax),%rax
    2c50:	48 85 c0             	test   %rax,%rax
    2c53:	74 0d                	je     2c62 <zephyr_app_main+0x66>
		return -ENOSYS;
	}
	return api->configure(dev, cfg);
    2c55:	ff d0                	callq  *%rax
		printk("Configuration of UART failed\n");
    2c57:	48 8d 3d 16 69 00 00 	lea    0x6916(%rip),%rdi        # 9574 <default_cmd+0x314>
	if(!uart_configure(uart_dev, &uartconf)){
    2c5e:	85 c0                	test   %eax,%eax
    2c60:	74 36                	je     2c98 <zephyr_app_main+0x9c>
	printk("UART configured\n");
    2c62:	48 8d 3d 29 69 00 00 	lea    0x6929(%rip),%rdi        # 9592 <default_cmd+0x332>
    2c69:	31 c0                	xor    %eax,%eax
    2c6b:	e8 06 04 00 00       	callq  3076 <printk>
    2c70:	48 8d 3d 2c 69 00 00 	lea    0x692c(%rip),%rdi        # 95a3 <default_cmd+0x343>
    2c77:	e8 bb 4e 00 00       	callq  7b37 <z_impl_device_get_binding>
	crypto_dev = device_get_binding(CRYPTO_DRV_NAME);
    2c7c:	48 8d 15 ed c7 00 00 	lea    0xc7ed(%rip),%rdx        # f470 <crypto_dev>
    2c83:	48 89 02             	mov    %rax,(%rdx)
	if(validate_hw_compatibility()!=0){
    2c86:	e8 35 ff ff ff       	callq  2bc0 <validate_hw_compatibility>
    2c8b:	85 c0                	test   %eax,%eax
    2c8d:	74 0f                	je     2c9e <zephyr_app_main+0xa2>
		printk("Crypto device not compatible\n");
    2c8f:	48 8d 3d 17 69 00 00 	lea    0x6917(%rip),%rdi        # 95ad <default_cmd+0x34d>
    2c96:	31 c0                	xor    %eax,%eax
}
    2c98:	5b                   	pop    %rbx
		printk("Crypto device not compatible\n");
    2c99:	e9 d8 03 00 00       	jmpq   3076 <printk>
	printk("Crypto device is compatible\n");
    2c9e:	48 8d 3d 26 69 00 00 	lea    0x6926(%rip),%rdi        # 95cb <default_cmd+0x36b>
    2ca5:	31 c0                	xor    %eax,%eax
		printk("\nmain is waiting for death\n"); // "main is alive" ist mir irgendwie zu langweilig...
    2ca7:	48 8d 1d 3a 69 00 00 	lea    0x693a(%rip),%rbx        # 95e8 <default_cmd+0x388>
	printk("Crypto device is compatible\n");
    2cae:	e8 c3 03 00 00       	callq  3076 <printk>
		printk("\nmain is waiting for death\n"); // "main is alive" ist mir irgendwie zu langweilig...
    2cb3:	48 89 df             	mov    %rbx,%rdi
    2cb6:	31 c0                	xor    %eax,%eax
    2cb8:	e8 b9 03 00 00       	callq  3076 <printk>
	return z_impl_k_sleep(timeout);
    2cbd:	bf e8 03 00 00       	mov    $0x3e8,%edi
    2cc2:	e8 11 5a 00 00       	callq  86d8 <z_impl_k_sleep>
    2cc7:	eb ea                	jmp    2cb3 <zephyr_app_main+0xb7>

0000000000002cc9 <cbc_mode>:

void cbc_mode(uint8_t *key, uint8_t *iv, uint8_t *ciphertext, uint8_t **plaintext_addr)
// uebernommen aus Krypto-Sample von Zephyr und von Mitterhuber
{
    2cc9:	f3 0f 1e fa          	endbr64 
    2ccd:	41 57                	push   %r15
    2ccf:	49 89 ff             	mov    %rdi,%r15
	uint8_t *iv_ciphertext = malloc((DATA_SIZE_MAX+KEY_IV_LEN)*sizeof(uint8_t));
    2cd2:	bf 0f 01 00 00       	mov    $0x10f,%edi
{
    2cd7:	41 56                	push   %r14
    2cd9:	41 55                	push   %r13
    2cdb:	49 89 d5             	mov    %rdx,%r13
    2cde:	41 54                	push   %r12
    2ce0:	55                   	push   %rbp
    2ce1:	48 89 cd             	mov    %rcx,%rbp
    2ce4:	53                   	push   %rbx
    2ce5:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    2cec:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    2cf1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2cf8:	00 00 
    2cfa:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    2cff:	31 c0                	xor    %eax,%eax
	uint8_t *iv_ciphertext = malloc((DATA_SIZE_MAX+KEY_IV_LEN)*sizeof(uint8_t));
    2d01:	e8 ba f8 ff ff       	callq  25c0 <malloc@plt>
	uint8_t *plaintext = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2d06:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *iv_ciphertext = malloc((DATA_SIZE_MAX+KEY_IV_LEN)*sizeof(uint8_t));
    2d0b:	49 89 c6             	mov    %rax,%r14
	uint8_t *plaintext = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2d0e:	e8 ad f8 ff ff       	callq  25c0 <malloc@plt>
	xerror = false;

	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    2d13:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    2d18:	45 31 d2             	xor    %r10d,%r10d
    2d1b:	45 31 c0             	xor    %r8d,%r8d
	xerror = false;
    2d1e:	4c 8d 25 88 c8 00 00 	lea    0xc888(%rip),%r12        # f5ad <xerror>
	uint8_t *plaintext = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2d25:	48 89 c3             	mov    %rax,%rbx
	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    2d28:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	xerror = false;
    2d2c:	41 c6 04 24 00       	movb   $0x0,(%r12)
	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    2d31:	48 89 d1             	mov    %rdx,%rcx
    2d34:	4c 89 ef             	mov    %r13,%rdi
    2d37:	44 89 c0             	mov    %r8d,%eax
    2d3a:	4d 63 ca             	movslq %r10d,%r9
    2d3d:	f2 ae                	repnz scas %es:(%rdi),%al
    2d3f:	48 f7 d1             	not    %rcx
    2d42:	48 83 c1 0f          	add    $0xf,%rcx
    2d46:	49 39 c9             	cmp    %rcx,%r9
    2d49:	73 1c                	jae    2d67 <cbc_mode+0x9e>
		if(i<KEY_IV_LEN){
    2d4b:	4b 8d 04 0e          	lea    (%r14,%r9,1),%rax
    2d4f:	41 83 fa 0f          	cmp    $0xf,%r10d
    2d53:	7f 06                	jg     2d5b <cbc_mode+0x92>
			*(iv_ciphertext+i) = *(iv+i);
    2d55:	42 8a 0c 0e          	mov    (%rsi,%r9,1),%cl
    2d59:	eb 05                	jmp    2d60 <cbc_mode+0x97>
		}
		else{
			*(iv_ciphertext+i) = *(ciphertext+i-KEY_IV_LEN);
    2d5b:	43 8a 4c 0d f0       	mov    -0x10(%r13,%r9,1),%cl
    2d60:	88 08                	mov    %cl,(%rax)
	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    2d62:	41 ff c2             	inc    %r10d
    2d65:	eb ca                	jmp    2d31 <cbc_mode+0x68>
		}
	}

        struct cipher_ctx ini = {
    2d67:	31 c0                	xor    %eax,%eax
    2d69:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
    2d6e:	b9 0d 00 00 00       	mov    $0xd,%ecx
    2d73:	66 c7 44 24 74 10 00 	movw   $0x10,0x74(%rsp)
    2d7a:	f3 ab                	rep stos %eax,%es:(%rdi)
    2d7c:	48 8d 0d e5 c7 00 00 	lea    0xc7e5(%rip),%rcx        # f568 <cap_flags>
                .keylen = KEY_IV_LEN,
                .key.bit_stream = key,
                .flags = cap_flags,
        };

        struct cipher_pkt decrypt = {
    2d83:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
        struct cipher_ctx ini = {
    2d88:	4c 89 7c 24 50       	mov    %r15,0x50(%rsp)
        struct cipher_pkt decrypt = {
    2d8d:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
                .in_len = strlen(ciphertext)+KEY_IV_LEN,
                .out_buf = plaintext,
                .out_buf_max = strlen(ciphertext),
        };

        if (cipher_begin_session(crypto_dev, &ini, CRYPTO_CIPHER_ALGO_AES,
    2d92:	4c 8d 3d d7 c6 00 00 	lea    0xc6d7(%rip),%r15        # f470 <crypto_dev>
        struct cipher_ctx ini = {
    2d99:	8b 09                	mov    (%rcx),%ecx
    2d9b:	66 89 4c 24 76       	mov    %cx,0x76(%rsp)
        struct cipher_pkt decrypt = {
    2da0:	b9 08 00 00 00       	mov    $0x8,%ecx
    2da5:	f3 ab                	rep stos %eax,%es:(%rdi)
                .in_len = strlen(ciphertext)+KEY_IV_LEN,
    2da7:	44 89 c0             	mov    %r8d,%eax
    2daa:	4c 89 ef             	mov    %r13,%rdi
    2dad:	48 89 d1             	mov    %rdx,%rcx
    2db0:	f2 ae                	repnz scas %es:(%rdi),%al
        struct cipher_pkt decrypt = {
    2db2:	48 89 5c 24 28       	mov    %rbx,0x28(%rsp)
                .out_buf_max = strlen(ciphertext),
    2db7:	4c 89 ef             	mov    %r13,%rdi
	flags = (ctx->flags & (CAP_SYNC_OPS | CAP_ASYNC_OPS));
	__ASSERT(flags != 0U, "sync/async type missing");
	__ASSERT(flags != (CAP_SYNC_OPS |  CAP_ASYNC_OPS),
			"conflicting options for sync/async");

	return api->begin_session(dev, ctx, algo, mode, optype);
    2dba:	4c 8d 6c 24 40       	lea    0x40(%rsp),%r13
    2dbf:	4c 89 ee             	mov    %r13,%rsi
                .in_len = strlen(ciphertext)+KEY_IV_LEN,
    2dc2:	48 f7 d1             	not    %rcx
    2dc5:	83 c1 0f             	add    $0xf,%ecx
    2dc8:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
                .out_buf_max = strlen(ciphertext),
    2dcc:	48 89 d1             	mov    %rdx,%rcx
    2dcf:	ba 01 00 00 00       	mov    $0x1,%edx
    2dd4:	f2 ae                	repnz scas %es:(%rdi),%al
        if (cipher_begin_session(crypto_dev, &ini, CRYPTO_CIPHER_ALGO_AES,
    2dd6:	49 8b 3f             	mov    (%r15),%rdi
	ctx->ops.cipher_mode = mode;
    2dd9:	c7 44 24 40 02 00 00 	movl   $0x2,0x40(%rsp)
    2de0:	00 
	api = (struct crypto_driver_api *) dev->api;
    2de1:	48 8b 47 10          	mov    0x10(%rdi),%rax
	ctx->device = dev;
    2de5:	48 89 7c 24 58       	mov    %rdi,0x58(%rsp)
                .out_buf_max = strlen(ciphertext),
    2dea:	49 89 c8             	mov    %rcx,%r8
	return api->begin_session(dev, ctx, algo, mode, optype);
    2ded:	b9 02 00 00 00       	mov    $0x2,%ecx
    2df2:	49 f7 d0             	not    %r8
    2df5:	49 ff c8             	dec    %r8
        struct cipher_pkt decrypt = {
    2df8:	44 89 44 24 30       	mov    %r8d,0x30(%rsp)
    2dfd:	45 31 c0             	xor    %r8d,%r8d
    2e00:	ff 50 08             	callq  *0x8(%rax)
        if (cipher_begin_session(crypto_dev, &ini, CRYPTO_CIPHER_ALGO_AES,
    2e03:	85 c0                	test   %eax,%eax
    2e05:	75 37                	jne    2e3e <cbc_mode+0x175>
				struct cipher_pkt *pkt, uint8_t *iv)
{
	__ASSERT(ctx->ops.cipher_mode == CRYPTO_CIPHER_MODE_CBC, "CBC mode "
		 "session invoking a different mode handler");

	pkt->ctx = ctx;
    2e07:	4c 89 6c 24 38       	mov    %r13,0x38(%rsp)
	return ctx->ops.cbc_crypt_hndlr(ctx, pkt, iv);
    2e0c:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    2e11:	4c 89 f2             	mov    %r14,%rdx
    2e14:	4c 89 ef             	mov    %r13,%rdi
    2e17:	ff 54 24 48          	callq  *0x48(%rsp)
		k_msgq_put(&uart_msgq, "XERROR\n", K_FOREVER);
		xerror = true;
		goto out;
        }

        if (cipher_cbc_op(&ini, &decrypt, iv_ciphertext)!=0){
    2e1b:	85 c0                	test   %eax,%eax
    2e1d:	74 3d                	je     2e5c <cbc_mode+0x193>
                printk("CBC mode DECRYPT - Failed\n");
    2e1f:	48 8d 3d e6 67 00 00 	lea    0x67e6(%rip),%rdi        # 960c <default_cmd+0x3ac>
    2e26:	31 c0                	xor    %eax,%eax
    2e28:	e8 49 02 00 00       	callq  3076 <printk>
		printk("Plaintext is: %s\n", plaintext);
    2e2d:	48 89 de             	mov    %rbx,%rsi
    2e30:	48 8d 3d f0 67 00 00 	lea    0x67f0(%rip),%rdi        # 9627 <default_cmd+0x3c7>
    2e37:	31 c0                	xor    %eax,%eax
    2e39:	e8 38 02 00 00       	callq  3076 <printk>
		k_msgq_put(&uart_msgq, "XERROR\n", K_FOREVER);
    2e3e:	48 8d 3d 8b bc 00 00 	lea    0xbc8b(%rip),%rdi        # ead0 <uart_msgq>
    2e45:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    2e49:	48 8d 35 b4 67 00 00 	lea    0x67b4(%rip),%rsi        # 9604 <default_cmd+0x3a4>
    2e50:	e8 f6 f9 ff ff       	callq  284b <k_msgq_put.constprop.0>
		xerror = true;
    2e55:	41 c6 04 24 01       	movb   $0x1,(%r12)
                goto out;
    2e5a:	eb 23                	jmp    2e7f <cbc_mode+0x1b6>
        }

       	printk("Output length (decryption): %d\n", decrypt.out_len);
    2e5c:	8b 74 24 34          	mov    0x34(%rsp),%esi
    2e60:	48 8d 3d d2 67 00 00 	lea    0x67d2(%rip),%rdi        # 9639 <default_cmd+0x3d9>
    2e67:	31 c0                	xor    %eax,%eax
    2e69:	e8 08 02 00 00       	callq  3076 <printk>
	printk("plaintext: %s\n", plaintext);
    2e6e:	48 89 de             	mov    %rbx,%rsi
    2e71:	48 8d 3d e1 67 00 00 	lea    0x67e1(%rip),%rdi        # 9659 <default_cmd+0x3f9>
    2e78:	31 c0                	xor    %eax,%eax
    2e7a:	e8 f7 01 00 00       	callq  3076 <printk>

out:
        cipher_free_session(crypto_dev, &ini);
    2e7f:	49 8b 3f             	mov    (%r15),%rdi
	return api->free_session(dev, ctx);
    2e82:	4c 89 ee             	mov    %r13,%rsi
    2e85:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2e89:	ff 50 10             	callq  *0x10(%rax)
	*plaintext_addr = plaintext;
    2e8c:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
}
    2e90:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    2e95:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    2e9c:	00 00 
    2e9e:	74 05                	je     2ea5 <cbc_mode+0x1dc>
    2ea0:	e8 0b f6 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    2ea5:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    2eac:	5b                   	pop    %rbx
    2ead:	5d                   	pop    %rbp
    2eae:	41 5c                	pop    %r12
    2eb0:	41 5d                	pop    %r13
    2eb2:	41 5e                	pop    %r14
    2eb4:	41 5f                	pop    %r15
    2eb6:	c3                   	retq   

0000000000002eb7 <processing>:
void processing(void *ptr1, void *ptr2, void *ptr3){
    2eb7:	f3 0f 1e fa          	endbr64 
    2ebb:	41 55                	push   %r13
	uint8_t *plaintext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2ebd:	bf ff 00 00 00       	mov    $0xff,%edi
void processing(void *ptr1, void *ptr2, void *ptr3){
    2ec2:	41 54                	push   %r12
    2ec4:	55                   	push   %rbp
    2ec5:	53                   	push   %rbx
    2ec6:	48 83 ec 18          	sub    $0x18,%rsp
    2eca:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2ed1:	00 00 
    2ed3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2ed8:	31 c0                	xor    %eax,%eax
	uint8_t *plaintext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2eda:	e8 e1 f6 ff ff       	callq  25c0 <malloc@plt>
	uint8_t *plaintext_temp=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2edf:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *plaintext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2ee4:	48 89 c5             	mov    %rax,%rbp
	uint8_t *plaintext_temp=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2ee7:	e8 d4 f6 ff ff       	callq  25c0 <malloc@plt>
	uint8_t *ciphertext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2eec:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *plaintext_temp=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2ef1:	48 89 04 24          	mov    %rax,(%rsp)
	uint8_t *ciphertext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2ef5:	e8 c6 f6 ff ff       	callq  25c0 <malloc@plt>
		switch(state){
    2efa:	4c 8d 2d 63 c6 00 00 	lea    0xc663(%rip),%r13        # f564 <state>
	uint8_t *ciphertext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    2f01:	49 89 c4             	mov    %rax,%r12
		switch(state){
    2f04:	41 8b 45 00          	mov    0x0(%r13),%eax
    2f08:	83 f8 01             	cmp    $0x1,%eax
    2f0b:	74 0a                	je     2f17 <processing+0x60>
    2f0d:	83 f8 04             	cmp    $0x4,%eax
    2f10:	74 15                	je     2f27 <processing+0x70>
    2f12:	e9 df 00 00 00       	jmpq   2ff6 <processing+0x13f>
				k_msgq_put(&uart_msgq, "PROCESSING AVAILABLE\n", K_FOREVER);
    2f17:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    2f1b:	48 8d 35 46 67 00 00 	lea    0x6746(%rip),%rsi        # 9668 <default_cmd+0x408>
    2f22:	e9 ad 00 00 00       	jmpq   2fd4 <processing+0x11d>
	return z_impl_k_msgq_get(msgq, data, timeout);
    2f27:	48 8d 3d 5a bb 00 00 	lea    0xbb5a(%rip),%rdi        # ea88 <processing_msgq>
    2f2e:	31 d2                	xor    %edx,%edx
    2f30:	4c 89 e6             	mov    %r12,%rsi
    2f33:	e8 dc 4e 00 00       	callq  7e14 <z_impl_k_msgq_get>
    2f38:	89 c3                	mov    %eax,%ebx
				if(k_msgq_get(&processing_msgq, (void*)ciphertext, K_NO_WAIT)==0){
    2f3a:	85 c0                	test   %eax,%eax
    2f3c:	0f 85 b4 00 00 00    	jne    2ff6 <processing+0x13f>
					printk("Going to decrypt ciphertext: <%s>\n", ciphertext);
    2f42:	31 c0                	xor    %eax,%eax
    2f44:	4c 89 e6             	mov    %r12,%rsi
    2f47:	48 8d 3d 30 67 00 00 	lea    0x6730(%rip),%rdi        # 967e <default_cmd+0x41e>
    2f4e:	e8 23 01 00 00       	callq  3076 <printk>
					cbc_mode(key, iv, ciphertext, &plaintext_temp);
    2f53:	48 8d 35 47 67 00 00 	lea    0x6747(%rip),%rsi        # 96a1 <default_cmd+0x441>
    2f5a:	48 89 e1             	mov    %rsp,%rcx
    2f5d:	4c 89 e2             	mov    %r12,%rdx
    2f60:	48 89 f7             	mov    %rsi,%rdi
    2f63:	e8 61 fd ff ff       	callq  2cc9 <cbc_mode>
					if(xerror == false){ // Send data to uart_out
    2f68:	48 8d 05 3e c6 00 00 	lea    0xc63e(%rip),%rax        # f5ad <xerror>
    2f6f:	80 38 00             	cmpb   $0x0,(%rax)
    2f72:	75 6c                	jne    2fe0 <processing+0x129>
						send_termination = true;
    2f74:	48 8d 05 33 c6 00 00 	lea    0xc633(%rip),%rax        # f5ae <send_termination>
						for(int i=0; i<strlen(plaintext_temp)+2; i++){
    2f7b:	48 8b 34 24          	mov    (%rsp),%rsi
    2f7f:	49 83 c8 ff          	or     $0xffffffffffffffff,%r8
						send_termination = true;
    2f83:	c6 00 01             	movb   $0x1,(%rax)
						for(int i=0; i<strlen(plaintext_temp)+2; i++){
    2f86:	31 c0                	xor    %eax,%eax
    2f88:	4c 89 c1             	mov    %r8,%rcx
    2f8b:	48 89 f7             	mov    %rsi,%rdi
    2f8e:	48 63 d3             	movslq %ebx,%rdx
    2f91:	f2 ae                	repnz scas %es:(%rdi),%al
    2f93:	48 f7 d9             	neg    %rcx
    2f96:	48 39 ca             	cmp    %rcx,%rdx
    2f99:	73 21                	jae    2fbc <processing+0x105>
							if(i==0) *(plaintext+i) = 'D';
    2f9b:	85 db                	test   %ebx,%ebx
    2f9d:	75 06                	jne    2fa5 <processing+0xee>
    2f9f:	c6 45 00 44          	movb   $0x44,0x0(%rbp)
    2fa3:	eb 13                	jmp    2fb8 <processing+0x101>
							else if(i==1) *(plaintext+i) = ' ';
    2fa5:	83 fb 01             	cmp    $0x1,%ebx
    2fa8:	75 06                	jne    2fb0 <processing+0xf9>
    2faa:	c6 45 01 20          	movb   $0x20,0x1(%rbp)
    2fae:	eb 08                	jmp    2fb8 <processing+0x101>
							else *(plaintext+i) = *(plaintext_temp+i-2);
    2fb0:	8a 4c 16 fe          	mov    -0x2(%rsi,%rdx,1),%cl
    2fb4:	88 4c 15 00          	mov    %cl,0x0(%rbp,%rdx,1)
						for(int i=0; i<strlen(plaintext_temp)+2; i++){
    2fb8:	ff c3                	inc    %ebx
    2fba:	eb cc                	jmp    2f88 <processing+0xd1>
						printk("Sending plaintext <%s> to uart_out\n", plaintext);
    2fbc:	48 89 ee             	mov    %rbp,%rsi
    2fbf:	48 8d 3d ec 66 00 00 	lea    0x66ec(%rip),%rdi        # 96b2 <default_cmd+0x452>
    2fc6:	31 c0                	xor    %eax,%eax
    2fc8:	e8 a9 00 00 00       	callq  3076 <printk>
						k_msgq_put(&uart_msgq, plaintext, K_FOREVER);
    2fcd:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    2fd1:	48 89 ee             	mov    %rbp,%rsi
    2fd4:	48 8d 3d f5 ba 00 00 	lea    0xbaf5(%rip),%rdi        # ead0 <uart_msgq>
    2fdb:	e8 6b f8 ff ff       	callq  284b <k_msgq_put.constprop.0>
					printk("Changing state to st_init\n\n");
    2fe0:	48 8d 3d 4e 65 00 00 	lea    0x654e(%rip),%rdi        # 9535 <default_cmd+0x2d5>
    2fe7:	31 c0                	xor    %eax,%eax
    2fe9:	e8 88 00 00 00       	callq  3076 <printk>
					state = st_init;
    2fee:	41 c7 45 00 00 00 00 	movl   $0x0,0x0(%r13)
    2ff5:	00 
		k_usleep(1); // Abgeben des Prozessors
    2ff6:	e8 55 f8 ff ff       	callq  2850 <k_usleep.constprop.0>
		switch(state){
    2ffb:	e9 04 ff ff ff       	jmpq   2f04 <processing+0x4d>

0000000000003000 <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
    3000:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    3004:	31 c0                	xor    %eax,%eax
    3006:	c3                   	retq   

0000000000003007 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    3007:	f3 0f 1e fa          	endbr64 
	struct out_context *ctx = ctx_p;

	ctx->count++;
	return _char_out(c);
    300b:	48 8d 05 36 94 00 00 	lea    0x9436(%rip),%rax        # c448 <_char_out>
	ctx->count++;
    3012:	ff 06                	incl   (%rsi)
	return _char_out(c);
    3014:	ff 20                	jmpq   *(%rax)

0000000000003016 <__printk_hook_install>:
{
    3016:	f3 0f 1e fa          	endbr64 
	_char_out = fn;
    301a:	48 8d 05 27 94 00 00 	lea    0x9427(%rip),%rax        # c448 <_char_out>
    3021:	48 89 38             	mov    %rdi,(%rax)
}
    3024:	c3                   	retq   

0000000000003025 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    3025:	f3 0f 1e fa          	endbr64 
    3029:	48 83 ec 18          	sub    $0x18,%rsp
    302d:	48 89 fa             	mov    %rdi,%rdx
    3030:	48 89 f1             	mov    %rsi,%rcx
    3033:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    303a:	00 00 
    303c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3041:	31 c0                	xor    %eax,%eax
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    3043:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
    3048:	48 8d 3d b8 ff ff ff 	lea    -0x48(%rip),%rdi        # 3007 <char_out>
	struct out_context ctx = { 0 };
    304f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
    3056:	00 
	cbvprintf(char_out, &ctx, fmt, ap);
    3057:	e8 84 03 00 00       	callq  33e0 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    305c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    3061:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3068:	00 00 
    306a:	74 05                	je     3071 <vprintk+0x4c>
    306c:	e8 3f f4 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    3071:	48 83 c4 18          	add    $0x18,%rsp
    3075:	c3                   	retq   

0000000000003076 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
    3076:	f3 0f 1e fa          	endbr64 
    307a:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    3081:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    3086:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    308b:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    3090:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    3095:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    309a:	84 c0                	test   %al,%al
    309c:	74 37                	je     30d5 <printk+0x5f>
    309e:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    30a3:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    30a8:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    30ad:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    30b4:	00 
    30b5:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    30bc:	00 
    30bd:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    30c4:	00 
    30c5:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    30cc:	00 
    30cd:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    30d4:	00 
    30d5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    30dc:	00 00 
    30de:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    30e3:	31 c0                	xor    %eax,%eax
	va_list ap;

	va_start(ap, fmt);
    30e5:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    30ec:	00 

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    30ed:	48 89 e6             	mov    %rsp,%rsi
	va_start(ap, fmt);
    30f0:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    30f7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    30fc:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    3101:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    3106:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    310d:	00 
		vprintk(fmt, ap);
    310e:	e8 12 ff ff ff       	callq  3025 <vprintk>
	}
	va_end(ap);
}
    3113:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    3118:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    311f:	00 00 
    3121:	74 05                	je     3128 <printk+0xb2>
    3123:	e8 88 f3 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    3128:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    312f:	c3                   	retq   

0000000000003130 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    3130:	f3 0f 1e fa          	endbr64 
    3134:	50                   	push   %rax
    3135:	58                   	pop    %rax
    3136:	49 89 f8             	mov    %rdi,%r8
    3139:	50                   	push   %rax
    313a:	48 89 f7             	mov    %rsi,%rdi
    313d:	48 89 d6             	mov    %rdx,%rsi
    3140:	48 89 ca             	mov    %rcx,%rdx
	entry(p1, p2, p3);
    3143:	41 ff d0             	callq  *%r8
	return z_impl_k_current_get();
    3146:	e8 fe 55 00 00       	callq  8749 <z_impl_k_current_get>
    314b:	48 89 c7             	mov    %rax,%rdi
	z_impl_k_thread_abort(thread);
    314e:	e8 06 26 00 00       	callq  5759 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    3153:	ba 26 00 00 00       	mov    $0x26,%edx
    3158:	48 8d 35 9f 65 00 00 	lea    0x659f(%rip),%rsi        # 96fe <default_cmd+0x49e>
    315f:	31 c0                	xor    %eax,%eax
    3161:	48 8d 3d bf 65 00 00 	lea    0x65bf(%rip),%rdi        # 9727 <default_cmd+0x4c7>
    3168:	e8 d0 35 00 00       	callq  673d <posix_print_error_and_exit>

000000000000316d <chunk_size>:

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    316d:	89 f6                	mov    %esi,%esi
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    316f:	8b 44 f7 04          	mov    0x4(%rdi,%rsi,8),%eax
    3173:	d1 e8                	shr    %eax
}
    3175:	c3                   	retq   

0000000000003176 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    3176:	89 f6                	mov    %esi,%esi
{
    3178:	41 89 d0             	mov    %edx,%r8d
	void *cmem = &buf[c];
    317b:	48 8d 04 f7          	lea    (%rdi,%rsi,8),%rax

	if (big_heap(h)) {
		if (used) {
    317f:	8b 48 04             	mov    0x4(%rax),%ecx
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
    3182:	89 ca                	mov    %ecx,%edx
    3184:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
    3187:	45 84 c0             	test   %r8b,%r8b
    318a:	74 05                	je     3191 <set_chunk_used+0x1b>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    318c:	83 c9 01             	or     $0x1,%ecx
    318f:	89 ca                	mov    %ecx,%edx
    3191:	89 50 04             	mov    %edx,0x4(%rax)
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    3194:	c3                   	retq   

0000000000003195 <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    3195:	89 f2                	mov    %esi,%edx
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    3197:	e8 d1 ff ff ff       	callq  316d <chunk_size>
	if (!solo_free_header(h, c)) {
    319c:	83 f8 01             	cmp    $0x1,%eax
    319f:	74 5b                	je     31fc <free_list_add+0x67>
	return chunksz * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    31a1:	ff c8                	dec    %eax
	return 31 - __builtin_clz(usable_sz);
    31a3:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    31a8:	0f bd c0             	bsr    %eax,%eax
    31ab:	83 f0 1f             	xor    $0x1f,%eax
    31ae:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
    31b0:	48 63 c1             	movslq %ecx,%rax
    31b3:	4c 8d 14 87          	lea    (%rdi,%rax,4),%r10
    31b7:	89 d0                	mov    %edx,%eax
    31b9:	41 8b 72 10          	mov    0x10(%r10),%esi
    31bd:	48 8d 04 c5 08 00 00 	lea    0x8(,%rax,8),%rax
    31c4:	00 
    31c5:	4c 8d 0c 07          	lea    (%rdi,%rax,1),%r9
    31c9:	4c 8d 44 07 04       	lea    0x4(%rdi,%rax,1),%r8
    31ce:	85 f6                	test   %esi,%esi
    31d0:	75 15                	jne    31e7 <free_list_add+0x52>
		h->avail_buckets |= (1 << bidx);
    31d2:	b8 01 00 00 00       	mov    $0x1,%eax
    31d7:	d3 e0                	shl    %cl,%eax
    31d9:	09 47 0c             	or     %eax,0xc(%rdi)
		b->next = c;
    31dc:	41 89 52 10          	mov    %edx,0x10(%r10)
		((uint32_t *)cmem)[f] = val;
    31e0:	41 89 11             	mov    %edx,(%r9)
    31e3:	41 89 10             	mov    %edx,(%r8)
}
    31e6:	c3                   	retq   
	void *cmem = &buf[c];
    31e7:	89 f0                	mov    %esi,%eax
		return ((uint32_t *)cmem)[f];
    31e9:	48 8d 4c c7 08       	lea    0x8(%rdi,%rax,8),%rcx
    31ee:	8b 01                	mov    (%rcx),%eax
		((uint32_t *)cmem)[f] = val;
    31f0:	41 89 01             	mov    %eax,(%r9)
    31f3:	41 89 30             	mov    %esi,(%r8)
    31f6:	89 54 c7 0c          	mov    %edx,0xc(%rdi,%rax,8)
    31fa:	89 11                	mov    %edx,(%rcx)
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
	}
}
    31fc:	c3                   	retq   

00000000000031fd <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    31fd:	f3 0f 1e fa          	endbr64 
    3201:	49 89 f8             	mov    %rdi,%r8
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    3204:	4c 8d 4c 16 f8       	lea    -0x8(%rsi,%rdx,1),%r9
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    3209:	48 8d 7e 07          	lea    0x7(%rsi),%rdi
	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    320d:	ba 20 00 00 00       	mov    $0x20,%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    3212:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    3216:	49 83 e1 f8          	and    $0xfffffffffffffff8,%r9
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    321a:	49 29 f9             	sub    %rdi,%r9
	heap->heap = h;
    321d:	49 89 38             	mov    %rdi,(%r8)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    3220:	49 c1 e9 03          	shr    $0x3,%r9
	h->avail_buckets = 0;
    3224:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    322b:	41 8d 41 ff          	lea    -0x1(%r9),%eax
	h->end_chunk = heap_sz;
    322f:	44 89 4f 08          	mov    %r9d,0x8(%rdi)
	return 31 - __builtin_clz(usable_sz);
    3233:	0f bd c0             	bsr    %eax,%eax
    3236:	83 f0 1f             	xor    $0x1f,%eax
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    3239:	29 c2                	sub    %eax,%edx
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    323b:	48 63 c2             	movslq %edx,%rax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    323e:	4c 8d 14 85 17 00 00 	lea    0x17(,%rax,4),%r10
    3245:	00 
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    3246:	31 c0                	xor    %eax,%eax
    3248:	49 c1 ea 03          	shr    $0x3,%r10
    324c:	39 c2                	cmp    %eax,%edx
    324e:	7e 0d                	jle    325d <sys_heap_init+0x60>
		h->buckets[i].next = 0;
    3250:	c7 44 87 10 00 00 00 	movl   $0x0,0x10(%rdi,%rax,4)
    3257:	00 
	for (int i = 0; i < nb_buckets; i++) {
    3258:	48 ff c0             	inc    %rax
    325b:	eb ef                	jmp    324c <sys_heap_init+0x4f>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    325d:	43 8d 04 12          	lea    (%r10,%r10,1),%eax
		((uint32_t *)cmem)[f] = val;
    3261:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
    3267:	ba 01 00 00 00       	mov    $0x1,%edx
    326c:	31 f6                	xor    %esi,%esi
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    326e:	89 47 04             	mov    %eax,0x4(%rdi)
    3271:	e8 00 ff ff ff       	callq  3176 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    3276:	44 89 ca             	mov    %r9d,%edx
		((uint32_t *)cmem)[f] = val;
    3279:	46 89 14 d7          	mov    %r10d,(%rdi,%r10,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
    327d:	44 89 ce             	mov    %r9d,%esi
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    3280:	44 29 d2             	sub    %r10d,%edx
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    3283:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
    3286:	42 89 44 d7 04       	mov    %eax,0x4(%rdi,%r10,8)
	void *cmem = &buf[c];
    328b:	44 89 c8             	mov    %r9d,%eax
		((uint32_t *)cmem)[f] = val;
    328e:	89 14 c7             	mov    %edx,(%rdi,%rax,8)
	set_chunk_used(h, heap_sz, true);
    3291:	ba 01 00 00 00       	mov    $0x1,%edx
    3296:	c7 44 c7 04 00 00 00 	movl   $0x0,0x4(%rdi,%rax,8)
    329d:	00 
    329e:	e8 d3 fe ff ff       	callq  3176 <set_chunk_used>

	free_list_add(h, chunk0_size);
    32a3:	44 89 d6             	mov    %r10d,%esi
    32a6:	e9 ea fe ff ff       	jmpq   3195 <free_list_add>

00000000000032ab <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    32ab:	41 56                	push   %r14
    32ad:	49 89 f6             	mov    %rsi,%r14
    32b0:	41 55                	push   %r13
    32b2:	49 89 fd             	mov    %rdi,%r13
    32b5:	41 54                	push   %r12
    32b7:	49 89 cc             	mov    %rcx,%r12
    32ba:	55                   	push   %rbp
    32bb:	48 89 d5             	mov    %rdx,%rbp
    32be:	53                   	push   %rbx
	size_t count = 0;
    32bf:	31 db                	xor    %ebx,%ebx

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    32c1:	48 8d 44 1d 00       	lea    0x0(%rbp,%rbx,1),%rax
    32c6:	49 39 c4             	cmp    %rax,%r12
    32c9:	76 16                	jbe    32e1 <outs+0x36>
		int rc = out((int)*sp++, ctx);
    32cb:	31 c0                	xor    %eax,%eax
    32cd:	0f be 7c 1d 00       	movsbl 0x0(%rbp,%rbx,1),%edi
    32d2:	4c 89 f6             	mov    %r14,%rsi
    32d5:	41 ff d5             	callq  *%r13

		if (rc < 0) {
    32d8:	85 c0                	test   %eax,%eax
    32da:	78 17                	js     32f3 <outs+0x48>
			return rc;
		}
		++count;
    32dc:	48 ff c3             	inc    %rbx
    32df:	eb e0                	jmp    32c1 <outs+0x16>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    32e1:	4d 85 e4             	test   %r12,%r12
    32e4:	74 04                	je     32ea <outs+0x3f>
	}

	return (int)count;
    32e6:	89 d8                	mov    %ebx,%eax
    32e8:	eb 09                	jmp    32f3 <outs+0x48>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    32ea:	80 7c 1d 00 00       	cmpb   $0x0,0x0(%rbp,%rbx,1)
    32ef:	75 da                	jne    32cb <outs+0x20>
    32f1:	eb f3                	jmp    32e6 <outs+0x3b>
}
    32f3:	5b                   	pop    %rbx
    32f4:	5d                   	pop    %rbp
    32f5:	41 5c                	pop    %r12
    32f7:	41 5d                	pop    %r13
    32f9:	41 5e                	pop    %r14
    32fb:	c3                   	retq   

00000000000032fc <extract_decimal>:
{
    32fc:	55                   	push   %rbp
    32fd:	53                   	push   %rbx
    32fe:	48 89 fb             	mov    %rdi,%rbx
    3301:	51                   	push   %rcx
	const char *sp = *str;
    3302:	48 8b 2f             	mov    (%rdi),%rbp
	while (isdigit((int)(unsigned char)*sp)) {
    3305:	e8 b6 f3 ff ff       	callq  26c0 <__ctype_b_loc@plt>
    330a:	48 8b 08             	mov    (%rax),%rcx
	size_t val = 0;
    330d:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
    330f:	48 0f be 55 00       	movsbq 0x0(%rbp),%rdx
    3314:	0f b6 f2             	movzbl %dl,%esi
    3317:	f6 44 71 01 08       	testb  $0x8,0x1(%rcx,%rsi,2)
    331c:	74 0e                	je     332c <extract_decimal+0x30>
		val = 10U * val + *sp++ - '0';
    331e:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    3322:	48 ff c5             	inc    %rbp
    3325:	48 8d 44 10 d0       	lea    -0x30(%rax,%rdx,1),%rax
    332a:	eb e3                	jmp    330f <extract_decimal+0x13>
	*str = sp;
    332c:	48 89 2b             	mov    %rbp,(%rbx)
}
    332f:	5a                   	pop    %rdx
    3330:	5b                   	pop    %rbx
    3331:	5d                   	pop    %rbp
    3332:	c3                   	retq   

0000000000003333 <encode_uint>:
{
    3333:	41 55                	push   %r13
    3335:	49 89 fd             	mov    %rdi,%r13
    3338:	41 54                	push   %r12
    333a:	49 89 cc             	mov    %rcx,%r12
    333d:	55                   	push   %rbp
    333e:	48 89 d5             	mov    %rdx,%rbp
    3341:	53                   	push   %rbx
    3342:	48 89 f3             	mov    %rsi,%rbx
    3345:	41 50                	push   %r8
	bool upcase = isupper((int)conv->specifier);
    3347:	e8 74 f3 ff ff       	callq  26c0 <__ctype_b_loc@plt>
    334c:	0f b6 4b 03          	movzbl 0x3(%rbx),%ecx
    3350:	49 89 c0             	mov    %rax,%r8
    3353:	49 8b 10             	mov    (%r8),%rdx
    3356:	48 89 c8             	mov    %rcx,%rax
	switch (specifier) {
    3359:	41 b8 08 00 00 00    	mov    $0x8,%r8d
    335f:	66 8b 0c 4a          	mov    (%rdx,%rcx,2),%cx
    3363:	66 81 e1 00 01       	and    $0x100,%cx
    3368:	3c 6f                	cmp    $0x6f,%al
    336a:	74 3b                	je     33a7 <encode_uint+0x74>
    336c:	77 04                	ja     3372 <encode_uint+0x3f>
		return 16;
    336e:	3c 58                	cmp    $0x58,%al
    3370:	eb 05                	jmp    3377 <encode_uint+0x44>
	switch (specifier) {
    3372:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
    3375:	3c 70                	cmp    $0x70,%al
    3377:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
    337d:	b8 10 00 00 00       	mov    $0x10,%eax
    3382:	4c 0f 44 c0          	cmove  %rax,%r8
	char *bp = bps + (bpe - bps);
    3386:	eb 1f                	jmp    33a7 <encode_uint+0x74>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    3388:	8d 72 57             	lea    0x57(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    338b:	66 85 c9             	test   %cx,%cx
    338e:	74 03                	je     3393 <encode_uint+0x60>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    3390:	8d 72 37             	lea    0x37(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    3393:	49 ff cc             	dec    %r12
    3396:	41 88 34 24          	mov    %sil,(%r12)
	} while ((value != 0) && (bps < bp));
    339a:	4d 39 c5             	cmp    %r8,%r13
    339d:	72 1b                	jb     33ba <encode_uint+0x87>
    339f:	49 39 ec             	cmp    %rbp,%r12
    33a2:	76 16                	jbe    33ba <encode_uint+0x87>
		value /= radix;
    33a4:	49 89 c5             	mov    %rax,%r13
		unsigned int lsv = (unsigned int)(value % radix);
    33a7:	4c 89 e8             	mov    %r13,%rax
    33aa:	31 d2                	xor    %edx,%edx
    33ac:	49 f7 f0             	div    %r8
		*--bp = (lsv <= 9) ? ('0' + lsv)
    33af:	8d 72 30             	lea    0x30(%rdx),%esi
    33b2:	48 83 fa 09          	cmp    $0x9,%rdx
    33b6:	76 db                	jbe    3393 <encode_uint+0x60>
    33b8:	eb ce                	jmp    3388 <encode_uint+0x55>
	if (conv->flag_hash) {
    33ba:	f6 03 20             	testb  $0x20,(%rbx)
    33bd:	74 16                	je     33d5 <encode_uint+0xa2>
		if (radix == 8) {
    33bf:	49 83 f8 08          	cmp    $0x8,%r8
    33c3:	75 06                	jne    33cb <encode_uint+0x98>
			conv->altform_0 = true;
    33c5:	80 4b 02 08          	orb    $0x8,0x2(%rbx)
    33c9:	eb 0a                	jmp    33d5 <encode_uint+0xa2>
		} else if (radix == 16) {
    33cb:	49 83 f8 10          	cmp    $0x10,%r8
    33cf:	75 04                	jne    33d5 <encode_uint+0xa2>
			conv->altform_0c = true;
    33d1:	80 4b 02 10          	orb    $0x10,0x2(%rbx)
}
    33d5:	5a                   	pop    %rdx
    33d6:	4c 89 e0             	mov    %r12,%rax
    33d9:	5b                   	pop    %rbx
    33da:	5d                   	pop    %rbp
    33db:	41 5c                	pop    %r12
    33dd:	41 5d                	pop    %r13
    33df:	c3                   	retq   

00000000000033e0 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    33e0:	f3 0f 1e fa          	endbr64 
    33e4:	41 57                	push   %r15
    33e6:	49 89 f7             	mov    %rsi,%r15
    33e9:	41 56                	push   %r14
    33eb:	49 89 fe             	mov    %rdi,%r14
    33ee:	41 55                	push   %r13
    33f0:	49 89 d5             	mov    %rdx,%r13
    33f3:	41 54                	push   %r12
    33f5:	49 89 cc             	mov    %rcx,%r12
    33f8:	55                   	push   %rbp
    33f9:	53                   	push   %rbx
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    33fa:	31 db                	xor    %ebx,%ebx
{
    33fc:	48 83 ec 78          	sub    $0x78,%rsp
    3400:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3407:	00 00 
    3409:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    340e:	31 c0                	xor    %eax,%eax
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    3410:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
    3415:	40 84 ff             	test   %dil,%dil
    3418:	0f 84 d2 09 00 00    	je     3df0 <cbvprintf+0xa10>
		if (*fp != '%') {
    341e:	49 8d 6d 01          	lea    0x1(%r13),%rbp
			OUTC(*fp++);
    3422:	4c 89 fe             	mov    %r15,%rsi
		if (*fp != '%') {
    3425:	40 80 ff 25          	cmp    $0x25,%dil
    3429:	0f 85 89 06 00 00    	jne    3ab8 <cbvprintf+0x6d8>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    342f:	31 c0                	xor    %eax,%eax
    3431:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    3436:	b9 08 00 00 00       	mov    $0x8,%ecx
    343b:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (*sp == '%') {
    343d:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
    3442:	41 80 7d 01 25       	cmpb   $0x25,0x1(%r13)
    3447:	75 1c                	jne    3465 <cbvprintf+0x85>
		conv->specifier = *sp++;
    3449:	c6 44 24 43 25       	movb   $0x25,0x43(%rsp)
    344e:	49 8d 6d 02          	lea    0x2(%r13),%rbp
		return sp;
    3452:	e9 df 02 00 00       	jmpq   3736 <cbvprintf+0x356>
		switch (*sp) {
    3457:	7e 15                	jle    346e <cbvprintf+0x8e>
    3459:	3c 2d                	cmp    $0x2d,%al
    345b:	75 1b                	jne    3478 <cbvprintf+0x98>
			conv->flag_dash = true;
    345d:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
			++sp;
    3462:	48 ff c5             	inc    %rbp
		switch (*sp) {
    3465:	8a 45 00             	mov    0x0(%rbp),%al
    3468:	3c 2b                	cmp    $0x2b,%al
    346a:	75 eb                	jne    3457 <cbvprintf+0x77>
    346c:	eb 25                	jmp    3493 <cbvprintf+0xb3>
    346e:	3c 20                	cmp    $0x20,%al
    3470:	74 28                	je     349a <cbvprintf+0xba>
    3472:	3c 23                	cmp    $0x23,%al
    3474:	74 2b                	je     34a1 <cbvprintf+0xc1>
    3476:	eb 04                	jmp    347c <cbvprintf+0x9c>
    3478:	3c 30                	cmp    $0x30,%al
    347a:	74 2c                	je     34a8 <cbvprintf+0xc8>
	if (conv->flag_zero && conv->flag_dash) {
    347c:	8a 44 24 40          	mov    0x40(%rsp),%al
    3480:	89 c2                	mov    %eax,%edx
    3482:	83 e2 44             	and    $0x44,%edx
    3485:	80 fa 44             	cmp    $0x44,%dl
    3488:	75 25                	jne    34af <cbvprintf+0xcf>
		conv->flag_zero = false;
    348a:	83 e0 bf             	and    $0xffffffbf,%eax
    348d:	88 44 24 40          	mov    %al,0x40(%rsp)
    3491:	eb 1c                	jmp    34af <cbvprintf+0xcf>
			conv->flag_plus = true;
    3493:	80 4c 24 40 08       	orb    $0x8,0x40(%rsp)
			break;
    3498:	eb c8                	jmp    3462 <cbvprintf+0x82>
			conv->flag_space = true;
    349a:	80 4c 24 40 10       	orb    $0x10,0x40(%rsp)
			break;
    349f:	eb c1                	jmp    3462 <cbvprintf+0x82>
			conv->flag_hash = true;
    34a1:	80 4c 24 40 20       	orb    $0x20,0x40(%rsp)
			break;
    34a6:	eb ba                	jmp    3462 <cbvprintf+0x82>
			conv->flag_zero = true;
    34a8:	80 4c 24 40 40       	orb    $0x40,0x40(%rsp)
			break;
    34ad:	eb b3                	jmp    3462 <cbvprintf+0x82>
	conv->width_present = true;
    34af:	80 4c 24 40 80       	orb    $0x80,0x40(%rsp)
    34b4:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	if (*sp == '*') {
    34b9:	80 7d 00 2a          	cmpb   $0x2a,0x0(%rbp)
    34bd:	75 0a                	jne    34c9 <cbvprintf+0xe9>
		conv->width_star = true;
    34bf:	80 4c 24 41 01       	orb    $0x1,0x41(%rsp)
		return ++sp;
    34c4:	48 ff c5             	inc    %rbp
    34c7:	eb 5d                	jmp    3526 <cbvprintf+0x146>
	size_t width = extract_decimal(&sp);
    34c9:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    34ce:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    34d3:	e8 24 fe ff ff       	callq  32fc <extract_decimal>
	if (sp != wp) {
    34d8:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    34dd:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    34e2:	48 39 e9             	cmp    %rbp,%rcx
    34e5:	74 3f                	je     3526 <cbvprintf+0x146>
		conv->width_present = true;
    34e7:	8a 54 24 40          	mov    0x40(%rsp),%dl
		conv->width_value = width;
    34eb:	89 44 24 44          	mov    %eax,0x44(%rsp)
				      || (width != (size_t)conv->width_value));
    34ef:	bf 01 00 00 00       	mov    $0x1,%edi
		conv->width_present = true;
    34f4:	83 ca 80             	or     $0xffffff80,%edx
    34f7:	88 54 24 40          	mov    %dl,0x40(%rsp)
		conv->unsupported |= ((conv->width_value < 0)
    34fb:	d0 ea                	shr    %dl
    34fd:	83 e2 01             	and    $0x1,%edx
				      || (width != (size_t)conv->width_value));
    3500:	85 c0                	test   %eax,%eax
    3502:	78 0e                	js     3512 <cbvprintf+0x132>
    3504:	48 63 f8             	movslq %eax,%rdi
    3507:	48 39 c7             	cmp    %rax,%rdi
    350a:	40 0f 95 c7          	setne  %dil
    350e:	40 0f b6 ff          	movzbl %dil,%edi
		conv->unsupported |= ((conv->width_value < 0)
    3512:	8a 44 24 40          	mov    0x40(%rsp),%al
    3516:	09 fa                	or     %edi,%edx
    3518:	48 89 cd             	mov    %rcx,%rbp
    351b:	01 d2                	add    %edx,%edx
    351d:	83 e0 fd             	and    $0xfffffffd,%eax
    3520:	09 c2                	or     %eax,%edx
    3522:	88 54 24 40          	mov    %dl,0x40(%rsp)
	sp = extract_prec(conv, sp);
    3526:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	conv->prec_present = (*sp == '.');
    352b:	8a 4d 00             	mov    0x0(%rbp),%cl
    352e:	80 f9 2e             	cmp    $0x2e,%cl
    3531:	0f 94 c0             	sete   %al
    3534:	8d 14 00             	lea    (%rax,%rax,1),%edx
    3537:	8a 44 24 41          	mov    0x41(%rsp),%al
    353b:	83 e0 fd             	and    $0xfffffffd,%eax
    353e:	09 d0                	or     %edx,%eax
    3540:	88 44 24 41          	mov    %al,0x41(%rsp)
	if (!conv->prec_present) {
    3544:	80 f9 2e             	cmp    $0x2e,%cl
    3547:	75 6b                	jne    35b4 <cbvprintf+0x1d4>
	++sp;
    3549:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    354d:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
	if (*sp == '*') {
    3552:	80 7d 01 2a          	cmpb   $0x2a,0x1(%rbp)
    3556:	75 0d                	jne    3565 <cbvprintf+0x185>
		conv->prec_star = true;
    3558:	83 c8 04             	or     $0x4,%eax
		return ++sp;
    355b:	48 83 c5 02          	add    $0x2,%rbp
		conv->prec_star = true;
    355f:	88 44 24 41          	mov    %al,0x41(%rsp)
		return ++sp;
    3563:	eb 4f                	jmp    35b4 <cbvprintf+0x1d4>
	size_t prec = extract_decimal(&sp);
    3565:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    356a:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    356f:	e8 88 fd ff ff       	callq  32fc <extract_decimal>
			      || (prec != (size_t)conv->prec_value));
    3574:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    3579:	b9 01 00 00 00       	mov    $0x1,%ecx
	size_t prec = extract_decimal(&sp);
    357e:	48 89 c2             	mov    %rax,%rdx
	conv->prec_value = prec;
    3581:	89 44 24 48          	mov    %eax,0x48(%rsp)
	conv->unsupported |= ((conv->prec_value < 0)
    3585:	8a 44 24 40          	mov    0x40(%rsp),%al
    3589:	d0 e8                	shr    %al
    358b:	83 e0 01             	and    $0x1,%eax
			      || (prec != (size_t)conv->prec_value));
    358e:	85 d2                	test   %edx,%edx
    3590:	78 0c                	js     359e <cbvprintf+0x1be>
    3592:	48 63 ca             	movslq %edx,%rcx
    3595:	48 39 d1             	cmp    %rdx,%rcx
    3598:	0f 95 c1             	setne  %cl
    359b:	0f b6 c9             	movzbl %cl,%ecx
	conv->unsupported |= ((conv->prec_value < 0)
    359e:	8a 54 24 40          	mov    0x40(%rsp),%dl
    35a2:	09 c8                	or     %ecx,%eax
	return sp;
    35a4:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
	conv->unsupported |= ((conv->prec_value < 0)
    35a9:	01 c0                	add    %eax,%eax
    35ab:	83 e2 fd             	and    $0xfffffffd,%edx
    35ae:	09 d0                	or     %edx,%eax
    35b0:	88 44 24 40          	mov    %al,0x40(%rsp)
	switch (*sp) {
    35b4:	8a 4d 00             	mov    0x0(%rbp),%cl
    35b7:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    35bb:	80 f9 6c             	cmp    $0x6c,%cl
    35be:	74 54                	je     3614 <cbvprintf+0x234>
    35c0:	7f 22                	jg     35e4 <cbvprintf+0x204>
    35c2:	80 f9 68             	cmp    $0x68,%cl
    35c5:	74 33                	je     35fa <cbvprintf+0x21a>
    35c7:	80 f9 6a             	cmp    $0x6a,%cl
    35ca:	74 6e                	je     363a <cbvprintf+0x25a>
    35cc:	80 f9 4c             	cmp    $0x4c,%cl
    35cf:	75 7d                	jne    364e <cbvprintf+0x26e>
		conv->unsupported = true;
    35d1:	8b 44 24 40          	mov    0x40(%rsp),%eax
    35d5:	66 25 fd 87          	and    $0x87fd,%ax
    35d9:	66 0d 02 40          	or     $0x4002,%ax
    35dd:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
		break;
    35e2:	eb 72                	jmp    3656 <cbvprintf+0x276>
	switch (*sp) {
    35e4:	80 f9 74             	cmp    $0x74,%cl
    35e7:	8a 44 24 41          	mov    0x41(%rsp),%al
    35eb:	74 59                	je     3646 <cbvprintf+0x266>
    35ed:	80 f9 7a             	cmp    $0x7a,%cl
    35f0:	75 5c                	jne    364e <cbvprintf+0x26e>
		conv->length_mod = LENGTH_Z;
    35f2:	83 e0 87             	and    $0xffffff87,%eax
    35f5:	83 c8 30             	or     $0x30,%eax
    35f8:	eb 3a                	jmp    3634 <cbvprintf+0x254>
		if (*++sp == 'h') {
    35fa:	80 7d 01 68          	cmpb   $0x68,0x1(%rbp)
    35fe:	8a 44 24 41          	mov    0x41(%rsp),%al
    3602:	75 08                	jne    360c <cbvprintf+0x22c>
			conv->length_mod = LENGTH_HH;
    3604:	83 e0 87             	and    $0xffffff87,%eax
    3607:	83 c8 08             	or     $0x8,%eax
    360a:	eb 18                	jmp    3624 <cbvprintf+0x244>
			conv->length_mod = LENGTH_H;
    360c:	83 e0 87             	and    $0xffffff87,%eax
    360f:	83 c8 10             	or     $0x10,%eax
    3612:	eb 20                	jmp    3634 <cbvprintf+0x254>
		if (*++sp == 'l') {
    3614:	80 7d 01 6c          	cmpb   $0x6c,0x1(%rbp)
    3618:	8a 44 24 41          	mov    0x41(%rsp),%al
    361c:	75 10                	jne    362e <cbvprintf+0x24e>
			conv->length_mod = LENGTH_LL;
    361e:	83 e0 87             	and    $0xffffff87,%eax
    3621:	83 c8 20             	or     $0x20,%eax
    3624:	88 44 24 41          	mov    %al,0x41(%rsp)
			++sp;
    3628:	48 8d 55 02          	lea    0x2(%rbp),%rdx
    362c:	eb 28                	jmp    3656 <cbvprintf+0x276>
			conv->length_mod = LENGTH_L;
    362e:	83 e0 87             	and    $0xffffff87,%eax
    3631:	83 c8 18             	or     $0x18,%eax
    3634:	88 44 24 41          	mov    %al,0x41(%rsp)
    3638:	eb 1c                	jmp    3656 <cbvprintf+0x276>
		conv->length_mod = LENGTH_J;
    363a:	8a 44 24 41          	mov    0x41(%rsp),%al
    363e:	83 e0 87             	and    $0xffffff87,%eax
    3641:	83 c8 28             	or     $0x28,%eax
    3644:	eb ee                	jmp    3634 <cbvprintf+0x254>
		conv->length_mod = LENGTH_T;
    3646:	83 e0 87             	and    $0xffffff87,%eax
    3649:	83 c8 38             	or     $0x38,%eax
    364c:	eb e6                	jmp    3634 <cbvprintf+0x254>
		conv->length_mod = LENGTH_NONE;
    364e:	80 64 24 41 87       	andb   $0x87,0x41(%rsp)
		break;
    3653:	48 89 ea             	mov    %rbp,%rdx
	conv->specifier = *sp++;
    3656:	8a 02                	mov    (%rdx),%al
    3658:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
    365c:	8a 54 24 41          	mov    0x41(%rsp),%dl
    3660:	88 44 24 43          	mov    %al,0x43(%rsp)
	switch (conv->specifier) {
    3664:	3c 78                	cmp    $0x78,%al
    3666:	0f 8f ab 00 00 00    	jg     3717 <cbvprintf+0x337>
    366c:	3c 57                	cmp    $0x57,%al
    366e:	7f 11                	jg     3681 <cbvprintf+0x2a1>
    3670:	3c 41                	cmp    $0x41,%al
    3672:	74 62                	je     36d6 <cbvprintf+0x2f6>
    3674:	83 e8 45             	sub    $0x45,%eax
    3677:	3c 02                	cmp    $0x2,%al
    3679:	0f 87 98 00 00 00    	ja     3717 <cbvprintf+0x337>
    367f:	eb 55                	jmp    36d6 <cbvprintf+0x2f6>
    3681:	8d 48 a8             	lea    -0x58(%rax),%ecx
    3684:	80 f9 20             	cmp    $0x20,%cl
    3687:	0f 87 8a 00 00 00    	ja     3717 <cbvprintf+0x337>
    368d:	48 8d 3d 14 5c 00 00 	lea    0x5c14(%rip),%rdi        # 92a8 <default_cmd+0x48>
    3694:	0f b6 c9             	movzbl %cl,%ecx
    3697:	48 63 0c 8f          	movslq (%rdi,%rcx,4),%rcx
    369b:	48 01 f9             	add    %rdi,%rcx
    369e:	3e ff e1             	notrack jmpq *%rcx
		conv->specifier_cat = SPECIFIER_SINT;
    36a1:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    36a5:	83 e1 f8             	and    $0xfffffff8,%ecx
    36a8:	83 c9 01             	or     $0x1,%ecx
    36ab:	eb 0a                	jmp    36b7 <cbvprintf+0x2d7>
		conv->specifier_cat = SPECIFIER_UINT;
    36ad:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    36b1:	83 e1 f8             	and    $0xfffffff8,%ecx
    36b4:	83 c9 02             	or     $0x2,%ecx
    36b7:	f3 0f 1e fa          	endbr64 
		if (conv->length_mod == LENGTH_UPPER_L) {
    36bb:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
    36be:	88 4c 24 42          	mov    %cl,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    36c2:	80 fa 40             	cmp    $0x40,%dl
    36c5:	75 05                	jne    36cc <cbvprintf+0x2ec>
			conv->invalid = true;
    36c7:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    36cc:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
    36ce:	3c 63                	cmp    $0x63,%al
    36d0:	75 4c                	jne    371e <cbvprintf+0x33e>
			unsupported = (conv->length_mod != LENGTH_NONE);
    36d2:	84 d2                	test   %dl,%dl
    36d4:	eb 3c                	jmp    3712 <cbvprintf+0x332>
		conv->specifier_cat = SPECIFIER_FP;
    36d6:	8a 44 24 42          	mov    0x42(%rsp),%al
			unsupported = true;
    36da:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
    36dc:	83 e0 f8             	and    $0xfffffff8,%eax
    36df:	83 c8 04             	or     $0x4,%eax
    36e2:	88 44 24 42          	mov    %al,0x42(%rsp)
			break;
    36e6:	eb 36                	jmp    371e <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    36e8:	8a 44 24 42          	mov    0x42(%rsp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
    36ec:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
    36ef:	83 e0 f8             	and    $0xfffffff8,%eax
    36f2:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    36f5:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    36f8:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    36fc:	0f 94 c1             	sete   %cl
    36ff:	eb 1d                	jmp    371e <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    3701:	8a 44 24 42          	mov    0x42(%rsp),%al
    3705:	83 e0 f8             	and    $0xfffffff8,%eax
    3708:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
    370b:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    370e:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod != LENGTH_NONE) {
    3712:	0f 95 c1             	setne  %cl
    3715:	eb 07                	jmp    371e <cbvprintf+0x33e>
		conv->invalid = true;
    3717:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    371c:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
    371e:	8a 54 24 40          	mov    0x40(%rsp),%dl
    3722:	89 d0                	mov    %edx,%eax
    3724:	83 e2 fd             	and    $0xfffffffd,%edx
    3727:	d0 e8                	shr    %al
    3729:	83 e0 01             	and    $0x1,%eax
    372c:	09 c8                	or     %ecx,%eax
    372e:	01 c0                	add    %eax,%eax
    3730:	09 d0                	or     %edx,%eax
    3732:	88 44 24 40          	mov    %al,0x40(%rsp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set with if present.
		 */
		if (conv->width_star) {
    3736:	8a 4c 24 41          	mov    0x41(%rsp),%cl
    373a:	f6 c1 01             	test   $0x1,%cl
    373d:	74 3c                	je     377b <cbvprintf+0x39b>
			width = va_arg(ap, int);
    373f:	41 8b 14 24          	mov    (%r12),%edx
    3743:	83 fa 2f             	cmp    $0x2f,%edx
    3746:	77 10                	ja     3758 <cbvprintf+0x378>
    3748:	89 d0                	mov    %edx,%eax
    374a:	83 c2 08             	add    $0x8,%edx
    374d:	49 03 44 24 10       	add    0x10(%r12),%rax
    3752:	41 89 14 24          	mov    %edx,(%r12)
    3756:	eb 0e                	jmp    3766 <cbvprintf+0x386>
    3758:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    375d:	48 8d 50 08          	lea    0x8(%rax),%rdx
    3761:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    3766:	8b 00                	mov    (%rax),%eax
    3768:	89 44 24 08          	mov    %eax,0x8(%rsp)

			if (width < 0) {
    376c:	85 c0                	test   %eax,%eax
    376e:	79 22                	jns    3792 <cbvprintf+0x3b2>
				conv->flag_dash = true;
    3770:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
				width = -width;
    3775:	f7 5c 24 08          	negl   0x8(%rsp)
    3779:	eb 17                	jmp    3792 <cbvprintf+0x3b2>
			}
		} else if (conv->width_present) {
    377b:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
		int width = -1;
    3780:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%rsp)
    3787:	ff 
		} else if (conv->width_present) {
    3788:	79 08                	jns    3792 <cbvprintf+0x3b2>
			width = conv->width_value;
    378a:	8b 44 24 44          	mov    0x44(%rsp),%eax
    378e:	89 44 24 08          	mov    %eax,0x8(%rsp)

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    3792:	f6 c1 04             	test   $0x4,%cl
    3795:	74 3a                	je     37d1 <cbvprintf+0x3f1>
			int arg = va_arg(ap, int);
    3797:	41 8b 14 24          	mov    (%r12),%edx
    379b:	83 fa 2f             	cmp    $0x2f,%edx
    379e:	77 10                	ja     37b0 <cbvprintf+0x3d0>
    37a0:	89 d0                	mov    %edx,%eax
    37a2:	83 c2 08             	add    $0x8,%edx
    37a5:	49 03 44 24 10       	add    0x10(%r12),%rax
    37aa:	41 89 14 24          	mov    %edx,(%r12)
    37ae:	eb 0e                	jmp    37be <cbvprintf+0x3de>
    37b0:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    37b5:	48 8d 50 08          	lea    0x8(%rax),%rdx
    37b9:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    37be:	44 8b 10             	mov    (%rax),%r10d

			if (arg < 0) {
    37c1:	45 85 d2             	test   %r10d,%r10d
    37c4:	79 19                	jns    37df <cbvprintf+0x3ff>
				conv->prec_present = false;
    37c6:	80 64 24 41 fd       	andb   $0xfd,0x41(%rsp)
		int precision = -1;
    37cb:	41 83 ca ff          	or     $0xffffffff,%r10d
    37cf:	eb 0e                	jmp    37df <cbvprintf+0x3ff>
    37d1:	41 83 ca ff          	or     $0xffffffff,%r10d
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
    37d5:	80 e1 02             	and    $0x2,%cl
    37d8:	74 05                	je     37df <cbvprintf+0x3ff>
			precision = conv->prec_value;
    37da:	44 8b 54 24 48       	mov    0x48(%rsp),%r10d
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    37df:	8a 54 24 41          	mov    0x41(%rsp),%dl
			= (enum specifier_cat_enum)conv->specifier_cat;
    37e3:	8a 44 24 42          	mov    0x42(%rsp),%al
		conv->pad0_value = 0;
    37e7:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
    37ee:	00 00 
			= (enum length_mod_enum)conv->length_mod;
    37f0:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
    37f3:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
    37f6:	83 e2 0f             	and    $0xf,%edx
		enum length_mod_enum length_mod
    37f9:	0f b6 ca             	movzbl %dl,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    37fc:	83 f8 01             	cmp    $0x1,%eax
    37ff:	0f 85 d8 00 00 00    	jne    38dd <cbvprintf+0x4fd>
			switch (length_mod) {
    3805:	41 8b 04 24          	mov    (%r12),%eax
    3809:	80 fa 05             	cmp    $0x5,%dl
    380c:	0f 84 1e 01 00 00    	je     3930 <cbvprintf+0x550>
    3812:	77 10                	ja     3824 <cbvprintf+0x444>
    3814:	80 fa 03             	cmp    $0x3,%dl
    3817:	74 3f                	je     3858 <cbvprintf+0x478>
    3819:	80 fa 04             	cmp    $0x4,%dl
    381c:	0f 84 0e 01 00 00    	je     3930 <cbvprintf+0x550>
    3822:	eb 0c                	jmp    3830 <cbvprintf+0x450>
    3824:	8d 7a 0a             	lea    0xa(%rdx),%edi
    3827:	83 e7 0f             	and    $0xf,%edi
    382a:	40 80 ff 01          	cmp    $0x1,%dil
    382e:	76 5e                	jbe    388e <cbvprintf+0x4ae>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
    3830:	83 f8 2f             	cmp    $0x2f,%eax
    3833:	77 10                	ja     3845 <cbvprintf+0x465>
    3835:	89 c7                	mov    %eax,%edi
    3837:	83 c0 08             	add    $0x8,%eax
    383a:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    383f:	41 89 04 24          	mov    %eax,(%r12)
    3843:	eb 0e                	jmp    3853 <cbvprintf+0x473>
    3845:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    384a:	48 8d 47 08          	lea    0x8(%rdi),%rax
    384e:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3853:	48 63 07             	movslq (%rdi),%rax
    3856:	eb 5c                	jmp    38b4 <cbvprintf+0x4d4>
				break;
			case LENGTH_L:
				if (WCHAR_IS_SIGNED
    3858:	80 7c 24 43 63       	cmpb   $0x63,0x43(%rsp)
    385d:	0f 85 cd 00 00 00    	jne    3930 <cbvprintf+0x550>
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
    3863:	83 f8 2f             	cmp    $0x2f,%eax
    3866:	77 10                	ja     3878 <cbvprintf+0x498>
    3868:	89 c1                	mov    %eax,%ecx
    386a:	83 c0 08             	add    $0x8,%eax
    386d:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    3872:	41 89 04 24          	mov    %eax,(%r12)
    3876:	eb 0e                	jmp    3886 <cbvprintf+0x4a6>
    3878:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    387d:	48 8d 41 08          	lea    0x8(%rcx),%rax
    3881:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3886:	48 63 01             	movslq (%rcx),%rax
    3889:	e9 b1 01 00 00       	jmpq   3a3f <cbvprintf+0x65f>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    388e:	83 f8 2f             	cmp    $0x2f,%eax
    3891:	77 10                	ja     38a3 <cbvprintf+0x4c3>
    3893:	89 c7                	mov    %eax,%edi
    3895:	83 c0 08             	add    $0x8,%eax
    3898:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    389d:	41 89 04 24          	mov    %eax,(%r12)
    38a1:	eb 0e                	jmp    38b1 <cbvprintf+0x4d1>
    38a3:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    38a8:	48 8d 47 08          	lea    0x8(%rdi),%rax
    38ac:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    38b1:	48 8b 07             	mov    (%rdi),%rax
				value->sint =
    38b4:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    38b9:	83 f9 01             	cmp    $0x1,%ecx
    38bc:	75 0b                	jne    38c9 <cbvprintf+0x4e9>
				value->sint = (char)value->sint;
    38be:	48 0f be 44 24 30    	movsbq 0x30(%rsp),%rax
    38c4:	e9 76 01 00 00       	jmpq   3a3f <cbvprintf+0x65f>
			} else if (length_mod == LENGTH_H) {
    38c9:	83 f9 02             	cmp    $0x2,%ecx
    38cc:	0f 85 72 01 00 00    	jne    3a44 <cbvprintf+0x664>
				value->sint = (short)value->sint;
    38d2:	48 0f bf 44 24 30    	movswq 0x30(%rsp),%rax
    38d8:	e9 62 01 00 00       	jmpq   3a3f <cbvprintf+0x65f>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    38dd:	83 f8 02             	cmp    $0x2,%eax
    38e0:	0f 85 ca 00 00 00    	jne    39b0 <cbvprintf+0x5d0>
			switch (length_mod) {
    38e6:	41 8b 04 24          	mov    (%r12),%eax
    38ea:	80 fa 05             	cmp    $0x5,%dl
    38ed:	74 41                	je     3930 <cbvprintf+0x550>
    38ef:	77 0c                	ja     38fd <cbvprintf+0x51d>
    38f1:	80 fa 03             	cmp    $0x3,%dl
    38f4:	74 3a                	je     3930 <cbvprintf+0x550>
    38f6:	80 fa 04             	cmp    $0x4,%dl
    38f9:	74 35                	je     3930 <cbvprintf+0x550>
    38fb:	eb 0c                	jmp    3909 <cbvprintf+0x529>
    38fd:	8d 7a 0a             	lea    0xa(%rdx),%edi
    3900:	83 e7 0f             	and    $0xf,%edi
    3903:	40 80 ff 01          	cmp    $0x1,%dil
    3907:	76 52                	jbe    395b <cbvprintf+0x57b>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->uint = va_arg(ap, unsigned int);
    3909:	83 f8 2f             	cmp    $0x2f,%eax
    390c:	77 10                	ja     391e <cbvprintf+0x53e>
    390e:	89 c7                	mov    %eax,%edi
    3910:	83 c0 08             	add    $0x8,%eax
    3913:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    3918:	41 89 04 24          	mov    %eax,(%r12)
    391c:	eb 0e                	jmp    392c <cbvprintf+0x54c>
    391e:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    3923:	48 8d 47 08          	lea    0x8(%rdi),%rax
    3927:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    392c:	8b 07                	mov    (%rdi),%eax
    392e:	eb 51                	jmp    3981 <cbvprintf+0x5a1>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
    3930:	83 f8 2f             	cmp    $0x2f,%eax
    3933:	77 10                	ja     3945 <cbvprintf+0x565>
    3935:	89 c1                	mov    %eax,%ecx
    3937:	83 c0 08             	add    $0x8,%eax
    393a:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    393f:	41 89 04 24          	mov    %eax,(%r12)
    3943:	eb 0e                	jmp    3953 <cbvprintf+0x573>
    3945:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    394a:	48 8d 41 08          	lea    0x8(%rcx),%rax
    394e:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3953:	48 8b 01             	mov    (%rcx),%rax
    3956:	e9 e4 00 00 00       	jmpq   3a3f <cbvprintf+0x65f>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    395b:	83 f8 2f             	cmp    $0x2f,%eax
    395e:	77 10                	ja     3970 <cbvprintf+0x590>
    3960:	89 c7                	mov    %eax,%edi
    3962:	83 c0 08             	add    $0x8,%eax
    3965:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    396a:	41 89 04 24          	mov    %eax,(%r12)
    396e:	eb 0e                	jmp    397e <cbvprintf+0x59e>
    3970:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    3975:	48 8d 47 08          	lea    0x8(%rdi),%rax
    3979:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    397e:	48 8b 07             	mov    (%rdi),%rax
				value->uint =
    3981:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    3986:	83 f9 01             	cmp    $0x1,%ecx
    3989:	75 0e                	jne    3999 <cbvprintf+0x5b9>
				value->uint = (unsigned char)value->uint;
    398b:	48 81 64 24 30 ff 00 	andq   $0xff,0x30(%rsp)
    3992:	00 00 
    3994:	e9 ab 00 00 00       	jmpq   3a44 <cbvprintf+0x664>
			} else if (length_mod == LENGTH_H) {
    3999:	83 f9 02             	cmp    $0x2,%ecx
    399c:	0f 85 a2 00 00 00    	jne    3a44 <cbvprintf+0x664>
				value->uint = (unsigned short)value->uint;
    39a2:	48 81 64 24 30 ff ff 	andq   $0xffff,0x30(%rsp)
    39a9:	00 00 
    39ab:	e9 94 00 00 00       	jmpq   3a44 <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    39b0:	83 f8 04             	cmp    $0x4,%eax
    39b3:	75 5b                	jne    3a10 <cbvprintf+0x630>
			if (length_mod == LENGTH_UPPER_L) {
    39b5:	83 f9 08             	cmp    $0x8,%ecx
    39b8:	75 1e                	jne    39d8 <cbvprintf+0x5f8>
				value->ldbl = va_arg(ap, long double);
    39ba:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    39bf:	48 83 c0 0f          	add    $0xf,%rax
    39c3:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    39c7:	48 8d 48 10          	lea    0x10(%rax),%rcx
    39cb:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    39d0:	db 28                	fldt   (%rax)
    39d2:	db 7c 24 30          	fstpt  0x30(%rsp)
    39d6:	eb 6c                	jmp    3a44 <cbvprintf+0x664>
			} else {
				value->dbl = va_arg(ap, double);
    39d8:	41 8b 4c 24 04       	mov    0x4(%r12),%ecx
    39dd:	81 f9 af 00 00 00    	cmp    $0xaf,%ecx
    39e3:	77 11                	ja     39f6 <cbvprintf+0x616>
    39e5:	89 c8                	mov    %ecx,%eax
    39e7:	83 c1 10             	add    $0x10,%ecx
    39ea:	49 03 44 24 10       	add    0x10(%r12),%rax
    39ef:	41 89 4c 24 04       	mov    %ecx,0x4(%r12)
    39f4:	eb 0e                	jmp    3a04 <cbvprintf+0x624>
    39f6:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    39fb:	48 8d 48 08          	lea    0x8(%rax),%rcx
    39ff:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    3a04:	f2 0f 10 00          	movsd  (%rax),%xmm0
    3a08:	f2 0f 11 44 24 30    	movsd  %xmm0,0x30(%rsp)
    3a0e:	eb 34                	jmp    3a44 <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    3a10:	83 f8 03             	cmp    $0x3,%eax
    3a13:	75 2f                	jne    3a44 <cbvprintf+0x664>
			value->ptr = va_arg(ap, void *);
    3a15:	41 8b 0c 24          	mov    (%r12),%ecx
    3a19:	83 f9 2f             	cmp    $0x2f,%ecx
    3a1c:	77 10                	ja     3a2e <cbvprintf+0x64e>
    3a1e:	89 c8                	mov    %ecx,%eax
    3a20:	83 c1 08             	add    $0x8,%ecx
    3a23:	49 03 44 24 10       	add    0x10(%r12),%rax
    3a28:	41 89 0c 24          	mov    %ecx,(%r12)
    3a2c:	eb 0e                	jmp    3a3c <cbvprintf+0x65c>
    3a2e:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3a33:	48 8d 48 08          	lea    0x8(%rax),%rcx
    3a37:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    3a3c:	48 8b 00             	mov    (%rax),%rax
    3a3f:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    3a44:	8a 4c 24 40          	mov    0x40(%rsp),%cl
    3a48:	f6 c1 03             	test   $0x3,%cl
    3a4b:	74 23                	je     3a70 <cbvprintf+0x690>
			OUTS(sp, fp);
    3a4d:	48 89 e9             	mov    %rbp,%rcx
    3a50:	4c 89 ea             	mov    %r13,%rdx
    3a53:	4c 89 fe             	mov    %r15,%rsi
    3a56:	4c 89 f7             	mov    %r14,%rdi
    3a59:	e8 4d f8 ff ff       	callq  32ab <outs>
    3a5e:	85 c0                	test   %eax,%eax
    3a60:	0f 88 8c 03 00 00    	js     3df2 <cbvprintf+0xa12>
    3a66:	48 98                	cltq   
    3a68:	48 01 c3             	add    %rax,%rbx
			continue;
    3a6b:	e9 78 03 00 00       	jmpq   3de8 <cbvprintf+0xa08>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    3a70:	8a 44 24 43          	mov    0x43(%rsp),%al
    3a74:	3c 78                	cmp    $0x78,%al
    3a76:	0f 87 6c 03 00 00    	ja     3de8 <cbvprintf+0xa08>
    3a7c:	3c 62                	cmp    $0x62,%al
    3a7e:	77 11                	ja     3a91 <cbvprintf+0x6b1>
    3a80:	3c 25                	cmp    $0x25,%al
    3a82:	74 2c                	je     3ab0 <cbvprintf+0x6d0>
    3a84:	3c 58                	cmp    $0x58,%al
    3a86:	0f 84 c6 00 00 00    	je     3b52 <cbvprintf+0x772>
    3a8c:	e9 57 03 00 00       	jmpq   3de8 <cbvprintf+0xa08>
    3a91:	83 e8 63             	sub    $0x63,%eax
    3a94:	3c 15                	cmp    $0x15,%al
    3a96:	0f 87 4c 03 00 00    	ja     3de8 <cbvprintf+0xa08>
    3a9c:	48 8d 3d 89 58 00 00 	lea    0x5889(%rip),%rdi        # 932c <default_cmd+0xcc>
    3aa3:	0f b6 c0             	movzbl %al,%eax
    3aa6:	48 63 04 87          	movslq (%rdi,%rax,4),%rax
    3aaa:	48 01 f8             	add    %rdi,%rax
    3aad:	3e ff e0             	notrack jmpq *%rax
		case '%':
			OUTC('%');
    3ab0:	4c 89 fe             	mov    %r15,%rsi
    3ab3:	bf 25 00 00 00       	mov    $0x25,%edi
    3ab8:	31 c0                	xor    %eax,%eax
    3aba:	41 ff d6             	callq  *%r14
    3abd:	85 c0                	test   %eax,%eax
    3abf:	0f 88 2d 03 00 00    	js     3df2 <cbvprintf+0xa12>
    3ac5:	48 ff c3             	inc    %rbx
			break;
    3ac8:	e9 1b 03 00 00       	jmpq   3de8 <cbvprintf+0xa08>
		case 's': {
			bps = (const char *)value->ptr;
    3acd:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13

			size_t len;

			if (precision >= 0) {
    3ad2:	45 85 d2             	test   %r10d,%r10d
    3ad5:	78 0d                	js     3ae4 <cbvprintf+0x704>
				len = strnlen(bps, precision);
    3ad7:	49 63 f2             	movslq %r10d,%rsi
    3ada:	4c 89 ef             	mov    %r13,%rdi
    3add:	e8 0e ea ff ff       	callq  24f0 <strnlen@plt>
    3ae2:	eb 14                	jmp    3af8 <cbvprintf+0x718>
			} else {
				len = strlen(bps);
    3ae4:	31 c0                	xor    %eax,%eax
    3ae6:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3aea:	4c 89 ef             	mov    %r13,%rdi
    3aed:	f2 ae                	repnz scas %es:(%rdi),%al
    3aef:	48 89 c8             	mov    %rcx,%rax
    3af2:	48 f7 d0             	not    %rax
    3af5:	48 ff c8             	dec    %rax
			}

			bpe = bps + len;
    3af8:	4c 01 e8             	add    %r13,%rax
		char sign = 0;
    3afb:	45 31 c9             	xor    %r9d,%r9d
			bpe = bps + len;
    3afe:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			precision = -1;

			break;
    3b03:	e9 55 01 00 00       	jmpq   3c5d <cbvprintf+0x87d>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    3b08:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			bpe = buf + 1;
			break;
    3b0d:	45 31 c9             	xor    %r9d,%r9d
			bps = buf;
    3b10:	4c 8d 6c 24 52       	lea    0x52(%rsp),%r13
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    3b15:	88 44 24 52          	mov    %al,0x52(%rsp)
			bpe = buf + 1;
    3b19:	48 8d 44 24 53       	lea    0x53(%rsp),%rax
    3b1e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			break;
    3b23:	e9 3e 01 00 00       	jmpq   3c66 <cbvprintf+0x886>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
    3b28:	41 b1 2b             	mov    $0x2b,%r9b
			if (conv->flag_plus) {
    3b2b:	f6 c1 08             	test   $0x8,%cl
    3b2e:	75 0b                	jne    3b3b <cbvprintf+0x75b>
			} else if (conv->flag_space) {
				sign = ' ';
    3b30:	80 e1 10             	and    $0x10,%cl
    3b33:	41 0f 95 c1          	setne  %r9b
    3b37:	41 c1 e1 05          	shl    $0x5,%r9d

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    3b3b:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			if (sint < 0) {
    3b40:	48 85 c0             	test   %rax,%rax
    3b43:	79 10                	jns    3b55 <cbvprintf+0x775>
				sign = '-';
				value->uint = (uint_value_type)-sint;
    3b45:	48 f7 d8             	neg    %rax
				sign = '-';
    3b48:	41 b1 2d             	mov    $0x2d,%r9b
				value->uint = (uint_value_type)-sint;
    3b4b:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    3b50:	eb 03                	jmp    3b55 <cbvprintf+0x775>
		switch (conv->specifier) {
    3b52:	45 31 c9             	xor    %r9d,%r9d
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    3b55:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    3b5a:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    3b5f:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    3b64:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    3b69:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    3b6e:	e8 c0 f7 ff ff       	callq  3333 <encode_uint>
    3b73:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
    3b78:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    3b7d:	49 89 c5             	mov    %rax,%r13
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    3b80:	45 85 d2             	test   %r10d,%r10d
    3b83:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
    3b88:	0f 88 ca 00 00 00    	js     3c58 <cbvprintf+0x878>
				size_t len = bpe - bps;
    3b8e:	48 89 c1             	mov    %rax,%rcx
				 * conversions with precision.
				 */
				conv->flag_zero = false;

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    3b91:	49 63 d2             	movslq %r10d,%rdx
				conv->flag_zero = false;
    3b94:	80 64 24 40 bf       	andb   $0xbf,0x40(%rsp)
				size_t len = bpe - bps;
    3b99:	4c 29 e9             	sub    %r13,%rcx
		const char *bpe = buf + sizeof(buf);
    3b9c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
				if (len < (size_t)precision) {
    3ba1:	48 39 ca             	cmp    %rcx,%rdx
    3ba4:	0f 86 b3 00 00 00    	jbe    3c5d <cbvprintf+0x87d>
					conv->pad0_value = precision - (int)len;
    3baa:	41 29 ca             	sub    %ecx,%r10d
    3bad:	44 89 54 24 44       	mov    %r10d,0x44(%rsp)
    3bb2:	e9 a6 00 00 00       	jmpq   3c5d <cbvprintf+0x87d>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    3bb7:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    3bbc:	48 8d 05 8e 5b 00 00 	lea    0x5b8e(%rip),%rax        # 9751 <default_cmd+0x4f1>
    3bc3:	45 31 c9             	xor    %r9d,%r9d
    3bc6:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			bps = "(nil)";
    3bcb:	4c 8d 68 fb          	lea    -0x5(%rax),%r13
			if (value->ptr != NULL) {
    3bcf:	48 85 ff             	test   %rdi,%rdi
    3bd2:	0f 84 8e 00 00 00    	je     3c66 <cbvprintf+0x886>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    3bd8:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    3bdd:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    3be2:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    3be7:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    3bec:	e8 42 f7 ff ff       	callq  3333 <encode_uint>
				goto prec_int_pad0;
    3bf1:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    3bf6:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
				bps = encode_uint((uintptr_t)value->ptr, conv,
    3bfb:	49 89 c5             	mov    %rax,%r13
				conv->altform_0c = true;
    3bfe:	66 8b 44 24 42       	mov    0x42(%rsp),%ax
    3c03:	66 25 ef 00          	and    $0xef,%ax
    3c07:	66 0d 10 78          	or     $0x7810,%ax
    3c0b:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
				goto prec_int_pad0;
    3c10:	e9 6b ff ff ff       	jmpq   3b80 <cbvprintf+0x7a0>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    3c15:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    3c1a:	48 63 c3             	movslq %ebx,%rax
    3c1d:	80 fa 07             	cmp    $0x7,%dl
    3c20:	0f 87 c2 01 00 00    	ja     3de8 <cbvprintf+0xa08>
    3c26:	48 8d 35 57 57 00 00 	lea    0x5757(%rip),%rsi        # 9384 <default_cmd+0x124>
    3c2d:	0f b6 d2             	movzbl %dl,%edx
    3c30:	48 63 14 96          	movslq (%rsi,%rdx,4),%rdx
    3c34:	48 01 f2             	add    %rsi,%rdx
    3c37:	3e ff e2             	notrack jmpq *%rdx
		*(int *)dp = count;
    3c3a:	89 01                	mov    %eax,(%rcx)
		break;
    3c3c:	e9 a7 01 00 00       	jmpq   3de8 <cbvprintf+0xa08>
		*(signed char *)dp = (signed char)count;
    3c41:	88 19                	mov    %bl,(%rcx)
		break;
    3c43:	e9 a0 01 00 00       	jmpq   3de8 <cbvprintf+0xa08>
		*(short *)dp = (short)count;
    3c48:	66 89 19             	mov    %bx,(%rcx)
		break;
    3c4b:	e9 98 01 00 00       	jmpq   3de8 <cbvprintf+0xa08>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    3c50:	48 89 01             	mov    %rax,(%rcx)
		break;
    3c53:	e9 90 01 00 00       	jmpq   3de8 <cbvprintf+0xa08>
		const char *bpe = buf + sizeof(buf);
    3c58:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    3c5d:	4d 85 ed             	test   %r13,%r13
    3c60:	0f 84 82 01 00 00    	je     3de8 <cbvprintf+0xa08>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    3c66:	48 8b 44 24 10       	mov    0x10(%rsp),%rax

		if (sign != 0) {
			nj_len += 1U;
		}

		if (conv->altform_0c) {
    3c6b:	8a 4c 24 42          	mov    0x42(%rsp),%cl
		size_t nj_len = (bpe - bps);
    3c6f:	4c 29 e8             	sub    %r13,%rax
			nj_len += 1U;
    3c72:	41 80 f9 01          	cmp    $0x1,%r9b
    3c76:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		if (conv->altform_0c) {
    3c7a:	f6 c1 10             	test   $0x10,%cl
    3c7d:	74 06                	je     3c85 <cbvprintf+0x8a5>
			nj_len += 2U;
    3c7f:	48 83 c0 02          	add    $0x2,%rax
    3c83:	eb 0c                	jmp    3c91 <cbvprintf+0x8b1>
		} else if (conv->altform_0) {
    3c85:	89 ca                	mov    %ecx,%edx
    3c87:	83 e2 08             	and    $0x8,%edx
			nj_len += 1U;
    3c8a:	80 fa 01             	cmp    $0x1,%dl
    3c8d:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		}

		nj_len += conv->pad0_value;
    3c91:	48 63 54 24 44       	movslq 0x44(%rsp),%rdx
    3c96:	48 01 d0             	add    %rdx,%rax
		if (conv->pad_fp) {
    3c99:	80 e1 40             	and    $0x40,%cl
    3c9c:	74 08                	je     3ca6 <cbvprintf+0x8c6>
			nj_len += conv->pad0_pre_exp;
    3c9e:	48 63 54 24 48       	movslq 0x48(%rsp),%rdx
    3ca3:	48 01 d0             	add    %rdx,%rax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    3ca6:	83 7c 24 08 00       	cmpl   $0x0,0x8(%rsp)
    3cab:	7e 73                	jle    3d20 <cbvprintf+0x940>
			width -= (int)nj_len;
    3cad:	29 44 24 08          	sub    %eax,0x8(%rsp)

			if (!conv->flag_dash) {
    3cb1:	8a 44 24 40          	mov    0x40(%rsp),%al
    3cb5:	a8 04                	test   $0x4,%al
    3cb7:	75 67                	jne    3d20 <cbvprintf+0x940>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    3cb9:	a8 40                	test   $0x40,%al
    3cbb:	74 21                	je     3cde <cbvprintf+0x8fe>
					if (sign != 0) {
    3cbd:	45 84 c9             	test   %r9b,%r9b
    3cc0:	74 20                	je     3ce2 <cbvprintf+0x902>
						OUTC(sign);
    3cc2:	31 c0                	xor    %eax,%eax
    3cc4:	41 0f be f9          	movsbl %r9b,%edi
    3cc8:	4c 89 fe             	mov    %r15,%rsi
    3ccb:	41 ff d6             	callq  *%r14
    3cce:	85 c0                	test   %eax,%eax
    3cd0:	0f 88 1c 01 00 00    	js     3df2 <cbvprintf+0xa12>
    3cd6:	48 ff c3             	inc    %rbx
						sign = 0;
    3cd9:	45 31 c9             	xor    %r9d,%r9d
    3cdc:	eb 04                	jmp    3ce2 <cbvprintf+0x902>
				char pad = ' ';
    3cde:	b0 20                	mov    $0x20,%al
    3ce0:	eb 02                	jmp    3ce4 <cbvprintf+0x904>
					}
					pad = '0';
    3ce2:	b0 30                	mov    $0x30,%al
    3ce4:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
				}

				while (width-- > 0) {
					OUTC(pad);
    3ce8:	0f be d0             	movsbl %al,%edx
				while (width-- > 0) {
    3ceb:	ff 4c 24 08          	decl   0x8(%rsp)
    3cef:	85 c9                	test   %ecx,%ecx
    3cf1:	7e 2d                	jle    3d20 <cbvprintf+0x940>
					OUTC(pad);
    3cf3:	31 c0                	xor    %eax,%eax
    3cf5:	44 88 4c 24 1f       	mov    %r9b,0x1f(%rsp)
    3cfa:	4c 89 fe             	mov    %r15,%rsi
    3cfd:	89 d7                	mov    %edx,%edi
    3cff:	89 54 24 18          	mov    %edx,0x18(%rsp)
    3d03:	41 ff d6             	callq  *%r14
    3d06:	85 c0                	test   %eax,%eax
    3d08:	0f 88 e4 00 00 00    	js     3df2 <cbvprintf+0xa12>
				while (width-- > 0) {
    3d0e:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
    3d12:	8b 54 24 18          	mov    0x18(%rsp),%edx
					OUTC(pad);
    3d16:	48 ff c3             	inc    %rbx
    3d19:	44 8a 4c 24 1f       	mov    0x1f(%rsp),%r9b
    3d1e:	eb cb                	jmp    3ceb <cbvprintf+0x90b>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    3d20:	45 84 c9             	test   %r9b,%r9b
    3d23:	74 17                	je     3d3c <cbvprintf+0x95c>
			OUTC(sign);
    3d25:	31 c0                	xor    %eax,%eax
    3d27:	41 0f be f9          	movsbl %r9b,%edi
    3d2b:	4c 89 fe             	mov    %r15,%rsi
    3d2e:	41 ff d6             	callq  *%r14
    3d31:	85 c0                	test   %eax,%eax
    3d33:	0f 88 b9 00 00 00    	js     3df2 <cbvprintf+0xa12>
    3d39:	48 ff c3             	inc    %rbx
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    3d3c:	8a 44 24 42          	mov    0x42(%rsp),%al
    3d40:	a8 10                	test   $0x10,%al
    3d42:	75 04                	jne    3d48 <cbvprintf+0x968>
    3d44:	a8 08                	test   $0x8,%al
    3d46:	74 18                	je     3d60 <cbvprintf+0x980>
				OUTC('0');
    3d48:	31 c0                	xor    %eax,%eax
    3d4a:	4c 89 fe             	mov    %r15,%rsi
    3d4d:	bf 30 00 00 00       	mov    $0x30,%edi
    3d52:	41 ff d6             	callq  *%r14
    3d55:	85 c0                	test   %eax,%eax
    3d57:	0f 88 95 00 00 00    	js     3df2 <cbvprintf+0xa12>
    3d5d:	48 ff c3             	inc    %rbx
			}

			if (conv->altform_0c) {
    3d60:	f6 44 24 42 10       	testb  $0x10,0x42(%rsp)
    3d65:	74 14                	je     3d7b <cbvprintf+0x99b>
				OUTC(conv->specifier);
    3d67:	31 c0                	xor    %eax,%eax
    3d69:	0f b6 7c 24 43       	movzbl 0x43(%rsp),%edi
    3d6e:	4c 89 fe             	mov    %r15,%rsi
    3d71:	41 ff d6             	callq  *%r14
    3d74:	85 c0                	test   %eax,%eax
    3d76:	78 7a                	js     3df2 <cbvprintf+0xa12>
    3d78:	48 ff c3             	inc    %rbx
			}

			pad_len = conv->pad0_value;
			while (pad_len-- > 0) {
    3d7b:	8b 44 24 44          	mov    0x44(%rsp),%eax
    3d7f:	01 d8                	add    %ebx,%eax
    3d81:	89 44 24 18          	mov    %eax,0x18(%rsp)
    3d85:	8b 44 24 18          	mov    0x18(%rsp),%eax
    3d89:	29 d8                	sub    %ebx,%eax
    3d8b:	85 c0                	test   %eax,%eax
    3d8d:	7e 16                	jle    3da5 <cbvprintf+0x9c5>
				OUTC('0');
    3d8f:	31 c0                	xor    %eax,%eax
    3d91:	4c 89 fe             	mov    %r15,%rsi
    3d94:	bf 30 00 00 00       	mov    $0x30,%edi
    3d99:	41 ff d6             	callq  *%r14
    3d9c:	85 c0                	test   %eax,%eax
    3d9e:	78 52                	js     3df2 <cbvprintf+0xa12>
    3da0:	48 ff c3             	inc    %rbx
    3da3:	eb e0                	jmp    3d85 <cbvprintf+0x9a5>
			}

			OUTS(bps, bpe);
    3da5:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    3daa:	4c 89 ea             	mov    %r13,%rdx
    3dad:	4c 89 fe             	mov    %r15,%rsi
    3db0:	4c 89 f7             	mov    %r14,%rdi
    3db3:	e8 f3 f4 ff ff       	callq  32ab <outs>
    3db8:	85 c0                	test   %eax,%eax
    3dba:	78 36                	js     3df2 <cbvprintf+0xa12>
    3dbc:	44 8b 6c 24 08       	mov    0x8(%rsp),%r13d
    3dc1:	48 98                	cltq   
    3dc3:	48 01 c3             	add    %rax,%rbx
    3dc6:	41 01 dd             	add    %ebx,%r13d
		}

		/* Finish left justification */
		while (width > 0) {
    3dc9:	44 89 e8             	mov    %r13d,%eax
    3dcc:	29 d8                	sub    %ebx,%eax
    3dce:	85 c0                	test   %eax,%eax
    3dd0:	7e 16                	jle    3de8 <cbvprintf+0xa08>
			OUTC(' ');
    3dd2:	31 c0                	xor    %eax,%eax
    3dd4:	4c 89 fe             	mov    %r15,%rsi
    3dd7:	bf 20 00 00 00       	mov    $0x20,%edi
    3ddc:	41 ff d6             	callq  *%r14
    3ddf:	85 c0                	test   %eax,%eax
    3de1:	78 0f                	js     3df2 <cbvprintf+0xa12>
    3de3:	48 ff c3             	inc    %rbx
			--width;
    3de6:	eb e1                	jmp    3dc9 <cbvprintf+0x9e9>
			OUTS(bps, bpe);
    3de8:	49 89 ed             	mov    %rbp,%r13
    3deb:	e9 20 f6 ff ff       	jmpq   3410 <cbvprintf+0x30>
		}
	}

	return count;
    3df0:	89 d8                	mov    %ebx,%eax
#undef OUTS
#undef OUTC
}
    3df2:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
    3df7:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    3dfe:	00 00 
    3e00:	74 05                	je     3e07 <cbvprintf+0xa27>
    3e02:	e8 a9 e6 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    3e07:	48 83 c4 78          	add    $0x78,%rsp
    3e0b:	5b                   	pop    %rbx
    3e0c:	5d                   	pop    %rbp
    3e0d:	41 5c                	pop    %r12
    3e0f:	41 5d                	pop    %r13
    3e11:	41 5e                	pop    %r14
    3e13:	41 5f                	pop    %r15
    3e15:	c3                   	retq   

0000000000003e16 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
    3e16:	f3 0f 1e fa          	endbr64 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    3e1a:	c3                   	retq   

0000000000003e1b <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    3e1b:	f3 0f 1e fa          	endbr64 
    3e1f:	50                   	push   %rax
    3e20:	48 8d 3d 2a 57 00 00 	lea    0x572a(%rip),%rdi        # 9551 <default_cmd+0x2f1>
    3e27:	e8 0b 3d 00 00       	callq  7b37 <z_impl_device_get_binding>
	__printk_hook_install(console_out);
    3e2c:	48 8d 3d 10 00 00 00 	lea    0x10(%rip),%rdi        # 3e43 <console_out>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    3e33:	48 89 05 4e b6 00 00 	mov    %rax,0xb64e(%rip)        # f488 <uart_console_dev>
	__printk_hook_install(console_out);
    3e3a:	e8 d7 f1 ff ff       	callq  3016 <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
    3e3f:	31 c0                	xor    %eax,%eax
    3e41:	5a                   	pop    %rdx
    3e42:	c3                   	retq   

0000000000003e43 <console_out>:
{
    3e43:	f3 0f 1e fa          	endbr64 
    3e47:	41 54                	push   %r12
    3e49:	41 89 fc             	mov    %edi,%r12d
	if ('\n' == c) {
    3e4c:	83 ff 0a             	cmp    $0xa,%edi
    3e4f:	75 13                	jne    3e64 <console_out+0x21>
    3e51:	48 8b 3d 30 b6 00 00 	mov    0xb630(%rip),%rdi        # f488 <uart_console_dev>
	api->poll_out(dev, out_char);
    3e58:	48 8b 47 10          	mov    0x10(%rdi),%rax
    3e5c:	be 0d 00 00 00       	mov    $0xd,%esi
    3e61:	ff 50 08             	callq  *0x8(%rax)
	uart_poll_out(uart_console_dev, c);
    3e64:	48 8b 3d 1d b6 00 00 	mov    0xb61d(%rip),%rdi        # f488 <uart_console_dev>
    3e6b:	48 8b 47 10          	mov    0x10(%rdi),%rax
    3e6f:	41 0f b6 f4          	movzbl %r12b,%esi
    3e73:	ff 50 08             	callq  *0x8(%rax)
}
    3e76:	44 89 e0             	mov    %r12d,%eax
    3e79:	41 5c                	pop    %r12
    3e7b:	c3                   	retq   

0000000000003e7c <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
    3e7c:	f3 0f 1e fa          	endbr64 
    3e80:	50                   	push   %rax
	setvbuf(stdout, NULL, _IOLBF, 512);
    3e81:	48 8b 05 20 81 00 00 	mov    0x8120(%rip),%rax        # bfa8 <stdout@GLIBC_2.2.5>
    3e88:	b9 00 02 00 00       	mov    $0x200,%ecx
    3e8d:	31 f6                	xor    %esi,%esi
    3e8f:	ba 01 00 00 00       	mov    $0x1,%edx
    3e94:	48 8b 38             	mov    (%rax),%rdi
    3e97:	e8 44 e7 ff ff       	callq  25e0 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
    3e9c:	48 8b 05 4d 81 00 00 	mov    0x814d(%rip),%rax        # bff0 <stderr@GLIBC_2.2.5>
    3ea3:	ba 01 00 00 00       	mov    $0x1,%edx
    3ea8:	31 f6                	xor    %esi,%esi
    3eaa:	b9 00 02 00 00       	mov    $0x200,%ecx
    3eaf:	48 8b 38             	mov    (%rax),%rdi
    3eb2:	e8 29 e7 ff ff       	callq  25e0 <setvbuf@plt>
	__printk_hook_install(putchar);
    3eb7:	48 8b 3d da 80 00 00 	mov    0x80da(%rip),%rdi        # bf98 <putchar@GLIBC_2.2.5>
    3ebe:	e8 53 f1 ff ff       	callq  3016 <__printk_hook_install>
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    3ec3:	31 c0                	xor    %eax,%eax
    3ec5:	5a                   	pop    %rdx
    3ec6:	c3                   	retq   

0000000000003ec7 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
    3ec7:	f3 0f 1e fa          	endbr64 
    3ecb:	50                   	push   %rax
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
    3ecc:	e8 75 1e 00 00       	callq  5d46 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    3ed1:	48 8b 35 b8 b5 00 00 	mov    0xb5b8(%rip),%rsi        # f490 <last_tick_time>
    3ed8:	48 8b 0d b9 b5 00 00 	mov    0xb5b9(%rip),%rcx        # f498 <tick_period>
    3edf:	31 d2                	xor    %edx,%edx
    3ee1:	48 29 f0             	sub    %rsi,%rax
    3ee4:	48 f7 f1             	div    %rcx

	last_tick_time += elapsed_ticks*tick_period;
    3ee7:	48 63 d0             	movslq %eax,%rdx
	sys_clock_announce(elapsed_ticks);
    3eea:	89 c7                	mov    %eax,%edi
	last_tick_time += elapsed_ticks*tick_period;
    3eec:	48 0f af d1          	imul   %rcx,%rdx
    3ef0:	48 01 f2             	add    %rsi,%rdx
    3ef3:	48 89 15 96 b5 00 00 	mov    %rdx,0xb596(%rip)        # f490 <last_tick_time>
}
    3efa:	5a                   	pop    %rdx
	sys_clock_announce(elapsed_ticks);
    3efb:	e9 16 4d 00 00       	jmpq   8c16 <sys_clock_announce>

0000000000003f00 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int sys_clock_driver_init(const struct device *dev)
{
    3f00:	f3 0f 1e fa          	endbr64 
    3f04:	50                   	push   %rax
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    3f05:	48 c7 05 88 b5 00 00 	movq   $0x2710,0xb588(%rip)        # f498 <tick_period>
    3f0c:	10 27 00 00 

	last_tick_time = hwm_get_time();
    3f10:	e8 31 1e 00 00       	callq  5d46 <hwm_get_time>
	hwtimer_enable(tick_period);
    3f15:	48 8b 3d 7c b5 00 00 	mov    0xb57c(%rip),%rdi        # f498 <tick_period>
	last_tick_time = hwm_get_time();
    3f1c:	48 89 05 6d b5 00 00 	mov    %rax,0xb56d(%rip)        # f490 <last_tick_time>
	hwtimer_enable(tick_period);
    3f23:	e8 bf 20 00 00       	callq  5fe7 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    3f28:	31 c9                	xor    %ecx,%ecx
    3f2a:	48 8d 15 96 ff ff ff 	lea    -0x6a(%rip),%rdx        # 3ec7 <np_timer_isr>
    3f31:	31 f6                	xor    %esi,%esi
    3f33:	31 ff                	xor    %edi,%edi
    3f35:	e8 97 24 00 00       	callq  63d1 <posix_isr_declare>
    3f3a:	31 d2                	xor    %edx,%edx
    3f3c:	be 01 00 00 00       	mov    $0x1,%esi
    3f41:	31 ff                	xor    %edi,%edi
    3f43:	e8 ae 24 00 00       	callq  63f6 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    3f48:	31 ff                	xor    %edi,%edi
    3f4a:	e8 00 14 00 00       	callq  534f <arch_irq_enable>

	return 0;
}
    3f4f:	31 c0                	xor    %eax,%eax
    3f51:	5a                   	pop    %rdx
    3f52:	c3                   	retq   

0000000000003f53 <sys_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    3f53:	f3 0f 1e fa          	endbr64 

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with sys_clock_announce() is INT_MAX
	 */
	if (ticks == K_TICKS_FOREVER) {
		silent_ticks = INT64_MAX;
    3f57:	49 b8 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%r8
    3f5e:	ff ff 7f 
	if (ticks == K_TICKS_FOREVER) {
    3f61:	83 ff ff             	cmp    $0xffffffff,%edi
    3f64:	74 0c                	je     3f72 <sys_clock_set_timeout+0x1f>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    3f66:	45 31 c0             	xor    %r8d,%r8d
	} else if (ticks > 0) {
    3f69:	85 ff                	test   %edi,%edi
    3f6b:	7e 05                	jle    3f72 <sys_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
    3f6d:	ff cf                	dec    %edi
    3f6f:	4c 63 c7             	movslq %edi,%r8
	}
	hwtimer_set_silent_ticks(silent_ticks);
    3f72:	4c 89 c7             	mov    %r8,%rdi
    3f75:	e9 1f 22 00 00       	jmpq   6199 <hwtimer_set_silent_ticks>

0000000000003f7a <sys_clock_elapsed>:
 * last call to sys_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
uint32_t sys_clock_elapsed(void)
{
    3f7a:	f3 0f 1e fa          	endbr64 
    3f7e:	50                   	push   %rax
	return (hwm_get_time() - last_tick_time)/tick_period;
    3f7f:	e8 c2 1d 00 00       	callq  5d46 <hwm_get_time>
    3f84:	31 d2                	xor    %edx,%edx
    3f86:	48 2b 05 03 b5 00 00 	sub    0xb503(%rip),%rax        # f490 <last_tick_time>
    3f8d:	48 f7 35 04 b5 00 00 	divq   0xb504(%rip)        # f498 <tick_period>
}
    3f94:	5a                   	pop    %rdx
    3f95:	c3                   	retq   

0000000000003f96 <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
    3f96:	f3 0f 1e fa          	endbr64 
    3f9a:	41 89 f1             	mov    %esi,%r9d
    3f9d:	89 c8                	mov    %ecx,%eax
    3f9f:	48 89 d6             	mov    %rdx,%rsi
	if (from_len <= to_len) {
    3fa2:	44 39 c9             	cmp    %r9d,%ecx
    3fa5:	77 05                	ja     3fac <_copy+0x16>
		(void)memcpy(to, from, from_len);
    3fa7:	89 c9                	mov    %ecx,%ecx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    3fa9:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		return from_len;
    3fab:	c3                   	retq   
	} else {
		return TC_CRYPTO_FAIL;
    3fac:	31 c0                	xor    %eax,%eax
	}
}
    3fae:	c3                   	retq   

0000000000003faf <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
    3faf:	f3 0f 1e fa          	endbr64 
	(void)memset(to, val, len);
    3fb3:	89 d1                	mov    %edx,%ecx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    3fb5:	89 f0                	mov    %esi,%eax
    3fb7:	f3 aa                	rep stos %al,%es:(%rdi)
}
    3fb9:	c3                   	retq   

0000000000003fba <_double_byte>:

/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
    3fba:	f3 0f 1e fa          	endbr64 
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
    3fbe:	89 f8                	mov    %edi,%eax
    3fc0:	b2 1b                	mov    $0x1b,%dl
    3fc2:	01 ff                	add    %edi,%edi
    3fc4:	c0 e8 07             	shr    $0x7,%al
    3fc7:	0f af c2             	imul   %edx,%eax
    3fca:	31 f8                	xor    %edi,%eax
}
    3fcc:	c3                   	retq   

0000000000003fcd <_compare>:

int _compare(const uint8_t *a, const uint8_t *b, size_t size)
{
    3fcd:	f3 0f 1e fa          	endbr64 
	const uint8_t *tempa = a;
	const uint8_t *tempb = b;
	uint8_t result = 0;

	for (unsigned int i = 0; i < size; i++) {
    3fd1:	45 31 c0             	xor    %r8d,%r8d
	uint8_t result = 0;
    3fd4:	31 c0                	xor    %eax,%eax
	for (unsigned int i = 0; i < size; i++) {
    3fd6:	44 89 c1             	mov    %r8d,%ecx
    3fd9:	48 39 d1             	cmp    %rdx,%rcx
    3fdc:	73 12                	jae    3ff0 <_compare+0x23>
		result |= tempa[i] ^ tempb[i];
    3fde:	44 8a 0c 0f          	mov    (%rdi,%rcx,1),%r9b
    3fe2:	44 32 0c 0e          	xor    (%rsi,%rcx,1),%r9b
	for (unsigned int i = 0; i < size; i++) {
    3fe6:	41 ff c0             	inc    %r8d
		result |= tempa[i] ^ tempb[i];
    3fe9:	44 89 c9             	mov    %r9d,%ecx
    3fec:	09 c8                	or     %ecx,%eax
	for (unsigned int i = 0; i < size; i++) {
    3fee:	eb e6                	jmp    3fd6 <_compare+0x9>
	}
	return result;
    3ff0:	0f b6 c0             	movzbl %al,%eax
}
    3ff3:	c3                   	retq   

0000000000003ff4 <add_round_key>:
	(void)_copy(s, sizeof(t), t, sizeof(t));
}

static inline void add_round_key(uint8_t *s, const unsigned int *k)
{
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    3ff4:	8a 46 03             	mov    0x3(%rsi),%al
    3ff7:	30 07                	xor    %al,(%rdi)
    3ff9:	8a 46 02             	mov    0x2(%rsi),%al
    3ffc:	30 47 01             	xor    %al,0x1(%rdi)
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    3fff:	8a 46 01             	mov    0x1(%rsi),%al
    4002:	30 47 02             	xor    %al,0x2(%rdi)
    4005:	8b 06                	mov    (%rsi),%eax
    4007:	30 47 03             	xor    %al,0x3(%rdi)
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    400a:	0f b6 46 07          	movzbl 0x7(%rsi),%eax
    400e:	30 47 04             	xor    %al,0x4(%rdi)
    4011:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    4015:	30 47 05             	xor    %al,0x5(%rdi)
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    4018:	8a 46 05             	mov    0x5(%rsi),%al
    401b:	30 47 06             	xor    %al,0x6(%rdi)
    401e:	8b 46 04             	mov    0x4(%rsi),%eax
    4021:	30 47 07             	xor    %al,0x7(%rdi)
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    4024:	0f b6 46 0b          	movzbl 0xb(%rsi),%eax
    4028:	30 47 08             	xor    %al,0x8(%rdi)
    402b:	0f b7 46 0a          	movzwl 0xa(%rsi),%eax
    402f:	30 47 09             	xor    %al,0x9(%rdi)
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    4032:	8a 46 09             	mov    0x9(%rsi),%al
    4035:	30 47 0a             	xor    %al,0xa(%rdi)
    4038:	8b 46 08             	mov    0x8(%rsi),%eax
    403b:	30 47 0b             	xor    %al,0xb(%rdi)
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    403e:	0f b6 46 0f          	movzbl 0xf(%rsi),%eax
    4042:	30 47 0c             	xor    %al,0xc(%rdi)
    4045:	0f b7 46 0e          	movzwl 0xe(%rsi),%eax
    4049:	30 47 0d             	xor    %al,0xd(%rdi)
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    404c:	8a 46 0d             	mov    0xd(%rsi),%al
    404f:	30 47 0e             	xor    %al,0xe(%rdi)
    4052:	8b 46 0c             	mov    0xc(%rsi),%eax
    4055:	30 47 0f             	xor    %al,0xf(%rdi)
}
    4058:	c3                   	retq   

0000000000004059 <inv_shift_rows>:
 * This inv_shift_rows also implements the matrix flip required for
 * inv_mix_columns, but performs it here to reduce the number of memory
 * operations.
 */
static inline void inv_shift_rows(uint8_t *s)
{
    4059:	48 83 ec 28          	sub    $0x28,%rsp

	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
	t[4]  = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
	t[8]  = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
	(void)_copy(s, sizeof(t), t, sizeof(t));
    405d:	b9 10 00 00 00       	mov    $0x10,%ecx
    4062:	be 10 00 00 00       	mov    $0x10,%esi
{
    4067:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    406e:	00 00 
    4070:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4075:	31 c0                	xor    %eax,%eax
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
    4077:	8a 07                	mov    (%rdi),%al
	(void)_copy(s, sizeof(t), t, sizeof(t));
    4079:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
    407e:	88 44 24 08          	mov    %al,0x8(%rsp)
    4082:	8a 47 0d             	mov    0xd(%rdi),%al
    4085:	88 44 24 09          	mov    %al,0x9(%rsp)
    4089:	8a 47 0a             	mov    0xa(%rdi),%al
    408c:	88 44 24 0a          	mov    %al,0xa(%rsp)
    4090:	8a 47 07             	mov    0x7(%rdi),%al
    4093:	88 44 24 0b          	mov    %al,0xb(%rsp)
	t[4]  = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
    4097:	8a 47 04             	mov    0x4(%rdi),%al
    409a:	88 44 24 0c          	mov    %al,0xc(%rsp)
    409e:	8a 47 01             	mov    0x1(%rdi),%al
    40a1:	88 44 24 0d          	mov    %al,0xd(%rsp)
    40a5:	8a 47 0e             	mov    0xe(%rdi),%al
    40a8:	88 44 24 0e          	mov    %al,0xe(%rsp)
    40ac:	8a 47 0b             	mov    0xb(%rdi),%al
    40af:	88 44 24 0f          	mov    %al,0xf(%rsp)
	t[8]  = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
    40b3:	8a 47 08             	mov    0x8(%rdi),%al
    40b6:	88 44 24 10          	mov    %al,0x10(%rsp)
    40ba:	8a 47 05             	mov    0x5(%rdi),%al
    40bd:	88 44 24 11          	mov    %al,0x11(%rsp)
    40c1:	8a 47 02             	mov    0x2(%rdi),%al
    40c4:	88 44 24 12          	mov    %al,0x12(%rsp)
    40c8:	8a 47 0f             	mov    0xf(%rdi),%al
    40cb:	88 44 24 13          	mov    %al,0x13(%rsp)
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
    40cf:	8a 47 0c             	mov    0xc(%rdi),%al
    40d2:	88 44 24 14          	mov    %al,0x14(%rsp)
    40d6:	8a 47 09             	mov    0x9(%rdi),%al
    40d9:	88 44 24 15          	mov    %al,0x15(%rsp)
    40dd:	8a 47 06             	mov    0x6(%rdi),%al
    40e0:	88 44 24 16          	mov    %al,0x16(%rsp)
    40e4:	8a 47 03             	mov    0x3(%rdi),%al
    40e7:	88 44 24 17          	mov    %al,0x17(%rsp)
	(void)_copy(s, sizeof(t), t, sizeof(t));
    40eb:	e8 a6 fe ff ff       	callq  3f96 <_copy>
}
    40f0:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    40f5:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    40fc:	00 00 
    40fe:	74 05                	je     4105 <inv_shift_rows+0xac>
    4100:	e8 ab e3 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4105:	48 83 c4 28          	add    $0x28,%rsp
    4109:	c3                   	retq   

000000000000410a <mult_row_column>:
{
    410a:	41 57                	push   %r15
    410c:	41 56                	push   %r14
    410e:	41 55                	push   %r13
    4110:	41 54                	push   %r12
    4112:	55                   	push   %rbp
    4113:	48 89 fd             	mov    %rdi,%rbp
    4116:	53                   	push   %rbx
    4117:	48 89 f3             	mov    %rsi,%rbx
    411a:	48 83 ec 18          	sub    $0x18,%rsp
	out[0] = multe(in[0]) ^ multb(in[1]) ^ multd(in[2]) ^ mult9(in[3]);
    411e:	0f b6 3e             	movzbl (%rsi),%edi
    4121:	e8 94 fe ff ff       	callq  3fba <_double_byte>
    4126:	0f b6 f8             	movzbl %al,%edi
    4129:	e8 8c fe ff ff       	callq  3fba <_double_byte>
    412e:	0f b6 f8             	movzbl %al,%edi
    4131:	e8 84 fe ff ff       	callq  3fba <_double_byte>
    4136:	0f b6 3b             	movzbl (%rbx),%edi
    4139:	41 89 c7             	mov    %eax,%r15d
    413c:	e8 79 fe ff ff       	callq  3fba <_double_byte>
    4141:	0f b6 f8             	movzbl %al,%edi
    4144:	e8 71 fe ff ff       	callq  3fba <_double_byte>
    4149:	0f b6 3b             	movzbl (%rbx),%edi
    414c:	41 89 c6             	mov    %eax,%r14d
    414f:	e8 66 fe ff ff       	callq  3fba <_double_byte>
    4154:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4158:	41 89 c5             	mov    %eax,%r13d
    415b:	e8 5a fe ff ff       	callq  3fba <_double_byte>
    4160:	0f b6 f8             	movzbl %al,%edi
    4163:	e8 52 fe ff ff       	callq  3fba <_double_byte>
    4168:	0f b6 f8             	movzbl %al,%edi
    416b:	e8 4a fe ff ff       	callq  3fba <_double_byte>
    4170:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4174:	41 89 c4             	mov    %eax,%r12d
    4177:	e8 3e fe ff ff       	callq  3fba <_double_byte>
    417c:	8a 53 01             	mov    0x1(%rbx),%dl
    417f:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    4183:	88 44 24 0c          	mov    %al,0xc(%rsp)
    4187:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    418b:	e8 2a fe ff ff       	callq  3fba <_double_byte>
    4190:	0f b6 f8             	movzbl %al,%edi
    4193:	e8 22 fe ff ff       	callq  3fba <_double_byte>
    4198:	0f b6 f8             	movzbl %al,%edi
    419b:	e8 1a fe ff ff       	callq  3fba <_double_byte>
    41a0:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    41a4:	88 44 24 0d          	mov    %al,0xd(%rsp)
    41a8:	e8 0d fe ff ff       	callq  3fba <_double_byte>
    41ad:	0f b6 f8             	movzbl %al,%edi
    41b0:	e8 05 fe ff ff       	callq  3fba <_double_byte>
    41b5:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    41b9:	8a 54 24 0f          	mov    0xf(%rsp),%dl
    41bd:	32 53 02             	xor    0x2(%rbx),%dl
    41c0:	88 44 24 0e          	mov    %al,0xe(%rsp)
    41c4:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    41c8:	e8 ed fd ff ff       	callq  3fba <_double_byte>
    41cd:	0f b6 f8             	movzbl %al,%edi
    41d0:	e8 e5 fd ff ff       	callq  3fba <_double_byte>
    41d5:	0f b6 f8             	movzbl %al,%edi
    41d8:	e8 dd fd ff ff       	callq  3fba <_double_byte>
    41dd:	8a 54 24 0f          	mov    0xf(%rsp),%dl
    41e1:	41 89 c0             	mov    %eax,%r8d
    41e4:	8a 43 03             	mov    0x3(%rbx),%al
    41e7:	31 d0                	xor    %edx,%eax
    41e9:	44 31 f8             	xor    %r15d,%eax
    41ec:	44 31 f0             	xor    %r14d,%eax
    41ef:	44 31 e8             	xor    %r13d,%eax
    41f2:	44 31 e0             	xor    %r12d,%eax
    41f5:	33 44 24 0c          	xor    0xc(%rsp),%eax
    41f9:	32 44 24 0d          	xor    0xd(%rsp),%al
    41fd:	32 44 24 0e          	xor    0xe(%rsp),%al
    4201:	44 31 c0             	xor    %r8d,%eax
    4204:	88 45 00             	mov    %al,0x0(%rbp)
	out[1] = mult9(in[0]) ^ multe(in[1]) ^ multb(in[2]) ^ multd(in[3]);
    4207:	0f b6 3b             	movzbl (%rbx),%edi
    420a:	e8 ab fd ff ff       	callq  3fba <_double_byte>
    420f:	0f b6 f8             	movzbl %al,%edi
    4212:	e8 a3 fd ff ff       	callq  3fba <_double_byte>
    4217:	0f b6 f8             	movzbl %al,%edi
    421a:	e8 9b fd ff ff       	callq  3fba <_double_byte>
    421f:	8a 13                	mov    (%rbx),%dl
    4221:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4225:	41 89 c7             	mov    %eax,%r15d
    4228:	88 54 24 0e          	mov    %dl,0xe(%rsp)
    422c:	e8 89 fd ff ff       	callq  3fba <_double_byte>
    4231:	0f b6 f8             	movzbl %al,%edi
    4234:	e8 81 fd ff ff       	callq  3fba <_double_byte>
    4239:	0f b6 f8             	movzbl %al,%edi
    423c:	e8 79 fd ff ff       	callq  3fba <_double_byte>
    4241:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4245:	41 89 c6             	mov    %eax,%r14d
    4248:	e8 6d fd ff ff       	callq  3fba <_double_byte>
    424d:	0f b6 f8             	movzbl %al,%edi
    4250:	e8 65 fd ff ff       	callq  3fba <_double_byte>
    4255:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4259:	41 89 c5             	mov    %eax,%r13d
    425c:	e8 59 fd ff ff       	callq  3fba <_double_byte>
    4261:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    4265:	41 89 c4             	mov    %eax,%r12d
    4268:	e8 4d fd ff ff       	callq  3fba <_double_byte>
    426d:	0f b6 f8             	movzbl %al,%edi
    4270:	e8 45 fd ff ff       	callq  3fba <_double_byte>
    4275:	0f b6 f8             	movzbl %al,%edi
    4278:	e8 3d fd ff ff       	callq  3fba <_double_byte>
    427d:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    4281:	88 44 24 0c          	mov    %al,0xc(%rsp)
    4285:	e8 30 fd ff ff       	callq  3fba <_double_byte>
    428a:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    428e:	8a 54 24 0e          	mov    0xe(%rsp),%dl
    4292:	32 53 02             	xor    0x2(%rbx),%dl
    4295:	88 44 24 0d          	mov    %al,0xd(%rsp)
    4299:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    429d:	e8 18 fd ff ff       	callq  3fba <_double_byte>
    42a2:	0f b6 f8             	movzbl %al,%edi
    42a5:	e8 10 fd ff ff       	callq  3fba <_double_byte>
    42aa:	0f b6 f8             	movzbl %al,%edi
    42ad:	e8 08 fd ff ff       	callq  3fba <_double_byte>
    42b2:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    42b6:	88 44 24 0e          	mov    %al,0xe(%rsp)
    42ba:	e8 fb fc ff ff       	callq  3fba <_double_byte>
    42bf:	0f b6 f8             	movzbl %al,%edi
    42c2:	e8 f3 fc ff ff       	callq  3fba <_double_byte>
    42c7:	8a 54 24 0f          	mov    0xf(%rsp),%dl
    42cb:	41 89 c0             	mov    %eax,%r8d
    42ce:	8a 43 03             	mov    0x3(%rbx),%al
    42d1:	31 d0                	xor    %edx,%eax
    42d3:	44 31 f8             	xor    %r15d,%eax
    42d6:	44 31 f0             	xor    %r14d,%eax
    42d9:	44 31 e8             	xor    %r13d,%eax
    42dc:	44 31 e0             	xor    %r12d,%eax
    42df:	33 44 24 0c          	xor    0xc(%rsp),%eax
    42e3:	32 44 24 0d          	xor    0xd(%rsp),%al
    42e7:	32 44 24 0e          	xor    0xe(%rsp),%al
    42eb:	44 31 c0             	xor    %r8d,%eax
    42ee:	88 45 01             	mov    %al,0x1(%rbp)
	out[2] = multd(in[0]) ^ mult9(in[1]) ^ multe(in[2]) ^ multb(in[3]);
    42f1:	0f b6 3b             	movzbl (%rbx),%edi
    42f4:	e8 c1 fc ff ff       	callq  3fba <_double_byte>
    42f9:	0f b6 f8             	movzbl %al,%edi
    42fc:	e8 b9 fc ff ff       	callq  3fba <_double_byte>
    4301:	0f b6 f8             	movzbl %al,%edi
    4304:	e8 b1 fc ff ff       	callq  3fba <_double_byte>
    4309:	0f b6 3b             	movzbl (%rbx),%edi
    430c:	41 89 c7             	mov    %eax,%r15d
    430f:	e8 a6 fc ff ff       	callq  3fba <_double_byte>
    4314:	0f b6 f8             	movzbl %al,%edi
    4317:	e8 9e fc ff ff       	callq  3fba <_double_byte>
    431c:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4320:	44 8a 23             	mov    (%rbx),%r12b
    4323:	41 89 c6             	mov    %eax,%r14d
    4326:	e8 8f fc ff ff       	callq  3fba <_double_byte>
    432b:	0f b6 f8             	movzbl %al,%edi
    432e:	e8 87 fc ff ff       	callq  3fba <_double_byte>
    4333:	0f b6 f8             	movzbl %al,%edi
    4336:	e8 7f fc ff ff       	callq  3fba <_double_byte>
    433b:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    433f:	44 32 63 01          	xor    0x1(%rbx),%r12b
    4343:	41 89 c5             	mov    %eax,%r13d
    4346:	e8 6f fc ff ff       	callq  3fba <_double_byte>
    434b:	0f b6 f8             	movzbl %al,%edi
    434e:	e8 67 fc ff ff       	callq  3fba <_double_byte>
    4353:	0f b6 f8             	movzbl %al,%edi
    4356:	e8 5f fc ff ff       	callq  3fba <_double_byte>
    435b:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    435f:	88 44 24 0c          	mov    %al,0xc(%rsp)
    4363:	e8 52 fc ff ff       	callq  3fba <_double_byte>
    4368:	0f b6 f8             	movzbl %al,%edi
    436b:	e8 4a fc ff ff       	callq  3fba <_double_byte>
    4370:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    4374:	88 44 24 0d          	mov    %al,0xd(%rsp)
    4378:	e8 3d fc ff ff       	callq  3fba <_double_byte>
    437d:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    4381:	88 44 24 0e          	mov    %al,0xe(%rsp)
    4385:	e8 30 fc ff ff       	callq  3fba <_double_byte>
    438a:	0f b6 f8             	movzbl %al,%edi
    438d:	e8 28 fc ff ff       	callq  3fba <_double_byte>
    4392:	0f b6 f8             	movzbl %al,%edi
    4395:	e8 20 fc ff ff       	callq  3fba <_double_byte>
    439a:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    439e:	88 44 24 0f          	mov    %al,0xf(%rsp)
    43a2:	e8 13 fc ff ff       	callq  3fba <_double_byte>
    43a7:	41 89 c0             	mov    %eax,%r8d
    43aa:	8a 43 03             	mov    0x3(%rbx),%al
    43ad:	44 31 e0             	xor    %r12d,%eax
    43b0:	44 31 f8             	xor    %r15d,%eax
    43b3:	44 31 f0             	xor    %r14d,%eax
    43b6:	44 31 e8             	xor    %r13d,%eax
    43b9:	33 44 24 0c          	xor    0xc(%rsp),%eax
    43bd:	32 44 24 0d          	xor    0xd(%rsp),%al
    43c1:	32 44 24 0e          	xor    0xe(%rsp),%al
    43c5:	32 44 24 0f          	xor    0xf(%rsp),%al
    43c9:	44 31 c0             	xor    %r8d,%eax
    43cc:	88 45 02             	mov    %al,0x2(%rbp)
	out[3] = multb(in[0]) ^ multd(in[1]) ^ mult9(in[2]) ^ multe(in[3]);
    43cf:	0f b6 3b             	movzbl (%rbx),%edi
    43d2:	e8 e3 fb ff ff       	callq  3fba <_double_byte>
    43d7:	0f b6 f8             	movzbl %al,%edi
    43da:	e8 db fb ff ff       	callq  3fba <_double_byte>
    43df:	0f b6 f8             	movzbl %al,%edi
    43e2:	e8 d3 fb ff ff       	callq  3fba <_double_byte>
    43e7:	0f b6 3b             	movzbl (%rbx),%edi
    43ea:	41 89 c4             	mov    %eax,%r12d
    43ed:	e8 c8 fb ff ff       	callq  3fba <_double_byte>
    43f2:	8a 13                	mov    (%rbx),%dl
    43f4:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    43f8:	41 89 c7             	mov    %eax,%r15d
    43fb:	88 54 24 0c          	mov    %dl,0xc(%rsp)
    43ff:	e8 b6 fb ff ff       	callq  3fba <_double_byte>
    4404:	0f b6 f8             	movzbl %al,%edi
    4407:	e8 ae fb ff ff       	callq  3fba <_double_byte>
    440c:	0f b6 f8             	movzbl %al,%edi
    440f:	e8 a6 fb ff ff       	callq  3fba <_double_byte>
    4414:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    4418:	41 89 c6             	mov    %eax,%r14d
    441b:	e8 9a fb ff ff       	callq  3fba <_double_byte>
    4420:	0f b6 f8             	movzbl %al,%edi
    4423:	e8 92 fb ff ff       	callq  3fba <_double_byte>
    4428:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    442c:	8a 54 24 0c          	mov    0xc(%rsp),%dl
    4430:	32 53 01             	xor    0x1(%rbx),%dl
    4433:	41 89 c5             	mov    %eax,%r13d
    4436:	88 54 24 0c          	mov    %dl,0xc(%rsp)
    443a:	e8 7b fb ff ff       	callq  3fba <_double_byte>
    443f:	0f b6 f8             	movzbl %al,%edi
    4442:	e8 73 fb ff ff       	callq  3fba <_double_byte>
    4447:	0f b6 f8             	movzbl %al,%edi
    444a:	e8 6b fb ff ff       	callq  3fba <_double_byte>
    444f:	8a 54 24 0c          	mov    0xc(%rsp),%dl
    4453:	32 53 02             	xor    0x2(%rbx),%dl
    4456:	41 31 d4             	xor    %edx,%r12d
    4459:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    445d:	45 31 fc             	xor    %r15d,%r12d
    4460:	45 31 f4             	xor    %r14d,%r12d
    4463:	45 31 ec             	xor    %r13d,%r12d
    4466:	41 31 c4             	xor    %eax,%r12d
    4469:	e8 4c fb ff ff       	callq  3fba <_double_byte>
    446e:	0f b6 f8             	movzbl %al,%edi
    4471:	e8 44 fb ff ff       	callq  3fba <_double_byte>
    4476:	0f b6 f8             	movzbl %al,%edi
    4479:	e8 3c fb ff ff       	callq  3fba <_double_byte>
    447e:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    4482:	41 89 c5             	mov    %eax,%r13d
    4485:	e8 30 fb ff ff       	callq  3fba <_double_byte>
    448a:	45 31 ec             	xor    %r13d,%r12d
    448d:	0f b6 f8             	movzbl %al,%edi
    4490:	e8 25 fb ff ff       	callq  3fba <_double_byte>
    4495:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    4499:	41 89 c6             	mov    %eax,%r14d
    449c:	e8 19 fb ff ff       	callq  3fba <_double_byte>
    44a1:	45 31 f4             	xor    %r14d,%r12d
    44a4:	41 31 c4             	xor    %eax,%r12d
    44a7:	44 88 65 03          	mov    %r12b,0x3(%rbp)
}
    44ab:	48 83 c4 18          	add    $0x18,%rsp
    44af:	5b                   	pop    %rbx
    44b0:	5d                   	pop    %rbp
    44b1:	41 5c                	pop    %r12
    44b3:	41 5d                	pop    %r13
    44b5:	41 5e                	pop    %r14
    44b7:	41 5f                	pop    %r15
    44b9:	c3                   	retq   

00000000000044ba <tc_aes_decrypt>:

int tc_aes_decrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    44ba:	f3 0f 1e fa          	endbr64 
    44be:	41 57                	push   %r15
    44c0:	41 56                	push   %r14
    44c2:	41 55                	push   %r13
    44c4:	41 54                	push   %r12
    44c6:	49 89 d4             	mov    %rdx,%r12
    44c9:	55                   	push   %rbp
    44ca:	53                   	push   %rbx
    44cb:	48 83 ec 48          	sub    $0x48,%rsp
    44cf:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    44d4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    44db:	00 00 
    44dd:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    44e2:	31 c0                	xor    %eax,%eax

	if (out == (uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    44e4:	48 85 d2             	test   %rdx,%rdx
    44e7:	0f 94 c2             	sete   %dl
	} else if (in == (const uint8_t *) 0) {
    44ea:	48 85 f6             	test   %rsi,%rsi
    44ed:	0f 94 c0             	sete   %al
	} else if (s == (TCAesKeySched_t) 0) {
    44f0:	08 c2                	or     %al,%dl
    44f2:	0f 85 21 01 00 00    	jne    4619 <tc_aes_decrypt+0x15f>
    44f8:	48 85 ff             	test   %rdi,%rdi
    44fb:	0f 84 18 01 00 00    	je     4619 <tc_aes_decrypt+0x15f>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    4501:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
    4506:	48 89 f2             	mov    %rsi,%rdx
    4509:	b9 10 00 00 00       	mov    $0x10,%ecx
    450e:	be 10 00 00 00       	mov    $0x10,%esi
    4513:	48 89 ef             	mov    %rbp,%rdi
    4516:	4d 8d b4 24 90 00 00 	lea    0x90(%r12),%r14
    451d:	00 
		s[i] = inv_sbox[s[i]];
    451e:	4c 8d 3d db 4a 00 00 	lea    0x4adb(%rip),%r15        # 9000 <inv_sbox>
	(void)_copy(state, sizeof(state), in, sizeof(state));
    4525:	e8 6c fa ff ff       	callq  3f96 <_copy>

	add_round_key(state, s->words + Nb*Nr);
    452a:	49 8d b4 24 a0 00 00 	lea    0xa0(%r12),%rsi
    4531:	00 
    4532:	48 89 ef             	mov    %rbp,%rdi
    4535:	e8 ba fa ff ff       	callq  3ff4 <add_round_key>

	for (i = Nr - 1; i > 0; --i) {
		inv_shift_rows(state);
    453a:	48 89 ef             	mov    %rbp,%rdi
    453d:	49 89 ed             	mov    %rbp,%r13
    4540:	48 8d 5c 24 28       	lea    0x28(%rsp),%rbx
    4545:	e8 0f fb ff ff       	callq  4059 <inv_shift_rows>
    454a:	48 89 e8             	mov    %rbp,%rax
		s[i] = inv_sbox[s[i]];
    454d:	0f b6 10             	movzbl (%rax),%edx
    4550:	48 ff c0             	inc    %rax
    4553:	41 8a 14 17          	mov    (%r15,%rdx,1),%dl
    4557:	88 50 ff             	mov    %dl,-0x1(%rax)
	for (i = 0; i < (Nb*Nk); ++i) {
    455a:	48 39 d8             	cmp    %rbx,%rax
    455d:	75 ee                	jne    454d <tc_aes_decrypt+0x93>
		inv_sub_bytes(state);
		add_round_key(state, s->words + Nb*i);
    455f:	4c 89 f6             	mov    %r14,%rsi
    4562:	48 89 ef             	mov    %rbp,%rdi
    4565:	49 83 ee 10          	sub    $0x10,%r14
    4569:	e8 86 fa ff ff       	callq  3ff4 <add_round_key>
	mult_row_column(t, s);
    456e:	48 89 ee             	mov    %rbp,%rsi
    4571:	48 89 df             	mov    %rbx,%rdi
    4574:	e8 91 fb ff ff       	callq  410a <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    4579:	48 8d 74 24 1c       	lea    0x1c(%rsp),%rsi
    457e:	48 8d 7c 24 2c       	lea    0x2c(%rsp),%rdi
    4583:	e8 82 fb ff ff       	callq  410a <mult_row_column>
	mult_row_column(&t[2*Nb], s+(2*Nb));
    4588:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
    458d:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    4592:	e8 73 fb ff ff       	callq  410a <mult_row_column>
	mult_row_column(&t[3*Nb], s+(3*Nb));
    4597:	48 8d 74 24 24       	lea    0x24(%rsp),%rsi
    459c:	48 8d 7c 24 34       	lea    0x34(%rsp),%rdi
    45a1:	e8 64 fb ff ff       	callq  410a <mult_row_column>
	(void)_copy(s, sizeof(t), t, sizeof(t));
    45a6:	b9 10 00 00 00       	mov    $0x10,%ecx
    45ab:	48 89 da             	mov    %rbx,%rdx
    45ae:	48 89 ef             	mov    %rbp,%rdi
    45b1:	be 10 00 00 00       	mov    $0x10,%esi
    45b6:	e8 db f9 ff ff       	callq  3f96 <_copy>
	for (i = Nr - 1; i > 0; --i) {
    45bb:	4d 39 e6             	cmp    %r12,%r14
    45be:	0f 85 76 ff ff ff    	jne    453a <tc_aes_decrypt+0x80>
		inv_mix_columns(state);
	}

	inv_shift_rows(state);
    45c4:	48 89 ef             	mov    %rbp,%rdi
    45c7:	e8 8d fa ff ff       	callq  4059 <inv_shift_rows>
		s[i] = inv_sbox[s[i]];
    45cc:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
    45d1:	49 ff c5             	inc    %r13
    45d4:	41 8a 04 07          	mov    (%r15,%rax,1),%al
    45d8:	41 88 45 ff          	mov    %al,-0x1(%r13)
	for (i = 0; i < (Nb*Nk); ++i) {
    45dc:	49 39 dd             	cmp    %rbx,%r13
    45df:	75 eb                	jne    45cc <tc_aes_decrypt+0x112>
	inv_sub_bytes(state);
	add_round_key(state, s->words);
    45e1:	4c 89 e6             	mov    %r12,%rsi
    45e4:	48 89 ef             	mov    %rbp,%rdi
    45e7:	e8 08 fa ff ff       	callq  3ff4 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    45ec:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    45f1:	b9 10 00 00 00       	mov    $0x10,%ecx
    45f6:	48 89 ea             	mov    %rbp,%rdx
    45f9:	be 10 00 00 00       	mov    $0x10,%esi
    45fe:	e8 93 f9 ff ff       	callq  3f96 <_copy>

	/*zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    4603:	ba 10 00 00 00       	mov    $0x10,%edx
    4608:	31 f6                	xor    %esi,%esi
    460a:	48 89 ef             	mov    %rbp,%rdi
    460d:	e8 9d f9 ff ff       	callq  3faf <_set>


	return TC_CRYPTO_SUCCESS;
    4612:	b8 01 00 00 00       	mov    $0x1,%eax
    4617:	eb 02                	jmp    461b <tc_aes_decrypt+0x161>
		return TC_CRYPTO_FAIL;
    4619:	31 c0                	xor    %eax,%eax
}
    461b:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    4620:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    4627:	00 00 
    4629:	74 05                	je     4630 <tc_aes_decrypt+0x176>
    462b:	e8 80 de ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4630:	48 83 c4 48          	add    $0x48,%rsp
    4634:	5b                   	pop    %rbx
    4635:	5d                   	pop    %rbp
    4636:	41 5c                	pop    %r12
    4638:	41 5d                	pop    %r13
    463a:	41 5e                	pop    %r14
    463c:	41 5f                	pop    %r15
    463e:	c3                   	retq   

000000000000463f <add_round_key>:
	return TC_CRYPTO_SUCCESS;
}

static inline void add_round_key(uint8_t *s, const unsigned int *k)
{
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    463f:	8a 46 03             	mov    0x3(%rsi),%al
    4642:	30 07                	xor    %al,(%rdi)
    4644:	8a 46 02             	mov    0x2(%rsi),%al
    4647:	30 47 01             	xor    %al,0x1(%rdi)
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    464a:	8a 46 01             	mov    0x1(%rsi),%al
    464d:	30 47 02             	xor    %al,0x2(%rdi)
    4650:	8b 06                	mov    (%rsi),%eax
    4652:	30 47 03             	xor    %al,0x3(%rdi)
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    4655:	0f b6 46 07          	movzbl 0x7(%rsi),%eax
    4659:	30 47 04             	xor    %al,0x4(%rdi)
    465c:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    4660:	30 47 05             	xor    %al,0x5(%rdi)
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    4663:	8a 46 05             	mov    0x5(%rsi),%al
    4666:	30 47 06             	xor    %al,0x6(%rdi)
    4669:	8b 46 04             	mov    0x4(%rsi),%eax
    466c:	30 47 07             	xor    %al,0x7(%rdi)
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    466f:	0f b6 46 0b          	movzbl 0xb(%rsi),%eax
    4673:	30 47 08             	xor    %al,0x8(%rdi)
    4676:	0f b7 46 0a          	movzwl 0xa(%rsi),%eax
    467a:	30 47 09             	xor    %al,0x9(%rdi)
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    467d:	8a 46 09             	mov    0x9(%rsi),%al
    4680:	30 47 0a             	xor    %al,0xa(%rdi)
    4683:	8b 46 08             	mov    0x8(%rsi),%eax
    4686:	30 47 0b             	xor    %al,0xb(%rdi)
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    4689:	0f b6 46 0f          	movzbl 0xf(%rsi),%eax
    468d:	30 47 0c             	xor    %al,0xc(%rdi)
    4690:	0f b7 46 0e          	movzwl 0xe(%rsi),%eax
    4694:	30 47 0d             	xor    %al,0xd(%rdi)
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    4697:	8a 46 0d             	mov    0xd(%rsi),%al
    469a:	30 47 0e             	xor    %al,0xe(%rdi)
    469d:	8b 46 0c             	mov    0xc(%rsi),%eax
    46a0:	30 47 0f             	xor    %al,0xf(%rdi)
}
    46a3:	c3                   	retq   

00000000000046a4 <shift_rows>:
/*
 * This shift_rows also implements the matrix flip required for mix_columns, but
 * performs it here to reduce the number of memory operations.
 */
static inline void shift_rows(uint8_t *s)
{
    46a4:	48 83 ec 28          	sub    $0x28,%rsp

	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
    46a8:	b9 10 00 00 00       	mov    $0x10,%ecx
    46ad:	be 10 00 00 00       	mov    $0x10,%esi
{
    46b2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    46b9:	00 00 
    46bb:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    46c0:	31 c0                	xor    %eax,%eax
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    46c2:	8a 07                	mov    (%rdi),%al
	(void) _copy(s, sizeof(t), t, sizeof(t));
    46c4:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    46c9:	88 44 24 08          	mov    %al,0x8(%rsp)
    46cd:	8a 47 05             	mov    0x5(%rdi),%al
    46d0:	88 44 24 09          	mov    %al,0x9(%rsp)
    46d4:	8a 47 0a             	mov    0xa(%rdi),%al
    46d7:	88 44 24 0a          	mov    %al,0xa(%rsp)
    46db:	8a 47 0f             	mov    0xf(%rdi),%al
    46de:	88 44 24 0b          	mov    %al,0xb(%rsp)
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
    46e2:	8a 47 04             	mov    0x4(%rdi),%al
    46e5:	88 44 24 0c          	mov    %al,0xc(%rsp)
    46e9:	8a 47 09             	mov    0x9(%rdi),%al
    46ec:	88 44 24 0d          	mov    %al,0xd(%rsp)
    46f0:	8a 47 0e             	mov    0xe(%rdi),%al
    46f3:	88 44 24 0e          	mov    %al,0xe(%rsp)
    46f7:	8a 47 03             	mov    0x3(%rdi),%al
    46fa:	88 44 24 0f          	mov    %al,0xf(%rsp)
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
    46fe:	8a 47 08             	mov    0x8(%rdi),%al
    4701:	88 44 24 10          	mov    %al,0x10(%rsp)
    4705:	8a 47 0d             	mov    0xd(%rdi),%al
    4708:	88 44 24 11          	mov    %al,0x11(%rsp)
    470c:	8a 47 02             	mov    0x2(%rdi),%al
    470f:	88 44 24 12          	mov    %al,0x12(%rsp)
    4713:	8a 47 07             	mov    0x7(%rdi),%al
    4716:	88 44 24 13          	mov    %al,0x13(%rsp)
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
    471a:	8a 47 0c             	mov    0xc(%rdi),%al
    471d:	88 44 24 14          	mov    %al,0x14(%rsp)
    4721:	8a 47 01             	mov    0x1(%rdi),%al
    4724:	88 44 24 15          	mov    %al,0x15(%rsp)
    4728:	8a 47 06             	mov    0x6(%rdi),%al
    472b:	88 44 24 16          	mov    %al,0x16(%rsp)
    472f:	8a 47 0b             	mov    0xb(%rdi),%al
    4732:	88 44 24 17          	mov    %al,0x17(%rsp)
	(void) _copy(s, sizeof(t), t, sizeof(t));
    4736:	e8 5b f8 ff ff       	callq  3f96 <_copy>
}
    473b:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    4740:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4747:	00 00 
    4749:	74 05                	je     4750 <shift_rows+0xac>
    474b:	e8 60 dd ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4750:	48 83 c4 28          	add    $0x28,%rsp
    4754:	c3                   	retq   

0000000000004755 <mult_row_column>:
{
    4755:	41 55                	push   %r13
    4757:	41 54                	push   %r12
    4759:	49 89 fc             	mov    %rdi,%r12
    475c:	55                   	push   %rbp
    475d:	53                   	push   %rbx
    475e:	48 89 f3             	mov    %rsi,%rbx
    4761:	50                   	push   %rax
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    4762:	0f b6 3e             	movzbl (%rsi),%edi
    4765:	e8 50 f8 ff ff       	callq  3fba <_double_byte>
    476a:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    476e:	89 c5                	mov    %eax,%ebp
    4770:	e8 45 f8 ff ff       	callq  3fba <_double_byte>
    4775:	41 89 c0             	mov    %eax,%r8d
    4778:	8a 43 01             	mov    0x1(%rbx),%al
    477b:	32 43 02             	xor    0x2(%rbx),%al
    477e:	32 43 03             	xor    0x3(%rbx),%al
    4781:	31 e8                	xor    %ebp,%eax
    4783:	44 31 c0             	xor    %r8d,%eax
    4786:	41 88 04 24          	mov    %al,(%r12)
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    478a:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    478e:	40 8a 2b             	mov    (%rbx),%bpl
    4791:	e8 24 f8 ff ff       	callq  3fba <_double_byte>
    4796:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    479a:	41 89 c5             	mov    %eax,%r13d
    479d:	e8 18 f8 ff ff       	callq  3fba <_double_byte>
    47a2:	41 89 c0             	mov    %eax,%r8d
    47a5:	8a 43 02             	mov    0x2(%rbx),%al
    47a8:	31 e8                	xor    %ebp,%eax
    47aa:	32 43 03             	xor    0x3(%rbx),%al
    47ad:	44 31 e8             	xor    %r13d,%eax
    47b0:	44 31 c0             	xor    %r8d,%eax
    47b3:	41 88 44 24 01       	mov    %al,0x1(%r12)
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    47b8:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    47bc:	40 8a 2b             	mov    (%rbx),%bpl
    47bf:	40 32 6b 01          	xor    0x1(%rbx),%bpl
    47c3:	e8 f2 f7 ff ff       	callq  3fba <_double_byte>
    47c8:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    47cc:	41 89 c5             	mov    %eax,%r13d
    47cf:	e8 e6 f7 ff ff       	callq  3fba <_double_byte>
    47d4:	40 32 6b 03          	xor    0x3(%rbx),%bpl
    47d8:	44 31 ed             	xor    %r13d,%ebp
    47db:	31 c5                	xor    %eax,%ebp
    47dd:	41 88 6c 24 02       	mov    %bpl,0x2(%r12)
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    47e2:	0f b6 3b             	movzbl (%rbx),%edi
    47e5:	e8 d0 f7 ff ff       	callq  3fba <_double_byte>
    47ea:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    47ee:	40 8a 2b             	mov    (%rbx),%bpl
    47f1:	40 32 6b 01          	xor    0x1(%rbx),%bpl
    47f5:	40 32 6b 02          	xor    0x2(%rbx),%bpl
    47f9:	31 c5                	xor    %eax,%ebp
    47fb:	e8 ba f7 ff ff       	callq  3fba <_double_byte>
    4800:	31 c5                	xor    %eax,%ebp
    4802:	41 88 6c 24 03       	mov    %bpl,0x3(%r12)
}
    4807:	5a                   	pop    %rdx
    4808:	5b                   	pop    %rbx
    4809:	5d                   	pop    %rbp
    480a:	41 5c                	pop    %r12
    480c:	41 5d                	pop    %r13
    480e:	c3                   	retq   

000000000000480f <tc_aes128_set_encrypt_key>:
{
    480f:	f3 0f 1e fa          	endbr64 
    4813:	48 83 ec 48          	sub    $0x48,%rsp
    4817:	49 89 f8             	mov    %rdi,%r8
    481a:	49 89 f1             	mov    %rsi,%r9
	const unsigned int rconst[11] = {
    481d:	b9 0b 00 00 00       	mov    $0xb,%ecx
{
    4822:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4829:	00 00 
    482b:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    4830:	31 c0                	xor    %eax,%eax
	const unsigned int rconst[11] = {
    4832:	48 8d 7c 24 0c       	lea    0xc(%rsp),%rdi
    4837:	48 8d 35 c2 48 00 00 	lea    0x48c2(%rip),%rsi        # 9100 <inv_sbox+0x100>
    483e:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	} else if (k == (const uint8_t *) 0) {
    4840:	4d 85 c0             	test   %r8,%r8
    4843:	0f 84 ad 00 00 00    	je     48f6 <tc_aes128_set_encrypt_key+0xe7>
    4849:	4d 85 c9             	test   %r9,%r9
    484c:	0f 84 a4 00 00 00    	je     48f6 <tc_aes128_set_encrypt_key+0xe7>
    4852:	31 d2                	xor    %edx,%edx
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    4854:	41 0f b6 04 11       	movzbl (%r9,%rdx,1),%eax
    4859:	41 0f b6 4c 11 01    	movzbl 0x1(%r9,%rdx,1),%ecx
    485f:	c1 e0 18             	shl    $0x18,%eax
    4862:	c1 e1 10             	shl    $0x10,%ecx
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    4865:	09 c8                	or     %ecx,%eax
    4867:	41 0f b6 4c 11 03    	movzbl 0x3(%r9,%rdx,1),%ecx
    486d:	09 c8                	or     %ecx,%eax
    486f:	41 0f b6 4c 11 02    	movzbl 0x2(%r9,%rdx,1),%ecx
    4875:	c1 e1 08             	shl    $0x8,%ecx
    4878:	09 c8                	or     %ecx,%eax
    487a:	41 89 04 10          	mov    %eax,(%r8,%rdx,1)
	for (i = 0; i < Nk; ++i) {
    487e:	48 83 c2 04          	add    $0x4,%rdx
    4882:	48 83 fa 10          	cmp    $0x10,%rdx
    4886:	75 cc                	jne    4854 <tc_aes128_set_encrypt_key+0x45>
    4888:	be 04 00 00 00       	mov    $0x4,%esi
			t = subword(rotword(t)) ^ rconst[i/Nk];
    488d:	48 8d 3d ac 48 00 00 	lea    0x48ac(%rip),%rdi        # 9140 <sbox>
		t = s->words[i-1];
    4894:	41 8b 44 b0 fc       	mov    -0x4(%r8,%rsi,4),%eax
		if ((i % Nk) == 0) {
    4899:	40 f6 c6 03          	test   $0x3,%sil
    489d:	75 3e                	jne    48dd <tc_aes128_set_encrypt_key+0xce>
	return (((a) >> 24)|((a) << 8));
    489f:	c1 c0 08             	rol    $0x8,%eax
			t = subword(rotword(t)) ^ rconst[i/Nk];
    48a2:	89 c2                	mov    %eax,%edx
    48a4:	c1 ea 18             	shr    $0x18,%edx
    48a7:	0f b6 0c 17          	movzbl (%rdi,%rdx,1),%ecx
    48ab:	0f b6 d0             	movzbl %al,%edx
    48ae:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    48b2:	c1 e1 18             	shl    $0x18,%ecx
    48b5:	09 d1                	or     %edx,%ecx
    48b7:	89 c2                	mov    %eax,%edx
    48b9:	c1 ea 10             	shr    $0x10,%edx
    48bc:	0f b6 d2             	movzbl %dl,%edx
    48bf:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    48c3:	c1 e2 10             	shl    $0x10,%edx
    48c6:	09 d1                	or     %edx,%ecx
    48c8:	0f b6 d4             	movzbl %ah,%edx
    48cb:	0f b6 04 17          	movzbl (%rdi,%rdx,1),%eax
    48cf:	89 f2                	mov    %esi,%edx
    48d1:	c1 ea 02             	shr    $0x2,%edx
    48d4:	c1 e0 08             	shl    $0x8,%eax
    48d7:	09 c8                	or     %ecx,%eax
    48d9:	33 44 94 0c          	xor    0xc(%rsp,%rdx,4),%eax
		s->words[i] = s->words[i-Nk] ^ t;
    48dd:	41 33 44 b0 f0       	xor    -0x10(%r8,%rsi,4),%eax
    48e2:	41 89 04 b0          	mov    %eax,(%r8,%rsi,4)
	for (; i < (Nb * (Nr + 1)); ++i) {
    48e6:	48 ff c6             	inc    %rsi
    48e9:	48 83 fe 2c          	cmp    $0x2c,%rsi
    48ed:	75 a5                	jne    4894 <tc_aes128_set_encrypt_key+0x85>
	return TC_CRYPTO_SUCCESS;
    48ef:	b8 01 00 00 00       	mov    $0x1,%eax
    48f4:	eb 02                	jmp    48f8 <tc_aes128_set_encrypt_key+0xe9>
		return TC_CRYPTO_FAIL;
    48f6:	31 c0                	xor    %eax,%eax
}
    48f8:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    48fd:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    4904:	00 00 
    4906:	74 05                	je     490d <tc_aes128_set_encrypt_key+0xfe>
    4908:	e8 a3 db ff ff       	callq  24b0 <__stack_chk_fail@plt>
    490d:	48 83 c4 48          	add    $0x48,%rsp
    4911:	c3                   	retq   

0000000000004912 <tc_aes_encrypt>:

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    4912:	f3 0f 1e fa          	endbr64 
    4916:	41 57                	push   %r15
    4918:	41 56                	push   %r14
    491a:	41 55                	push   %r13
    491c:	41 54                	push   %r12
    491e:	49 89 d4             	mov    %rdx,%r12
    4921:	55                   	push   %rbp
    4922:	53                   	push   %rbx
    4923:	48 83 ec 38          	sub    $0x38,%rsp
    4927:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    492e:	00 00 
    4930:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    4935:	31 c0                	xor    %eax,%eax
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    4937:	48 85 f6             	test   %rsi,%rsi
    493a:	0f 94 c2             	sete   %dl
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    493d:	4d 85 e4             	test   %r12,%r12
    4940:	0f 94 c0             	sete   %al
    4943:	08 c2                	or     %al,%dl
    4945:	0f 85 25 01 00 00    	jne    4a70 <tc_aes_encrypt+0x15e>
    494b:	49 89 fd             	mov    %rdi,%r13
    494e:	48 85 ff             	test   %rdi,%rdi
    4951:	0f 84 19 01 00 00    	je     4a70 <tc_aes_encrypt+0x15e>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    4957:	48 8d 6c 24 08       	lea    0x8(%rsp),%rbp
    495c:	48 89 f2             	mov    %rsi,%rdx
    495f:	b9 10 00 00 00       	mov    $0x10,%ecx
    4964:	be 10 00 00 00       	mov    $0x10,%esi
    4969:	48 89 ef             	mov    %rbp,%rdi
    496c:	4d 8d 74 24 10       	lea    0x10(%r12),%r14
    4971:	e8 20 f6 ff ff       	callq  3f96 <_copy>
	add_round_key(state, s->words);
    4976:	4c 89 e6             	mov    %r12,%rsi
    4979:	48 89 ef             	mov    %rbp,%rdi
    497c:	49 81 c4 a0 00 00 00 	add    $0xa0,%r12
    4983:	e8 b7 fc ff ff       	callq  463f <add_round_key>
		s[i] = sbox[s[i]];
    4988:	4c 8d 05 b1 47 00 00 	lea    0x47b1(%rip),%r8        # 9140 <sbox>
	for (i = 0; i < (Nb * Nk); ++i) {
    498f:	48 89 eb             	mov    %rbp,%rbx
    4992:	4c 8d 7c 24 18       	lea    0x18(%rsp),%r15
{
    4997:	48 89 e8             	mov    %rbp,%rax
		s[i] = sbox[s[i]];
    499a:	0f b6 10             	movzbl (%rax),%edx
    499d:	48 ff c0             	inc    %rax
    49a0:	41 8a 14 10          	mov    (%r8,%rdx,1),%dl
    49a4:	88 50 ff             	mov    %dl,-0x1(%rax)
	for (i = 0; i < (Nb * Nk); ++i) {
    49a7:	4c 39 f8             	cmp    %r15,%rax
    49aa:	75 ee                	jne    499a <tc_aes_encrypt+0x88>

	for (i = 0; i < (Nr - 1); ++i) {
		sub_bytes(state);
		shift_rows(state);
    49ac:	48 89 ef             	mov    %rbp,%rdi
    49af:	e8 f0 fc ff ff       	callq  46a4 <shift_rows>
	mult_row_column(t, s);
    49b4:	48 89 ee             	mov    %rbp,%rsi
    49b7:	4c 89 ff             	mov    %r15,%rdi
    49ba:	e8 96 fd ff ff       	callq  4755 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    49bf:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
    49c4:	48 8d 7c 24 1c       	lea    0x1c(%rsp),%rdi
    49c9:	e8 87 fd ff ff       	callq  4755 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    49ce:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    49d3:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    49d8:	e8 78 fd ff ff       	callq  4755 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    49dd:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
    49e2:	48 8d 7c 24 24       	lea    0x24(%rsp),%rdi
    49e7:	e8 69 fd ff ff       	callq  4755 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    49ec:	b9 10 00 00 00       	mov    $0x10,%ecx
    49f1:	4c 89 fa             	mov    %r15,%rdx
    49f4:	48 89 ef             	mov    %rbp,%rdi
    49f7:	be 10 00 00 00       	mov    $0x10,%esi
    49fc:	e8 95 f5 ff ff       	callq  3f96 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    4a01:	4c 89 f6             	mov    %r14,%rsi
    4a04:	48 89 ef             	mov    %rbp,%rdi
    4a07:	49 83 c6 10          	add    $0x10,%r14
    4a0b:	e8 2f fc ff ff       	callq  463f <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    4a10:	4d 39 e6             	cmp    %r12,%r14
    4a13:	4c 8d 05 26 47 00 00 	lea    0x4726(%rip),%r8        # 9140 <sbox>
    4a1a:	0f 85 6f ff ff ff    	jne    498f <tc_aes_encrypt+0x7d>
		s[i] = sbox[s[i]];
    4a20:	0f b6 03             	movzbl (%rbx),%eax
    4a23:	48 ff c3             	inc    %rbx
    4a26:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    4a2a:	88 43 ff             	mov    %al,-0x1(%rbx)
	for (i = 0; i < (Nb * Nk); ++i) {
    4a2d:	4c 39 fb             	cmp    %r15,%rbx
    4a30:	75 ee                	jne    4a20 <tc_aes_encrypt+0x10e>
	}

	sub_bytes(state);
	shift_rows(state);
    4a32:	48 89 ef             	mov    %rbp,%rdi
    4a35:	e8 6a fc ff ff       	callq  46a4 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    4a3a:	4c 89 e6             	mov    %r12,%rsi
    4a3d:	48 89 ef             	mov    %rbp,%rdi
    4a40:	e8 fa fb ff ff       	callq  463f <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    4a45:	b9 10 00 00 00       	mov    $0x10,%ecx
    4a4a:	48 89 ea             	mov    %rbp,%rdx
    4a4d:	4c 89 ef             	mov    %r13,%rdi
    4a50:	be 10 00 00 00       	mov    $0x10,%esi
    4a55:	e8 3c f5 ff ff       	callq  3f96 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    4a5a:	ba 10 00 00 00       	mov    $0x10,%edx
    4a5f:	31 f6                	xor    %esi,%esi
    4a61:	48 89 ef             	mov    %rbp,%rdi
    4a64:	e8 46 f5 ff ff       	callq  3faf <_set>

	return TC_CRYPTO_SUCCESS;
    4a69:	b8 01 00 00 00       	mov    $0x1,%eax
    4a6e:	eb 02                	jmp    4a72 <tc_aes_encrypt+0x160>
		return TC_CRYPTO_FAIL;
    4a70:	31 c0                	xor    %eax,%eax
}
    4a72:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    4a77:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    4a7e:	00 00 
    4a80:	74 05                	je     4a87 <tc_aes_encrypt+0x175>
    4a82:	e8 29 da ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4a87:	48 83 c4 38          	add    $0x38,%rsp
    4a8b:	5b                   	pop    %rbx
    4a8c:	5d                   	pop    %rbp
    4a8d:	41 5c                	pop    %r12
    4a8f:	41 5d                	pop    %r13
    4a91:	41 5e                	pop    %r14
    4a93:	41 5f                	pop    %r15
    4a95:	c3                   	retq   

0000000000004a96 <tc_cbc_mode_encrypt>:
#include <tinycrypt/utils.h>

int tc_cbc_mode_encrypt(uint8_t *out, unsigned int outlen, const uint8_t *in,
			    unsigned int inlen, const uint8_t *iv,
			    const TCAesKeySched_t sched)
{
    4a96:	f3 0f 1e fa          	endbr64 
    4a9a:	41 57                	push   %r15
    4a9c:	41 56                	push   %r14
    4a9e:	41 55                	push   %r13
    4aa0:	41 54                	push   %r12
    4aa2:	55                   	push   %rbp
    4aa3:	53                   	push   %rbx
    4aa4:	48 83 ec 28          	sub    $0x28,%rsp
    4aa8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4aaf:	00 00 
    4ab1:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4ab6:	31 c0                	xor    %eax,%eax

	uint8_t buffer[TC_AES_BLOCK_SIZE];
	unsigned int n, m;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    4ab8:	48 85 ff             	test   %rdi,%rdi
    4abb:	0f 84 d8 00 00 00    	je     4b99 <tc_cbc_mode_encrypt+0x103>
    4ac1:	49 89 d6             	mov    %rdx,%r14
    4ac4:	48 85 d2             	test   %rdx,%rdx
    4ac7:	0f 84 cc 00 00 00    	je     4b99 <tc_cbc_mode_encrypt+0x103>
	    in == (const uint8_t *) 0 ||
	    sched == (TCAesKeySched_t) 0 ||
    4acd:	4d 85 c9             	test   %r9,%r9
    4ad0:	89 cb                	mov    %ecx,%ebx
    4ad2:	4d 89 cc             	mov    %r9,%r12
    4ad5:	0f 94 c2             	sete   %dl
	    inlen == 0 ||
    4ad8:	85 db                	test   %ebx,%ebx
    4ada:	0f 94 c0             	sete   %al
    4add:	08 c2                	or     %al,%dl
    4adf:	0f 85 b4 00 00 00    	jne    4b99 <tc_cbc_mode_encrypt+0x103>
    4ae5:	85 f6                	test   %esi,%esi
    4ae7:	0f 84 ac 00 00 00    	je     4b99 <tc_cbc_mode_encrypt+0x103>
    4aed:	89 da                	mov    %ebx,%edx
	    outlen == 0 ||
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
	    outlen != inlen + TC_AES_BLOCK_SIZE) {
		return TC_CRYPTO_FAIL;
    4aef:	31 c0                	xor    %eax,%eax
    4af1:	09 f2                	or     %esi,%edx
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
    4af3:	83 e2 0f             	and    $0xf,%edx
    4af6:	0f 85 9f 00 00 00    	jne    4b9b <tc_cbc_mode_encrypt+0x105>
	    outlen != inlen + TC_AES_BLOCK_SIZE) {
    4afc:	8d 4b 10             	lea    0x10(%rbx),%ecx
		return TC_CRYPTO_FAIL;
    4aff:	89 d0                	mov    %edx,%eax
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
    4b01:	39 f1                	cmp    %esi,%ecx
    4b03:	0f 85 92 00 00 00    	jne    4b9b <tc_cbc_mode_encrypt+0x105>
	}

	/* copy iv to the buffer */
	(void)_copy(buffer, TC_AES_BLOCK_SIZE, iv, TC_AES_BLOCK_SIZE);
    4b09:	4c 8d 6c 24 08       	lea    0x8(%rsp),%r13
    4b0e:	48 89 fd             	mov    %rdi,%rbp
    4b11:	4d 89 c7             	mov    %r8,%r15
    4b14:	4c 89 c2             	mov    %r8,%rdx
    4b17:	b9 10 00 00 00       	mov    $0x10,%ecx
    4b1c:	be 10 00 00 00       	mov    $0x10,%esi
    4b21:	4c 89 ef             	mov    %r13,%rdi
    4b24:	4c 01 f3             	add    %r14,%rbx
    4b27:	e8 6a f4 ff ff       	callq  3f96 <_copy>
	/* copy iv to the output buffer */
	(void)_copy(out, TC_AES_BLOCK_SIZE, iv, TC_AES_BLOCK_SIZE);
    4b2c:	48 89 ef             	mov    %rbp,%rdi
    4b2f:	b9 10 00 00 00       	mov    $0x10,%ecx
    4b34:	4c 89 fa             	mov    %r15,%rdx
    4b37:	be 10 00 00 00       	mov    $0x10,%esi
	out += TC_AES_BLOCK_SIZE;
    4b3c:	48 83 c5 10          	add    $0x10,%rbp
	(void)_copy(out, TC_AES_BLOCK_SIZE, iv, TC_AES_BLOCK_SIZE);
    4b40:	e8 51 f4 ff ff       	callq  3f96 <_copy>

	for (n = m = 0; n < inlen; ++n) {
    4b45:	31 c0                	xor    %eax,%eax
    4b47:	4c 39 f3             	cmp    %r14,%rbx
    4b4a:	74 46                	je     4b92 <tc_cbc_mode_encrypt+0xfc>
		buffer[m++] ^= *in++;
    4b4c:	89 c6                	mov    %eax,%esi
    4b4e:	49 ff c6             	inc    %r14
    4b51:	8d 48 01             	lea    0x1(%rax),%ecx
    4b54:	8a 54 34 08          	mov    0x8(%rsp,%rsi,1),%dl
    4b58:	41 32 56 ff          	xor    -0x1(%r14),%dl
    4b5c:	88 54 34 08          	mov    %dl,0x8(%rsp,%rsi,1)
		if (m == TC_AES_BLOCK_SIZE) {
    4b60:	83 f8 0f             	cmp    $0xf,%eax
    4b63:	75 29                	jne    4b8e <tc_cbc_mode_encrypt+0xf8>
			(void)tc_aes_encrypt(buffer, buffer, sched);
    4b65:	4c 89 e2             	mov    %r12,%rdx
    4b68:	4c 89 ee             	mov    %r13,%rsi
    4b6b:	4c 89 ef             	mov    %r13,%rdi
    4b6e:	e8 9f fd ff ff       	callq  4912 <tc_aes_encrypt>
			(void)_copy(out, TC_AES_BLOCK_SIZE,
    4b73:	b9 10 00 00 00       	mov    $0x10,%ecx
    4b78:	48 89 ef             	mov    %rbp,%rdi
    4b7b:	4c 89 ea             	mov    %r13,%rdx
    4b7e:	be 10 00 00 00       	mov    $0x10,%esi
				    buffer, TC_AES_BLOCK_SIZE);
			out += TC_AES_BLOCK_SIZE;
    4b83:	48 83 c5 10          	add    $0x10,%rbp
			(void)_copy(out, TC_AES_BLOCK_SIZE,
    4b87:	e8 0a f4 ff ff       	callq  3f96 <_copy>
			m = 0;
    4b8c:	31 c9                	xor    %ecx,%ecx
	for (n = m = 0; n < inlen; ++n) {
    4b8e:	89 c8                	mov    %ecx,%eax
    4b90:	eb b5                	jmp    4b47 <tc_cbc_mode_encrypt+0xb1>
		}
	}

	return TC_CRYPTO_SUCCESS;
    4b92:	b8 01 00 00 00       	mov    $0x1,%eax
    4b97:	eb 02                	jmp    4b9b <tc_cbc_mode_encrypt+0x105>
		return TC_CRYPTO_FAIL;
    4b99:	31 c0                	xor    %eax,%eax
}
    4b9b:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    4ba0:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    4ba7:	00 00 
    4ba9:	74 05                	je     4bb0 <tc_cbc_mode_encrypt+0x11a>
    4bab:	e8 00 d9 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4bb0:	48 83 c4 28          	add    $0x28,%rsp
    4bb4:	5b                   	pop    %rbx
    4bb5:	5d                   	pop    %rbp
    4bb6:	41 5c                	pop    %r12
    4bb8:	41 5d                	pop    %r13
    4bba:	41 5e                	pop    %r14
    4bbc:	41 5f                	pop    %r15
    4bbe:	c3                   	retq   

0000000000004bbf <tc_cbc_mode_decrypt>:

int tc_cbc_mode_decrypt(uint8_t *out, unsigned int outlen, const uint8_t *in,
			    unsigned int inlen, const uint8_t *iv,
			    const TCAesKeySched_t sched)
{
    4bbf:	f3 0f 1e fa          	endbr64 
    4bc3:	41 57                	push   %r15
    4bc5:	41 56                	push   %r14
    4bc7:	41 55                	push   %r13
    4bc9:	41 54                	push   %r12
    4bcb:	55                   	push   %rbp
    4bcc:	53                   	push   %rbx
    4bcd:	48 83 ec 38          	sub    $0x38,%rsp
    4bd1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4bd8:	00 00 
    4bda:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    4bdf:	31 c0                	xor    %eax,%eax
	uint8_t buffer[TC_AES_BLOCK_SIZE];
	const uint8_t *p;
	unsigned int n, m;

	/* sanity check the inputs */
	if (out == (uint8_t *) 0 ||
    4be1:	48 85 ff             	test   %rdi,%rdi
    4be4:	74 7d                	je     4c63 <tc_cbc_mode_decrypt+0xa4>
    4be6:	49 89 d4             	mov    %rdx,%r12
    4be9:	48 85 d2             	test   %rdx,%rdx
    4bec:	74 75                	je     4c63 <tc_cbc_mode_decrypt+0xa4>
	    in == (const uint8_t *) 0 ||
	    sched == (TCAesKeySched_t) 0 ||
    4bee:	4d 85 c9             	test   %r9,%r9
    4bf1:	4d 89 ce             	mov    %r9,%r14
    4bf4:	0f 94 c2             	sete   %dl
	    inlen == 0 ||
    4bf7:	85 c9                	test   %ecx,%ecx
    4bf9:	0f 94 c0             	sete   %al
    4bfc:	08 c2                	or     %al,%dl
    4bfe:	75 63                	jne    4c63 <tc_cbc_mode_decrypt+0xa4>
    4c00:	85 f6                	test   %esi,%esi
    4c02:	74 5f                	je     4c63 <tc_cbc_mode_decrypt+0xa4>
	    outlen == 0 ||
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
    4c04:	89 c8                	mov    %ecx,%eax
    4c06:	09 f0                	or     %esi,%eax
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
    4c08:	a8 0f                	test   $0xf,%al
    4c0a:	75 57                	jne    4c63 <tc_cbc_mode_decrypt+0xa4>
    4c0c:	39 f1                	cmp    %esi,%ecx
    4c0e:	75 53                	jne    4c63 <tc_cbc_mode_decrypt+0xa4>
    4c10:	89 f0                	mov    %esi,%eax
    4c12:	49 89 fd             	mov    %rdi,%r13
    4c15:	4d 89 c7             	mov    %r8,%r15
    4c18:	31 db                	xor    %ebx,%ebx
    4c1a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	 * that would not otherwise be possible.
	 */
	p = iv;
	for (n = m = 0; n < outlen; ++n) {
		if ((n % TC_AES_BLOCK_SIZE) == 0) {
			(void)tc_aes_decrypt(buffer, in, sched);
    4c1f:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
	for (n = m = 0; n < outlen; ++n) {
    4c24:	31 c0                	xor    %eax,%eax
    4c26:	48 39 5c 24 08       	cmp    %rbx,0x8(%rsp)
    4c2b:	74 2f                	je     4c5c <tc_cbc_mode_decrypt+0x9d>
		if ((n % TC_AES_BLOCK_SIZE) == 0) {
    4c2d:	f6 c3 0f             	test   $0xf,%bl
    4c30:	75 14                	jne    4c46 <tc_cbc_mode_decrypt+0x87>
			(void)tc_aes_decrypt(buffer, in, sched);
    4c32:	4c 89 e6             	mov    %r12,%rsi
    4c35:	4c 89 f2             	mov    %r14,%rdx
    4c38:	48 89 ef             	mov    %rbp,%rdi
			in += TC_AES_BLOCK_SIZE;
    4c3b:	49 83 c4 10          	add    $0x10,%r12
			(void)tc_aes_decrypt(buffer, in, sched);
    4c3f:	e8 76 f8 ff ff       	callq  44ba <tc_aes_decrypt>
			m = 0;
    4c44:	31 c0                	xor    %eax,%eax
		}
		*out++ = buffer[m++] ^ *p++;
    4c46:	89 c2                	mov    %eax,%edx
    4c48:	ff c0                	inc    %eax
    4c4a:	8a 54 14 18          	mov    0x18(%rsp,%rdx,1),%dl
    4c4e:	41 32 14 1f          	xor    (%r15,%rbx,1),%dl
    4c52:	41 88 54 1d 00       	mov    %dl,0x0(%r13,%rbx,1)
	for (n = m = 0; n < outlen; ++n) {
    4c57:	48 ff c3             	inc    %rbx
    4c5a:	eb ca                	jmp    4c26 <tc_cbc_mode_decrypt+0x67>
	}

	return TC_CRYPTO_SUCCESS;
    4c5c:	b8 01 00 00 00       	mov    $0x1,%eax
    4c61:	eb 02                	jmp    4c65 <tc_cbc_mode_decrypt+0xa6>
		return TC_CRYPTO_FAIL;
    4c63:	31 c0                	xor    %eax,%eax
}
    4c65:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    4c6a:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    4c71:	00 00 
    4c73:	74 05                	je     4c7a <tc_cbc_mode_decrypt+0xbb>
    4c75:	e8 36 d8 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4c7a:	48 83 c4 38          	add    $0x38,%rsp
    4c7e:	5b                   	pop    %rbx
    4c7f:	5d                   	pop    %rbp
    4c80:	41 5c                	pop    %r12
    4c82:	41 5d                	pop    %r13
    4c84:	41 5e                	pop    %r14
    4c86:	41 5f                	pop    %r15
    4c88:	c3                   	retq   

0000000000004c89 <tc_ctr_mode>:
#include <tinycrypt/ctr_mode.h>
#include <tinycrypt/utils.h>

int tc_ctr_mode(uint8_t *out, unsigned int outlen, const uint8_t *in,
		unsigned int inlen, uint8_t *ctr, const TCAesKeySched_t sched)
{
    4c89:	f3 0f 1e fa          	endbr64 
    4c8d:	41 57                	push   %r15
    4c8f:	41 56                	push   %r14
    4c91:	41 55                	push   %r13
    4c93:	41 54                	push   %r12
    4c95:	55                   	push   %rbp
    4c96:	53                   	push   %rbx
    4c97:	48 83 ec 58          	sub    $0x58,%rsp
    4c9b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4ca2:	00 00 
    4ca4:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    4ca9:	31 c0                	xor    %eax,%eax
	uint8_t nonce[TC_AES_BLOCK_SIZE];
	unsigned int block_num;
	unsigned int i;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    4cab:	48 85 ff             	test   %rdi,%rdi
    4cae:	74 08                	je     4cb8 <tc_ctr_mode+0x2f>
    4cb0:	49 89 d4             	mov    %rdx,%r12
    4cb3:	48 85 d2             	test   %rdx,%rdx
    4cb6:	75 07                	jne    4cbf <tc_ctr_mode+0x36>
	    ctr == (uint8_t *) 0 ||
	    sched == (TCAesKeySched_t) 0 ||
	    inlen == 0 ||
	    outlen == 0 ||
	    outlen != inlen) {
		return TC_CRYPTO_FAIL;
    4cb8:	31 c0                	xor    %eax,%eax
    4cba:	e9 cb 00 00 00       	jmpq   4d8a <tc_ctr_mode+0x101>
	    ctr == (uint8_t *) 0 ||
    4cbf:	4d 85 c0             	test   %r8,%r8
    4cc2:	74 f4                	je     4cb8 <tc_ctr_mode+0x2f>
    4cc4:	4d 89 cd             	mov    %r9,%r13
    4cc7:	4d 85 c9             	test   %r9,%r9
    4cca:	74 ec                	je     4cb8 <tc_ctr_mode+0x2f>
	    inlen == 0 ||
    4ccc:	85 c9                	test   %ecx,%ecx
    4cce:	89 cb                	mov    %ecx,%ebx
    4cd0:	0f 94 c2             	sete   %dl
	    outlen == 0 ||
    4cd3:	85 f6                	test   %esi,%esi
    4cd5:	0f 94 c0             	sete   %al
    4cd8:	08 c2                	or     %al,%dl
    4cda:	75 dc                	jne    4cb8 <tc_ctr_mode+0x2f>
    4cdc:	39 f1                	cmp    %esi,%ecx
    4cde:	75 d8                	jne    4cb8 <tc_ctr_mode+0x2f>
	}

	/* copy the ctr to the nonce */
	(void)_copy(nonce, sizeof(nonce), ctr, sizeof(nonce));
    4ce0:	4c 8d 7c 24 38       	lea    0x38(%rsp),%r15
    4ce5:	4c 89 c2             	mov    %r8,%rdx
    4ce8:	48 89 fd             	mov    %rdi,%rbp
    4ceb:	b9 10 00 00 00       	mov    $0x10,%ecx
    4cf0:	4c 89 ff             	mov    %r15,%rdi
    4cf3:	be 10 00 00 00       	mov    $0x10,%esi
    4cf8:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    4cfd:	e8 94 f2 ff ff       	callq  3f96 <_copy>

	/* select the last 4 bytes of the nonce to be incremented */
	block_num = (nonce[12] << 24) | (nonce[13] << 16) |
    4d02:	89 d8                	mov    %ebx,%eax
    4d04:	44 8b 4c 24 44       	mov    0x44(%rsp),%r9d
		    (nonce[14] << 8) | (nonce[15]);
	for (i = 0; i < inlen; ++i) {
    4d09:	31 db                	xor    %ebx,%ebx
    4d0b:	48 89 04 24          	mov    %rax,(%rsp)
    4d0f:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
			/* encrypt data using the current nonce */
			if (tc_aes_encrypt(buffer, nonce, sched)) {
    4d14:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    4d19:	41 0f c9             	bswap  %r9d
	for (i = 0; i < inlen; ++i) {
    4d1c:	48 3b 1c 24          	cmp    (%rsp),%rbx
    4d20:	74 5b                	je     4d7d <tc_ctr_mode+0xf4>
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
    4d22:	41 89 de             	mov    %ebx,%r14d
    4d25:	41 83 e6 0f          	and    $0xf,%r14d
    4d29:	75 3d                	jne    4d68 <tc_ctr_mode+0xdf>
			if (tc_aes_encrypt(buffer, nonce, sched)) {
    4d2b:	4c 89 ea             	mov    %r13,%rdx
    4d2e:	4c 89 fe             	mov    %r15,%rsi
    4d31:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    4d36:	44 89 4c 24 14       	mov    %r9d,0x14(%rsp)
    4d3b:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    4d40:	e8 cd fb ff ff       	callq  4912 <tc_aes_encrypt>
    4d45:	85 c0                	test   %eax,%eax
    4d47:	0f 84 6b ff ff ff    	je     4cb8 <tc_ctr_mode+0x2f>
				block_num++;
    4d4d:	44 8b 4c 24 14       	mov    0x14(%rsp),%r9d
				nonce[12] = (uint8_t)(block_num >> 24);
    4d52:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    4d57:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
				block_num++;
    4d5c:	41 ff c1             	inc    %r9d
				nonce[13] = (uint8_t)(block_num >> 16);
				nonce[14] = (uint8_t)(block_num >> 8);
				nonce[15] = (uint8_t)(block_num);
    4d5f:	44 89 c8             	mov    %r9d,%eax
    4d62:	0f c8                	bswap  %eax
				nonce[12] = (uint8_t)(block_num >> 24);
    4d64:	89 44 24 44          	mov    %eax,0x44(%rsp)
			} else {
				return TC_CRYPTO_FAIL;
			}
		}
		/* update the output */
		*out++ = buffer[i%(TC_AES_BLOCK_SIZE)] ^ *in++;
    4d68:	45 89 f6             	mov    %r14d,%r14d
    4d6b:	42 8a 44 34 28       	mov    0x28(%rsp,%r14,1),%al
    4d70:	41 32 04 1c          	xor    (%r12,%rbx,1),%al
    4d74:	88 44 1d 00          	mov    %al,0x0(%rbp,%rbx,1)
	for (i = 0; i < inlen; ++i) {
    4d78:	48 ff c3             	inc    %rbx
    4d7b:	eb 9f                	jmp    4d1c <tc_ctr_mode+0x93>
	}

	/* update the counter */
	ctr[12] = nonce[12]; ctr[13] = nonce[13];
    4d7d:	8b 44 24 44          	mov    0x44(%rsp),%eax
    4d81:	41 89 40 0c          	mov    %eax,0xc(%r8)
	ctr[14] = nonce[14]; ctr[15] = nonce[15];

	return TC_CRYPTO_SUCCESS;
    4d85:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4d8a:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    4d8f:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    4d96:	00 00 
    4d98:	74 05                	je     4d9f <tc_ctr_mode+0x116>
    4d9a:	e8 11 d7 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4d9f:	48 83 c4 58          	add    $0x58,%rsp
    4da3:	5b                   	pop    %rbx
    4da4:	5d                   	pop    %rbp
    4da5:	41 5c                	pop    %r12
    4da7:	41 5d                	pop    %r13
    4da9:	41 5e                	pop    %r14
    4dab:	41 5f                	pop    %r15
    4dad:	c3                   	retq   

0000000000004dae <ccm_cbc_mac>:
/**
 * Variation of CBC-MAC mode used in CCM.
 */
static void ccm_cbc_mac(uint8_t *T, const uint8_t *data, unsigned int dlen,
			unsigned int flag, TCAesKeySched_t sched)
{
    4dae:	41 56                	push   %r14
    4db0:	41 55                	push   %r13
    4db2:	4d 89 c5             	mov    %r8,%r13
    4db5:	41 54                	push   %r12
    4db7:	49 89 f4             	mov    %rsi,%r12
    4dba:	55                   	push   %rbp
    4dbb:	89 d5                	mov    %edx,%ebp
    4dbd:	53                   	push   %rbx
    4dbe:	48 89 fb             	mov    %rdi,%rbx

	unsigned int i;

	if (flag > 0) {
    4dc1:	85 c9                	test   %ecx,%ecx
    4dc3:	74 34                	je     4df9 <ccm_cbc_mac+0x4b>
		T[0] ^= (uint8_t)(dlen >> 8);
    4dc5:	89 d0                	mov    %edx,%eax
		T[1] ^= (uint8_t)(dlen);
    4dc7:	30 57 01             	xor    %dl,0x1(%rdi)
		dlen += 2; i = 2;
    4dca:	83 c5 02             	add    $0x2,%ebp
    4dcd:	b9 02 00 00 00       	mov    $0x2,%ecx
		T[0] ^= (uint8_t)(dlen >> 8);
    4dd2:	c1 e8 08             	shr    $0x8,%eax
    4dd5:	30 07                	xor    %al,(%rdi)
		dlen += 2; i = 2;
    4dd7:	eb 20                	jmp    4df9 <ccm_cbc_mac+0x4b>
	} else {
		i = 0;
	}

	while (i < dlen) {
		T[i++ % (Nb * Nk)] ^= *data++;
    4dd9:	44 8d 71 01          	lea    0x1(%rcx),%r14d
    4ddd:	83 e1 0f             	and    $0xf,%ecx
    4de0:	49 ff c4             	inc    %r12
    4de3:	41 8a 44 24 ff       	mov    -0x1(%r12),%al
    4de8:	30 04 0b             	xor    %al,(%rbx,%rcx,1)
		if (((i % (Nb * Nk)) == 0) || dlen == i) {
    4deb:	41 f6 c6 0f          	test   $0xf,%r14b
    4def:	74 0e                	je     4dff <ccm_cbc_mac+0x51>
    4df1:	41 39 ee             	cmp    %ebp,%r14d
    4df4:	74 09                	je     4dff <ccm_cbc_mac+0x51>
		T[i++ % (Nb * Nk)] ^= *data++;
    4df6:	44 89 f1             	mov    %r14d,%ecx
	while (i < dlen) {
    4df9:	39 e9                	cmp    %ebp,%ecx
    4dfb:	72 dc                	jb     4dd9 <ccm_cbc_mac+0x2b>
    4dfd:	eb 10                	jmp    4e0f <ccm_cbc_mac+0x61>
			(void) tc_aes_encrypt(T, T, sched);
    4dff:	4c 89 ea             	mov    %r13,%rdx
    4e02:	48 89 de             	mov    %rbx,%rsi
    4e05:	48 89 df             	mov    %rbx,%rdi
    4e08:	e8 05 fb ff ff       	callq  4912 <tc_aes_encrypt>
    4e0d:	eb e7                	jmp    4df6 <ccm_cbc_mac+0x48>
		}
	}
}
    4e0f:	5b                   	pop    %rbx
    4e10:	5d                   	pop    %rbp
    4e11:	41 5c                	pop    %r12
    4e13:	41 5d                	pop    %r13
    4e15:	41 5e                	pop    %r14
    4e17:	c3                   	retq   

0000000000004e18 <ccm_ctr_mode.constprop.0>:
 * The CTR mode used by CCM is slightly different than the conventional CTR
 * mode (the counter is increased before encryption, instead of after
 * encryption). Besides, it is assumed that the counter is stored in the last
 * 2 bytes of the nonce.
 */
static int ccm_ctr_mode(uint8_t *out, unsigned int outlen, const uint8_t *in,
    4e18:	41 57                	push   %r15
    4e1a:	41 56                	push   %r14
    4e1c:	41 55                	push   %r13
    4e1e:	41 54                	push   %r12
    4e20:	55                   	push   %rbp
    4e21:	53                   	push   %rbx
    4e22:	48 83 ec 58          	sub    $0x58,%rsp
    4e26:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4e2d:	00 00 
    4e2f:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    4e34:	31 c0                	xor    %eax,%eax
	uint8_t nonce[TC_AES_BLOCK_SIZE];
	uint16_t block_num;
	unsigned int i;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    4e36:	48 85 ff             	test   %rdi,%rdi
    4e39:	0f 84 dc 00 00 00    	je     4f1b <ccm_ctr_mode.constprop.0+0x103>
    4e3f:	49 89 d5             	mov    %rdx,%r13
    4e42:	48 85 d2             	test   %rdx,%rdx
    4e45:	0f 84 d0 00 00 00    	je     4f1b <ccm_ctr_mode.constprop.0+0x103>
    4e4b:	4d 89 ce             	mov    %r9,%r14
	    in == (uint8_t *) 0 ||
	    ctr == (uint8_t *) 0 ||
    4e4e:	4d 85 c9             	test   %r9,%r9
    4e51:	0f 84 c6 00 00 00    	je     4f1d <ccm_ctr_mode.constprop.0+0x105>
	    sched == (TCAesKeySched_t) 0 ||
	    inlen == 0 ||
    4e57:	85 c9                	test   %ecx,%ecx
    4e59:	89 cb                	mov    %ecx,%ebx
    4e5b:	0f 94 c2             	sete   %dl
	    outlen == 0 ||
    4e5e:	85 f6                	test   %esi,%esi
    4e60:	0f 94 c0             	sete   %al
    4e63:	08 c2                	or     %al,%dl
    4e65:	0f 85 b0 00 00 00    	jne    4f1b <ccm_ctr_mode.constprop.0+0x103>
    4e6b:	39 f1                	cmp    %esi,%ecx
    4e6d:	0f 85 a8 00 00 00    	jne    4f1b <ccm_ctr_mode.constprop.0+0x103>
	    outlen != inlen) {
		return TC_CRYPTO_FAIL;
	}

	/* copy the counter to the nonce */
	(void) _copy(nonce, sizeof(nonce), ctr, sizeof(nonce));
    4e73:	4c 8d 7c 24 38       	lea    0x38(%rsp),%r15
    4e78:	4c 89 c2             	mov    %r8,%rdx
    4e7b:	49 89 fc             	mov    %rdi,%r12
    4e7e:	b9 10 00 00 00       	mov    $0x10,%ecx
    4e83:	4c 89 ff             	mov    %r15,%rdi
    4e86:	be 10 00 00 00       	mov    $0x10,%esi
    4e8b:	4c 89 c5             	mov    %r8,%rbp
    4e8e:	e8 03 f1 ff ff       	callq  3f96 <_copy>

	/* select the last 2 bytes of the nonce to be incremented */
	block_num = (uint16_t) ((nonce[14] << 8)|(nonce[15]));
    4e93:	44 0f b6 44 24 46    	movzbl 0x46(%rsp),%r8d
    4e99:	0f b6 44 24 47       	movzbl 0x47(%rsp),%eax
	for (i = 0; i < inlen; ++i) {
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
			block_num++;
			nonce[14] = (uint8_t)(block_num >> 8);
			nonce[15] = (uint8_t)(block_num);
			if (!tc_aes_encrypt(buffer, nonce, sched)) {
    4e9e:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
	block_num = (uint16_t) ((nonce[14] << 8)|(nonce[15]));
    4ea3:	41 c1 e0 08          	shl    $0x8,%r8d
    4ea7:	41 09 c0             	or     %eax,%r8d
	for (i = 0; i < inlen; ++i) {
    4eaa:	89 d8                	mov    %ebx,%eax
    4eac:	31 db                	xor    %ebx,%ebx
    4eae:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4eb3:	48 39 5c 24 08       	cmp    %rbx,0x8(%rsp)
    4eb8:	74 51                	je     4f0b <ccm_ctr_mode.constprop.0+0xf3>
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
    4eba:	89 d8                	mov    %ebx,%eax
    4ebc:	83 e0 0f             	and    $0xf,%eax
    4ebf:	89 44 24 18          	mov    %eax,0x18(%rsp)
    4ec3:	75 30                	jne    4ef5 <ccm_ctr_mode.constprop.0+0xdd>
			block_num++;
    4ec5:	41 ff c0             	inc    %r8d
			if (!tc_aes_encrypt(buffer, nonce, sched)) {
    4ec8:	4c 89 f2             	mov    %r14,%rdx
    4ecb:	4c 89 fe             	mov    %r15,%rsi
    4ece:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
			nonce[14] = (uint8_t)(block_num >> 8);
    4ed3:	44 89 c0             	mov    %r8d,%eax
    4ed6:	44 89 44 24 1c       	mov    %r8d,0x1c(%rsp)
    4edb:	86 e0                	xchg   %ah,%al
    4edd:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
			if (!tc_aes_encrypt(buffer, nonce, sched)) {
    4ee2:	e8 2b fa ff ff       	callq  4912 <tc_aes_encrypt>
    4ee7:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    4eec:	44 8b 44 24 1c       	mov    0x1c(%rsp),%r8d
    4ef1:	85 c0                	test   %eax,%eax
    4ef3:	74 28                	je     4f1d <ccm_ctr_mode.constprop.0+0x105>
				return TC_CRYPTO_FAIL;
			}
		}
		/* update the output */
		*out++ = buffer[i % (TC_AES_BLOCK_SIZE)] ^ *in++;
    4ef5:	8b 44 24 18          	mov    0x18(%rsp),%eax
    4ef9:	8a 44 04 28          	mov    0x28(%rsp,%rax,1),%al
    4efd:	41 32 44 1d 00       	xor    0x0(%r13,%rbx,1),%al
    4f02:	41 88 04 1c          	mov    %al,(%r12,%rbx,1)
	for (i = 0; i < inlen; ++i) {
    4f06:	48 ff c3             	inc    %rbx
    4f09:	eb a8                	jmp    4eb3 <ccm_ctr_mode.constprop.0+0x9b>
	}

	/* update the counter */
	ctr[14] = nonce[14]; ctr[15] = nonce[15];
    4f0b:	66 8b 44 24 46       	mov    0x46(%rsp),%ax
    4f10:	66 89 45 0e          	mov    %ax,0xe(%rbp)

	return TC_CRYPTO_SUCCESS;
    4f14:	b8 01 00 00 00       	mov    $0x1,%eax
    4f19:	eb 02                	jmp    4f1d <ccm_ctr_mode.constprop.0+0x105>
		return TC_CRYPTO_FAIL;
    4f1b:	31 c0                	xor    %eax,%eax
}
    4f1d:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    4f22:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    4f29:	00 00 
    4f2b:	74 05                	je     4f32 <ccm_ctr_mode.constprop.0+0x11a>
    4f2d:	e8 7e d5 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    4f32:	48 83 c4 58          	add    $0x58,%rsp
    4f36:	5b                   	pop    %rbx
    4f37:	5d                   	pop    %rbp
    4f38:	41 5c                	pop    %r12
    4f3a:	41 5d                	pop    %r13
    4f3c:	41 5e                	pop    %r14
    4f3e:	41 5f                	pop    %r15
    4f40:	c3                   	retq   

0000000000004f41 <tc_ccm_config>:
{
    4f41:	f3 0f 1e fa          	endbr64 
	if (c == (TCCcmMode_t) 0 ||
    4f45:	48 85 ff             	test   %rdi,%rdi
    4f48:	0f 94 c0             	sete   %al
	    sched == (TCAesKeySched_t) 0 ||
    4f4b:	48 85 f6             	test   %rsi,%rsi
    4f4e:	41 0f 94 c1          	sete   %r9b
	if (c == (TCCcmMode_t) 0 ||
    4f52:	44 09 c8             	or     %r9d,%eax
	    sched == (TCAesKeySched_t) 0 ||
    4f55:	48 85 d2             	test   %rdx,%rdx
    4f58:	41 0f 94 c1          	sete   %r9b
	} else if (nlen != 13) {
    4f5c:	44 08 c8             	or     %r9b,%al
    4f5f:	75 27                	jne    4f88 <tc_ccm_config+0x47>
    4f61:	83 f9 0d             	cmp    $0xd,%ecx
    4f64:	75 22                	jne    4f88 <tc_ccm_config+0x47>
	} else if ((mlen < 4) || (mlen > 16) || (mlen & 1)) {
    4f66:	41 8d 48 fc          	lea    -0x4(%r8),%ecx
		return TC_CRYPTO_FAIL; /* The allowed nonce size is: 13. See documentation.*/
    4f6a:	31 c0                	xor    %eax,%eax
	} else if ((mlen < 4) || (mlen > 16) || (mlen & 1)) {
    4f6c:	83 f9 0c             	cmp    $0xc,%ecx
    4f6f:	77 19                	ja     4f8a <tc_ccm_config+0x49>
    4f71:	41 f6 c0 01          	test   $0x1,%r8b
    4f75:	75 13                	jne    4f8a <tc_ccm_config+0x49>
	c->mlen = mlen;
    4f77:	44 89 47 10          	mov    %r8d,0x10(%rdi)
	return TC_CRYPTO_SUCCESS;
    4f7b:	b8 01 00 00 00       	mov    $0x1,%eax
	c->sched = sched;
    4f80:	48 89 37             	mov    %rsi,(%rdi)
	c->nonce = nonce;
    4f83:	48 89 57 08          	mov    %rdx,0x8(%rdi)
	return TC_CRYPTO_SUCCESS;
    4f87:	c3                   	retq   
		return TC_CRYPTO_FAIL; /* The allowed nonce size is: 13. See documentation.*/
    4f88:	31 c0                	xor    %eax,%eax
}
    4f8a:	c3                   	retq   

0000000000004f8b <tc_ccm_generation_encryption>:

int tc_ccm_generation_encryption(uint8_t *out, unsigned int olen,
				 const uint8_t *associated_data,
				 unsigned int alen, const uint8_t *payload,
				 unsigned int plen, TCCcmMode_t c)
{
    4f8b:	f3 0f 1e fa          	endbr64 
    4f8f:	41 57                	push   %r15
    4f91:	41 56                	push   %r14
    4f93:	41 55                	push   %r13
    4f95:	41 54                	push   %r12
    4f97:	55                   	push   %rbp
    4f98:	53                   	push   %rbx
    4f99:	48 83 ec 48          	sub    $0x48,%rsp
    4f9d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4fa4:	00 00 
    4fa6:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    4fab:	31 c0                	xor    %eax,%eax
    4fad:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
    4fb4:	00 

	/* input sanity check: */
	if ((out == (uint8_t *) 0) ||
    4fb5:	48 85 ff             	test   %rdi,%rdi
    4fb8:	0f 84 59 01 00 00    	je     5117 <tc_ccm_generation_encryption+0x18c>
    4fbe:	48 85 ed             	test   %rbp,%rbp
    4fc1:	0f 84 50 01 00 00    	je     5117 <tc_ccm_generation_encryption+0x18c>
    4fc7:	44 89 cb             	mov    %r9d,%ebx
    4fca:	49 89 fc             	mov    %rdi,%r12
    4fcd:	49 89 d3             	mov    %rdx,%r11
    4fd0:	41 89 ca             	mov    %ecx,%r10d
    4fd3:	4d 89 c6             	mov    %r8,%r14
		(c == (TCCcmMode_t) 0) ||
    4fd6:	85 db                	test   %ebx,%ebx
    4fd8:	74 0c                	je     4fe6 <tc_ccm_generation_encryption+0x5b>
		((plen > 0) && (payload == (uint8_t *) 0)) ||
		((alen > 0) && (associated_data == (uint8_t *) 0)) ||
		(alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
		(plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
		(olen < (plen + c->mlen))) {  /* invalid output buffer size */
		return TC_CRYPTO_FAIL;
    4fda:	45 31 c0             	xor    %r8d,%r8d
		(c == (TCCcmMode_t) 0) ||
    4fdd:	4d 85 f6             	test   %r14,%r14
    4fe0:	0f 84 34 01 00 00    	je     511a <tc_ccm_generation_encryption+0x18f>
		((plen > 0) && (payload == (uint8_t *) 0)) ||
    4fe6:	45 85 d2             	test   %r10d,%r10d
    4fe9:	74 0c                	je     4ff7 <tc_ccm_generation_encryption+0x6c>
		return TC_CRYPTO_FAIL;
    4feb:	45 31 c0             	xor    %r8d,%r8d
		((plen > 0) && (payload == (uint8_t *) 0)) ||
    4fee:	4d 85 db             	test   %r11,%r11
    4ff1:	0f 84 23 01 00 00    	je     511a <tc_ccm_generation_encryption+0x18f>
		(alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
    4ff7:	41 81 fa ff fe 00 00 	cmp    $0xfeff,%r10d
    4ffe:	0f 87 13 01 00 00    	ja     5117 <tc_ccm_generation_encryption+0x18c>
    5004:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    500a:	0f 87 07 01 00 00    	ja     5117 <tc_ccm_generation_encryption+0x18c>
		(olen < (plen + c->mlen))) {  /* invalid output buffer size */
    5010:	8b 45 10             	mov    0x10(%rbp),%eax
		return TC_CRYPTO_FAIL;
    5013:	45 31 c0             	xor    %r8d,%r8d
		(olen < (plen + c->mlen))) {  /* invalid output buffer size */
    5016:	8d 14 18             	lea    (%rax,%rbx,1),%edx
		(plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
    5019:	39 f2                	cmp    %esi,%edx
    501b:	0f 87 f9 00 00 00    	ja     511a <tc_ccm_generation_encryption+0x18f>
	unsigned int i;

	/* GENERATING THE AUTHENTICATION TAG: */

	/* formatting the sequence b for authentication: */
	b[0] = ((alen > 0) ? 0x40:0) | (((c->mlen - 2) / 2 << 3)) | (1);
    5021:	45 85 d2             	test   %r10d,%r10d
	for (i = 1; i <= 13; ++i) {
		b[i] = c->nonce[i - 1];
    5024:	48 8b 75 08          	mov    0x8(%rbp),%rsi
    5028:	4c 8d 6c 24 18       	lea    0x18(%rsp),%r13
	b[0] = ((alen > 0) ? 0x40:0) | (((c->mlen - 2) / 2 << 3)) | (1);
    502d:	0f 95 c2             	setne  %dl
    5030:	83 e8 02             	sub    $0x2,%eax
    5033:	d1 e8                	shr    %eax
    5035:	c1 e2 06             	shl    $0x6,%edx
    5038:	c1 e0 03             	shl    $0x3,%eax
    503b:	09 d0                	or     %edx,%eax
		b[i] = c->nonce[i - 1];
    503d:	48 8d 54 24 19       	lea    0x19(%rsp),%rdx
	b[0] = ((alen > 0) ? 0x40:0) | (((c->mlen - 2) / 2 << 3)) | (1);
    5042:	83 c8 01             	or     $0x1,%eax
    5045:	88 44 24 18          	mov    %al,0x18(%rsp)
		b[i] = c->nonce[i - 1];
    5049:	31 c0                	xor    %eax,%eax
    504b:	8a 0c 06             	mov    (%rsi,%rax,1),%cl
    504e:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
	for (i = 1; i <= 13; ++i) {
    5051:	48 ff c0             	inc    %rax
    5054:	48 83 f8 0d          	cmp    $0xd,%rax
    5058:	75 f1                	jne    504b <tc_ccm_generation_encryption+0xc0>
	}
	b[14] = (uint8_t)(plen >> 8);
    505a:	89 d8                	mov    %ebx,%eax
	b[15] = (uint8_t)(plen);

	/* computing the authentication tag using cbc-mac: */
	(void) tc_aes_encrypt(tag, b, c->sched);
    505c:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    5060:	4c 8d 7c 24 28       	lea    0x28(%rsp),%r15
    5065:	4c 89 ee             	mov    %r13,%rsi
	b[14] = (uint8_t)(plen >> 8);
    5068:	86 e0                	xchg   %ah,%al
	(void) tc_aes_encrypt(tag, b, c->sched);
    506a:	4c 89 ff             	mov    %r15,%rdi
    506d:	44 89 54 24 0c       	mov    %r10d,0xc(%rsp)
    5072:	4c 89 1c 24          	mov    %r11,(%rsp)
	b[14] = (uint8_t)(plen >> 8);
    5076:	66 89 44 24 26       	mov    %ax,0x26(%rsp)
	(void) tc_aes_encrypt(tag, b, c->sched);
    507b:	e8 92 f8 ff ff       	callq  4912 <tc_aes_encrypt>
	if (alen > 0) {
    5080:	44 8b 54 24 0c       	mov    0xc(%rsp),%r10d
    5085:	4c 8b 1c 24          	mov    (%rsp),%r11
    5089:	45 85 d2             	test   %r10d,%r10d
    508c:	74 17                	je     50a5 <tc_ccm_generation_encryption+0x11a>
		ccm_cbc_mac(tag, associated_data, alen, 1, c->sched);
    508e:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    5092:	b9 01 00 00 00       	mov    $0x1,%ecx
    5097:	44 89 d2             	mov    %r10d,%edx
    509a:	4c 89 de             	mov    %r11,%rsi
    509d:	4c 89 ff             	mov    %r15,%rdi
    50a0:	e8 09 fd ff ff       	callq  4dae <ccm_cbc_mac>
	}
	if (plen > 0) {
    50a5:	85 db                	test   %ebx,%ebx
    50a7:	74 13                	je     50bc <tc_ccm_generation_encryption+0x131>
		ccm_cbc_mac(tag, payload, plen, 0, c->sched);
    50a9:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    50ad:	31 c9                	xor    %ecx,%ecx
    50af:	89 da                	mov    %ebx,%edx
    50b1:	4c 89 f6             	mov    %r14,%rsi
    50b4:	4c 89 ff             	mov    %r15,%rdi
    50b7:	e8 f2 fc ff ff       	callq  4dae <ccm_cbc_mac>
	/* formatting the sequence b for encryption: */
	b[0] = 1; /* q - 1 = 2 - 1 = 1 */
	b[14] = b[15] = TC_ZERO_BYTE;

	/* encrypting payload using ctr mode: */
	ccm_ctr_mode(out, plen, payload, plen, b, c->sched);
    50bc:	4c 8b 4d 00          	mov    0x0(%rbp),%r9
    50c0:	89 d9                	mov    %ebx,%ecx
    50c2:	89 de                	mov    %ebx,%esi
    50c4:	4d 89 e8             	mov    %r13,%r8
    50c7:	4c 89 f2             	mov    %r14,%rdx
    50ca:	4c 89 e7             	mov    %r12,%rdi
	b[0] = 1; /* q - 1 = 2 - 1 = 1 */
    50cd:	c6 44 24 18 01       	movb   $0x1,0x18(%rsp)

	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter for ctr_mode (0):*/

	/* encrypting b and adding the tag to the output: */
	(void) tc_aes_encrypt(b, b, c->sched);
	out += plen;
    50d2:	4c 01 e3             	add    %r12,%rbx
	b[14] = b[15] = TC_ZERO_BYTE;
    50d5:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	ccm_ctr_mode(out, plen, payload, plen, b, c->sched);
    50dc:	e8 37 fd ff ff       	callq  4e18 <ccm_ctr_mode.constprop.0>
	(void) tc_aes_encrypt(b, b, c->sched);
    50e1:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    50e5:	4c 89 ee             	mov    %r13,%rsi
    50e8:	4c 89 ef             	mov    %r13,%rdi
	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter for ctr_mode (0):*/
    50eb:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	(void) tc_aes_encrypt(b, b, c->sched);
    50f2:	e8 1b f8 ff ff       	callq  4912 <tc_aes_encrypt>
	for (i = 0; i < c->mlen; ++i) {
    50f7:	31 c0                	xor    %eax,%eax
    50f9:	39 45 10             	cmp    %eax,0x10(%rbp)
    50fc:	76 11                	jbe    510f <tc_ccm_generation_encryption+0x184>
		*out++ = tag[i] ^ b[i];
    50fe:	41 8a 14 07          	mov    (%r15,%rax,1),%dl
    5102:	41 32 54 05 00       	xor    0x0(%r13,%rax,1),%dl
    5107:	88 14 03             	mov    %dl,(%rbx,%rax,1)
	for (i = 0; i < c->mlen; ++i) {
    510a:	48 ff c0             	inc    %rax
    510d:	eb ea                	jmp    50f9 <tc_ccm_generation_encryption+0x16e>
	}

	return TC_CRYPTO_SUCCESS;
    510f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5115:	eb 03                	jmp    511a <tc_ccm_generation_encryption+0x18f>
		return TC_CRYPTO_FAIL;
    5117:	45 31 c0             	xor    %r8d,%r8d
}
    511a:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    511f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5126:	00 00 
    5128:	74 05                	je     512f <tc_ccm_generation_encryption+0x1a4>
    512a:	e8 81 d3 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    512f:	48 83 c4 48          	add    $0x48,%rsp
    5133:	44 89 c0             	mov    %r8d,%eax
    5136:	5b                   	pop    %rbx
    5137:	5d                   	pop    %rbp
    5138:	41 5c                	pop    %r12
    513a:	41 5d                	pop    %r13
    513c:	41 5e                	pop    %r14
    513e:	41 5f                	pop    %r15
    5140:	c3                   	retq   

0000000000005141 <tc_ccm_decryption_verification>:

int tc_ccm_decryption_verification(uint8_t *out, unsigned int olen,
				   const uint8_t *associated_data,
				   unsigned int alen, const uint8_t *payload,
				   unsigned int plen, TCCcmMode_t c)
{
    5141:	f3 0f 1e fa          	endbr64 
    5145:	41 57                	push   %r15
    5147:	41 56                	push   %r14
    5149:	41 55                	push   %r13
    514b:	49 89 fd             	mov    %rdi,%r13
    514e:	41 54                	push   %r12
    5150:	55                   	push   %rbp
    5151:	53                   	push   %rbx
    5152:	48 83 ec 48          	sub    $0x48,%rsp
    5156:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    515d:	00 00 
    515f:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    5164:	31 c0                	xor    %eax,%eax
    5166:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
    516d:	00 

	/* input sanity check: */
	if ((out == (uint8_t *) 0) ||
    516e:	48 85 ff             	test   %rdi,%rdi
    5171:	0f 84 a2 01 00 00    	je     5319 <tc_ccm_decryption_verification+0x1d8>
    5177:	48 85 ed             	test   %rbp,%rbp
    517a:	0f 84 99 01 00 00    	je     5319 <tc_ccm_decryption_verification+0x1d8>
    5180:	89 f7                	mov    %esi,%edi
    5182:	49 89 d6             	mov    %rdx,%r14
    5185:	41 89 cf             	mov    %ecx,%r15d
    5188:	4d 89 c3             	mov    %r8,%r11
    518b:	44 89 cb             	mov    %r9d,%ebx
	    (c == (TCCcmMode_t) 0) ||
    518e:	45 85 c9             	test   %r9d,%r9d
    5191:	74 09                	je     519c <tc_ccm_decryption_verification+0x5b>
    5193:	4d 85 c0             	test   %r8,%r8
    5196:	0f 84 7f 01 00 00    	je     531b <tc_ccm_decryption_verification+0x1da>
	    ((plen > 0) && (payload == (uint8_t *) 0)) ||
    519c:	45 85 ff             	test   %r15d,%r15d
    519f:	74 0b                	je     51ac <tc_ccm_decryption_verification+0x6b>
	    ((alen > 0) && (associated_data == (uint8_t *) 0)) ||
	    (alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
	    (plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
	    (olen < plen - c->mlen)) { /* invalid output buffer size */
		return TC_CRYPTO_FAIL;
    51a1:	31 c0                	xor    %eax,%eax
	    ((plen > 0) && (payload == (uint8_t *) 0)) ||
    51a3:	4d 85 f6             	test   %r14,%r14
    51a6:	0f 84 6f 01 00 00    	je     531b <tc_ccm_decryption_verification+0x1da>
	    (alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
    51ac:	41 81 ff ff fe 00 00 	cmp    $0xfeff,%r15d
    51b3:	0f 87 60 01 00 00    	ja     5319 <tc_ccm_decryption_verification+0x1d8>
    51b9:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    51bf:	0f 87 54 01 00 00    	ja     5319 <tc_ccm_decryption_verification+0x1d8>
	    (olen < plen - c->mlen)) { /* invalid output buffer size */
    51c5:	89 de                	mov    %ebx,%esi
    51c7:	2b 75 10             	sub    0x10(%rbp),%esi
		return TC_CRYPTO_FAIL;
    51ca:	31 c0                	xor    %eax,%eax
	    (plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
    51cc:	39 fe                	cmp    %edi,%esi
    51ce:	0f 87 47 01 00 00    	ja     531b <tc_ccm_decryption_verification+0x1da>
	unsigned int i;

	/* DECRYPTION: */

	/* formatting the sequence b for decryption: */
	b[0] = 1; /* q - 1 = 2 - 1 = 1 */
    51d4:	c6 44 24 18 01       	movb   $0x1,0x18(%rsp)
	for (i = 1; i < 14; ++i) {
		b[i] = c->nonce[i - 1];
    51d9:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
    51dd:	31 c0                	xor    %eax,%eax
    51df:	4c 8d 64 24 18       	lea    0x18(%rsp),%r12
    51e4:	4c 8d 54 24 19       	lea    0x19(%rsp),%r10
    51e9:	8a 14 01             	mov    (%rcx,%rax,1),%dl
    51ec:	41 88 14 02          	mov    %dl,(%r10,%rax,1)
	for (i = 1; i < 14; ++i) {
    51f0:	48 ff c0             	inc    %rax
    51f3:	48 83 f8 0d          	cmp    $0xd,%rax
    51f7:	75 f0                	jne    51e9 <tc_ccm_decryption_verification+0xa8>
	}
	b[14] = b[15] = TC_ZERO_BYTE; /* initial counter value is 0 */

	/* decrypting payload using ctr mode: */
	ccm_ctr_mode(out, plen - c->mlen, payload, plen - c->mlen, b, c->sched);
    51f9:	4c 8b 4d 00          	mov    0x0(%rbp),%r9
    51fd:	89 f1                	mov    %esi,%ecx
    51ff:	4c 89 da             	mov    %r11,%rdx
    5202:	4d 89 e0             	mov    %r12,%r8
    5205:	4c 89 ef             	mov    %r13,%rdi
    5208:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
    520d:	4c 89 1c 24          	mov    %r11,(%rsp)
	b[14] = b[15] = TC_ZERO_BYTE; /* initial counter value is 0 */
    5211:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	ccm_ctr_mode(out, plen - c->mlen, payload, plen - c->mlen, b, c->sched);
    5218:	e8 fb fb ff ff       	callq  4e18 <ccm_ctr_mode.constprop.0>

	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter value (0) */

	/* encrypting b and restoring the tag from input: */
	(void) tc_aes_encrypt(b, b, c->sched);
    521d:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    5221:	4c 89 e6             	mov    %r12,%rsi
    5224:	4c 89 e7             	mov    %r12,%rdi
	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter value (0) */
    5227:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	(void) tc_aes_encrypt(b, b, c->sched);
    522e:	e8 df f6 ff ff       	callq  4912 <tc_aes_encrypt>
	for (i = 0; i < c->mlen; ++i) {
    5233:	8b 45 10             	mov    0x10(%rbp),%eax
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    5236:	4c 8b 1c 24          	mov    (%rsp),%r11
    523a:	41 89 d8             	mov    %ebx,%r8d
	for (i = 0; i < c->mlen; ++i) {
    523d:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    5242:	49 29 c0             	sub    %rax,%r8
	for (i = 0; i < c->mlen; ++i) {
    5245:	48 89 c1             	mov    %rax,%rcx
    5248:	31 c0                	xor    %eax,%eax
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    524a:	4d 01 c3             	add    %r8,%r11
	for (i = 0; i < c->mlen; ++i) {
    524d:	39 c1                	cmp    %eax,%ecx
    524f:	76 11                	jbe    5262 <tc_ccm_decryption_verification+0x121>
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    5251:	41 8a 14 03          	mov    (%r11,%rax,1),%dl
    5255:	41 32 14 04          	xor    (%r12,%rax,1),%dl
    5259:	88 54 04 28          	mov    %dl,0x28(%rsp,%rax,1)
	for (i = 0; i < c->mlen; ++i) {
    525d:	48 ff c0             	inc    %rax
    5260:	eb eb                	jmp    524d <tc_ccm_decryption_verification+0x10c>
	}

	/* VERIFYING THE AUTHENTICATION TAG: */

	/* formatting the sequence b for authentication: */
	b[0] = ((alen > 0) ? 0x40:0)|(((c->mlen - 2) / 2 << 3)) | (1);
    5262:	45 85 ff             	test   %r15d,%r15d
    5265:	0f 95 c0             	setne  %al
    5268:	c1 e0 06             	shl    $0x6,%eax
    526b:	89 c6                	mov    %eax,%esi
    526d:	8d 41 fe             	lea    -0x2(%rcx),%eax
    5270:	d1 e8                	shr    %eax
    5272:	8d 04 c5 00 00 00 00 	lea    0x0(,%rax,8),%eax
    5279:	09 f0                	or     %esi,%eax
	for (i = 1; i < 14; ++i) {
		b[i] = c->nonce[i - 1];
    527b:	48 8b 75 08          	mov    0x8(%rbp),%rsi
	b[0] = ((alen > 0) ? 0x40:0)|(((c->mlen - 2) / 2 << 3)) | (1);
    527f:	83 c8 01             	or     $0x1,%eax
    5282:	88 44 24 18          	mov    %al,0x18(%rsp)
		b[i] = c->nonce[i - 1];
    5286:	31 c0                	xor    %eax,%eax
    5288:	8a 14 06             	mov    (%rsi,%rax,1),%dl
    528b:	41 88 14 02          	mov    %dl,(%r10,%rax,1)
	for (i = 1; i < 14; ++i) {
    528f:	48 ff c0             	inc    %rax
    5292:	48 83 f8 0d          	cmp    $0xd,%rax
    5296:	75 f0                	jne    5288 <tc_ccm_decryption_verification+0x147>
	}
	b[14] = (uint8_t)((plen - c->mlen) >> 8);
    5298:	89 d8                	mov    %ebx,%eax
	b[15] = (uint8_t)(plen - c->mlen);

	/* computing the authentication tag using cbc-mac: */
	(void) tc_aes_encrypt(b, b, c->sched);
    529a:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    529e:	4c 89 e6             	mov    %r12,%rsi
    52a1:	4c 89 e7             	mov    %r12,%rdi
	b[14] = (uint8_t)((plen - c->mlen) >> 8);
    52a4:	29 c8                	sub    %ecx,%eax
    52a6:	88 64 24 26          	mov    %ah,0x26(%rsp)
	b[15] = (uint8_t)(plen - c->mlen);
    52aa:	89 d8                	mov    %ebx,%eax
    52ac:	29 c8                	sub    %ecx,%eax
    52ae:	88 44 24 27          	mov    %al,0x27(%rsp)
	(void) tc_aes_encrypt(b, b, c->sched);
    52b2:	e8 5b f6 ff ff       	callq  4912 <tc_aes_encrypt>
	if (alen > 0) {
    52b7:	45 85 ff             	test   %r15d,%r15d
    52ba:	74 17                	je     52d3 <tc_ccm_decryption_verification+0x192>
		ccm_cbc_mac(b, associated_data, alen, 1, c->sched);
    52bc:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    52c0:	b9 01 00 00 00       	mov    $0x1,%ecx
    52c5:	44 89 fa             	mov    %r15d,%edx
    52c8:	4c 89 f6             	mov    %r14,%rsi
    52cb:	4c 89 e7             	mov    %r12,%rdi
    52ce:	e8 db fa ff ff       	callq  4dae <ccm_cbc_mac>
	}
	if (plen > 0) {
    52d3:	85 db                	test   %ebx,%ebx
    52d5:	74 16                	je     52ed <tc_ccm_decryption_verification+0x1ac>
		ccm_cbc_mac(b, out, plen - c->mlen, 0, c->sched);
    52d7:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    52db:	89 da                	mov    %ebx,%edx
    52dd:	31 c9                	xor    %ecx,%ecx
    52df:	2b 55 10             	sub    0x10(%rbp),%edx
    52e2:	4c 89 ee             	mov    %r13,%rsi
    52e5:	4c 89 e7             	mov    %r12,%rdi
    52e8:	e8 c1 fa ff ff       	callq  4dae <ccm_cbc_mac>
	}

	/* comparing the received tag and the computed one: */
	if (_compare(b, tag, c->mlen) == 0) {
    52ed:	8b 55 10             	mov    0x10(%rbp),%edx
    52f0:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
    52f5:	4c 89 e7             	mov    %r12,%rdi
    52f8:	e8 d0 ec ff ff       	callq  3fcd <_compare>
    52fd:	41 89 c0             	mov    %eax,%r8d
		return TC_CRYPTO_SUCCESS;
    5300:	b8 01 00 00 00       	mov    $0x1,%eax
	if (_compare(b, tag, c->mlen) == 0) {
    5305:	45 85 c0             	test   %r8d,%r8d
    5308:	74 11                	je     531b <tc_ccm_decryption_verification+0x1da>
  	} else {
		/* erase the decrypted buffer in case of mac validation failure: */
		_set(out, 0, plen - c->mlen);
    530a:	2b 5d 10             	sub    0x10(%rbp),%ebx
    530d:	31 f6                	xor    %esi,%esi
    530f:	4c 89 ef             	mov    %r13,%rdi
    5312:	89 da                	mov    %ebx,%edx
    5314:	e8 96 ec ff ff       	callq  3faf <_set>
		return TC_CRYPTO_FAIL;
    5319:	31 c0                	xor    %eax,%eax
		return TC_CRYPTO_FAIL;
	}
}
    531b:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    5320:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5327:	00 00 
    5329:	74 05                	je     5330 <tc_ccm_decryption_verification+0x1ef>
    532b:	e8 80 d1 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    5330:	48 83 c4 48          	add    $0x48,%rsp
    5334:	5b                   	pop    %rbx
    5335:	5d                   	pop    %rbp
    5336:	41 5c                	pop    %r12
    5338:	41 5d                	pop    %r13
    533a:	41 5e                	pop    %r14
    533c:	41 5f                	pop    %r15
    533e:	c3                   	retq   

000000000000533f <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
    533f:	f3 0f 1e fa          	endbr64 
    5343:	50                   	push   %rax
	sys_trace_idle();
	posix_irq_full_unlock();
    5344:	e8 74 10 00 00       	callq  63bd <posix_irq_full_unlock>
	posix_halt_cpu();
}
    5349:	5a                   	pop    %rdx
	posix_halt_cpu();
    534a:	e9 42 06 00 00       	jmpq   5991 <posix_halt_cpu>

000000000000534f <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
    534f:	f3 0f 1e fa          	endbr64 
	posix_irq_enable(irq);
    5353:	e9 70 10 00 00       	jmpq   63c8 <posix_irq_enable>

0000000000005358 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    5358:	85 ff                	test   %edi,%edi
    535a:	74 0e                	je     536a <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    535c:	48 8d 3d f9 43 00 00 	lea    0x43f9(%rip),%rdi        # 975c <default_cmd+0x4fc>
    5363:	31 c0                	xor    %eax,%eax
    5365:	e9 d3 13 00 00       	jmpq   673d <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    536a:	c3                   	retq   

000000000000536b <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
    536b:	50                   	push   %rax
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    536c:	48 8d 3d ad 99 00 00 	lea    0x99ad(%rip),%rdi        # ed20 <mtx_threads>
    5373:	e8 28 d2 ff ff       	callq  25a0 <pthread_mutex_unlock@plt>
    5378:	48 8d 35 f7 43 00 00 	lea    0x43f7(%rip),%rsi        # 9776 <default_cmd+0x516>
    537f:	89 c7                	mov    %eax,%edi
    5381:	e8 d2 ff ff ff       	callq  5358 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    5386:	e8 65 d2 ff ff       	callq  25f0 <pthread_self@plt>
}
    538b:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    538c:	48 89 c7             	mov    %rax,%rdi
    538f:	e9 4c d0 ff ff       	jmpq   23e0 <pthread_detach@plt>

0000000000005394 <abort_tail>:
{
    5394:	50                   	push   %rax
    5395:	58                   	pop    %rax
	threads_table[this_th_nbr].running = false;
    5396:	48 63 ff             	movslq %edi,%rdi
{
    5399:	50                   	push   %rax
	threads_table[this_th_nbr].running = false;
    539a:	48 c1 e7 05          	shl    $0x5,%rdi
    539e:	48 03 3d fb a0 00 00 	add    0xa0fb(%rip),%rdi        # f4a0 <threads_table>
    53a5:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
	threads_table[this_th_nbr].state = ABORTED;
    53a9:	c7 07 03 00 00 00    	movl   $0x3,(%rdi)
	posix_preexit_cleanup();
    53af:	e8 b7 ff ff ff       	callq  536b <posix_preexit_cleanup>
	pthread_exit(NULL);
    53b4:	31 ff                	xor    %edi,%edi
    53b6:	e8 f5 d1 ff ff       	callq  25b0 <pthread_exit@plt>

00000000000053bb <posix_wait_until_allowed>:
{
    53bb:	41 54                	push   %r12
	threads_table[this_th_nbr].running = false;
    53bd:	48 8b 05 dc a0 00 00 	mov    0xa0dc(%rip),%rax        # f4a0 <threads_table>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    53c4:	4c 8d 25 55 99 00 00 	lea    0x9955(%rip),%r12        # ed20 <mtx_threads>
{
    53cb:	55                   	push   %rbp
    53cc:	53                   	push   %rbx
    53cd:	48 63 df             	movslq %edi,%rbx
    53d0:	48 89 dd             	mov    %rbx,%rbp
	threads_table[this_th_nbr].running = false;
    53d3:	48 c1 e3 05          	shl    $0x5,%rbx
    53d7:	c6 44 18 04 00       	movb   $0x0,0x4(%rax,%rbx,1)
	while (this_th_nbr != currently_allowed_thread) {
    53dc:	39 2d 8e a1 00 00    	cmp    %ebp,0xa18e(%rip)        # f570 <currently_allowed_thread>
    53e2:	74 28                	je     540c <posix_wait_until_allowed+0x51>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    53e4:	4c 89 e6             	mov    %r12,%rsi
    53e7:	48 8d 3d 72 99 00 00 	lea    0x9972(%rip),%rdi        # ed60 <cond_threads>
    53ee:	e8 ad d0 ff ff       	callq  24a0 <pthread_cond_wait@plt>
		if (threads_table &&
    53f3:	48 8b 05 a6 a0 00 00 	mov    0xa0a6(%rip),%rax        # f4a0 <threads_table>
    53fa:	48 85 c0             	test   %rax,%rax
    53fd:	74 dd                	je     53dc <posix_wait_until_allowed+0x21>
    53ff:	83 3c 18 02          	cmpl   $0x2,(%rax,%rbx,1)
    5403:	75 d7                	jne    53dc <posix_wait_until_allowed+0x21>
			abort_tail(this_th_nbr);
    5405:	89 ef                	mov    %ebp,%edi
    5407:	e8 88 ff ff ff       	callq  5394 <abort_tail>
	threads_table[this_th_nbr].running = true;
    540c:	48 8b 05 8d a0 00 00 	mov    0xa08d(%rip),%rax        # f4a0 <threads_table>
    5413:	c6 44 18 04 01       	movb   $0x1,0x4(%rax,%rbx,1)
}
    5418:	5b                   	pop    %rbx
    5419:	5d                   	pop    %rbp
    541a:	41 5c                	pop    %r12
    541c:	c3                   	retq   

000000000000541d <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
    541d:	f3 0f 1e fa          	endbr64 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    5421:	80 3d 87 a1 00 00 00 	cmpb   $0x0,0xa187(%rip)        # f5af <terminate>
    5428:	74 29                	je     5453 <posix_cleanup_handler+0x36>
{
    542a:	50                   	push   %rax
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    542b:	48 8d 3d ee 98 00 00 	lea    0x98ee(%rip),%rdi        # ed20 <mtx_threads>
    5432:	e8 69 d1 ff ff       	callq  25a0 <pthread_mutex_unlock@plt>
    5437:	48 8d 35 38 43 00 00 	lea    0x4338(%rip),%rsi        # 9776 <default_cmd+0x516>
    543e:	89 c7                	mov    %eax,%edi
    5440:	e8 13 ff ff ff       	callq  5358 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    5445:	e8 a6 d1 ff ff       	callq  25f0 <pthread_self@plt>
}
    544a:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    544b:	48 89 c7             	mov    %rax,%rdi
    544e:	e9 8d cf ff ff       	jmpq   23e0 <pthread_detach@plt>
    5453:	c3                   	retq   

0000000000005454 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    5454:	f3 0f 1e fa          	endbr64 
    5458:	50                   	push   %rax
    5459:	58                   	pop    %rax
    545a:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    5461:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    5466:	48 8d 3d b3 98 00 00 	lea    0x98b3(%rip),%rdi        # ed20 <mtx_threads>
{
    546d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5474:	00 00 
    5476:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    547b:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    547d:	e8 2e d2 ff ff       	callq  26b0 <pthread_mutex_lock@plt>
    5482:	48 8d 35 10 43 00 00 	lea    0x4310(%rip),%rsi        # 9799 <default_cmd+0x539>
    5489:	89 c7                	mov    %eax,%edi
    548b:	e8 c8 fe ff ff       	callq  5358 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    5490:	48 83 3d 08 a0 00 00 	cmpq   $0x0,0xa008(%rip)        # f4a0 <threads_table>
    5497:	00 
    5498:	75 11                	jne    54ab <posix_thread_starter+0x57>
		posix_cleanup_handler(arg);
    549a:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    549f:	e8 79 ff ff ff       	callq  541d <posix_cleanup_handler>
		pthread_exit(NULL);
    54a4:	31 ff                	xor    %edi,%edi
    54a6:	e8 05 d1 ff ff       	callq  25b0 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    54ab:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    54b0:	31 f6                	xor    %esi,%esi
    54b2:	e8 c9 d1 ff ff       	callq  2680 <__sigsetjmp@plt>
    54b7:	f3 0f 1e fa          	endbr64 
    54bb:	85 c0                	test   %eax,%eax
    54bd:	74 14                	je     54d3 <posix_thread_starter+0x7f>
    54bf:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    54c4:	e8 54 ff ff ff       	callq  541d <posix_cleanup_handler>
    54c9:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    54ce:	e8 7d d1 ff ff       	callq  2650 <__pthread_unwind_next@plt>
    54d3:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    54d8:	e8 73 cf ff ff       	callq  2450 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    54dd:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    54e1:	e8 d5 fe ff ff       	callq  53bb <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    54e6:	e8 92 03 00 00       	callq  587d <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    54eb:	48 63 44 24 08       	movslq 0x8(%rsp),%rax
    54f0:	48 c1 e0 05          	shl    $0x5,%rax
    54f4:	48 03 05 a5 9f 00 00 	add    0x9fa5(%rip),%rax        # f4a0 <threads_table>
    54fb:	48 8b 40 18          	mov    0x18(%rax),%rax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    54ff:	48 8b 48 18          	mov    0x18(%rax),%rcx
    5503:	48 8b 50 10          	mov    0x10(%rax),%rdx
    5507:	48 8b 70 08          	mov    0x8(%rax),%rsi
    550b:	48 8b 38             	mov    (%rax),%rdi
    550e:	e8 1d dc ff ff       	callq  3130 <z_thread_entry>

0000000000005513 <posix_swap>:
{
    5513:	f3 0f 1e fa          	endbr64 
    5517:	55                   	push   %rbp
    5518:	89 f5                	mov    %esi,%ebp
	currently_allowed_thread = next_allowed_th;
    551a:	89 3d 50 a0 00 00    	mov    %edi,0xa050(%rip)        # f570 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    5520:	48 8d 3d 39 98 00 00 	lea    0x9839(%rip),%rdi        # ed60 <cond_threads>
    5527:	e8 e4 ce ff ff       	callq  2410 <pthread_cond_broadcast@plt>
    552c:	48 8d 35 87 42 00 00 	lea    0x4287(%rip),%rsi        # 97ba <default_cmd+0x55a>
    5533:	89 c7                	mov    %eax,%edi
    5535:	e8 1e fe ff ff       	callq  5358 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    553a:	48 63 c5             	movslq %ebp,%rax
		abort_tail(this_th_nbr);
    553d:	89 ef                	mov    %ebp,%edi
	if (threads_table[this_th_nbr].state == ABORTING) {
    553f:	48 c1 e0 05          	shl    $0x5,%rax
    5543:	48 03 05 56 9f 00 00 	add    0x9f56(%rip),%rax        # f4a0 <threads_table>
    554a:	83 38 02             	cmpl   $0x2,(%rax)
    554d:	75 05                	jne    5554 <posix_swap+0x41>
		abort_tail(this_th_nbr);
    554f:	e8 40 fe ff ff       	callq  5394 <abort_tail>
}
    5554:	5d                   	pop    %rbp
		posix_wait_until_allowed(this_th_nbr);
    5555:	e9 61 fe ff ff       	jmpq   53bb <posix_wait_until_allowed>

000000000000555a <posix_main_thread_start>:
{
    555a:	f3 0f 1e fa          	endbr64 
    555e:	50                   	push   %rax
	currently_allowed_thread = next_allowed_th;
    555f:	89 3d 0b a0 00 00    	mov    %edi,0xa00b(%rip)        # f570 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    5565:	48 8d 3d f4 97 00 00 	lea    0x97f4(%rip),%rdi        # ed60 <cond_threads>
    556c:	e8 9f ce ff ff       	callq  2410 <pthread_cond_broadcast@plt>
    5571:	48 8d 35 42 42 00 00 	lea    0x4242(%rip),%rsi        # 97ba <default_cmd+0x55a>
    5578:	89 c7                	mov    %eax,%edi
    557a:	e8 d9 fd ff ff       	callq  5358 <pc_safe_call>
	posix_preexit_cleanup();
    557f:	e8 e7 fd ff ff       	callq  536b <posix_preexit_cleanup>
	pthread_exit(NULL);
    5584:	31 ff                	xor    %edi,%edi
    5586:	e8 25 d0 ff ff       	callq  25b0 <pthread_exit@plt>

000000000000558b <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    558b:	f3 0f 1e fa          	endbr64 
    558f:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    5590:	8b 35 e2 9f 00 00    	mov    0x9fe2(%rip),%esi        # f578 <threads_table_size>
{
    5596:	48 89 fb             	mov    %rdi,%rbx
	for (int i = 0; i < threads_table_size; i++) {
    5599:	31 c0                	xor    %eax,%eax
		if ((threads_table[i].state == NOTUSED)
    559b:	48 8b 3d fe 9e 00 00 	mov    0x9efe(%rip),%rdi        # f4a0 <threads_table>
    55a2:	41 89 c0             	mov    %eax,%r8d
	for (int i = 0; i < threads_table_size; i++) {
    55a5:	39 c6                	cmp    %eax,%esi
    55a7:	7e 13                	jle    55bc <posix_new_thread+0x31>
		if ((threads_table[i].state == NOTUSED)
    55a9:	48 ff c0             	inc    %rax
    55ac:	48 89 c2             	mov    %rax,%rdx
    55af:	48 c1 e2 05          	shl    $0x5,%rdx
    55b3:	83 7c 17 e0 00       	cmpl   $0x0,-0x20(%rdi,%rdx,1)
    55b8:	75 e8                	jne    55a2 <posix_new_thread+0x17>
    55ba:	eb 52                	jmp    560e <posix_new_thread+0x83>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
    55bc:	83 c6 40             	add    $0x40,%esi
    55bf:	48 63 f6             	movslq %esi,%rsi
	threads_table = realloc(threads_table,
    55c2:	48 c1 e6 05          	shl    $0x5,%rsi
    55c6:	e8 05 d0 ff ff       	callq  25d0 <realloc@plt>
    55cb:	48 89 05 ce 9e 00 00 	mov    %rax,0x9ece(%rip)        # f4a0 <threads_table>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    55d2:	48 85 c0             	test   %rax,%rax
    55d5:	75 0c                	jne    55e3 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    55d7:	48 8d 3d 02 42 00 00 	lea    0x4202(%rip),%rdi        # 97e0 <default_cmd+0x580>
    55de:	e8 5a 11 00 00       	callq  673d <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
    55e3:	48 63 15 8e 9f 00 00 	movslq 0x9f8e(%rip),%rdx        # f578 <threads_table_size>
    55ea:	31 c0                	xor    %eax,%eax
    55ec:	b9 00 02 00 00       	mov    $0x200,%ecx
    55f1:	49 89 d0             	mov    %rdx,%r8
    55f4:	48 c1 e2 05          	shl    $0x5,%rdx
    55f8:	48 03 15 a1 9e 00 00 	add    0x9ea1(%rip),%rdx        # f4a0 <threads_table>
    55ff:	48 89 d7             	mov    %rdx,%rdi
    5602:	f3 ab                	rep stos %eax,%es:(%rdi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    5604:	41 8d 40 40          	lea    0x40(%r8),%eax
    5608:	89 05 6a 9f 00 00    	mov    %eax,0x9f6a(%rip)        # f578 <threads_table_size>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
    560e:	49 63 c8             	movslq %r8d,%rcx
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5611:	8b 05 5d 9f 00 00    	mov    0x9f5d(%rip),%eax        # f574 <thread_create_count>
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    5617:	31 f6                	xor    %esi,%esi
	threads_table[t_slot].state = USED;
    5619:	48 89 cf             	mov    %rcx,%rdi
    561c:	48 c1 e7 05          	shl    $0x5,%rdi
    5620:	48 03 3d 79 9e 00 00 	add    0x9e79(%rip),%rdi        # f4a0 <threads_table>
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5627:	8d 50 01             	lea    0x1(%rax),%edx
	threads_table[t_slot].t_status = ptr;
    562a:	48 89 5f 18          	mov    %rbx,0x18(%rdi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    562e:	48 83 c7 08          	add    $0x8,%rdi
	threads_table[t_slot].state = USED;
    5632:	c7 47 f8 01 00 00 00 	movl   $0x1,-0x8(%rdi)
	threads_table[t_slot].running = false;
    5639:	c6 47 fc 00          	movb   $0x0,-0x4(%rdi)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    563d:	89 47 08             	mov    %eax,0x8(%rdi)
	ptr->thread_idx = t_slot;
    5640:	44 89 43 20          	mov    %r8d,0x20(%rbx)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5644:	89 15 2a 9f 00 00    	mov    %edx,0x9f2a(%rip)        # f574 <thread_create_count>
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    564a:	48 8d 15 03 fe ff ff 	lea    -0x1fd(%rip),%rdx        # 5454 <posix_thread_starter>
    5651:	e8 6a cd ff ff       	callq  23c0 <pthread_create@plt>
    5656:	48 8d 35 ab 41 00 00 	lea    0x41ab(%rip),%rsi        # 9808 <default_cmd+0x5a8>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    565d:	5b                   	pop    %rbx
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    565e:	89 c7                	mov    %eax,%edi
    5660:	e9 f3 fc ff ff       	jmpq   5358 <pc_safe_call>

0000000000005665 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    5665:	f3 0f 1e fa          	endbr64 
    5669:	52                   	push   %rdx
	thread_create_count = 0;

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    566a:	be 20 00 00 00       	mov    $0x20,%esi
    566f:	bf 40 00 00 00       	mov    $0x40,%edi
	thread_create_count = 0;
    5674:	c7 05 f6 9e 00 00 00 	movl   $0x0,0x9ef6(%rip)        # f574 <thread_create_count>
    567b:	00 00 00 
	currently_allowed_thread = -1;
    567e:	c7 05 e8 9e 00 00 ff 	movl   $0xffffffff,0x9ee8(%rip)        # f570 <currently_allowed_thread>
    5685:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    5688:	e8 a3 ce ff ff       	callq  2530 <calloc@plt>
    568d:	48 89 05 0c 9e 00 00 	mov    %rax,0x9e0c(%rip)        # f4a0 <threads_table>
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    5694:	48 85 c0             	test   %rax,%rax
    5697:	75 0c                	jne    56a5 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    5699:	48 8d 3d 40 41 00 00 	lea    0x4140(%rip),%rdi        # 97e0 <default_cmd+0x580>
    56a0:	e8 98 10 00 00       	callq  673d <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    56a5:	48 8d 3d 74 96 00 00 	lea    0x9674(%rip),%rdi        # ed20 <mtx_threads>
	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    56ac:	c7 05 c2 9e 00 00 40 	movl   $0x40,0x9ec2(%rip)        # f578 <threads_table_size>
    56b3:	00 00 00 
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    56b6:	e8 f5 cf ff ff       	callq  26b0 <pthread_mutex_lock@plt>
    56bb:	48 8d 35 d7 40 00 00 	lea    0x40d7(%rip),%rsi        # 9799 <default_cmd+0x539>
    56c2:	89 c7                	mov    %eax,%edi
}
    56c4:	58                   	pop    %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    56c5:	e9 8e fc ff ff       	jmpq   5358 <pc_safe_call>

00000000000056ca <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
    56ca:	f3 0f 1e fa          	endbr64 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    56ce:	48 83 3d ca 9d 00 00 	cmpq   $0x0,0x9dca(%rip)        # f4a0 <threads_table>
    56d5:	00 
    56d6:	74 62                	je     573a <posix_core_clean_up+0x70>
{
    56d8:	55                   	push   %rbp
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
    56d9:	48 8d 2d 8c 41 00 00 	lea    0x418c(%rip),%rbp        # 986c <default_cmd+0x60c>
{
    56e0:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    56e1:	31 db                	xor    %ebx,%ebx
{
    56e3:	52                   	push   %rdx
	terminate = true;
    56e4:	c6 05 c4 9e 00 00 01 	movb   $0x1,0x9ec4(%rip)        # f5af <terminate>
	for (int i = 0; i < threads_table_size; i++) {
    56eb:	39 1d 87 9e 00 00    	cmp    %ebx,0x9e87(%rip)        # f578 <threads_table_size>
    56f1:	48 8b 3d a8 9d 00 00 	mov    0x9da8(%rip),%rdi        # f4a0 <threads_table>
    56f8:	7e 2c                	jle    5726 <posix_core_clean_up+0x5c>
		if (threads_table[i].state != USED) {
    56fa:	48 63 c3             	movslq %ebx,%rax
    56fd:	48 c1 e0 05          	shl    $0x5,%rax
    5701:	48 01 c7             	add    %rax,%rdi
    5704:	83 3f 01             	cmpl   $0x1,(%rdi)
    5707:	75 19                	jne    5722 <posix_core_clean_up+0x58>
		if (pthread_cancel(threads_table[i].thread)) {
    5709:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
    570d:	e8 0e cd ff ff       	callq  2420 <pthread_cancel@plt>
    5712:	85 c0                	test   %eax,%eax
    5714:	74 0c                	je     5722 <posix_core_clean_up+0x58>
			posix_print_warning(
    5716:	89 de                	mov    %ebx,%esi
    5718:	48 89 ef             	mov    %rbp,%rdi
    571b:	31 c0                	xor    %eax,%eax
    571d:	e8 f4 10 00 00       	callq  6816 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
    5722:	ff c3                	inc    %ebx
    5724:	eb c5                	jmp    56eb <posix_core_clean_up+0x21>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    5726:	e8 85 cc ff ff       	callq  23b0 <free@plt>
	threads_table = NULL;
    572b:	48 c7 05 6a 9d 00 00 	movq   $0x0,0x9d6a(%rip)        # f4a0 <threads_table>
    5732:	00 00 00 00 
}
    5736:	58                   	pop    %rax
    5737:	5b                   	pop    %rbx
    5738:	5d                   	pop    %rbp
    5739:	c3                   	retq   
    573a:	c3                   	retq   

000000000000573b <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
    573b:	f3 0f 1e fa          	endbr64 
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    573f:	48 63 ff             	movslq %edi,%rdi
    5742:	48 c1 e7 05          	shl    $0x5,%rdi
    5746:	48 03 3d 53 9d 00 00 	add    0x9d53(%rip),%rdi        # f4a0 <threads_table>
    574d:	83 3f 01             	cmpl   $0x1,(%rdi)
    5750:	75 06                	jne    5758 <posix_abort_thread+0x1d>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    5752:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    5758:	c3                   	retq   

0000000000005759 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
    5759:	f3 0f 1e fa          	endbr64 
    575d:	41 55                	push   %r13
    575f:	41 54                	push   %r12
    5761:	55                   	push   %rbp
    5762:	48 89 fd             	mov    %rdi,%rbp
    5765:	53                   	push   %rbx
    5766:	52                   	push   %rdx
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    5767:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    576b:	44 8b 6b 20          	mov    0x20(%rbx),%r13d
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    576f:	e8 32 0c 00 00       	callq  63a6 <posix_irq_lock>
    5774:	41 89 c4             	mov    %eax,%r12d

	key = irq_lock();

	if (_current == thread) {
    5777:	48 8d 05 a2 9c 00 00 	lea    0x9ca2(%rip),%rax        # f420 <_kernel>
    577e:	48 39 68 10          	cmp    %rbp,0x10(%rax)
    5782:	75 34                	jne    57b8 <z_impl_k_thread_abort+0x5f>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    5784:	83 7b 24 00          	cmpl   $0x0,0x24(%rbx)
    5788:	75 09                	jne    5793 <z_impl_k_thread_abort+0x3a>
			tstatus->aborted = 1;
    578a:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
    5791:	eb 11                	jmp    57a4 <z_impl_k_thread_abort+0x4b>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    5793:	44 89 ee             	mov    %r13d,%esi
    5796:	48 8d 3d 03 41 00 00 	lea    0x4103(%rip),%rdi        # 98a0 <default_cmd+0x640>
    579d:	31 c0                	xor    %eax,%eax
    579f:	e8 72 10 00 00       	callq  6816 <posix_print_warning>
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    57a4:	49 63 c5             	movslq %r13d,%rax
    57a7:	48 c1 e0 05          	shl    $0x5,%rax
    57ab:	48 03 05 ee 9c 00 00 	add    0x9cee(%rip),%rax        # f4a0 <threads_table>
    57b2:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
    57b8:	48 89 ef             	mov    %rbp,%rdi
    57bb:	e8 99 2f 00 00       	callq  8759 <z_thread_abort>

	if (tstatus->aborted == 0) {
    57c0:	83 7b 24 00          	cmpl   $0x0,0x24(%rbx)
    57c4:	75 0f                	jne    57d5 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
    57c6:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
		posix_abort_thread(thread_idx);
    57cd:	44 89 ef             	mov    %r13d,%edi
    57d0:	e8 66 ff ff ff       	callq  573b <posix_abort_thread>
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
}
    57d5:	58                   	pop    %rax
	z_reschedule_irqlock(key);
    57d6:	44 89 e7             	mov    %r12d,%edi
}
    57d9:	5b                   	pop    %rbx
    57da:	5d                   	pop    %rbp
    57db:	41 5c                	pop    %r12
    57dd:	41 5d                	pop    %r13
	z_reschedule_irqlock(key);
    57df:	e9 2f 28 00 00       	jmpq   8013 <z_reschedule_irqlock>

00000000000057e4 <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <power/power.h>

int arch_swap(unsigned int key)
{
    57e4:	f3 0f 1e fa          	endbr64 
    57e8:	53                   	push   %rbx
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
    57e9:	48 8d 1d 30 9c 00 00 	lea    0x9c30(%rip),%rbx        # f420 <_kernel>
    57f0:	48 8b 43 10          	mov    0x10(%rbx),%rax
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    57f4:	48 8b 53 38          	mov    0x38(%rbx),%rdx
	_current->callee_saved.key = key;
    57f8:	89 78 48             	mov    %edi,0x48(%rax)
	posix_thread_status_t *ready_thread_ptr =
    57fb:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
	_current->callee_saved.retval = -EAGAIN;
    57ff:	c7 40 4c f5 ff ff ff 	movl   $0xfffffff5,0x4c(%rax)

	posix_thread_status_t *this_thread_ptr  =
    5806:	48 8b 40 50          	mov    0x50(%rax),%rax
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
    580a:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    580e:	8b 79 20             	mov    0x20(%rcx),%edi
    5811:	8b 70 20             	mov    0x20(%rax),%esi
    5814:	e8 fa fc ff ff       	callq  5513 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
    5819:	48 8b 43 10          	mov    0x10(%rbx),%rax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    581d:	8b 78 48             	mov    0x48(%rax),%edi
    5820:	e8 8f 0b 00 00       	callq  63b4 <posix_irq_unlock>

	return _current->callee_saved.retval;
    5825:	48 8b 43 10          	mov    0x10(%rbx),%rax
}
    5829:	5b                   	pop    %rbx
	return _current->callee_saved.retval;
    582a:	8b 40 4c             	mov    0x4c(%rax),%eax
}
    582d:	c3                   	retq   

000000000000582e <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    582e:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    5832:	48 8d 05 e7 9b 00 00 	lea    0x9be7(%rip),%rax        # f420 <_kernel>
    5839:	48 8b 50 38          	mov    0x38(%rax),%rdx
	posix_thread_status_t *ready_thread_ptr =
    583d:	48 8b 4a 50          	mov    0x50(%rdx),%rcx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
    5841:	48 89 50 10          	mov    %rdx,0x10(%rax)

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    5845:	8b 79 20             	mov    0x20(%rcx),%edi
    5848:	e9 0d fd ff ff       	jmpq   555a <posix_main_thread_start>

000000000000584d <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    584d:	f3 0f 1e fa          	endbr64 

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
    5851:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
{
    5856:	49 89 fa             	mov    %rdi,%r10
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
    5859:	48 8d 7a d8          	lea    -0x28(%rdx),%rdi
	thread_status->entry_point = entry;
    585d:	48 89 4a d8          	mov    %rcx,-0x28(%rdx)
	thread_status->arg1 = p1;
    5861:	4c 89 42 e0          	mov    %r8,-0x20(%rdx)
	thread_status->arg2 = p2;
    5865:	4c 89 4a e8          	mov    %r9,-0x18(%rdx)
	thread_status->arg3 = p3;
    5869:	48 89 42 f0          	mov    %rax,-0x10(%rdx)
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
    586d:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%rdx)
#endif

	thread->callee_saved.thread_status = thread_status;
    5874:	49 89 7a 50          	mov    %rdi,0x50(%r10)

	posix_new_thread(thread_status);
    5878:	e9 0e fd ff ff       	jmpq   558b <posix_new_thread>

000000000000587d <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
    587d:	f3 0f 1e fa          	endbr64 
	posix_irq_full_unlock();
    5881:	e9 37 0b 00 00       	jmpq   63bd <posix_irq_full_unlock>

0000000000005886 <pc_safe_call>:
	if (unlikely(test)) {
    5886:	85 ff                	test   %edi,%edi
    5888:	74 0e                	je     5898 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    588a:	48 8d 3d cb 3e 00 00 	lea    0x3ecb(%rip),%rdi        # 975c <default_cmd+0x4fc>
    5891:	31 c0                	xor    %eax,%eax
    5893:	e9 a5 0e 00 00       	jmpq   673d <posix_print_error_and_exit>
}
    5898:	c3                   	retq   

0000000000005899 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
    5899:	f3 0f 1e fa          	endbr64 
    589d:	50                   	push   %rax
    589e:	58                   	pop    %rax
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    589f:	48 8d 3d fa 94 00 00 	lea    0x94fa(%rip),%rdi        # eda0 <mtx_cpu>
{
    58a6:	50                   	push   %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    58a7:	e8 04 ce ff ff       	callq  26b0 <pthread_mutex_lock@plt>
    58ac:	48 8d 35 69 40 00 00 	lea    0x4069(%rip),%rsi        # 991c <default_cmd+0x6bc>
    58b3:	89 c7                	mov    %eax,%edi
    58b5:	e8 cc ff ff ff       	callq  5886 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    58ba:	48 8d 3d df 94 00 00 	lea    0x94df(%rip),%rdi        # eda0 <mtx_cpu>
    58c1:	e8 da cc ff ff       	callq  25a0 <pthread_mutex_unlock@plt>
    58c6:	48 8d 35 6c 40 00 00 	lea    0x406c(%rip),%rsi        # 9939 <default_cmd+0x6d9>
    58cd:	89 c7                	mov    %eax,%edi
    58cf:	e8 b2 ff ff ff       	callq  5886 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    58d4:	e8 8c fd ff ff       	callq  5665 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    58d9:	e8 13 23 00 00       	callq  7bf1 <z_cstart>

00000000000058de <posix_is_cpu_running>:
{
    58de:	f3 0f 1e fa          	endbr64 
	return !cpu_halted;
    58e2:	8a 05 94 6b 00 00    	mov    0x6b94(%rip),%al        # c47c <cpu_halted>
    58e8:	83 f0 01             	xor    $0x1,%eax
    58eb:	0f b6 c0             	movzbl %al,%eax
}
    58ee:	c3                   	retq   

00000000000058ef <posix_change_cpu_state_and_wait>:
{
    58ef:	f3 0f 1e fa          	endbr64 
    58f3:	55                   	push   %rbp
    58f4:	89 fd                	mov    %edi,%ebp
    58f6:	53                   	push   %rbx
    58f7:	89 fb                	mov    %edi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    58f9:	48 8d 3d a0 94 00 00 	lea    0x94a0(%rip),%rdi        # eda0 <mtx_cpu>
{
    5900:	52                   	push   %rdx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    5901:	e8 aa cd ff ff       	callq  26b0 <pthread_mutex_lock@plt>
    5906:	48 8d 35 0f 40 00 00 	lea    0x400f(%rip),%rsi        # 991c <default_cmd+0x6bc>
    590d:	89 c7                	mov    %eax,%edi
    590f:	e8 72 ff ff ff       	callq  5886 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    5914:	48 8d 3d c5 94 00 00 	lea    0x94c5(%rip),%rdi        # ede0 <cond_cpu>
	cpu_halted = halted;
    591b:	88 1d 5b 6b 00 00    	mov    %bl,0x6b5b(%rip)        # c47c <cpu_halted>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    5921:	48 8d 1d 78 94 00 00 	lea    0x9478(%rip),%rbx        # eda0 <mtx_cpu>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    5928:	e8 e3 ca ff ff       	callq  2410 <pthread_cond_broadcast@plt>
    592d:	48 8d 35 24 40 00 00 	lea    0x4024(%rip),%rsi        # 9958 <default_cmd+0x6f8>
    5934:	89 c7                	mov    %eax,%edi
    5936:	e8 4b ff ff ff       	callq  5886 <pc_safe_call>
	while (cpu_halted == halted) {
    593b:	40 38 2d 3a 6b 00 00 	cmp    %bpl,0x6b3a(%rip)        # c47c <cpu_halted>
    5942:	75 11                	jne    5955 <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    5944:	48 89 de             	mov    %rbx,%rsi
    5947:	48 8d 3d 92 94 00 00 	lea    0x9492(%rip),%rdi        # ede0 <cond_cpu>
    594e:	e8 4d cb ff ff       	callq  24a0 <pthread_cond_wait@plt>
    5953:	eb e6                	jmp    593b <posix_change_cpu_state_and_wait+0x4c>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    5955:	48 8d 3d 44 94 00 00 	lea    0x9444(%rip),%rdi        # eda0 <mtx_cpu>
    595c:	e8 3f cc ff ff       	callq  25a0 <pthread_mutex_unlock@plt>
    5961:	48 8d 35 d1 3f 00 00 	lea    0x3fd1(%rip),%rsi        # 9939 <default_cmd+0x6d9>
    5968:	89 c7                	mov    %eax,%edi
}
    596a:	58                   	pop    %rax
    596b:	5b                   	pop    %rbx
    596c:	5d                   	pop    %rbp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    596d:	e9 14 ff ff ff       	jmpq   5886 <pc_safe_call>

0000000000005972 <posix_interrupt_raised>:
{
    5972:	f3 0f 1e fa          	endbr64 
    5976:	51                   	push   %rcx
	posix_change_cpu_state_and_wait(false);
    5977:	31 ff                	xor    %edi,%edi
    5979:	e8 71 ff ff ff       	callq  58ef <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
    597e:	80 3d 2b 9c 00 00 00 	cmpb   $0x0,0x9c2b(%rip)        # f5b0 <soc_terminate>
    5985:	74 08                	je     598f <posix_interrupt_raised+0x1d>
		posix_exit(0);
    5987:	31 ff                	xor    %edi,%edi
}
    5989:	5a                   	pop    %rdx
		posix_exit(0);
    598a:	e9 b2 0c 00 00       	jmpq   6641 <posix_exit>
}
    598f:	58                   	pop    %rax
    5990:	c3                   	retq   

0000000000005991 <posix_halt_cpu>:
{
    5991:	f3 0f 1e fa          	endbr64 
    5995:	50                   	push   %rax
	posix_change_cpu_state_and_wait(true);
    5996:	bf 01 00 00 00       	mov    $0x1,%edi
    599b:	e8 4f ff ff ff       	callq  58ef <posix_change_cpu_state_and_wait>
}
    59a0:	5a                   	pop    %rdx
	posix_irq_handler();
    59a1:	e9 c6 08 00 00       	jmpq   626c <posix_irq_handler>

00000000000059a6 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    59a6:	f3 0f 1e fa          	endbr64 
    59aa:	53                   	push   %rbx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    59ab:	48 8d 3d ee 93 00 00 	lea    0x93ee(%rip),%rdi        # eda0 <mtx_cpu>
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    59b2:	48 8d 1d e7 93 00 00 	lea    0x93e7(%rip),%rbx        # eda0 <mtx_cpu>
{
    59b9:	48 83 ec 10          	sub    $0x10,%rsp
    59bd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    59c4:	00 00 
    59c6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    59cb:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    59cd:	e8 de cc ff ff       	callq  26b0 <pthread_mutex_lock@plt>
    59d2:	48 8d 35 43 3f 00 00 	lea    0x3f43(%rip),%rsi        # 991c <default_cmd+0x6bc>
    59d9:	89 c7                	mov    %eax,%edi
    59db:	e8 a6 fe ff ff       	callq  5886 <pc_safe_call>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    59e0:	48 89 e7             	mov    %rsp,%rdi
    59e3:	31 c9                	xor    %ecx,%ecx
    59e5:	31 f6                	xor    %esi,%esi
    59e7:	48 8d 15 ab fe ff ff 	lea    -0x155(%rip),%rdx        # 5899 <zephyr_wrapper>
	cpu_halted = false;
    59ee:	c6 05 87 6a 00 00 00 	movb   $0x0,0x6a87(%rip)        # c47c <cpu_halted>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    59f5:	e8 c6 c9 ff ff       	callq  23c0 <pthread_create@plt>
    59fa:	48 8d 35 79 3f 00 00 	lea    0x3f79(%rip),%rsi        # 997a <default_cmd+0x71a>
    5a01:	89 c7                	mov    %eax,%edi
    5a03:	e8 7e fe ff ff       	callq  5886 <pc_safe_call>
	while (cpu_halted == false) {
    5a08:	80 3d 6d 6a 00 00 00 	cmpb   $0x0,0x6a6d(%rip)        # c47c <cpu_halted>
    5a0f:	75 11                	jne    5a22 <posix_boot_cpu+0x7c>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    5a11:	48 89 de             	mov    %rbx,%rsi
    5a14:	48 8d 3d c5 93 00 00 	lea    0x93c5(%rip),%rdi        # ede0 <cond_cpu>
    5a1b:	e8 80 ca ff ff       	callq  24a0 <pthread_cond_wait@plt>
    5a20:	eb e6                	jmp    5a08 <posix_boot_cpu+0x62>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    5a22:	48 8d 3d 77 93 00 00 	lea    0x9377(%rip),%rdi        # eda0 <mtx_cpu>
    5a29:	e8 72 cb ff ff       	callq  25a0 <pthread_mutex_unlock@plt>
    5a2e:	48 8d 35 04 3f 00 00 	lea    0x3f04(%rip),%rsi        # 9939 <default_cmd+0x6d9>
    5a35:	89 c7                	mov    %eax,%edi
    5a37:	e8 4a fe ff ff       	callq  5886 <pc_safe_call>

	if (soc_terminate) {
    5a3c:	80 3d 6d 9b 00 00 00 	cmpb   $0x0,0x9b6d(%rip)        # f5b0 <soc_terminate>
    5a43:	74 07                	je     5a4c <posix_boot_cpu+0xa6>
		posix_exit(0);
    5a45:	31 ff                	xor    %edi,%edi
    5a47:	e8 f5 0b 00 00       	callq  6641 <posix_exit>
	}
}
    5a4c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    5a51:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5a58:	00 00 
    5a5a:	74 05                	je     5a61 <posix_boot_cpu+0xbb>
    5a5c:	e8 4f ca ff ff       	callq  24b0 <__stack_chk_fail@plt>
    5a61:	48 83 c4 10          	add    $0x10,%rsp
    5a65:	5b                   	pop    %rbx
    5a66:	c3                   	retq   

0000000000005a67 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
    5a67:	f3 0f 1e fa          	endbr64 
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    5a6b:	48 8d 05 ee 60 00 00 	lea    0x60ee(%rip),%rax        # bb60 <native_pre_tasks.6323>
    5a72:	48 63 d7             	movslq %edi,%rdx
{
    5a75:	41 54                	push   %r12
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    5a77:	ff c7                	inc    %edi
{
    5a79:	55                   	push   %rbp
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    5a7a:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    5a7e:	49 89 c4             	mov    %rax,%r12
{
    5a81:	53                   	push   %rbx
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    5a82:	48 63 df             	movslq %edi,%rbx
    5a85:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    5a89:	76 11                	jbe    5a9c <run_native_tasks+0x35>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    5a8b:	48 8b 45 00          	mov    0x0(%rbp),%rax
    5a8f:	48 85 c0             	test   %rax,%rax
    5a92:	74 02                	je     5a96 <run_native_tasks+0x2f>
			(*fptr)();
    5a94:	ff d0                	callq  *%rax
		fptr++) {
    5a96:	48 83 c5 08          	add    $0x8,%rbp
    5a9a:	eb e9                	jmp    5a85 <run_native_tasks+0x1e>
		}
	}
}
    5a9c:	5b                   	pop    %rbx
    5a9d:	5d                   	pop    %rbp
    5a9e:	41 5c                	pop    %r12
    5aa0:	c3                   	retq   

0000000000005aa1 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    5aa1:	f3 0f 1e fa          	endbr64 
    5aa5:	51                   	push   %rcx
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    5aa6:	80 3d cf 69 00 00 00 	cmpb   $0x0,0x69cf(%rip)        # c47c <cpu_halted>
    5aad:	74 10                	je     5abf <posix_soc_clean_up+0x1e>

		posix_core_clean_up();
    5aaf:	e8 16 fc ff ff       	callq  56ca <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    5ab4:	bf 04 00 00 00       	mov    $0x4,%edi
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    5ab9:	5a                   	pop    %rdx
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    5aba:	e9 a8 ff ff ff       	jmpq   5a67 <run_native_tasks>
	} else if (soc_terminate == false) {
    5abf:	80 3d ea 9a 00 00 00 	cmpb   $0x0,0x9aea(%rip)        # f5b0 <soc_terminate>
    5ac6:	75 68                	jne    5b30 <posix_soc_clean_up+0x8f>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    5ac8:	48 8d 3d d1 92 00 00 	lea    0x92d1(%rip),%rdi        # eda0 <mtx_cpu>
		soc_terminate = true;
    5acf:	c6 05 da 9a 00 00 01 	movb   $0x1,0x9ada(%rip)        # f5b0 <soc_terminate>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    5ad6:	e8 d5 cb ff ff       	callq  26b0 <pthread_mutex_lock@plt>
    5adb:	48 8d 35 3a 3e 00 00 	lea    0x3e3a(%rip),%rsi        # 991c <default_cmd+0x6bc>
    5ae2:	89 c7                	mov    %eax,%edi
    5ae4:	e8 9d fd ff ff       	callq  5886 <pc_safe_call>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    5ae9:	48 8d 3d f0 92 00 00 	lea    0x92f0(%rip),%rdi        # ede0 <cond_cpu>
		cpu_halted = true;
    5af0:	c6 05 85 69 00 00 01 	movb   $0x1,0x6985(%rip)        # c47c <cpu_halted>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    5af7:	e8 14 c9 ff ff       	callq  2410 <pthread_cond_broadcast@plt>
    5afc:	48 8d 35 55 3e 00 00 	lea    0x3e55(%rip),%rsi        # 9958 <default_cmd+0x6f8>
    5b03:	89 c7                	mov    %eax,%edi
    5b05:	e8 7c fd ff ff       	callq  5886 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    5b0a:	48 8d 3d 8f 92 00 00 	lea    0x928f(%rip),%rdi        # eda0 <mtx_cpu>
    5b11:	e8 8a ca ff ff       	callq  25a0 <pthread_mutex_unlock@plt>
    5b16:	48 8d 35 1c 3e 00 00 	lea    0x3e1c(%rip),%rsi        # 9939 <default_cmd+0x6d9>
    5b1d:	89 c7                	mov    %eax,%edi
    5b1f:	e8 62 fd ff ff       	callq  5886 <pc_safe_call>
			sleep(1);
    5b24:	bf 01 00 00 00       	mov    $0x1,%edi
    5b29:	e8 72 cb ff ff       	callq  26a0 <sleep@plt>
		while (1) {
    5b2e:	eb f4                	jmp    5b24 <posix_soc_clean_up+0x83>
}
    5b30:	58                   	pop    %rax
    5b31:	c3                   	retq   

0000000000005b32 <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
    5b32:	f3 0f 1e fa          	endbr64 
	signaled_end = 1;
    5b36:	c7 05 3c 9a 00 00 01 	movl   $0x1,0x9a3c(%rip)        # f57c <signaled_end>
    5b3d:	00 00 00 
}
    5b40:	c3                   	retq   

0000000000005b41 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    5b41:	f3 0f 1e fa          	endbr64 
    5b45:	55                   	push   %rbp
    5b46:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    5b4d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5b54:	00 00 
    5b56:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    5b5d:	00 
    5b5e:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
    5b60:	48 8d 05 cb ff ff ff 	lea    -0x35(%rip),%rax        # 5b32 <hwm_signal_end_handler>
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    5b67:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
	act.sa_handler = hwm_signal_end_handler;
    5b6c:	48 89 04 24          	mov    %rax,(%rsp)
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    5b70:	e8 0b ca ff ff       	callq  2580 <sigemptyset@plt>
	if (unlikely(test)) {
    5b75:	85 c0                	test   %eax,%eax
    5b77:	74 15                	je     5b8e <hwm_set_sig_handler+0x4d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    5b79:	48 8d 35 35 3e 00 00 	lea    0x3e35(%rip),%rsi        # 99b5 <default_cmd+0x755>
    5b80:	48 8d 3d d5 3b 00 00 	lea    0x3bd5(%rip),%rdi        # 975c <default_cmd+0x4fc>
    5b87:	31 c0                	xor    %eax,%eax
    5b89:	e8 af 0b 00 00       	callq  673d <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    5b8e:	48 89 e5             	mov    %rsp,%rbp
    5b91:	31 d2                	xor    %edx,%edx
    5b93:	bf 0f 00 00 00       	mov    $0xf,%edi
	act.sa_flags = SA_RESETHAND;
    5b98:	c7 84 24 88 00 00 00 	movl   $0x80000000,0x88(%rsp)
    5b9f:	00 00 00 80 
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    5ba3:	48 89 ee             	mov    %rbp,%rsi
    5ba6:	e8 95 c8 ff ff       	callq  2440 <sigaction@plt>
	if (unlikely(test)) {
    5bab:	85 c0                	test   %eax,%eax
    5bad:	74 15                	je     5bc4 <hwm_set_sig_handler+0x83>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    5baf:	48 8d 35 19 3e 00 00 	lea    0x3e19(%rip),%rsi        # 99cf <default_cmd+0x76f>
    5bb6:	48 8d 3d 9f 3b 00 00 	lea    0x3b9f(%rip),%rdi        # 975c <default_cmd+0x4fc>
    5bbd:	31 c0                	xor    %eax,%eax
    5bbf:	e8 79 0b 00 00       	callq  673d <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    5bc4:	31 d2                	xor    %edx,%edx
    5bc6:	48 89 ee             	mov    %rbp,%rsi
    5bc9:	bf 02 00 00 00       	mov    $0x2,%edi
    5bce:	e8 6d c8 ff ff       	callq  2440 <sigaction@plt>
	if (unlikely(test)) {
    5bd3:	85 c0                	test   %eax,%eax
    5bd5:	74 15                	je     5bec <hwm_set_sig_handler+0xab>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    5bd7:	48 8d 35 10 3e 00 00 	lea    0x3e10(%rip),%rsi        # 99ee <default_cmd+0x78e>
    5bde:	48 8d 3d 77 3b 00 00 	lea    0x3b77(%rip),%rdi        # 975c <default_cmd+0x4fc>
    5be5:	31 c0                	xor    %eax,%eax
    5be7:	e8 51 0b 00 00       	callq  673d <posix_print_error_and_exit>
}
    5bec:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
    5bf3:	00 
    5bf4:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5bfb:	00 00 
    5bfd:	74 05                	je     5c04 <hwm_set_sig_handler+0xc3>
    5bff:	e8 ac c8 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    5c04:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    5c0b:	5d                   	pop    %rbp
    5c0c:	c3                   	retq   

0000000000005c0d <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
    5c0d:	f3 0f 1e fa          	endbr64 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
    5c11:	48 8d 05 d8 98 00 00 	lea    0x98d8(%rip),%rax        # f4f0 <hw_timer_timer>
	next_timer_index = 0;
    5c18:	c7 05 4e 68 00 00 00 	movl   $0x0,0x684e(%rip)        # c470 <next_timer_index>
    5c1f:	00 00 00 
	next_timer_time  = *Timer_list[0];
    5c22:	48 8b 10             	mov    (%rax),%rdx

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    5c25:	48 8d 05 34 68 00 00 	lea    0x6834(%rip),%rax        # c460 <irq_ctrl_timer>
    5c2c:	48 8b 00             	mov    (%rax),%rax
	next_timer_time  = *Timer_list[0];
    5c2f:	48 89 15 72 98 00 00 	mov    %rdx,0x9872(%rip)        # f4a8 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    5c36:	48 39 c2             	cmp    %rax,%rdx
    5c39:	76 11                	jbe    5c4c <hwm_find_next_timer+0x3f>
			next_timer_index = i;
    5c3b:	c7 05 2b 68 00 00 01 	movl   $0x1,0x682b(%rip)        # c470 <next_timer_index>
    5c42:	00 00 00 
			next_timer_time = *Timer_list[i];
    5c45:	48 89 05 5c 98 00 00 	mov    %rax,0x985c(%rip)        # f4a8 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    5c4c:	48 8d 05 ed 98 00 00 	lea    0x98ed(%rip),%rax        # f540 <hw_counter_timer>
    5c53:	48 8b 00             	mov    (%rax),%rax
    5c56:	48 3b 05 4b 98 00 00 	cmp    0x984b(%rip),%rax        # f4a8 <next_timer_time>
    5c5d:	73 11                	jae    5c70 <hwm_find_next_timer+0x63>
			next_timer_index = i;
    5c5f:	c7 05 07 68 00 00 02 	movl   $0x2,0x6807(%rip)        # c470 <next_timer_index>
    5c66:	00 00 00 
			next_timer_time = *Timer_list[i];
    5c69:	48 89 05 38 98 00 00 	mov    %rax,0x9838(%rip)        # f4a8 <next_timer_time>
		}
	}
}
    5c70:	c3                   	retq   

0000000000005c71 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    5c71:	f3 0f 1e fa          	endbr64 
    5c75:	48 83 ec 18          	sub    $0x18,%rsp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    5c79:	48 8b 35 28 98 00 00 	mov    0x9828(%rip),%rsi        # f4a8 <next_timer_time>
    5c80:	48 8b 15 29 98 00 00 	mov    0x9829(%rip),%rdx        # f4b0 <simu_time>
    5c87:	48 39 d6             	cmp    %rdx,%rsi
    5c8a:	72 09                	jb     5c95 <hwm_main_loop+0x24>
		simu_time = next_timer_time;
    5c8c:	48 89 35 1d 98 00 00 	mov    %rsi,0x981d(%rip)        # f4b0 <simu_time>
    5c93:	eb 14                	jmp    5ca9 <hwm_main_loop+0x38>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    5c95:	8b 0d d5 67 00 00    	mov    0x67d5(%rip),%ecx        # c470 <next_timer_index>
    5c9b:	48 8d 3d 6a 3d 00 00 	lea    0x3d6a(%rip),%rdi        # 9a0c <default_cmd+0x7ac>
    5ca2:	31 c0                	xor    %eax,%eax
    5ca4:	e8 6d 0b 00 00       	callq  6816 <posix_print_warning>
	if (signaled_end || (simu_time > end_of_time)) {
    5ca9:	8b 15 cd 98 00 00    	mov    0x98cd(%rip),%edx        # f57c <signaled_end>
    5caf:	48 8b 05 fa 97 00 00 	mov    0x97fa(%rip),%rax        # f4b0 <simu_time>
    5cb6:	85 d2                	test   %edx,%edx
    5cb8:	75 09                	jne    5cc3 <hwm_main_loop+0x52>
    5cba:	48 39 05 8f 67 00 00 	cmp    %rax,0x678f(%rip)        # c450 <end_of_time>
    5cc1:	73 36                	jae    5cf9 <hwm_main_loop+0x88>
				((long double)simu_time)/1.0e6);
    5cc3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    5cc8:	df 6c 24 08          	fildll 0x8(%rsp)
    5ccc:	48 85 c0             	test   %rax,%rax
    5ccf:	79 06                	jns    5cd7 <hwm_main_loop+0x66>
    5cd1:	d8 05 cd 36 00 00    	fadds  0x36cd(%rip)        # 93a4 <default_cmd+0x144>
		posix_print_trace("\nStopped at %.3Lfs\n",
    5cd7:	d8 35 cb 36 00 00    	fdivs  0x36cb(%rip)        # 93a8 <default_cmd+0x148>
    5cdd:	50                   	push   %rax
    5cde:	48 8d 3d 5c 3d 00 00 	lea    0x3d5c(%rip),%rdi        # 9a41 <default_cmd+0x7e1>
    5ce5:	50                   	push   %rax
    5ce6:	31 c0                	xor    %eax,%eax
    5ce8:	db 3c 24             	fstpt  (%rsp)
    5ceb:	e8 f5 0b 00 00       	callq  68e5 <posix_print_trace>
    5cf0:	5a                   	pop    %rdx
		posix_exit(0);
    5cf1:	31 ff                	xor    %edi,%edi
		posix_print_trace("\nStopped at %.3Lfs\n",
    5cf3:	59                   	pop    %rcx
		posix_exit(0);
    5cf4:	e8 48 09 00 00       	callq  6641 <posix_exit>
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    5cf9:	8b 05 71 67 00 00    	mov    0x6771(%rip),%eax        # c470 <next_timer_index>
    5cff:	83 f8 01             	cmp    $0x1,%eax
    5d02:	74 10                	je     5d14 <hwm_main_loop+0xa3>
    5d04:	83 f8 02             	cmp    $0x2,%eax
    5d07:	74 12                	je     5d1b <hwm_main_loop+0xaa>
    5d09:	85 c0                	test   %eax,%eax
    5d0b:	75 15                	jne    5d22 <hwm_main_loop+0xb1>
		case HWTIMER:
			hwtimer_timer_reached();
    5d0d:	e8 02 03 00 00       	callq  6014 <hwtimer_timer_reached>
			break;
    5d12:	eb 1c                	jmp    5d30 <hwm_main_loop+0xbf>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
    5d14:	e8 11 09 00 00       	callq  662a <hw_irq_ctrl_timer_triggered>
			break;
    5d19:	eb 15                	jmp    5d30 <hwm_main_loop+0xbf>
		case HW_COUNTER:
			hw_counter_triggered();
    5d1b:	e8 29 16 00 00       	callq  7349 <hw_counter_triggered>
			break;
    5d20:	eb 0e                	jmp    5d30 <hwm_main_loop+0xbf>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    5d22:	48 8d 3d 2c 3d 00 00 	lea    0x3d2c(%rip),%rdi        # 9a55 <default_cmd+0x7f5>
    5d29:	31 c0                	xor    %eax,%eax
    5d2b:	e8 0d 0a 00 00       	callq  673d <posix_print_error_and_exit>
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    5d30:	e8 d8 fe ff ff       	callq  5c0d <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    5d35:	e9 3f ff ff ff       	jmpq   5c79 <hwm_main_loop+0x8>

0000000000005d3a <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
    5d3a:	f3 0f 1e fa          	endbr64 
	end_of_time = new_end_of_time;
    5d3e:	48 89 3d 0b 67 00 00 	mov    %rdi,0x670b(%rip)        # c450 <end_of_time>
}
    5d45:	c3                   	retq   

0000000000005d46 <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
    5d46:	f3 0f 1e fa          	endbr64 
	return simu_time;
}
    5d4a:	48 8b 05 5f 97 00 00 	mov    0x975f(%rip),%rax        # f4b0 <simu_time>
    5d51:	c3                   	retq   

0000000000005d52 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    5d52:	f3 0f 1e fa          	endbr64 
    5d56:	50                   	push   %rax
	hwm_set_sig_handler();
    5d57:	e8 e5 fd ff ff       	callq  5b41 <hwm_set_sig_handler>
	hwtimer_init();
    5d5c:	e8 7e 01 00 00       	callq  5edf <hwtimer_init>
	hw_counter_init();
    5d61:	e8 a8 15 00 00       	callq  730e <hw_counter_init>
	hw_irq_ctrl_init();
    5d66:	e8 f3 06 00 00       	callq  645e <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    5d6b:	5a                   	pop    %rdx
	hwm_find_next_timer();
    5d6c:	e9 9c fe ff ff       	jmpq   5c0d <hwm_find_next_timer>

0000000000005d71 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    5d71:	f3 0f 1e fa          	endbr64 
    5d75:	50                   	push   %rax
	hwtimer_cleanup();
    5d76:	e8 67 02 00 00       	callq  5fe2 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    5d7b:	5a                   	pop    %rdx
	hw_irq_ctrl_cleanup();
    5d7c:	e9 1c 07 00 00       	jmpq   649d <hw_irq_ctrl_cleanup>

0000000000005d81 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    5d81:	48 8d 15 58 97 00 00 	lea    0x9758(%rip),%rdx        # f4e0 <hw_timer_awake_timer>
    5d88:	48 8d 05 59 97 00 00 	lea    0x9759(%rip),%rax        # f4e8 <hw_timer_tick_timer>
    5d8f:	48 8b 00             	mov    (%rax),%rax
    5d92:	48 39 02             	cmp    %rax,(%rdx)
    5d95:	48 0f 46 02          	cmovbe (%rdx),%rax
    5d99:	48 8d 15 50 97 00 00 	lea    0x9750(%rip),%rdx        # f4f0 <hw_timer_timer>
    5da0:	48 89 02             	mov    %rax,(%rdx)
}
    5da3:	c3                   	retq   

0000000000005da4 <native_add_time_options>:
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}

static void native_add_time_options(void)
{
    5da4:	f3 0f 1e fa          	endbr64 
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    5da8:	48 8d 3d 51 62 00 00 	lea    0x6251(%rip),%rdi        # c000 <timer_options.3187>
    5daf:	e9 e8 13 00 00       	jmpq   719c <native_add_command_line_opts>

0000000000005db4 <cmd_stop_at_found>:
{
    5db4:	f3 0f 1e fa          	endbr64 
	if (args.stop_at < 0) {
    5db8:	0f 57 c0             	xorps  %xmm0,%xmm0
{
    5dbb:	52                   	push   %rdx
	if (args.stop_at < 0) {
    5dbc:	66 0f 2f 05 5c 90 00 	comisd 0x905c(%rip),%xmm0        # ee20 <args>
    5dc3:	00 
    5dc4:	76 11                	jbe    5dd7 <cmd_stop_at_found+0x23>
    5dc6:	48 89 fe             	mov    %rdi,%rsi
		posix_print_error_and_exit("Error: stop-at must be positive "
    5dc9:	31 c0                	xor    %eax,%eax
    5dcb:	48 8d 3d 9f 3c 00 00 	lea    0x3c9f(%rip),%rdi        # 9a71 <default_cmd+0x811>
    5dd2:	e8 66 09 00 00       	callq  673d <posix_print_error_and_exit>
	hwm_set_end_of_time(args.stop_at*1e6);
    5dd7:	f2 0f 10 05 99 34 00 	movsd  0x3499(%rip),%xmm0        # 9278 <default_cmd+0x18>
    5dde:	00 
    5ddf:	f2 0f 59 05 39 90 00 	mulsd  0x9039(%rip),%xmm0        # ee20 <args>
    5de6:	00 
    5de7:	f2 0f 10 0d 91 34 00 	movsd  0x3491(%rip),%xmm1        # 9280 <default_cmd+0x20>
    5dee:	00 
    5def:	66 0f 2f c1          	comisd %xmm1,%xmm0
    5df3:	73 07                	jae    5dfc <cmd_stop_at_found+0x48>
    5df5:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    5dfa:	eb 0e                	jmp    5e0a <cmd_stop_at_found+0x56>
    5dfc:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    5e00:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    5e05:	48 0f ba ff 3f       	btc    $0x3f,%rdi
}
    5e0a:	58                   	pop    %rax
	hwm_set_end_of_time(args.stop_at*1e6);
    5e0b:	e9 2a ff ff ff       	jmpq   5d3a <hwm_set_end_of_time>

0000000000005e10 <hwtimer_set_real_time_mode>:
{
    5e10:	f3 0f 1e fa          	endbr64 
	real_time_mode = new_rt;
    5e14:	40 88 3d 62 66 00 00 	mov    %dil,0x6662(%rip)        # c47d <real_time_mode>
}
    5e1b:	c3                   	retq   

0000000000005e1c <cmd_no_realtime_found>:
{
    5e1c:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(false);
    5e20:	31 ff                	xor    %edi,%edi
    5e22:	e9 e9 ff ff ff       	jmpq   5e10 <hwtimer_set_real_time_mode>

0000000000005e27 <cmd_realtime_found>:
{
    5e27:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(true);
    5e2b:	bf 01 00 00 00       	mov    $0x1,%edi
    5e30:	e9 db ff ff ff       	jmpq   5e10 <hwtimer_set_real_time_mode>

0000000000005e35 <get_host_us_time>:
{
    5e35:	f3 0f 1e fa          	endbr64 
    5e39:	48 83 ec 28          	sub    $0x28,%rsp
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    5e3d:	bf 04 00 00 00       	mov    $0x4,%edi
{
    5e42:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5e49:	00 00 
    5e4b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5e50:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    5e52:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    5e57:	e8 24 c6 ff ff       	callq  2480 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    5e5c:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    5e61:	48 85 d2             	test   %rdx,%rdx
    5e64:	78 07                	js     5e6d <get_host_us_time+0x38>
    5e66:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    5e6b:	eb 15                	jmp    5e82 <get_host_us_time+0x4d>
    5e6d:	48 89 d0             	mov    %rdx,%rax
    5e70:	83 e2 01             	and    $0x1,%edx
    5e73:	48 d1 e8             	shr    %rax
    5e76:	48 09 d0             	or     %rdx,%rax
    5e79:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    5e7e:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    5e82:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    5e87:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    5e8c:	f2 0f 59 05 e4 33 00 	mulsd  0x33e4(%rip),%xmm0        # 9278 <default_cmd+0x18>
    5e93:	00 
    5e94:	48 99                	cqto   
    5e96:	48 f7 f9             	idiv   %rcx
    5e99:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    5e9e:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    5ea2:	f2 0f 10 0d d6 33 00 	movsd  0x33d6(%rip),%xmm1        # 9280 <default_cmd+0x20>
    5ea9:	00 
    5eaa:	66 0f 2f c1          	comisd %xmm1,%xmm0
    5eae:	73 07                	jae    5eb7 <get_host_us_time+0x82>
    5eb0:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    5eb5:	eb 0e                	jmp    5ec5 <get_host_us_time+0x90>
    5eb7:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    5ebb:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    5ec0:	48 0f ba f8 3f       	btc    $0x3f,%rax
}
    5ec5:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    5eca:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5ed1:	00 00 
    5ed3:	74 05                	je     5eda <get_host_us_time+0xa5>
    5ed5:	e8 d6 c5 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    5eda:	48 83 c4 28          	add    $0x28,%rsp
    5ede:	c3                   	retq   

0000000000005edf <hwtimer_init>:
{
    5edf:	f3 0f 1e fa          	endbr64 
    5ee3:	48 83 ec 28          	sub    $0x28,%rsp
    5ee7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5eee:	00 00 
    5ef0:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5ef5:	31 c0                	xor    %eax,%eax
	hw_timer_tick_timer = NEVER;
    5ef7:	48 8d 05 ea 95 00 00 	lea    0x95ea(%rip),%rax        # f4e8 <hw_timer_tick_timer>
	silent_ticks = 0;
    5efe:	48 c7 05 c7 95 00 00 	movq   $0x0,0x95c7(%rip)        # f4d0 <silent_ticks>
    5f05:	00 00 00 00 
	hw_timer_tick_timer = NEVER;
    5f09:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hw_timer_awake_timer = NEVER;
    5f10:	48 8d 05 c9 95 00 00 	lea    0x95c9(%rip),%rax        # f4e0 <hw_timer_awake_timer>
    5f17:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    5f1e:	e8 5e fe ff ff       	callq  5d81 <hwtimer_update_timer>
	if (real_time_mode) {
    5f23:	80 3d 53 65 00 00 00 	cmpb   $0x0,0x6553(%rip)        # c47d <real_time_mode>
    5f2a:	74 17                	je     5f43 <hwtimer_init+0x64>
		boot_time = get_host_us_time();
    5f2c:	e8 04 ff ff ff       	callq  5e35 <get_host_us_time>
		last_radj_stime = 0U;
    5f31:	48 c7 05 7c 95 00 00 	movq   $0x0,0x957c(%rip)        # f4b8 <last_radj_stime>
    5f38:	00 00 00 00 
		last_radj_rtime = boot_time;
    5f3c:	48 89 05 7d 95 00 00 	mov    %rax,0x957d(%rip)        # f4c0 <last_radj_rtime>
	if (!reset_rtc) {
    5f43:	80 3d 67 96 00 00 00 	cmpb   $0x0,0x9667(%rip)        # f5b1 <reset_rtc>
    5f4a:	75 7c                	jne    5fc8 <hwtimer_init+0xe9>
		clock_gettime(CLOCK_REALTIME, &tv);
    5f4c:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    5f51:	31 ff                	xor    %edi,%edi
    5f53:	e8 28 c5 ff ff       	callq  2480 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    5f58:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    5f5d:	48 85 d2             	test   %rdx,%rdx
    5f60:	78 07                	js     5f69 <hwtimer_init+0x8a>
    5f62:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    5f67:	eb 15                	jmp    5f7e <hwtimer_init+0x9f>
    5f69:	48 89 d0             	mov    %rdx,%rax
    5f6c:	83 e2 01             	and    $0x1,%edx
    5f6f:	48 d1 e8             	shr    %rax
    5f72:	48 09 d0             	or     %rdx,%rax
    5f75:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    5f7a:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    5f7e:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    5f83:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    5f88:	f2 0f 59 05 e8 32 00 	mulsd  0x32e8(%rip),%xmm0        # 9278 <default_cmd+0x18>
    5f8f:	00 
    5f90:	48 99                	cqto   
    5f92:	48 f7 f9             	idiv   %rcx
    5f95:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    5f9a:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    5f9e:	f2 0f 10 0d da 32 00 	movsd  0x32da(%rip),%xmm1        # 9280 <default_cmd+0x20>
    5fa5:	00 
    5fa6:	66 0f 2f c1          	comisd %xmm1,%xmm0
    5faa:	73 07                	jae    5fb3 <hwtimer_init+0xd4>
    5fac:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    5fb1:	eb 0e                	jmp    5fc1 <hwtimer_init+0xe2>
    5fb3:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    5fb7:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    5fbc:	48 0f ba f8 3f       	btc    $0x3f,%rax
		rtc_offset += realhosttime;
    5fc1:	48 01 05 00 95 00 00 	add    %rax,0x9500(%rip)        # f4c8 <rtc_offset>
}
    5fc8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    5fcd:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5fd4:	00 00 
    5fd6:	74 05                	je     5fdd <hwtimer_init+0xfe>
    5fd8:	e8 d3 c4 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    5fdd:	48 83 c4 28          	add    $0x28,%rsp
    5fe1:	c3                   	retq   

0000000000005fe2 <hwtimer_cleanup>:
{
    5fe2:	f3 0f 1e fa          	endbr64 
}
    5fe6:	c3                   	retq   

0000000000005fe7 <hwtimer_enable>:
{
    5fe7:	f3 0f 1e fa          	endbr64 
    5feb:	50                   	push   %rax
	tick_p = period;
    5fec:	48 89 3d e5 94 00 00 	mov    %rdi,0x94e5(%rip)        # f4d8 <tick_p>
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    5ff3:	e8 4e fd ff ff       	callq  5d46 <hwm_get_time>
    5ff8:	48 8d 15 e9 94 00 00 	lea    0x94e9(%rip),%rdx        # f4e8 <hw_timer_tick_timer>
    5fff:	48 03 05 d2 94 00 00 	add    0x94d2(%rip),%rax        # f4d8 <tick_p>
    6006:	48 89 02             	mov    %rax,(%rdx)
	hwtimer_update_timer();
    6009:	e8 73 fd ff ff       	callq  5d81 <hwtimer_update_timer>
}
    600e:	5a                   	pop    %rdx
	hwm_find_next_timer();
    600f:	e9 f9 fb ff ff       	jmpq   5c0d <hwm_find_next_timer>

0000000000006014 <hwtimer_timer_reached>:
{
    6014:	f3 0f 1e fa          	endbr64 
    6018:	55                   	push   %rbp
    6019:	53                   	push   %rbx
    601a:	48 83 ec 38          	sub    $0x38,%rsp
    601e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6025:	00 00 
    6027:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    602c:	31 c0                	xor    %eax,%eax
	uint64_t Now = hw_timer_timer;
    602e:	48 8d 05 bb 94 00 00 	lea    0x94bb(%rip),%rax        # f4f0 <hw_timer_timer>
    6035:	48 8b 18             	mov    (%rax),%rbx
	if (hw_timer_awake_timer == Now) {
    6038:	48 8d 05 a1 94 00 00 	lea    0x94a1(%rip),%rax        # f4e0 <hw_timer_awake_timer>
    603f:	48 39 18             	cmp    %rbx,(%rax)
    6042:	75 16                	jne    605a <hwtimer_timer_reached+0x46>
	hw_timer_awake_timer = NEVER;
    6044:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    604b:	e8 31 fd ff ff       	callq  5d81 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    6050:	bf ff ff 00 00       	mov    $0xffff,%edi
    6055:	e8 5a 05 00 00       	callq  65b4 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
    605a:	48 8d 2d 87 94 00 00 	lea    0x9487(%rip),%rbp        # f4e8 <hw_timer_tick_timer>
    6061:	48 39 5d 00          	cmp    %rbx,0x0(%rbp)
    6065:	0f 85 12 01 00 00    	jne    617d <hwtimer_timer_reached+0x169>
	if (real_time_mode) {
    606b:	80 3d 0b 64 00 00 00 	cmpb   $0x0,0x640b(%rip)        # c47d <real_time_mode>
    6072:	0f 84 d6 00 00 00    	je     614e <hwtimer_timer_reached+0x13a>
				    / clock_ratio
    6078:	48 2b 1d 39 94 00 00 	sub    0x9439(%rip),%rbx        # f4b8 <last_radj_stime>
    607f:	78 07                	js     6088 <hwtimer_timer_reached+0x74>
    6081:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    6086:	eb 15                	jmp    609d <hwtimer_timer_reached+0x89>
    6088:	48 89 d8             	mov    %rbx,%rax
    608b:	83 e3 01             	and    $0x1,%ebx
    608e:	48 d1 e8             	shr    %rax
    6091:	48 09 d8             	or     %rbx,%rax
    6094:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    6099:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
				    + last_radj_rtime;
    609d:	48 8b 15 1c 94 00 00 	mov    0x941c(%rip),%rdx        # f4c0 <last_radj_rtime>
				    / clock_ratio
    60a4:	f2 0f 5e 05 ac 63 00 	divsd  0x63ac(%rip),%xmm0        # c458 <clock_ratio>
    60ab:	00 
				    + last_radj_rtime;
    60ac:	48 85 d2             	test   %rdx,%rdx
    60af:	78 07                	js     60b8 <hwtimer_timer_reached+0xa4>
    60b1:	f2 48 0f 2a ca       	cvtsi2sd %rdx,%xmm1
    60b6:	eb 15                	jmp    60cd <hwtimer_timer_reached+0xb9>
    60b8:	48 89 d0             	mov    %rdx,%rax
    60bb:	83 e2 01             	and    $0x1,%edx
    60be:	48 d1 e8             	shr    %rax
    60c1:	48 09 d0             	or     %rdx,%rax
    60c4:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    60c9:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
    60cd:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    60d1:	f2 0f 10 0d a7 31 00 	movsd  0x31a7(%rip),%xmm1        # 9280 <default_cmd+0x20>
    60d8:	00 
    60d9:	66 0f 2f c1          	comisd %xmm1,%xmm0
    60dd:	73 07                	jae    60e6 <hwtimer_timer_reached+0xd2>
    60df:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    60e4:	eb 0e                	jmp    60f4 <hwtimer_timer_reached+0xe0>
    60e6:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    60ea:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    60ef:	48 0f ba fb 3f       	btc    $0x3f,%rbx
		uint64_t real_time = get_host_us_time();
    60f4:	e8 3c fd ff ff       	callq  5e35 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
    60f9:	48 29 c3             	sub    %rax,%rbx
		if (diff > 0) { /* we need to slow down */
    60fc:	48 85 db             	test   %rbx,%rbx
    60ff:	7e 4d                	jle    614e <hwtimer_timer_reached+0x13a>
			requested_time.tv_sec  = diff / 1e6;
    6101:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    6106:	f2 0f 10 1d 6a 31 00 	movsd  0x316a(%rip),%xmm3        # 9278 <default_cmd+0x18>
    610d:	00 
			(void) nanosleep(&requested_time, &remaining);
    610e:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    6113:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
			requested_time.tv_sec  = diff / 1e6;
    6118:	66 0f 28 d0          	movapd %xmm0,%xmm2
    611c:	f2 0f 5e d3          	divsd  %xmm3,%xmm2
    6120:	f2 48 0f 2c c2       	cvttsd2si %xmm2,%rax
						 requested_time.tv_sec*1e6)*1e3;
    6125:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
			requested_time.tv_sec  = diff / 1e6;
    612a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
						 requested_time.tv_sec*1e6)*1e3;
    612f:	f2 0f 59 cb          	mulsd  %xmm3,%xmm1
			requested_time.tv_nsec = (diff -
    6133:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
						 requested_time.tv_sec*1e6)*1e3;
    6137:	f2 0f 59 05 49 31 00 	mulsd  0x3149(%rip),%xmm0        # 9288 <default_cmd+0x28>
    613e:	00 
			requested_time.tv_nsec = (diff -
    613f:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    6144:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			(void) nanosleep(&requested_time, &remaining);
    6149:	e8 92 c3 ff ff       	callq  24e0 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
    614e:	48 8b 05 83 93 00 00 	mov    0x9383(%rip),%rax        # f4d8 <tick_p>
    6155:	48 01 45 00          	add    %rax,0x0(%rbp)
	hwtimer_update_timer();
    6159:	e8 23 fc ff ff       	callq  5d81 <hwtimer_update_timer>
	if (silent_ticks > 0) {
    615e:	48 8b 05 6b 93 00 00 	mov    0x936b(%rip),%rax        # f4d0 <silent_ticks>
    6165:	48 85 c0             	test   %rax,%rax
    6168:	7e 0c                	jle    6176 <hwtimer_timer_reached+0x162>
		silent_ticks -= 1;
    616a:	48 ff c8             	dec    %rax
    616d:	48 89 05 5c 93 00 00 	mov    %rax,0x935c(%rip)        # f4d0 <silent_ticks>
    6174:	eb 07                	jmp    617d <hwtimer_timer_reached+0x169>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    6176:	31 ff                	xor    %edi,%edi
    6178:	e8 37 04 00 00       	callq  65b4 <hw_irq_ctrl_set_irq>
}
    617d:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    6182:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    6189:	00 00 
    618b:	74 05                	je     6192 <hwtimer_timer_reached+0x17e>
    618d:	e8 1e c3 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    6192:	48 83 c4 38          	add    $0x38,%rsp
    6196:	5b                   	pop    %rbx
    6197:	5d                   	pop    %rbp
    6198:	c3                   	retq   

0000000000006199 <hwtimer_set_silent_ticks>:
{
    6199:	f3 0f 1e fa          	endbr64 
	silent_ticks = sys_ticks;
    619d:	48 89 3d 2c 93 00 00 	mov    %rdi,0x932c(%rip)        # f4d0 <silent_ticks>
}
    61a4:	c3                   	retq   

00000000000061a5 <hwtimer_reset_rtc>:
{
    61a5:	f3 0f 1e fa          	endbr64 
	reset_rtc = true;
    61a9:	c6 05 01 94 00 00 01 	movb   $0x1,0x9401(%rip)        # f5b1 <reset_rtc>
}
    61b0:	c3                   	retq   

00000000000061b1 <cmd_rtcreset_found>:
{
    61b1:	f3 0f 1e fa          	endbr64 
	hwtimer_reset_rtc();
    61b5:	e9 eb ff ff ff       	jmpq   61a5 <hwtimer_reset_rtc>

00000000000061ba <hwtimer_set_rtc_offset>:
{
    61ba:	f3 0f 1e fa          	endbr64 
	rtc_offset = offset;
    61be:	48 89 3d 03 93 00 00 	mov    %rdi,0x9303(%rip)        # f4c8 <rtc_offset>
}
    61c5:	c3                   	retq   

00000000000061c6 <cmd_rtcoffset_found>:
{
    61c6:	f3 0f 1e fa          	endbr64 
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    61ca:	f2 0f 10 05 a6 30 00 	movsd  0x30a6(%rip),%xmm0        # 9278 <default_cmd+0x18>
    61d1:	00 
    61d2:	f2 0f 59 05 4e 8c 00 	mulsd  0x8c4e(%rip),%xmm0        # ee28 <args+0x8>
    61d9:	00 
    61da:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    61df:	e9 d6 ff ff ff       	jmpq   61ba <hwtimer_set_rtc_offset>

00000000000061e4 <hwtimer_set_rt_ratio>:
{
    61e4:	f3 0f 1e fa          	endbr64 
	clock_ratio = ratio;
    61e8:	f2 0f 11 05 68 62 00 	movsd  %xmm0,0x6268(%rip)        # c458 <clock_ratio>
    61ef:	00 
}
    61f0:	c3                   	retq   

00000000000061f1 <cmd_rt_ratio_found>:
{
    61f1:	f3 0f 1e fa          	endbr64 
	if ((args.rt_ratio <= 0)) {
    61f5:	0f 57 c0             	xorps  %xmm0,%xmm0
    61f8:	66 0f 2f 05 38 8c 00 	comisd 0x8c38(%rip),%xmm0        # ee38 <args+0x18>
    61ff:	00 
    6200:	72 1a                	jb     621c <cmd_rt_ratio_found+0x2b>
{
    6202:	50                   	push   %rax
		posix_print_error_and_exit("The ratio needs to be > 0. "
    6203:	48 8d 3d 8d 38 00 00 	lea    0x388d(%rip),%rdi        # 9a97 <default_cmd+0x837>
    620a:	31 c0                	xor    %eax,%eax
    620c:	e8 2c 05 00 00       	callq  673d <posix_print_error_and_exit>
	hwtimer_set_rt_ratio(args.rt_ratio);
    6211:	f2 0f 10 05 1f 8c 00 	movsd  0x8c1f(%rip),%xmm0        # ee38 <args+0x18>
    6218:	00 
}
    6219:	5a                   	pop    %rdx
    621a:	eb 08                	jmp    6224 <cmd_rt_ratio_found+0x33>
	hwtimer_set_rt_ratio(args.rt_ratio);
    621c:	f2 0f 10 05 14 8c 00 	movsd  0x8c14(%rip),%xmm0        # ee38 <args+0x18>
    6223:	00 
    6224:	e9 bb ff ff ff       	jmpq   61e4 <hwtimer_set_rt_ratio>

0000000000006229 <cmd_rt_drift_found>:
{
    6229:	f3 0f 1e fa          	endbr64 
    622d:	52                   	push   %rdx
	if (!(args.rt_drift > -1)) {
    622e:	f2 0f 10 05 fa 8b 00 	movsd  0x8bfa(%rip),%xmm0        # ee30 <args+0x10>
    6235:	00 
    6236:	66 0f 2f 05 52 30 00 	comisd 0x3052(%rip),%xmm0        # 9290 <default_cmd+0x30>
    623d:	00 
    623e:	77 0e                	ja     624e <cmd_rt_drift_found+0x25>
		posix_print_error_and_exit("The drift needs to be > -1. "
    6240:	48 8d 3d 8c 38 00 00 	lea    0x388c(%rip),%rdi        # 9ad3 <default_cmd+0x873>
    6247:	31 c0                	xor    %eax,%eax
    6249:	e8 ef 04 00 00       	callq  673d <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
    624e:	f2 0f 10 05 42 30 00 	movsd  0x3042(%rip),%xmm0        # 9298 <default_cmd+0x38>
    6255:	00 
    6256:	f2 0f 58 05 d2 8b 00 	addsd  0x8bd2(%rip),%xmm0        # ee30 <args+0x10>
    625d:	00 
    625e:	f2 0f 11 05 d2 8b 00 	movsd  %xmm0,0x8bd2(%rip)        # ee38 <args+0x18>
    6265:	00 
}
    6266:	58                   	pop    %rax
	hwtimer_set_rt_ratio(args.rt_ratio);
    6267:	e9 78 ff ff ff       	jmpq   61e4 <hwtimer_set_rt_ratio>

000000000000626c <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    626c:	f3 0f 1e fa          	endbr64 
    6270:	41 56                	push   %r14
    6272:	41 55                	push   %r13
    6274:	41 54                	push   %r12
    6276:	55                   	push   %rbp
    6277:	53                   	push   %rbx
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    6278:	e8 5e 02 00 00       	callq  64db <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    627d:	85 c0                	test   %eax,%eax
    627f:	0f 85 e6 00 00 00    	jne    636b <posix_irq_handler+0xff>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
    6285:	48 8d 1d 94 91 00 00 	lea    0x9194(%rip),%rbx        # f420 <_kernel>
    628c:	8b 03                	mov    (%rbx),%eax
    628e:	85 c0                	test   %eax,%eax
    6290:	75 0a                	jne    629c <posix_irq_handler+0x30>
		may_swap = 0;
    6292:	c7 05 e4 92 00 00 00 	movl   $0x0,0x92e4(%rip)        # f580 <may_swap.5208>
    6299:	00 00 00 
	}

	_kernel.cpus[0].nested++;
    629c:	ff c0                	inc    %eax
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    629e:	4c 8d 2d 9b 8b 00 00 	lea    0x8b9b(%rip),%r13        # ee40 <irq_vector_table>
	_kernel.cpus[0].nested++;
    62a5:	89 03                	mov    %eax,(%rbx)

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    62a7:	e8 7a 02 00 00       	callq  6526 <hw_irq_ctrl_get_highest_prio_irq>
    62ac:	89 c5                	mov    %eax,%ebp
    62ae:	83 f8 ff             	cmp    $0xffffffff,%eax
    62b1:	0f 84 84 00 00 00    	je     633b <posix_irq_handler+0xcf>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    62b7:	e8 f1 01 00 00       	callq  64ad <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    62bc:	89 ef                	mov    %ebp,%edi
		int last_running_irq = currently_running_irq;
    62be:	44 8b 35 af 61 00 00 	mov    0x61af(%rip),%r14d        # c474 <currently_running_irq>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    62c5:	41 89 c4             	mov    %eax,%r12d
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    62c8:	e8 fd 01 00 00       	callq  64ca <hw_irq_ctrl_get_prio>
    62cd:	0f b6 f8             	movzbl %al,%edi
    62d0:	e8 cd 01 00 00       	callq  64a2 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    62d5:	89 ef                	mov    %ebp,%edi
    62d7:	e8 b9 02 00 00       	callq  6595 <hw_irq_ctrl_clear_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    62dc:	48 63 c5             	movslq %ebp,%rax

		currently_running_irq = irq_nbr;
    62df:	89 2d 8f 61 00 00    	mov    %ebp,0x618f(%rip)        # c474 <currently_running_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    62e5:	48 6b c0 18          	imul   $0x18,%rax,%rax
    62e9:	4c 01 e8             	add    %r13,%rax
    62ec:	48 8b 50 08          	mov    0x8(%rax),%rdx
    62f0:	48 85 d2             	test   %rdx,%rdx
    62f3:	75 12                	jne    6307 <posix_irq_handler+0x9b>
		posix_print_error_and_exit("Received irq %i without a "
    62f5:	89 ee                	mov    %ebp,%esi
    62f7:	48 8d 3d eb 3b 00 00 	lea    0x3beb(%rip),%rdi        # 9ee9 <default_cmd+0xc89>
    62fe:	31 c0                	xor    %eax,%eax
    6300:	e8 38 04 00 00       	callq  673d <posix_print_error_and_exit>
    6305:	eb 20                	jmp    6327 <posix_irq_handler+0xbb>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    6307:	f6 40 04 01          	testb  $0x1,0x4(%rax)
    630b:	74 0a                	je     6317 <posix_irq_handler+0xab>
			*may_swap |= ((direct_irq_f_ptr)
    630d:	ff d2                	callq  *%rdx
    630f:	09 05 6b 92 00 00    	or     %eax,0x926b(%rip)        # f580 <may_swap.5208>
    6315:	eb 10                	jmp    6327 <posix_irq_handler+0xbb>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    6317:	48 8b 78 10          	mov    0x10(%rax),%rdi
    631b:	ff d2                	callq  *%rdx
			*may_swap = 1;
    631d:	c7 05 59 92 00 00 01 	movl   $0x1,0x9259(%rip)        # f580 <may_swap.5208>
    6324:	00 00 00 
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    6327:	44 89 e7             	mov    %r12d,%edi
		currently_running_irq = last_running_irq;
    632a:	44 89 35 43 61 00 00 	mov    %r14d,0x6143(%rip)        # c474 <currently_running_irq>
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    6331:	e8 6c 01 00 00       	callq  64a2 <hw_irq_ctrl_set_cur_prio>
    6336:	e9 6c ff ff ff       	jmpq   62a7 <posix_irq_handler+0x3b>
	}

	_kernel.cpus[0].nested--;
    633b:	ff 0b                	decl   (%rbx)
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    633d:	83 3d 3c 92 00 00 00 	cmpl   $0x0,0x923c(%rip)        # f580 <may_swap.5208>
    6344:	74 25                	je     636b <posix_irq_handler+0xff>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    6346:	e8 62 01 00 00       	callq  64ad <hw_irq_ctrl_get_cur_prio>
    634b:	3d 00 01 00 00       	cmp    $0x100,%eax
    6350:	75 19                	jne    636b <posix_irq_handler+0xff>
		&& (_kernel.ready_q.cache != _current)) {
    6352:	48 8b 43 10          	mov    0x10(%rbx),%rax
    6356:	48 39 43 38          	cmp    %rax,0x38(%rbx)
    635a:	74 0f                	je     636b <posix_irq_handler+0xff>

		(void)z_swap_irqlock(irq_lock);
	}
}
    635c:	5b                   	pop    %rbx

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
    635d:	31 ff                	xor    %edi,%edi
    635f:	5d                   	pop    %rbp
    6360:	41 5c                	pop    %r12
    6362:	41 5d                	pop    %r13
    6364:	41 5e                	pop    %r14
    6366:	e9 79 f4 ff ff       	jmpq   57e4 <arch_swap>
    636b:	5b                   	pop    %rbx
    636c:	5d                   	pop    %rbp
    636d:	41 5c                	pop    %r12
    636f:	41 5d                	pop    %r13
    6371:	41 5e                	pop    %r14
    6373:	c3                   	retq   

0000000000006374 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    6374:	f3 0f 1e fa          	endbr64 
    6378:	51                   	push   %rcx
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    6379:	e8 a8 01 00 00       	callq  6526 <hw_irq_ctrl_get_highest_prio_irq>
    637e:	ff c0                	inc    %eax
    6380:	74 22                	je     63a4 <posix_irq_handler_im_from_sw+0x30>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    6382:	e8 57 f5 ff ff       	callq  58de <posix_is_cpu_running>
    6387:	85 c0                	test   %eax,%eax
    6389:	75 13                	jne    639e <posix_irq_handler_im_from_sw+0x2a>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    638b:	48 8d 35 ae 2e 00 00 	lea    0x2eae(%rip),%rsi        # 9240 <__func__.5217>
    6392:	48 8d 3d 7e 3b 00 00 	lea    0x3b7e(%rip),%rdi        # 9f17 <default_cmd+0xcb7>
    6399:	e8 9f 03 00 00       	callq  673d <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    639e:	5a                   	pop    %rdx
		posix_irq_handler();
    639f:	e9 c8 fe ff ff       	jmpq   626c <posix_irq_handler>
}
    63a4:	58                   	pop    %rax
    63a5:	c3                   	retq   

00000000000063a6 <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
    63a6:	f3 0f 1e fa          	endbr64 
	return hw_irq_ctrl_change_lock(true);
    63aa:	bf 01 00 00 00       	mov    $0x1,%edi
    63af:	e9 33 01 00 00       	jmpq   64e7 <hw_irq_ctrl_change_lock>

00000000000063b4 <posix_irq_unlock>:
 *
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
    63b4:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(key);
    63b8:	e9 2a 01 00 00       	jmpq   64e7 <hw_irq_ctrl_change_lock>

00000000000063bd <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
    63bd:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(false);
    63c1:	31 ff                	xor    %edi,%edi
    63c3:	e9 1f 01 00 00       	jmpq   64e7 <hw_irq_ctrl_change_lock>

00000000000063c8 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
    63c8:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_enable_irq(irq);
    63cc:	e9 31 02 00 00       	jmpq   6602 <hw_irq_ctrl_enable_irq>

00000000000063d1 <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
    63d1:	f3 0f 1e fa          	endbr64 
	irq_vector_table[irq_p].irq   = irq_p;
    63d5:	89 f8                	mov    %edi,%eax
{
    63d7:	49 89 d0             	mov    %rdx,%r8
	irq_vector_table[irq_p].irq   = irq_p;
    63da:	48 6b d0 18          	imul   $0x18,%rax,%rdx
    63de:	48 8d 05 5b 8a 00 00 	lea    0x8a5b(%rip),%rax        # ee40 <irq_vector_table>
    63e5:	48 01 d0             	add    %rdx,%rax
    63e8:	89 38                	mov    %edi,(%rax)
	irq_vector_table[irq_p].func  = isr_p;
    63ea:	4c 89 40 08          	mov    %r8,0x8(%rax)
	irq_vector_table[irq_p].param = isr_param_p;
    63ee:	48 89 48 10          	mov    %rcx,0x10(%rax)
	irq_vector_table[irq_p].flags = flags;
    63f2:	89 70 04             	mov    %esi,0x4(%rax)
}
    63f5:	c3                   	retq   

00000000000063f6 <posix_irq_priority_set>:
 * Lower values take priority over higher values.
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    63f6:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_prio_set(irq, prio);
    63fa:	e9 b9 00 00 00       	jmpq   64b8 <hw_irq_ctrl_prio_set>

00000000000063ff <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    63ff:	80 3d ad 91 00 00 00 	cmpb   $0x0,0x91ad(%rip)        # f5b3 <irqs_locked>
    6406:	74 09                	je     6411 <irq_raising_from_hw_now+0x12>
    6408:	80 3d a3 91 00 00 00 	cmpb   $0x0,0x91a3(%rip)        # f5b2 <lock_ignore>
    640f:	74 0c                	je     641d <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
    6411:	c6 05 9a 91 00 00 00 	movb   $0x0,0x919a(%rip)        # f5b2 <lock_ignore>
		posix_interrupt_raised();
    6418:	e9 55 f5 ff ff       	jmpq   5972 <posix_interrupt_raised>
	}
}
    641d:	c3                   	retq   

000000000000641e <hw_irq_ctrl_irq_raise_prefix>:
{
    641e:	89 f9                	mov    %edi,%ecx
	if (irq < N_IRQS) {
    6420:	83 ff 1f             	cmp    $0x1f,%edi
    6423:	77 29                	ja     644e <hw_irq_ctrl_irq_raise_prefix+0x30>
		if (irq_mask & (1 << irq)) {
    6425:	b8 01 00 00 00       	mov    $0x1,%eax
		irq_premask |= ((uint64_t)1<<irq);
    642a:	ba 01 00 00 00       	mov    $0x1,%edx
		if (irq_mask & (1 << irq)) {
    642f:	d3 e0                	shl    %cl,%eax
		irq_premask |= ((uint64_t)1<<irq);
    6431:	48 d3 e2             	shl    %cl,%rdx
    6434:	48 09 15 c5 90 00 00 	or     %rdx,0x90c5(%rip)        # f500 <irq_premask>
		if (irq_mask & (1 << irq)) {
    643b:	48 98                	cltq   
    643d:	48 85 05 b4 90 00 00 	test   %rax,0x90b4(%rip)        # f4f8 <irq_mask>
    6444:	74 17                	je     645d <hw_irq_ctrl_irq_raise_prefix+0x3f>
			irq_status |= ((uint64_t)1<<irq);
    6446:	48 09 15 bb 90 00 00 	or     %rdx,0x90bb(%rip)        # f508 <irq_status>
    644d:	c3                   	retq   
	} else if (irq == PHONY_HARD_IRQ) {
    644e:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
    6454:	75 07                	jne    645d <hw_irq_ctrl_irq_raise_prefix+0x3f>
		lock_ignore = true;
    6456:	c6 05 55 91 00 00 01 	movb   $0x1,0x9155(%rip)        # f5b2 <lock_ignore>
}
    645d:	c3                   	retq   

000000000000645e <hw_irq_ctrl_init>:
{
    645e:	f3 0f 1e fa          	endbr64 
	irqs_locked = false;
    6462:	c6 05 4a 91 00 00 00 	movb   $0x0,0x914a(%rip)        # f5b3 <irqs_locked>
    6469:	48 8d 05 d0 8c 00 00 	lea    0x8cd0(%rip),%rax        # f140 <irq_prio>
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    6470:	48 c7 05 7d 90 00 00 	movq   $0x0,0x907d(%rip)        # f4f8 <irq_mask>
    6477:	00 00 00 00 
	irq_premask = 0U;
    647b:	48 8d 50 20          	lea    0x20(%rax),%rdx
    647f:	48 c7 05 76 90 00 00 	movq   $0x0,0x9076(%rip)        # f500 <irq_premask>
    6486:	00 00 00 00 
	lock_ignore = false;
    648a:	c6 05 21 91 00 00 00 	movb   $0x0,0x9121(%rip)        # f5b2 <lock_ignore>
		irq_prio[i] = 255U;
    6491:	c6 00 ff             	movb   $0xff,(%rax)
	for (int i = 0 ; i < N_IRQS; i++) {
    6494:	48 ff c0             	inc    %rax
    6497:	48 39 d0             	cmp    %rdx,%rax
    649a:	75 f5                	jne    6491 <hw_irq_ctrl_init+0x33>
}
    649c:	c3                   	retq   

000000000000649d <hw_irq_ctrl_cleanup>:
{
    649d:	f3 0f 1e fa          	endbr64 
}
    64a1:	c3                   	retq   

00000000000064a2 <hw_irq_ctrl_set_cur_prio>:
{
    64a2:	f3 0f 1e fa          	endbr64 
	currently_running_prio = new;
    64a6:	89 3d cc 5f 00 00    	mov    %edi,0x5fcc(%rip)        # c478 <currently_running_prio>
}
    64ac:	c3                   	retq   

00000000000064ad <hw_irq_ctrl_get_cur_prio>:
{
    64ad:	f3 0f 1e fa          	endbr64 
}
    64b1:	8b 05 c1 5f 00 00    	mov    0x5fc1(%rip),%eax        # c478 <currently_running_prio>
    64b7:	c3                   	retq   

00000000000064b8 <hw_irq_ctrl_prio_set>:
{
    64b8:	f3 0f 1e fa          	endbr64 
	irq_prio[irq] = prio;
    64bc:	89 ff                	mov    %edi,%edi
    64be:	48 8d 05 7b 8c 00 00 	lea    0x8c7b(%rip),%rax        # f140 <irq_prio>
    64c5:	40 88 34 38          	mov    %sil,(%rax,%rdi,1)
}
    64c9:	c3                   	retq   

00000000000064ca <hw_irq_ctrl_get_prio>:
{
    64ca:	f3 0f 1e fa          	endbr64 
	return irq_prio[irq];
    64ce:	89 ff                	mov    %edi,%edi
    64d0:	48 8d 05 69 8c 00 00 	lea    0x8c69(%rip),%rax        # f140 <irq_prio>
    64d7:	8a 04 38             	mov    (%rax,%rdi,1),%al
}
    64da:	c3                   	retq   

00000000000064db <hw_irq_ctrl_get_current_lock>:
{
    64db:	f3 0f 1e fa          	endbr64 
	return irqs_locked;
    64df:	0f b6 05 cd 90 00 00 	movzbl 0x90cd(%rip),%eax        # f5b3 <irqs_locked>
}
    64e6:	c3                   	retq   

00000000000064e7 <hw_irq_ctrl_change_lock>:
{
    64e7:	f3 0f 1e fa          	endbr64 
	irqs_locked = new_lock;
    64eb:	85 ff                	test   %edi,%edi
{
    64ed:	41 54                	push   %r12
	uint32_t previous_lock = irqs_locked;
    64ef:	44 0f b6 25 bc 90 00 	movzbl 0x90bc(%rip),%r12d        # f5b3 <irqs_locked>
    64f6:	00 
	irqs_locked = new_lock;
    64f7:	0f 95 05 b5 90 00 00 	setne  0x90b5(%rip)        # f5b3 <irqs_locked>
	if ((previous_lock == true) && (new_lock == false)) {
    64fe:	75 14                	jne    6514 <hw_irq_ctrl_change_lock+0x2d>
    6500:	45 84 e4             	test   %r12b,%r12b
    6503:	74 0f                	je     6514 <hw_irq_ctrl_change_lock+0x2d>
		if (irq_status != 0U) {
    6505:	48 83 3d fb 8f 00 00 	cmpq   $0x0,0x8ffb(%rip)        # f508 <irq_status>
    650c:	00 
    650d:	74 05                	je     6514 <hw_irq_ctrl_change_lock+0x2d>
			posix_irq_handler_im_from_sw();
    650f:	e8 60 fe ff ff       	callq  6374 <posix_irq_handler_im_from_sw>
}
    6514:	44 89 e0             	mov    %r12d,%eax
    6517:	41 5c                	pop    %r12
    6519:	c3                   	retq   

000000000000651a <hw_irq_ctrl_get_irq_status>:
{
    651a:	f3 0f 1e fa          	endbr64 
}
    651e:	48 8b 05 e3 8f 00 00 	mov    0x8fe3(%rip),%rax        # f508 <irq_status>
    6525:	c3                   	retq   

0000000000006526 <hw_irq_ctrl_get_highest_prio_irq>:
{
    6526:	f3 0f 1e fa          	endbr64 
	if (irqs_locked) {
    652a:	80 3d 82 90 00 00 00 	cmpb   $0x0,0x9082(%rip)        # f5b3 <irqs_locked>
    6531:	75 55                	jne    6588 <hw_irq_ctrl_get_highest_prio_irq+0x62>
{
    6533:	51                   	push   %rcx
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
    6534:	e8 e1 ff ff ff       	callq  651a <hw_irq_ctrl_get_irq_status>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    6539:	8b 3d 39 5f 00 00    	mov    0x5f39(%rip),%edi        # c478 <currently_running_prio>
	int winner_prio = 256;
    653f:	be 00 01 00 00       	mov    $0x100,%esi
	int winner = -1;
    6544:	41 83 c8 ff          	or     $0xffffffff,%r8d
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	return __builtin_ffs(op);
    6548:	41 83 c9 ff          	or     $0xffffffff,%r9d
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    654c:	41 ba 01 00 00 00    	mov    $0x1,%r10d
		if ((winner_prio > (int)irq_prio[irq_nbr])
    6552:	4c 8d 1d e7 8b 00 00 	lea    0x8be7(%rip),%r11        # f140 <irq_prio>
	while (irq_status != 0U) {
    6559:	48 85 c0             	test   %rax,%rax
    655c:	74 32                	je     6590 <hw_irq_ctrl_get_highest_prio_irq+0x6a>
    655e:	0f bc c8             	bsf    %eax,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    6561:	4c 89 d2             	mov    %r10,%rdx
		int irq_nbr = find_lsb_set(irq_status) - 1;
    6564:	41 0f 44 c9          	cmove  %r9d,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    6568:	48 d3 e2             	shl    %cl,%rdx
    656b:	48 f7 d2             	not    %rdx
    656e:	48 21 d0             	and    %rdx,%rax
		if ((winner_prio > (int)irq_prio[irq_nbr])
    6571:	48 63 d1             	movslq %ecx,%rdx
    6574:	41 0f b6 14 13       	movzbl (%r11,%rdx,1),%edx
    6579:	39 f2                	cmp    %esi,%edx
    657b:	7d dc                	jge    6559 <hw_irq_ctrl_get_highest_prio_irq+0x33>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    657d:	39 fa                	cmp    %edi,%edx
    657f:	0f 4c f2             	cmovl  %edx,%esi
    6582:	44 0f 4c c1          	cmovl  %ecx,%r8d
    6586:	eb d1                	jmp    6559 <hw_irq_ctrl_get_highest_prio_irq+0x33>
    6588:	41 83 c8 ff          	or     $0xffffffff,%r8d
}
    658c:	44 89 c0             	mov    %r8d,%eax
    658f:	c3                   	retq   
    6590:	44 89 c0             	mov    %r8d,%eax
    6593:	5a                   	pop    %rdx
    6594:	c3                   	retq   

0000000000006595 <hw_irq_ctrl_clear_irq>:
{
    6595:	f3 0f 1e fa          	endbr64 
	irq_status  &= ~((uint64_t)1<<irq);
    6599:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    65a0:	89 f9                	mov    %edi,%ecx
    65a2:	48 d3 c0             	rol    %cl,%rax
    65a5:	48 21 05 5c 8f 00 00 	and    %rax,0x8f5c(%rip)        # f508 <irq_status>
	irq_premask &= ~((uint64_t)1<<irq);
    65ac:	48 21 05 4d 8f 00 00 	and    %rax,0x8f4d(%rip)        # f500 <irq_premask>
}
    65b3:	c3                   	retq   

00000000000065b4 <hw_irq_ctrl_set_irq>:
{
    65b4:	f3 0f 1e fa          	endbr64 
    65b8:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    65b9:	e8 60 fe ff ff       	callq  641e <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    65be:	80 3d ee 8f 00 00 00 	cmpb   $0x0,0x8fee(%rip)        # f5b3 <irqs_locked>
    65c5:	74 09                	je     65d0 <hw_irq_ctrl_set_irq+0x1c>
    65c7:	80 3d e4 8f 00 00 00 	cmpb   $0x0,0x8fe4(%rip)        # f5b2 <lock_ignore>
    65ce:	74 15                	je     65e5 <hw_irq_ctrl_set_irq+0x31>
		irq_ctrl_timer = hwm_get_time();
    65d0:	e8 71 f7 ff ff       	callq  5d46 <hwm_get_time>
    65d5:	48 8d 15 84 5e 00 00 	lea    0x5e84(%rip),%rdx        # c460 <irq_ctrl_timer>
    65dc:	48 89 02             	mov    %rax,(%rdx)
}
    65df:	5a                   	pop    %rdx
		hwm_find_next_timer();
    65e0:	e9 28 f6 ff ff       	jmpq   5c0d <hwm_find_next_timer>
}
    65e5:	58                   	pop    %rax
    65e6:	c3                   	retq   

00000000000065e7 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    65e7:	f3 0f 1e fa          	endbr64 
    65eb:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    65ec:	e8 2d fe ff ff       	callq  641e <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    65f1:	80 3d bb 8f 00 00 00 	cmpb   $0x0,0x8fbb(%rip)        # f5b3 <irqs_locked>
    65f8:	75 06                	jne    6600 <hw_irq_ctrl_raise_im_from_sw+0x19>
		posix_irq_handler_im_from_sw();
	}
}
    65fa:	5a                   	pop    %rdx
		posix_irq_handler_im_from_sw();
    65fb:	e9 74 fd ff ff       	jmpq   6374 <posix_irq_handler_im_from_sw>
}
    6600:	58                   	pop    %rax
    6601:	c3                   	retq   

0000000000006602 <hw_irq_ctrl_enable_irq>:
{
    6602:	f3 0f 1e fa          	endbr64 
	irq_mask |= ((uint64_t)1<<irq);
    6606:	b8 01 00 00 00       	mov    $0x1,%eax
    660b:	89 f9                	mov    %edi,%ecx
    660d:	48 d3 e0             	shl    %cl,%rax
    6610:	48 09 05 e1 8e 00 00 	or     %rax,0x8ee1(%rip)        # f4f8 <irq_mask>
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    6617:	48 8b 05 e2 8e 00 00 	mov    0x8ee2(%rip),%rax        # f500 <irq_premask>
    661e:	48 0f a3 f8          	bt     %rdi,%rax
    6622:	73 05                	jae    6629 <hw_irq_ctrl_enable_irq+0x27>
		hw_irq_ctrl_raise_im_from_sw(irq);
    6624:	e9 be ff ff ff       	jmpq   65e7 <hw_irq_ctrl_raise_im_from_sw>
}
    6629:	c3                   	retq   

000000000000662a <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
    662a:	f3 0f 1e fa          	endbr64 
	irq_ctrl_timer = NEVER;
    662e:	48 8d 05 2b 5e 00 00 	lea    0x5e2b(%rip),%rax        # c460 <irq_ctrl_timer>
    6635:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	irq_raising_from_hw_now();
    663c:	e9 be fd ff ff       	jmpq   63ff <irq_raising_from_hw_now>

0000000000006641 <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    6641:	f3 0f 1e fa          	endbr64 
    6645:	50                   	push   %rax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    6646:	39 3d 38 8f 00 00    	cmp    %edi,0x8f38(%rip)        # f584 <max_exit_code.2396>
    664c:	0f 4d 3d 31 8f 00 00 	cmovge 0x8f31(%rip),%edi        # f584 <max_exit_code.2396>
    6653:	89 3d 2b 8f 00 00    	mov    %edi,0x8f2b(%rip)        # f584 <max_exit_code.2396>
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    6659:	e8 43 f4 ff ff       	callq  5aa1 <posix_soc_clean_up>
	hwm_cleanup();
    665e:	e8 0e f7 ff ff       	callq  5d71 <hwm_cleanup>
	native_cleanup_cmd_line();
    6663:	e8 10 0b 00 00       	callq  7178 <native_cleanup_cmd_line>
	exit(max_exit_code);
    6668:	8b 3d 16 8f 00 00    	mov    0x8f16(%rip),%edi        # f584 <max_exit_code.2396>
    666e:	e8 ed bf ff ff       	callq  2660 <exit@plt>

0000000000006673 <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    6673:	f3 0f 1e fa          	endbr64 
    6677:	55                   	push   %rbp
    6678:	89 fd                	mov    %edi,%ebp
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    667a:	31 ff                	xor    %edi,%edi
{
    667c:	48 83 ec 10          	sub    $0x10,%rsp
    6680:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    6685:	e8 dd f3 ff ff       	callq  5a67 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
    668a:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    668f:	89 ef                	mov    %ebp,%edi
    6691:	e8 bd 0b 00 00       	callq  7253 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    6696:	bf 01 00 00 00       	mov    $0x1,%edi
    669b:	e8 c7 f3 ff ff       	callq  5a67 <run_native_tasks>

	hwm_init();
    66a0:	e8 ad f6 ff ff       	callq  5d52 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    66a5:	bf 02 00 00 00       	mov    $0x2,%edi
    66aa:	e8 b8 f3 ff ff       	callq  5a67 <run_native_tasks>

	posix_boot_cpu();
    66af:	e8 f2 f2 ff ff       	callq  59a6 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    66b4:	bf 03 00 00 00       	mov    $0x3,%edi
    66b9:	e8 a9 f3 ff ff       	callq  5a67 <run_native_tasks>

	hwm_main_loop();
    66be:	e8 ae f5 ff ff       	callq  5c71 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    66c3:	48 83 c4 10          	add    $0x10,%rsp
    66c7:	b8 01 00 00 00       	mov    $0x1,%eax
    66cc:	5d                   	pop    %rbp
    66cd:	c3                   	retq   

00000000000066ce <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
    66ce:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 0;
    66d2:	48 c7 05 8b 5d 00 00 	movq   $0x0,0x5d8b(%rip)        # c468 <is_a_tty>
    66d9:	00 00 00 00 
	is_a_tty[1] = 0;
}
    66dd:	c3                   	retq   

00000000000066de <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
    66de:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = -1;
    66e2:	48 c7 05 7b 5d 00 00 	movq   $0xffffffffffffffff,0x5d7b(%rip)        # c468 <is_a_tty>
    66e9:	ff ff ff ff 
	is_a_tty[1] = -1;

}
    66ed:	c3                   	retq   

00000000000066ee <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
    66ee:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 1;
    66f2:	48 b8 01 00 00 00 01 	movabs $0x100000001,%rax
    66f9:	00 00 00 
    66fc:	48 89 05 65 5d 00 00 	mov    %rax,0x5d65(%rip)        # c468 <is_a_tty>
	is_a_tty[1] = 1;
}
    6703:	c3                   	retq   

0000000000006704 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    6704:	f3 0f 1e fa          	endbr64 
    6708:	52                   	push   %rdx
	if (is_a_tty[0] == -1) {
    6709:	83 3d 58 5d 00 00 ff 	cmpl   $0xffffffff,0x5d58(%rip)        # c468 <is_a_tty>
    6710:	75 10                	jne    6722 <decide_about_color+0x1e>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    6712:	bf 01 00 00 00       	mov    $0x1,%edi
    6717:	e8 14 bd ff ff       	callq  2430 <isatty@plt>
    671c:	89 05 46 5d 00 00    	mov    %eax,0x5d46(%rip)        # c468 <is_a_tty>
	}
	if (is_a_tty[1] == -1) {
    6722:	83 3d 43 5d 00 00 ff 	cmpl   $0xffffffff,0x5d43(%rip)        # c46c <is_a_tty+0x4>
    6729:	75 10                	jne    673b <decide_about_color+0x37>
		is_a_tty[1] = isatty(STDERR_FILENO);
    672b:	bf 02 00 00 00       	mov    $0x2,%edi
    6730:	e8 fb bc ff ff       	callq  2430 <isatty@plt>
    6735:	89 05 31 5d 00 00    	mov    %eax,0x5d31(%rip)        # c46c <is_a_tty+0x4>
	}
}
    673b:	58                   	pop    %rax
    673c:	c3                   	retq   

000000000000673d <posix_print_error_and_exit>:
{
    673d:	f3 0f 1e fa          	endbr64 
    6741:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    6748:	49 89 fa             	mov    %rdi,%r10
    674b:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    6750:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    6755:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    675a:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    675f:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    6764:	84 c0                	test   %al,%al
    6766:	74 37                	je     679f <posix_print_error_and_exit+0x62>
    6768:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    676d:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    6772:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6777:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    677e:	00 
    677f:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    6786:	00 
    6787:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    678e:	00 
    678f:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    6796:	00 
    6797:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    679e:	00 
    679f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    67a6:	00 00 
    67a8:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    67ad:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    67af:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    67b6:	00 

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    67b7:	48 89 e1             	mov    %rsp,%rcx
    67ba:	4c 89 d2             	mov    %r10,%rdx
    67bd:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    67c2:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    67c7:	be 01 00 00 00       	mov    $0x1,%esi
    67cc:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    67d1:	48 8b 05 18 58 00 00 	mov    0x5818(%rip),%rax        # bff0 <stderr@GLIBC_2.2.5>
    67d8:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    67df:	48 8b 38             	mov    (%rax),%rdi
    67e2:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    67e9:	00 
    67ea:	e8 01 bc ff ff       	callq  23f0 <__vfprintf_chk@plt>
	posix_exit(1);
    67ef:	bf 01 00 00 00       	mov    $0x1,%edi
    67f4:	e8 48 fe ff ff       	callq  6641 <posix_exit>
}
    67f9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    67fe:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    6805:	00 00 
    6807:	74 05                	je     680e <posix_print_error_and_exit+0xd1>
    6809:	e8 a2 bc ff ff       	callq  24b0 <__stack_chk_fail@plt>
    680e:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    6815:	c3                   	retq   

0000000000006816 <posix_print_warning>:
{
    6816:	f3 0f 1e fa          	endbr64 
    681a:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    6821:	49 89 fa             	mov    %rdi,%r10
    6824:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    6829:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    682e:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    6833:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6838:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    683d:	84 c0                	test   %al,%al
    683f:	74 37                	je     6878 <posix_print_warning+0x62>
    6841:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    6846:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    684b:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6850:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    6857:	00 
    6858:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    685f:	00 
    6860:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    6867:	00 
    6868:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    686f:	00 
    6870:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    6877:	00 
    6878:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    687f:	00 00 
    6881:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    6886:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    6888:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    688f:	00 
    6890:	48 89 e1             	mov    %rsp,%rcx
    6893:	4c 89 d2             	mov    %r10,%rdx
    6896:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    689b:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    68a0:	be 01 00 00 00       	mov    $0x1,%esi
    68a5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    68aa:	48 8b 05 3f 57 00 00 	mov    0x573f(%rip),%rax        # bff0 <stderr@GLIBC_2.2.5>
    68b1:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    68b8:	48 8b 38             	mov    (%rax),%rdi
    68bb:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    68c2:	00 
    68c3:	e8 28 bb ff ff       	callq  23f0 <__vfprintf_chk@plt>
}
    68c8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    68cd:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    68d4:	00 00 
    68d6:	74 05                	je     68dd <posix_print_warning+0xc7>
    68d8:	e8 d3 bb ff ff       	callq  24b0 <__stack_chk_fail@plt>
    68dd:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    68e4:	c3                   	retq   

00000000000068e5 <posix_print_trace>:
{
    68e5:	f3 0f 1e fa          	endbr64 
    68e9:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    68f0:	49 89 fa             	mov    %rdi,%r10
    68f3:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    68f8:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    68fd:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    6902:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6907:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    690c:	84 c0                	test   %al,%al
    690e:	74 37                	je     6947 <posix_print_trace+0x62>
    6910:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    6915:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    691a:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    691f:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    6926:	00 
    6927:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    692e:	00 
    692f:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    6936:	00 
    6937:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    693e:	00 
    693f:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    6946:	00 
    6947:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    694e:	00 00 
    6950:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    6955:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    6957:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    695e:	00 
    695f:	48 89 e1             	mov    %rsp,%rcx
    6962:	4c 89 d2             	mov    %r10,%rdx
    6965:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    696a:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    696f:	be 01 00 00 00       	mov    $0x1,%esi
    6974:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    6979:	48 8b 05 28 56 00 00 	mov    0x5628(%rip),%rax        # bfa8 <stdout@GLIBC_2.2.5>
    6980:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    6987:	48 8b 38             	mov    (%rax),%rdi
    698a:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    6991:	00 
    6992:	e8 59 ba ff ff       	callq  23f0 <__vfprintf_chk@plt>
}
    6997:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    699c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    69a3:	00 00 
    69a5:	74 05                	je     69ac <posix_print_trace+0xc7>
    69a7:	e8 04 bb ff ff       	callq  24b0 <__stack_chk_fail@plt>
    69ac:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    69b3:	c3                   	retq   

00000000000069b4 <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
    69b4:	f3 0f 1e fa          	endbr64 
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    69b8:	48 8d 3d 01 58 00 00 	lea    0x5801(%rip),%rdi        # c1c0 <trace_options.3560>
    69bf:	e9 d8 07 00 00       	jmpq   719c <native_add_command_line_opts>

00000000000069c4 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    69c4:	41 55                	push   %r13
    69c6:	41 bd 46 00 00 00    	mov    $0x46,%r13d
    69cc:	41 54                	push   %r12
    69ce:	49 89 f4             	mov    %rsi,%r12
    69d1:	55                   	push   %rbp
    69d2:	48 89 fd             	mov    %rdi,%rbp
    69d5:	53                   	push   %rbx
    69d6:	41 53                	push   %r11

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    69d8:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
    69dc:	75 0c                	jne    69ea <cmd_gen_switch_syntax.constprop.0+0x26>
		*buf++ = '[';
    69de:	c6 07 5b             	movb   $0x5b,(%rdi)
    69e1:	48 ff c5             	inc    %rbp
		size--;
    69e4:	41 bd 45 00 00 00    	mov    $0x45,%r13d
	}

	if (args_s_el->is_switch == true) {
    69ea:	41 80 7c 24 02 00    	cmpb   $0x0,0x2(%r12)
    69f0:	4d 8b 4c 24 08       	mov    0x8(%r12),%r9
    69f5:	49 63 f5             	movslq %r13d,%rsi
    69f8:	74 1c                	je     6a16 <cmd_gen_switch_syntax.constprop.0+0x52>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    69fa:	4c 8d 05 03 36 00 00 	lea    0x3603(%rip),%r8        # a004 <default_cmd+0xda4>
    6a01:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6a05:	48 89 ef             	mov    %rbp,%rdi
    6a08:	31 c0                	xor    %eax,%eax
    6a0a:	ba 01 00 00 00       	mov    $0x1,%edx
    6a0f:	e8 8c b9 ff ff       	callq  23a0 <__snprintf_chk@plt>
    6a14:	eb 38                	jmp    6a4e <cmd_gen_switch_syntax.constprop.0+0x8a>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
    6a16:	41 80 7c 24 18 6c    	cmpb   $0x6c,0x18(%r12)
    6a1c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    6a21:	74 0c                	je     6a2f <cmd_gen_switch_syntax.constprop.0+0x6b>
    6a23:	4c 8d 05 de 35 00 00 	lea    0x35de(%rip),%r8        # a008 <default_cmd+0xda8>
    6a2a:	41 52                	push   %r10
    6a2c:	50                   	push   %rax
    6a2d:	eb 0a                	jmp    6a39 <cmd_gen_switch_syntax.constprop.0+0x75>
    6a2f:	41 50                	push   %r8
    6a31:	4c 8d 05 d9 35 00 00 	lea    0x35d9(%rip),%r8        # a011 <default_cmd+0xdb1>
    6a38:	50                   	push   %rax
    6a39:	48 89 ef             	mov    %rbp,%rdi
    6a3c:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6a40:	ba 01 00 00 00       	mov    $0x1,%edx
    6a45:	31 c0                	xor    %eax,%eax
    6a47:	e8 54 b9 ff ff       	callq  23a0 <__snprintf_chk@plt>
    6a4c:	5e                   	pop    %rsi
    6a4d:	5f                   	pop    %rdi
    6a4e:	48 63 d8             	movslq %eax,%rbx
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    6a51:	85 db                	test   %ebx,%ebx
    6a53:	79 1a                	jns    6a6f <cmd_gen_switch_syntax.constprop.0+0xab>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    6a55:	ba 07 01 00 00       	mov    $0x107,%edx
    6a5a:	48 8d 35 bc 35 00 00 	lea    0x35bc(%rip),%rsi        # a01d <default_cmd+0xdbd>
    6a61:	48 8d 3d f3 35 00 00 	lea    0x35f3(%rip),%rdi        # a05b <default_cmd+0xdfb>
    6a68:	31 c0                	xor    %eax,%eax
    6a6a:	e8 ce fc ff ff       	callq  673d <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    6a6f:	41 29 dd             	sub    %ebx,%r13d
    6a72:	78 2c                	js     6aa0 <cmd_gen_switch_syntax.constprop.0+0xdc>
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    6a74:	41 80 7c 24 01 00    	cmpb   $0x0,0x1(%r12)
	buf += ret;
    6a7a:	48 8d 7c 1d 00       	lea    0x0(%rbp,%rbx,1),%rdi
	if (args_s_el->is_mandatory == false) {
    6a7f:	49 63 f5             	movslq %r13d,%rsi
    6a82:	48 8d 15 ed 35 00 00 	lea    0x35ed(%rip),%rdx        # a076 <default_cmd+0xe16>
    6a89:	74 07                	je     6a92 <cmd_gen_switch_syntax.constprop.0+0xce>
    6a8b:	48 8d 15 e5 35 00 00 	lea    0x35e5(%rip),%rdx        # a077 <default_cmd+0xe17>
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    6a92:	59                   	pop    %rcx
    6a93:	31 c0                	xor    %eax,%eax
    6a95:	5b                   	pop    %rbx
    6a96:	5d                   	pop    %rbp
    6a97:	41 5c                	pop    %r12
    6a99:	41 5d                	pop    %r13
    6a9b:	e9 30 ba ff ff       	jmpq   24d0 <snprintf@plt>
    6aa0:	58                   	pop    %rax
    6aa1:	5b                   	pop    %rbx
    6aa2:	5d                   	pop    %rbp
    6aa3:	41 5c                	pop    %r12
    6aa5:	41 5d                	pop    %r13
    6aa7:	c3                   	retq   

0000000000006aa8 <cmd_is_option>:
{
    6aa8:	f3 0f 1e fa          	endbr64 
    6aac:	41 54                	push   %r12
    6aae:	49 89 f8             	mov    %rdi,%r8
    6ab1:	41 89 d4             	mov    %edx,%r12d
    6ab4:	55                   	push   %rbp
    6ab5:	48 89 f5             	mov    %rsi,%rbp
    6ab8:	53                   	push   %rbx
	int of = 0;
    6ab9:	31 db                	xor    %ebx,%ebx
    6abb:	80 3f 2d             	cmpb   $0x2d,(%rdi)
	if (arg[of] == '-') {
    6abe:	0f 94 c0             	sete   %al
	int of = 0;
    6ac1:	0f 94 c3             	sete   %bl
	if (arg[of] == '-') {
    6ac4:	0f b6 c0             	movzbl %al,%eax
    6ac7:	80 3c 07 2d          	cmpb   $0x2d,(%rdi,%rax,1)
    6acb:	75 02                	jne    6acf <cmd_is_option+0x27>
		of++;
    6acd:	ff c3                	inc    %ebx
	if (!with_value) {
    6acf:	45 85 e4             	test   %r12d,%r12d
    6ad2:	75 28                	jne    6afc <cmd_is_option+0x54>
		if (strcmp(&arg[of], option) != 0) {
    6ad4:	48 63 fb             	movslq %ebx,%rdi
    6ad7:	48 89 ee             	mov    %rbp,%rsi
    6ada:	4c 01 c7             	add    %r8,%rdi
    6add:	e8 5e ba ff ff       	callq  2540 <strcmp@plt>
    6ae2:	85 c0                	test   %eax,%eax
    6ae4:	75 68                	jne    6b4e <cmd_is_option+0xa6>
	size_t to_match_len = strlen(option);
    6ae6:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6aea:	48 89 ef             	mov    %rbp,%rdi
    6aed:	f2 ae                	repnz scas %es:(%rdi),%al
    6aef:	48 89 c8             	mov    %rcx,%rax
    6af2:	48 f7 d0             	not    %rax
			return of + to_match_len;
    6af5:	44 8d 64 03 ff       	lea    -0x1(%rbx,%rax,1),%r12d
    6afa:	eb 52                	jmp    6b4e <cmd_is_option+0xa6>
    6afc:	31 d2                	xor    %edx,%edx
    6afe:	44 8d 24 13          	lea    (%rbx,%rdx,1),%r12d
	while (!(arg[of] == 0 && *option == 0)) {
    6b02:	8a 4c 15 00          	mov    0x0(%rbp,%rdx,1),%cl
    6b06:	49 63 c4             	movslq %r12d,%rax
    6b09:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    6b0d:	89 c6                	mov    %eax,%esi
    6b0f:	40 08 ce             	or     %cl,%sil
    6b12:	74 24                	je     6b38 <cmd_is_option+0x90>
		if (*option == 0) {
    6b14:	84 c9                	test   %cl,%cl
    6b16:	75 17                	jne    6b2f <cmd_is_option+0x87>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    6b18:	3c 3a                	cmp    $0x3a,%al
    6b1a:	74 04                	je     6b20 <cmd_is_option+0x78>
    6b1c:	3c 3d                	cmp    $0x3d,%al
    6b1e:	75 2b                	jne    6b4b <cmd_is_option+0xa3>
				of++;
    6b20:	41 ff c4             	inc    %r12d
	if (arg[of] == 0) { /* we need a value to follow */
    6b23:	49 63 c4             	movslq %r12d,%rax
    6b26:	41 80 3c 00 00       	cmpb   $0x0,(%r8,%rax,1)
    6b2b:	75 21                	jne    6b4e <cmd_is_option+0xa6>
    6b2d:	eb 09                	jmp    6b38 <cmd_is_option+0x90>
		if (arg[of] != *option) {
    6b2f:	48 ff c2             	inc    %rdx
    6b32:	38 c8                	cmp    %cl,%al
    6b34:	74 c8                	je     6afe <cmd_is_option+0x56>
    6b36:	eb 13                	jmp    6b4b <cmd_is_option+0xa3>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    6b38:	4c 89 c6             	mov    %r8,%rsi
    6b3b:	48 8d 3d 37 35 00 00 	lea    0x3537(%rip),%rdi        # a079 <default_cmd+0xe19>
    6b42:	31 c0                	xor    %eax,%eax
    6b44:	e8 f4 fb ff ff       	callq  673d <posix_print_error_and_exit>
    6b49:	eb 03                	jmp    6b4e <cmd_is_option+0xa6>
			return 0;
    6b4b:	45 31 e4             	xor    %r12d,%r12d
}
    6b4e:	44 89 e0             	mov    %r12d,%eax
    6b51:	5b                   	pop    %rbx
    6b52:	5d                   	pop    %rbp
    6b53:	41 5c                	pop    %r12
    6b55:	c3                   	retq   

0000000000006b56 <cmd_is_help_option>:
{
    6b56:	f3 0f 1e fa          	endbr64 
    6b5a:	55                   	push   %rbp
	if (arg[0] == '-') {
    6b5b:	80 3f 2d             	cmpb   $0x2d,(%rdi)
{
    6b5e:	48 89 fd             	mov    %rdi,%rbp
	if (arg[0] == '-') {
    6b61:	75 0f                	jne    6b72 <cmd_is_help_option+0x1c>
	if (arg[0] == '-') {
    6b63:	80 7f 01 2d          	cmpb   $0x2d,0x1(%rdi)
    6b67:	74 05                	je     6b6e <cmd_is_help_option+0x18>
		arg++;
    6b69:	48 ff c5             	inc    %rbp
    6b6c:	eb 04                	jmp    6b72 <cmd_is_help_option+0x1c>
		arg++;
    6b6e:	48 83 c5 02          	add    $0x2,%rbp
	if ((strcasecmp(arg, "?") == 0) ||
    6b72:	48 8d 35 5a 35 00 00 	lea    0x355a(%rip),%rsi        # a0d3 <default_cmd+0xe73>
    6b79:	48 89 ef             	mov    %rbp,%rdi
    6b7c:	e8 4f b8 ff ff       	callq  23d0 <strcasecmp@plt>
    6b81:	41 89 c0             	mov    %eax,%r8d
		return 1;
    6b84:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    6b89:	45 85 c0             	test   %r8d,%r8d
    6b8c:	74 33                	je     6bc1 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
    6b8e:	48 8d 35 40 35 00 00 	lea    0x3540(%rip),%rsi        # a0d5 <default_cmd+0xe75>
    6b95:	48 89 ef             	mov    %rbp,%rdi
    6b98:	e8 33 b8 ff ff       	callq  23d0 <strcasecmp@plt>
    6b9d:	41 89 c0             	mov    %eax,%r8d
		return 1;
    6ba0:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    6ba5:	45 85 c0             	test   %r8d,%r8d
    6ba8:	74 17                	je     6bc1 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
    6baa:	48 8d 35 c4 35 00 00 	lea    0x35c4(%rip),%rsi        # a175 <default_cmd+0xf15>
    6bb1:	48 89 ef             	mov    %rbp,%rdi
    6bb4:	e8 17 b8 ff ff       	callq  23d0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
    6bb9:	85 c0                	test   %eax,%eax
    6bbb:	0f 94 c0             	sete   %al
    6bbe:	0f b6 c0             	movzbl %al,%eax
}
    6bc1:	5d                   	pop    %rbp
    6bc2:	c3                   	retq   

0000000000006bc3 <cmd_read_option_value>:
{
    6bc3:	f3 0f 1e fa          	endbr64 
    6bc7:	41 54                	push   %r12
    6bc9:	49 89 fc             	mov    %rdi,%r12
    6bcc:	55                   	push   %rbp
    6bcd:	48 89 cd             	mov    %rcx,%rbp
    6bd0:	53                   	push   %rbx
    6bd1:	48 89 f3             	mov    %rsi,%rbx
    6bd4:	48 83 ec 10          	sub    $0x10,%rsp
    6bd8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6bdf:	00 00 
    6be1:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    6be6:	31 c0                	xor    %eax,%eax
	char *endptr = NULL;
    6be8:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    6bef:	00 
	switch (type) {
    6bf0:	80 fa 64             	cmp    $0x64,%dl
    6bf3:	0f 84 11 01 00 00    	je     6d0a <cmd_read_option_value+0x147>
    6bf9:	7f 26                	jg     6c21 <cmd_read_option_value+0x5e>
    6bfb:	80 fa 55             	cmp    $0x55,%dl
    6bfe:	0f 84 f1 00 00 00    	je     6cf5 <cmd_read_option_value+0x132>
    6c04:	80 fa 62             	cmp    $0x62,%dl
    6c07:	74 42                	je     6c4b <cmd_read_option_value+0x88>
    6c09:	80 fa 49             	cmp    $0x49,%dl
    6c0c:	0f 85 06 01 00 00    	jne    6d18 <cmd_read_option_value+0x155>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    6c12:	48 89 e6             	mov    %rsp,%rsi
    6c15:	31 d2                	xor    %edx,%edx
    6c17:	e8 34 b9 ff ff       	callq  2550 <strtoll@plt>
    6c1c:	e9 e4 00 00 00       	jmpq   6d05 <cmd_read_option_value+0x142>
	switch (type) {
    6c21:	80 fa 73             	cmp    $0x73,%dl
    6c24:	0f 84 aa 00 00 00    	je     6cd4 <cmd_read_option_value+0x111>
    6c2a:	80 fa 75             	cmp    $0x75,%dl
    6c2d:	0f 84 b6 00 00 00    	je     6ce9 <cmd_read_option_value+0x126>
    6c33:	80 fa 69             	cmp    $0x69,%dl
    6c36:	0f 85 dc 00 00 00    	jne    6d18 <cmd_read_option_value+0x155>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    6c3c:	48 89 e6             	mov    %rsp,%rsi
    6c3f:	31 d2                	xor    %edx,%edx
    6c41:	e8 4a b9 ff ff       	callq  2590 <strtol@plt>
    6c46:	e9 b6 00 00 00       	jmpq   6d01 <cmd_read_option_value+0x13e>
		if (strcasecmp(str, "false") == 0) {
    6c4b:	48 8d 35 85 34 00 00 	lea    0x3485(%rip),%rsi        # a0d7 <default_cmd+0xe77>
    6c52:	e8 79 b7 ff ff       	callq  23d0 <strcasecmp@plt>
    6c57:	85 c0                	test   %eax,%eax
    6c59:	75 0a                	jne    6c65 <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
    6c5b:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 5;
    6c5e:	49 8d 44 24 05       	lea    0x5(%r12),%rax
    6c63:	eb 1b                	jmp    6c80 <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "0") == 0) {
    6c65:	48 8d 35 59 39 00 00 	lea    0x3959(%rip),%rsi        # a5c5 <default_cmd+0x1365>
    6c6c:	4c 89 e7             	mov    %r12,%rdi
    6c6f:	e8 cc b8 ff ff       	callq  2540 <strcmp@plt>
    6c74:	85 c0                	test   %eax,%eax
    6c76:	75 11                	jne    6c89 <cmd_read_option_value+0xc6>
			*(bool *)dest = false;
    6c78:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 1;
    6c7b:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    6c80:	48 89 04 24          	mov    %rax,(%rsp)
	if (!error && endptr && *endptr != 0) {
    6c84:	e9 a0 00 00 00       	jmpq   6d29 <cmd_read_option_value+0x166>
		} else if (strcasecmp(str, "true") == 0) {
    6c89:	48 8d 35 4d 34 00 00 	lea    0x344d(%rip),%rsi        # a0dd <default_cmd+0xe7d>
    6c90:	4c 89 e7             	mov    %r12,%rdi
    6c93:	e8 38 b7 ff ff       	callq  23d0 <strcasecmp@plt>
    6c98:	85 c0                	test   %eax,%eax
    6c9a:	75 0a                	jne    6ca6 <cmd_read_option_value+0xe3>
			*(bool *)dest = true;
    6c9c:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 4;
    6c9f:	49 8d 44 24 04       	lea    0x4(%r12),%rax
    6ca4:	eb da                	jmp    6c80 <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "1") == 0) {
    6ca6:	48 8d 35 35 34 00 00 	lea    0x3435(%rip),%rsi        # a0e2 <default_cmd+0xe82>
    6cad:	4c 89 e7             	mov    %r12,%rdi
    6cb0:	e8 8b b8 ff ff       	callq  2540 <strcmp@plt>
    6cb5:	85 c0                	test   %eax,%eax
    6cb7:	74 16                	je     6ccf <cmd_read_option_value+0x10c>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    6cb9:	4c 89 e2             	mov    %r12,%rdx
    6cbc:	48 89 ee             	mov    %rbp,%rsi
    6cbf:	48 8d 3d 1e 34 00 00 	lea    0x341e(%rip),%rdi        # a0e4 <default_cmd+0xe84>
    6cc6:	31 c0                	xor    %eax,%eax
    6cc8:	e8 70 fa ff ff       	callq  673d <posix_print_error_and_exit>
    6ccd:	eb 68                	jmp    6d37 <cmd_read_option_value+0x174>
			*(bool *)dest = true;
    6ccf:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 1;
    6cd2:	eb a7                	jmp    6c7b <cmd_read_option_value+0xb8>
		*(char **)dest = (char *)str;
    6cd4:	48 89 3b             	mov    %rdi,(%rbx)
		endptr = (char *)str + strlen(str);
    6cd7:	31 c0                	xor    %eax,%eax
    6cd9:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6cdd:	f2 ae                	repnz scas %es:(%rdi),%al
    6cdf:	48 f7 d1             	not    %rcx
    6ce2:	49 8d 44 0c ff       	lea    -0x1(%r12,%rcx,1),%rax
    6ce7:	eb 97                	jmp    6c80 <cmd_read_option_value+0xbd>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
    6ce9:	48 89 e6             	mov    %rsp,%rsi
    6cec:	31 d2                	xor    %edx,%edx
    6cee:	e8 2d b9 ff ff       	callq  2620 <strtoul@plt>
    6cf3:	eb 0c                	jmp    6d01 <cmd_read_option_value+0x13e>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
    6cf5:	48 89 e6             	mov    %rsp,%rsi
    6cf8:	31 d2                	xor    %edx,%edx
    6cfa:	e8 21 b8 ff ff       	callq  2520 <strtoull@plt>
    6cff:	eb 04                	jmp    6d05 <cmd_read_option_value+0x142>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    6d01:	89 03                	mov    %eax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    6d03:	eb 24                	jmp    6d29 <cmd_read_option_value+0x166>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    6d05:	48 89 03             	mov    %rax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    6d08:	eb 1f                	jmp    6d29 <cmd_read_option_value+0x166>
		*(double *)dest = strtod(str, &endptr);
    6d0a:	48 89 e6             	mov    %rsp,%rsi
    6d0d:	e8 4e b7 ff ff       	callq  2460 <strtod@plt>
    6d12:	f2 0f 11 03          	movsd  %xmm0,(%rbx)
	if (!error && endptr && *endptr != 0) {
    6d16:	eb 11                	jmp    6d29 <cmd_read_option_value+0x166>
	switch (type) {
    6d18:	0f be f2             	movsbl %dl,%esi
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    6d1b:	48 8d 3d 04 34 00 00 	lea    0x3404(%rip),%rdi        # a126 <default_cmd+0xec6>
    6d22:	31 c0                	xor    %eax,%eax
    6d24:	e8 14 fa ff ff       	callq  673d <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
    6d29:	48 8b 04 24          	mov    (%rsp),%rax
    6d2d:	48 85 c0             	test   %rax,%rax
    6d30:	74 05                	je     6d37 <cmd_read_option_value+0x174>
    6d32:	80 38 00             	cmpb   $0x0,(%rax)
    6d35:	75 82                	jne    6cb9 <cmd_read_option_value+0xf6>
}
    6d37:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    6d3c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    6d43:	00 00 
    6d45:	74 05                	je     6d4c <cmd_read_option_value+0x189>
    6d47:	e8 64 b7 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    6d4c:	48 83 c4 10          	add    $0x10,%rsp
    6d50:	5b                   	pop    %rbx
    6d51:	5d                   	pop    %rbp
    6d52:	41 5c                	pop    %r12
    6d54:	c3                   	retq   

0000000000006d55 <cmd_args_set_defaults>:
{
    6d55:	f3 0f 1e fa          	endbr64 
    6d59:	55                   	push   %rbp
	int count = 0;
    6d5a:	31 ed                	xor    %ebp,%ebp
{
    6d5c:	53                   	push   %rbx
    6d5d:	48 89 fb             	mov    %rdi,%rbx
    6d60:	52                   	push   %rdx
	while (args_struct[count].option != NULL) {
    6d61:	48 63 d5             	movslq %ebp,%rdx
    6d64:	48 6b d2 38          	imul   $0x38,%rdx,%rdx
    6d68:	48 01 da             	add    %rbx,%rdx
    6d6b:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
    6d70:	0f 84 a0 00 00 00    	je     6e16 <cmd_args_set_defaults+0xc1>
		if (args_struct[count].dest == NULL) {
    6d76:	48 8b 42 20          	mov    0x20(%rdx),%rax
    6d7a:	ff c5                	inc    %ebp
    6d7c:	48 85 c0             	test   %rax,%rax
    6d7f:	74 e0                	je     6d61 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    6d81:	0f be 72 18          	movsbl 0x18(%rdx),%esi
    6d85:	40 80 fe 64          	cmp    $0x64,%sil
    6d89:	74 69                	je     6df4 <cmd_args_set_defaults+0x9f>
    6d8b:	7f 2d                	jg     6dba <cmd_args_set_defaults+0x65>
    6d8d:	40 80 fe 55          	cmp    $0x55,%sil
    6d91:	74 55                	je     6de8 <cmd_args_set_defaults+0x93>
    6d93:	7f 1a                	jg     6daf <cmd_args_set_defaults+0x5a>
    6d95:	40 84 f6             	test   %sil,%sil
    6d98:	74 c7                	je     6d61 <cmd_args_set_defaults+0xc>
    6d9a:	40 80 fe 49          	cmp    $0x49,%sil
    6d9e:	75 63                	jne    6e03 <cmd_args_set_defaults+0xae>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
    6da0:	48 b9 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rcx
    6da7:	ff ff 7f 
    6daa:	48 89 08             	mov    %rcx,(%rax)
			break;
    6dad:	eb b2                	jmp    6d61 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    6daf:	40 80 fe 62          	cmp    $0x62,%sil
    6db3:	75 4e                	jne    6e03 <cmd_args_set_defaults+0xae>
			*(bool *)args_struct[count].dest = false;
    6db5:	c6 00 00             	movb   $0x0,(%rax)
			break;
    6db8:	eb a7                	jmp    6d61 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    6dba:	40 80 fe 73          	cmp    $0x73,%sil
    6dbe:	74 14                	je     6dd4 <cmd_args_set_defaults+0x7f>
    6dc0:	40 80 fe 75          	cmp    $0x75,%sil
    6dc4:	74 17                	je     6ddd <cmd_args_set_defaults+0x88>
    6dc6:	40 80 fe 69          	cmp    $0x69,%sil
    6dca:	75 37                	jne    6e03 <cmd_args_set_defaults+0xae>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
    6dcc:	c7 00 ff ff ff 7f    	movl   $0x7fffffff,(%rax)
			break;
    6dd2:	eb 8d                	jmp    6d61 <cmd_args_set_defaults+0xc>
			*(char **)args_struct[count].dest = NULL;
    6dd4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			break;
    6ddb:	eb 84                	jmp    6d61 <cmd_args_set_defaults+0xc>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
    6ddd:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
			break;
    6de3:	e9 79 ff ff ff       	jmpq   6d61 <cmd_args_set_defaults+0xc>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
    6de8:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
			break;
    6def:	e9 6d ff ff ff       	jmpq   6d61 <cmd_args_set_defaults+0xc>
			*(double *)args_struct[count].dest = NAN;
    6df4:	48 8b 0d a5 24 00 00 	mov    0x24a5(%rip),%rcx        # 92a0 <default_cmd+0x40>
    6dfb:	48 89 08             	mov    %rcx,(%rax)
			break;
    6dfe:	e9 5e ff ff ff       	jmpq   6d61 <cmd_args_set_defaults+0xc>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    6e03:	48 8d 3d 1c 33 00 00 	lea    0x331c(%rip),%rdi        # a126 <default_cmd+0xec6>
    6e0a:	31 c0                	xor    %eax,%eax
    6e0c:	e8 2c f9 ff ff       	callq  673d <posix_print_error_and_exit>
			break;
    6e11:	e9 4b ff ff ff       	jmpq   6d61 <cmd_args_set_defaults+0xc>
}
    6e16:	58                   	pop    %rax
    6e17:	5b                   	pop    %rbx
    6e18:	5d                   	pop    %rbp
    6e19:	c3                   	retq   

0000000000006e1a <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    6e1a:	f3 0f 1e fa          	endbr64 
    6e1e:	41 56                	push   %r14
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    6e20:	be 01 00 00 00       	mov    $0x1,%esi
    6e25:	48 8d 0d 1f 33 00 00 	lea    0x331f(%rip),%rcx        # a14b <default_cmd+0xeeb>
    6e2c:	48 8d 15 31 33 00 00 	lea    0x3331(%rip),%rdx        # a164 <default_cmd+0xf04>
    6e33:	41 55                	push   %r13
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    6e35:	41 be 19 00 00 00    	mov    $0x19,%r14d
	int count = 0;
    6e3b:	45 31 ed             	xor    %r13d,%r13d
{
    6e3e:	41 54                	push   %r12
    6e40:	49 89 fc             	mov    %rdi,%r12
    6e43:	55                   	push   %rbp
    6e44:	53                   	push   %rbx
    6e45:	48 83 ec 50          	sub    $0x50,%rsp

	fprintf(stdout, "%s ", _HELP_SWITCH);
    6e49:	48 8b 1d 58 51 00 00 	mov    0x5158(%rip),%rbx        # bfa8 <stdout@GLIBC_2.2.5>
{
    6e50:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6e57:	00 00 
    6e59:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    6e5e:	31 c0                	xor    %eax,%eax

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    6e60:	48 8d 6c 24 02       	lea    0x2(%rsp),%rbp
    6e65:	48 8b 3b             	mov    (%rbx),%rdi
    6e68:	e8 03 b8 ff ff       	callq  2670 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
    6e6d:	49 63 f5             	movslq %r13d,%rsi
    6e70:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    6e74:	4c 01 e6             	add    %r12,%rsi
    6e77:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
    6e7c:	74 6e                	je     6eec <cmd_print_switches_help+0xd2>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    6e7e:	48 89 ef             	mov    %rbp,%rdi
    6e81:	e8 3e fb ff ff       	callq  69c4 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    6e86:	31 c0                	xor    %eax,%eax
    6e88:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6e8c:	48 89 ef             	mov    %rbp,%rdi
    6e8f:	f2 ae                	repnz scas %es:(%rdi),%al
    6e91:	49 63 c6             	movslq %r14d,%rax
    6e94:	48 f7 d1             	not    %rcx
    6e97:	48 8d 44 01 ff       	lea    -0x1(%rcx,%rax,1),%rax
    6e9c:	48 83 f8 64          	cmp    $0x64,%rax
    6ea0:	76 19                	jbe    6ebb <cmd_print_switches_help+0xa1>
    6ea2:	48 8b 3b             	mov    (%rbx),%rdi
    6ea5:	48 8d 15 0c 26 00 00 	lea    0x260c(%rip),%rdx        # 94b8 <default_cmd+0x258>
    6eac:	31 c0                	xor    %eax,%eax
			fprintf(stdout, "\n");
			printed_in_line = 0;
    6eae:	45 31 f6             	xor    %r14d,%r14d
    6eb1:	be 01 00 00 00       	mov    $0x1,%esi
    6eb6:	e8 b5 b7 ff ff       	callq  2670 <__fprintf_chk@plt>
    6ebb:	48 8b 3b             	mov    (%rbx),%rdi
    6ebe:	48 89 e9             	mov    %rbp,%rcx
    6ec1:	48 8d 15 3d 31 00 00 	lea    0x313d(%rip),%rdx        # a005 <default_cmd+0xda5>
    6ec8:	31 c0                	xor    %eax,%eax
    6eca:	be 01 00 00 00       	mov    $0x1,%esi
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
		count++;
    6ecf:	41 ff c5             	inc    %r13d
    6ed2:	e8 99 b7 ff ff       	callq  2670 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
    6ed7:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6edb:	31 c0                	xor    %eax,%eax
    6edd:	48 89 ef             	mov    %rbp,%rdi
    6ee0:	f2 ae                	repnz scas %es:(%rdi),%al
    6ee2:	48 f7 d1             	not    %rcx
    6ee5:	45 8d 74 0e ff       	lea    -0x1(%r14,%rcx,1),%r14d
		count++;
    6eea:	eb 81                	jmp    6e6d <cmd_print_switches_help+0x53>
    6eec:	48 8b 3b             	mov    (%rbx),%rdi
    6eef:	31 c0                	xor    %eax,%eax
    6ef1:	be 01 00 00 00       	mov    $0x1,%esi
    6ef6:	48 8d 15 bb 25 00 00 	lea    0x25bb(%rip),%rdx        # 94b8 <default_cmd+0x258>
    6efd:	e8 6e b7 ff ff       	callq  2670 <__fprintf_chk@plt>
	}

	fprintf(stdout, "\n");
}
    6f02:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    6f07:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    6f0e:	00 00 
    6f10:	74 05                	je     6f17 <cmd_print_switches_help+0xfd>
    6f12:	e8 99 b5 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    6f17:	48 83 c4 50          	add    $0x50,%rsp
    6f1b:	5b                   	pop    %rbx
    6f1c:	5d                   	pop    %rbp
    6f1d:	41 5c                	pop    %r12
    6f1f:	41 5d                	pop    %r13
    6f21:	41 5e                	pop    %r14
    6f23:	c3                   	retq   

0000000000006f24 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    6f24:	f3 0f 1e fa          	endbr64 
    6f28:	41 57                	push   %r15
    6f2a:	4c 8d 3d 88 25 00 00 	lea    0x2588(%rip),%r15        # 94b9 <default_cmd+0x259>
    6f31:	41 56                	push   %r14
    6f33:	41 55                	push   %r13
	int ret;
	int count = 0;
    6f35:	45 31 ed             	xor    %r13d,%r13d
{
    6f38:	41 54                	push   %r12
    6f3a:	49 89 fc             	mov    %rdi,%r12
    6f3d:	55                   	push   %rbp
    6f3e:	53                   	push   %rbx
    6f3f:	48 83 ec 68          	sub    $0x68,%rsp
    6f43:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6f4a:	00 00 
    6f4c:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    6f51:	31 c0                	xor    %eax,%eax
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    6f53:	e8 c2 fe ff ff       	callq  6e1a <cmd_print_switches_help>

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
    6f58:	48 8b 1d 49 50 00 00 	mov    0x5049(%rip),%rbx        # bfa8 <stdout@GLIBC_2.2.5>
    6f5f:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    6f64:	31 c0                	xor    %eax,%eax
    6f66:	4c 8d 0d fb 31 00 00 	lea    0x31fb(%rip),%r9        # a168 <default_cmd+0xf08>
    6f6d:	4c 8d 05 d7 31 00 00 	lea    0x31d7(%rip),%r8        # a14b <default_cmd+0xeeb>
    6f74:	be 01 00 00 00       	mov    $0x1,%esi
    6f79:	48 8b 3b             	mov    (%rbx),%rdi
    6f7c:	48 8d 15 f7 31 00 00 	lea    0x31f7(%rip),%rdx        # a17a <default_cmd+0xf1a>
    6f83:	e8 e8 b6 ff ff       	callq  2670 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    6f88:	49 63 ed             	movslq %r13d,%rbp
    6f8b:	48 6b ed 38          	imul   $0x38,%rbp,%rbp
    6f8f:	4c 01 e5             	add    %r12,%rbp
    6f92:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
    6f97:	0f 84 c8 00 00 00    	je     7065 <cmd_print_long_help+0x141>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    6f9d:	4c 8d 44 24 12       	lea    0x12(%rsp),%r8
    6fa2:	48 89 ee             	mov    %rbp,%rsi
    6fa5:	4c 89 c7             	mov    %r8,%rdi
    6fa8:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    6fad:	e8 12 fa ff ff       	callq  69c4 <cmd_gen_switch_syntax.constprop.0>
    6fb2:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    6fb7:	48 8b 3b             	mov    (%rbx),%rdi
    6fba:	31 c0                	xor    %eax,%eax
    6fbc:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    6fc1:	48 8d 15 bd 31 00 00 	lea    0x31bd(%rip),%rdx        # a185 <default_cmd+0xf25>
    6fc8:	be 01 00 00 00       	mov    $0x1,%esi
    6fcd:	e8 9e b6 ff ff       	callq  2670 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    6fd2:	4c 8b 75 30          	mov    0x30(%rbp),%r14
		total_to_print = strlen(toprint);
    6fd6:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6fda:	48 8d 15 ab 31 00 00 	lea    0x31ab(%rip),%rdx        # a18c <default_cmd+0xf2c>
    6fe1:	41 89 c0             	mov    %eax,%r8d
    6fe4:	31 c0                	xor    %eax,%eax
    6fe6:	be 01 00 00 00       	mov    $0x1,%esi
    6feb:	4c 89 f7             	mov    %r14,%rdi
    6fee:	f2 ae                	repnz scas %es:(%rdi),%al
    6ff0:	48 8b 3b             	mov    (%rbx),%rdi
    6ff3:	48 f7 d1             	not    %rcx
    6ff6:	8d 41 ff             	lea    -0x1(%rcx),%eax
		ret = fprintf(stdout, "%.*s\n",
    6ff9:	b9 64 00 00 00       	mov    $0x64,%ecx
		total_to_print = strlen(toprint);
    6ffe:	89 44 24 08          	mov    %eax,0x8(%rsp)
		ret = fprintf(stdout, "%.*s\n",
    7002:	44 29 c1             	sub    %r8d,%ecx
    7005:	31 c0                	xor    %eax,%eax
    7007:	4d 89 f0             	mov    %r14,%r8
    700a:	e8 61 b6 ff ff       	callq  2670 <__fprintf_chk@plt>
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    700f:	8d 68 ff             	lea    -0x1(%rax),%ebp

		while (printed_right < total_to_print) {
    7012:	3b 6c 24 08          	cmp    0x8(%rsp),%ebp
    7016:	7d 45                	jge    705d <cmd_print_long_help+0x139>
    7018:	48 8b 3b             	mov    (%rbx),%rdi
    701b:	4d 89 f8             	mov    %r15,%r8
    701e:	b9 1e 00 00 00       	mov    $0x1e,%ecx
    7023:	be 01 00 00 00       	mov    $0x1,%esi
    7028:	48 8d 15 63 31 00 00 	lea    0x3163(%rip),%rdx        # a192 <default_cmd+0xf32>
    702f:	31 c0                	xor    %eax,%eax
    7031:	e8 3a b6 ff ff       	callq  2670 <__fprintf_chk@plt>
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    7036:	4c 63 c5             	movslq %ebp,%r8
    7039:	48 8b 3b             	mov    (%rbx),%rdi
    703c:	b9 46 00 00 00       	mov    $0x46,%ecx
    7041:	4d 01 f0             	add    %r14,%r8
    7044:	48 8d 15 41 31 00 00 	lea    0x3141(%rip),%rdx        # a18c <default_cmd+0xf2c>
    704b:	be 01 00 00 00       	mov    $0x1,%esi
    7050:	31 c0                	xor    %eax,%eax
    7052:	e8 19 b6 ff ff       	callq  2670 <__fprintf_chk@plt>
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    7057:	8d 6c 05 ff          	lea    -0x1(%rbp,%rax,1),%ebp
    705b:	eb b5                	jmp    7012 <cmd_print_long_help+0xee>
		}
		count++;
    705d:	41 ff c5             	inc    %r13d
    7060:	e9 23 ff ff ff       	jmpq   6f88 <cmd_print_long_help+0x64>
    7065:	48 8b 3b             	mov    (%rbx),%rdi
    7068:	48 8d 15 49 24 00 00 	lea    0x2449(%rip),%rdx        # 94b8 <default_cmd+0x258>
    706f:	be 01 00 00 00       	mov    $0x1,%esi
    7074:	31 c0                	xor    %eax,%eax
    7076:	e8 f5 b5 ff ff       	callq  2670 <__fprintf_chk@plt>
    707b:	48 8b 3b             	mov    (%rbx),%rdi
    707e:	31 c0                	xor    %eax,%eax
    7080:	be 01 00 00 00       	mov    $0x1,%esi
    7085:	48 8d 15 0a 31 00 00 	lea    0x310a(%rip),%rdx        # a196 <default_cmd+0xf36>
    708c:	e8 df b5 ff ff       	callq  2670 <__fprintf_chk@plt>
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    7091:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    7096:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    709d:	00 00 
    709f:	74 05                	je     70a6 <cmd_print_long_help+0x182>
    70a1:	e8 0a b4 ff ff       	callq  24b0 <__stack_chk_fail@plt>
    70a6:	48 83 c4 68          	add    $0x68,%rsp
    70aa:	5b                   	pop    %rbx
    70ab:	5d                   	pop    %rbp
    70ac:	41 5c                	pop    %r12
    70ae:	41 5d                	pop    %r13
    70b0:	41 5e                	pop    %r14
    70b2:	41 5f                	pop    %r15
    70b4:	c3                   	retq   

00000000000070b5 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    70b5:	f3 0f 1e fa          	endbr64 
    70b9:	41 56                	push   %r14
    70bb:	41 55                	push   %r13
    70bd:	49 89 f5             	mov    %rsi,%r13
    70c0:	41 54                	push   %r12
    70c2:	55                   	push   %rbp
    70c3:	48 89 fd             	mov    %rdi,%rbp
    70c6:	53                   	push   %rbx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    70c7:	e8 8a fa ff ff       	callq  6b56 <cmd_is_help_option>
    70cc:	85 c0                	test   %eax,%eax
    70ce:	74 0f                	je     70df <cmd_parse_one_arg+0x2a>
		cmd_print_long_help(args_struct);
    70d0:	4c 89 ef             	mov    %r13,%rdi
    70d3:	e8 4c fe ff ff       	callq  6f24 <cmd_print_long_help>
		posix_exit(0);
    70d8:	31 ff                	xor    %edi,%edi
    70da:	e8 62 f5 ff ff       	callq  6641 <posix_exit>
{
    70df:	45 31 f6             	xor    %r14d,%r14d
	}

	while (args_struct[count].option != NULL) {
    70e2:	49 63 de             	movslq %r14d,%rbx
    70e5:	48 6b db 38          	imul   $0x38,%rbx,%rbx
    70e9:	4c 01 eb             	add    %r13,%rbx
    70ec:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    70f0:	48 85 f6             	test   %rsi,%rsi
    70f3:	74 78                	je     716d <cmd_parse_one_arg+0xb8>
		if (args_struct[count].manual) {
    70f5:	80 3b 00             	cmpb   $0x0,(%rbx)
    70f8:	75 6b                	jne    7165 <cmd_parse_one_arg+0xb0>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
				    !args_struct[count].is_switch);
    70fa:	8a 53 02             	mov    0x2(%rbx),%dl
		ret = cmd_is_option(argv, args_struct[count].option,
    70fd:	48 89 ef             	mov    %rbp,%rdi
				    !args_struct[count].is_switch);
    7100:	83 f2 01             	xor    $0x1,%edx
		ret = cmd_is_option(argv, args_struct[count].option,
    7103:	0f b6 d2             	movzbl %dl,%edx
    7106:	e8 9d f9 ff ff       	callq  6aa8 <cmd_is_option>
    710b:	41 89 c4             	mov    %eax,%r12d
		if (ret) {
    710e:	85 c0                	test   %eax,%eax
    7110:	74 53                	je     7165 <cmd_parse_one_arg+0xb0>
	if (arg_element->dest != NULL) {
    7112:	48 8b 73 20          	mov    0x20(%rbx),%rsi
    7116:	48 85 f6             	test   %rsi,%rsi
    7119:	74 33                	je     714e <cmd_parse_one_arg+0x99>
		if (arg_element->is_switch) {
    711b:	80 7b 02 00          	cmpb   $0x0,0x2(%rbx)
    711f:	0f be 53 18          	movsbl 0x18(%rbx),%edx
    7123:	74 1a                	je     713f <cmd_parse_one_arg+0x8a>
			if (arg_element->type == 'b') {
    7125:	80 fa 62             	cmp    $0x62,%dl
    7128:	75 05                	jne    712f <cmd_parse_one_arg+0x7a>
				*(bool *)arg_element->dest = true;
    712a:	c6 06 01             	movb   $0x1,(%rsi)
    712d:	eb 1f                	jmp    714e <cmd_parse_one_arg+0x99>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    712f:	48 8d 3d b0 30 00 00 	lea    0x30b0(%rip),%rdi        # a1e6 <default_cmd+0xf86>
    7136:	31 c0                	xor    %eax,%eax
    7138:	e8 00 f6 ff ff       	callq  673d <posix_print_error_and_exit>
    713d:	eb 0f                	jmp    714e <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
    713f:	48 63 f8             	movslq %eax,%rdi
    7142:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    7146:	48 01 ef             	add    %rbp,%rdi
    7149:	e8 75 fa ff ff       	callq  6bc3 <cmd_read_option_value>
	if (arg_element->call_when_found) {
    714e:	48 8b 53 28          	mov    0x28(%rbx),%rdx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    7152:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
    7154:	48 85 d2             	test   %rdx,%rdx
    7157:	74 16                	je     716f <cmd_parse_one_arg+0xba>
		arg_element->call_when_found(argv, offset);
    7159:	44 89 e6             	mov    %r12d,%esi
    715c:	48 89 ef             	mov    %rbp,%rdi
    715f:	ff d2                	callq  *%rdx
			return true;
    7161:	b0 01                	mov    $0x1,%al
    7163:	eb 0a                	jmp    716f <cmd_parse_one_arg+0xba>
    7165:	41 ff c6             	inc    %r14d
    7168:	e9 75 ff ff ff       	jmpq   70e2 <cmd_parse_one_arg+0x2d>
		}
		count++;
	}
	return false;
    716d:	31 c0                	xor    %eax,%eax
}
    716f:	5b                   	pop    %rbx
    7170:	5d                   	pop    %rbp
    7171:	41 5c                	pop    %r12
    7173:	41 5d                	pop    %r13
    7175:	41 5e                	pop    %r14
    7177:	c3                   	retq   

0000000000007178 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
    7178:	f3 0f 1e fa          	endbr64 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    717c:	48 8b 3d 8d 83 00 00 	mov    0x838d(%rip),%rdi        # f510 <args_struct>
    7183:	48 85 ff             	test   %rdi,%rdi
    7186:	74 13                	je     719b <native_cleanup_cmd_line+0x23>
{
    7188:	50                   	push   %rax
		free(args_struct);
    7189:	e8 22 b2 ff ff       	callq  23b0 <free@plt>
		args_struct = NULL;
    718e:	48 c7 05 77 83 00 00 	movq   $0x0,0x8377(%rip)        # f510 <args_struct>
    7195:	00 00 00 00 
	}
}
    7199:	5a                   	pop    %rdx
    719a:	c3                   	retq   
    719b:	c3                   	retq   

000000000000719c <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    719c:	f3 0f 1e fa          	endbr64 
    71a0:	41 54                	push   %r12
    71a2:	55                   	push   %rbp
    71a3:	48 89 fd             	mov    %rdi,%rbp
    71a6:	53                   	push   %rbx
	int count = 0;
    71a7:	31 db                	xor    %ebx,%ebx

	while (args[count].option != NULL) {
    71a9:	48 63 c3             	movslq %ebx,%rax
    71ac:	ff c3                	inc    %ebx
    71ae:	48 6b c0 38          	imul   $0x38,%rax,%rax
    71b2:	48 83 7c 05 08 00    	cmpq   $0x0,0x8(%rbp,%rax,1)
    71b8:	75 ef                	jne    71a9 <native_add_command_line_opts+0xd>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    71ba:	8b 15 cc 83 00 00    	mov    0x83cc(%rip),%edx        # f58c <used_args>
    71c0:	8b 05 c2 83 00 00    	mov    0x83c2(%rip),%eax        # f588 <args_aval>
    71c6:	01 da                	add    %ebx,%edx
    71c8:	39 c2                	cmp    %eax,%edx
    71ca:	7c 44                	jl     7210 <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    71cc:	83 fb 14             	cmp    $0x14,%ebx
    71cf:	41 bc 14 00 00 00    	mov    $0x14,%r12d
		struct args_struct_t *new_args_struct = realloc(args_struct,
    71d5:	48 8b 3d 34 83 00 00 	mov    0x8334(%rip),%rdi        # f510 <args_struct>
				      (args_aval + growby)*
    71dc:	44 0f 4d e3          	cmovge %ebx,%r12d
    71e0:	41 01 c4             	add    %eax,%r12d
    71e3:	49 63 f4             	movslq %r12d,%rsi
		struct args_struct_t *new_args_struct = realloc(args_struct,
    71e6:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    71ea:	e8 e1 b3 ff ff       	callq  25d0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
    71ef:	44 89 25 92 83 00 00 	mov    %r12d,0x8392(%rip)        # f588 <args_aval>
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    71f6:	48 85 c0             	test   %rax,%rax
    71f9:	75 0e                	jne    7209 <native_add_command_line_opts+0x6d>
			posix_print_error_and_exit("Could not allocate memory");
    71fb:	48 8d 3d 2f 30 00 00 	lea    0x302f(%rip),%rdi        # a231 <default_cmd+0xfd1>
    7202:	e8 36 f5 ff ff       	callq  673d <posix_print_error_and_exit>
    7207:	eb 07                	jmp    7210 <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
    7209:	48 89 05 00 83 00 00 	mov    %rax,0x8300(%rip)        # f510 <args_struct>
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    7210:	48 63 05 75 83 00 00 	movslq 0x8375(%rip),%rax        # f58c <used_args>
    7217:	48 63 cb             	movslq %ebx,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    721a:	48 89 ee             	mov    %rbp,%rsi
    721d:	48 6b c9 38          	imul   $0x38,%rcx,%rcx
    7221:	48 89 c2             	mov    %rax,%rdx
    7224:	48 6b c0 38          	imul   $0x38,%rax,%rax
    7228:	48 03 05 e1 82 00 00 	add    0x82e1(%rip),%rax        # f510 <args_struct>
    722f:	48 89 c7             	mov    %rax,%rdi
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    7232:	8d 44 1a ff          	lea    -0x1(%rdx,%rbx,1),%eax
    7236:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    7238:	89 05 4e 83 00 00    	mov    %eax,0x834e(%rip)        # f58c <used_args>
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    723e:	5b                   	pop    %rbx
    723f:	5d                   	pop    %rbp
    7240:	41 5c                	pop    %r12
    7242:	c3                   	retq   

0000000000007243 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
    7243:	f3 0f 1e fa          	endbr64 
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    7247:	48 8d 3d 52 50 00 00 	lea    0x5052(%rip),%rdi        # c2a0 <testargs_options.2552>
    724e:	e9 49 ff ff ff       	jmpq   719c <native_add_command_line_opts>

0000000000007253 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    7253:	f3 0f 1e fa          	endbr64 
    7257:	41 57                	push   %r15

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    7259:	4c 8d 3d eb 2f 00 00 	lea    0x2feb(%rip),%r15        # a24b <default_cmd+0xfeb>
{
    7260:	41 56                	push   %r14
    7262:	41 55                	push   %r13
    7264:	41 54                	push   %r12
    7266:	49 89 f4             	mov    %rsi,%r12
    7269:	55                   	push   %rbp
	for (i = 1; i < argc; i++) {
    726a:	bd 01 00 00 00       	mov    $0x1,%ebp
{
    726f:	53                   	push   %rbx
    7270:	89 fb                	mov    %edi,%ebx
    7272:	52                   	push   %rdx
	native_add_tracing_options();
    7273:	e8 3c f7 ff ff       	callq  69b4 <native_add_tracing_options>
	native_add_testargs_option();
    7278:	e8 c6 ff ff ff       	callq  7243 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
    727d:	48 8b 3d 8c 82 00 00 	mov    0x828c(%rip),%rdi        # f510 <args_struct>
	s_argv = argv;
    7284:	4c 89 25 95 82 00 00 	mov    %r12,0x8295(%rip)        # f520 <s_argv>
	s_argc = argc;
    728b:	89 1d 03 83 00 00    	mov    %ebx,0x8303(%rip)        # f594 <s_argc>
	cmd_args_set_defaults(args_struct);
    7291:	e8 bf fa ff ff       	callq  6d55 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
    7296:	41 89 ee             	mov    %ebp,%r14d
    7299:	39 eb                	cmp    %ebp,%ebx
    729b:	7e 65                	jle    7302 <native_handle_cmd_line+0xaf>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
    729d:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    72a1:	31 d2                	xor    %edx,%edx
    72a3:	4c 89 fe             	mov    %r15,%rsi
    72a6:	4c 8d 6d 01          	lea    0x1(%rbp),%r13
    72aa:	e8 f9 f7 ff ff       	callq  6aa8 <cmd_is_option>
    72af:	85 c0                	test   %eax,%eax
    72b1:	74 18                	je     72cb <native_handle_cmd_line+0x78>
			test_argc = argc - i - 1;
    72b3:	ff cb                	dec    %ebx
			test_argv = &argv[i+1];
    72b5:	4b 8d 04 ec          	lea    (%r12,%r13,8),%rax
			test_argc = argc - i - 1;
    72b9:	44 29 f3             	sub    %r14d,%ebx
			test_argv = &argv[i+1];
    72bc:	48 89 05 55 82 00 00 	mov    %rax,0x8255(%rip)        # f518 <test_argv>
			test_argc = argc - i - 1;
    72c3:	89 1d c7 82 00 00    	mov    %ebx,0x82c7(%rip)        # f590 <test_argc>
			break;
    72c9:	eb 37                	jmp    7302 <native_handle_cmd_line+0xaf>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    72cb:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    72cf:	48 8b 35 3a 82 00 00 	mov    0x823a(%rip),%rsi        # f510 <args_struct>
    72d6:	e8 da fd ff ff       	callq  70b5 <cmd_parse_one_arg>
    72db:	84 c0                	test   %al,%al
    72dd:	75 1e                	jne    72fd <native_handle_cmd_line+0xaa>
			cmd_print_switches_help(args_struct);
    72df:	48 8b 3d 2a 82 00 00 	mov    0x822a(%rip),%rdi        # f510 <args_struct>
    72e6:	e8 2f fb ff ff       	callq  6e1a <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    72eb:	49 8b 34 ec          	mov    (%r12,%rbp,8),%rsi
    72ef:	48 8d 3d 5e 2f 00 00 	lea    0x2f5e(%rip),%rdi        # a254 <default_cmd+0xff4>
    72f6:	31 c0                	xor    %eax,%eax
    72f8:	e8 40 f4 ff ff       	callq  673d <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
    72fd:	4c 89 ed             	mov    %r13,%rbp
    7300:	eb 94                	jmp    7296 <native_handle_cmd_line+0x43>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    7302:	58                   	pop    %rax
    7303:	5b                   	pop    %rbx
    7304:	5d                   	pop    %rbp
    7305:	41 5c                	pop    %r12
    7307:	41 5d                	pop    %r13
    7309:	41 5e                	pop    %r14
    730b:	41 5f                	pop    %r15
    730d:	c3                   	retq   

000000000000730e <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
    730e:	f3 0f 1e fa          	endbr64 
	hw_counter_timer = NEVER;
    7312:	48 8d 05 27 82 00 00 	lea    0x8227(%rip),%rax        # f540 <hw_counter_timer>
	counter_target = NEVER;
	counter_value = 0;
	counter_running = false;
    7319:	c6 05 94 82 00 00 00 	movb   $0x0,0x8294(%rip)        # f5b4 <counter_running>
	counter_target = NEVER;
    7320:	48 c7 05 05 82 00 00 	movq   $0xffffffffffffffff,0x8205(%rip)        # f530 <counter_target>
    7327:	ff ff ff ff 
	hw_counter_timer = NEVER;
    732b:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	counter_value = 0;
    7332:	48 c7 05 fb 81 00 00 	movq   $0x0,0x81fb(%rip)        # f538 <counter_value>
    7339:	00 00 00 00 
	counter_period = NEVER;
    733d:	48 c7 05 e0 81 00 00 	movq   $0xffffffffffffffff,0x81e0(%rip)        # f528 <counter_period>
    7344:	ff ff ff ff 
}
    7348:	c3                   	retq   

0000000000007349 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
    7349:	f3 0f 1e fa          	endbr64 
	if (!counter_running) {
    734d:	80 3d 60 82 00 00 00 	cmpb   $0x0,0x8260(%rip)        # f5b4 <counter_running>
{
    7354:	53                   	push   %rbx
    7355:	48 8d 1d e4 81 00 00 	lea    0x81e4(%rip),%rbx        # f540 <hw_counter_timer>
	if (!counter_running) {
    735c:	75 09                	jne    7367 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
    735e:	48 c7 03 ff ff ff ff 	movq   $0xffffffffffffffff,(%rbx)
		return;
    7365:	eb 34                	jmp    739b <hw_counter_triggered+0x52>
	}

	hw_counter_timer = hwm_get_time() + counter_period;
    7367:	e8 da e9 ff ff       	callq  5d46 <hwm_get_time>
    736c:	48 03 05 b5 81 00 00 	add    0x81b5(%rip),%rax        # f528 <counter_period>
    7373:	48 89 03             	mov    %rax,(%rbx)
	counter_value = counter_value + 1;
    7376:	48 8b 05 bb 81 00 00 	mov    0x81bb(%rip),%rax        # f538 <counter_value>
    737d:	48 ff c0             	inc    %rax

	if (counter_value == counter_target) {
    7380:	48 3b 05 a9 81 00 00 	cmp    0x81a9(%rip),%rax        # f530 <counter_target>
	counter_value = counter_value + 1;
    7387:	48 89 05 aa 81 00 00 	mov    %rax,0x81aa(%rip)        # f538 <counter_value>
	if (counter_value == counter_target) {
    738e:	75 0b                	jne    739b <hw_counter_triggered+0x52>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    7390:	bf 02 00 00 00       	mov    $0x2,%edi
	}
}
    7395:	5b                   	pop    %rbx
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    7396:	e9 19 f2 ff ff       	jmpq   65b4 <hw_irq_ctrl_set_irq>
}
    739b:	5b                   	pop    %rbx
    739c:	c3                   	retq   

000000000000739d <tc_query_caps>:

	return 0;
}

static int tc_query_caps(const struct device *dev)
{
    739d:	f3 0f 1e fa          	endbr64 
	return (CAP_RAW_KEY | CAP_SEPARATE_IO_BUFS | CAP_SYNC_OPS);
}
    73a1:	b8 32 00 00 00       	mov    $0x32,%eax
    73a6:	c3                   	retq   

00000000000073a7 <tc_shim_init>:

	return 0;
}

static int tc_shim_init(const struct device *dev)
{
    73a7:	f3 0f 1e fa          	endbr64 
	int i;

	ARG_UNUSED(dev);
	for (i = 0; i < CRYPTO_MAX_SESSION; i++) {
		tc_driver_state[i].in_use = 0;
    73ab:	c7 05 ab 7d 00 00 00 	movl   $0x0,0x7dab(%rip)        # f160 <tc_driver_state>
    73b2:	00 00 00 
	}

	return 0;
}
    73b5:	31 c0                	xor    %eax,%eax
		tc_driver_state[i].in_use = 0;
    73b7:	c7 05 53 7e 00 00 00 	movl   $0x0,0x7e53(%rip)        # f214 <tc_driver_state+0xb4>
    73be:	00 00 00 
}
    73c1:	c3                   	retq   

00000000000073c2 <tc_session_free>:
{
    73c2:	f3 0f 1e fa          	endbr64 
	struct tc_shim_drv_state *data =  sessn->drv_sessn_state;
    73c6:	48 8b 56 20          	mov    0x20(%rsi),%rdx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    73ca:	31 c0                	xor    %eax,%eax
    73cc:	b9 2d 00 00 00       	mov    $0x2d,%ecx
    73d1:	48 89 d7             	mov    %rdx,%rdi
    73d4:	f3 ab                	rep stos %eax,%es:(%rdi)
}
    73d6:	c3                   	retq   

00000000000073d7 <tc_session_setup>:
{
    73d7:	f3 0f 1e fa          	endbr64 
	if (algo != CRYPTO_CIPHER_ALGO_AES) {
    73db:	ff ca                	dec    %edx
		return -EINVAL;
    73dd:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (algo != CRYPTO_CIPHER_ALGO_AES) {
    73e2:	0f 85 fb 00 00 00    	jne    74e3 <tc_session_setup+0x10c>
{
    73e8:	55                   	push   %rbp
    73e9:	53                   	push   %rbx
    73ea:	48 89 f3             	mov    %rsi,%rbx
    73ed:	57                   	push   %rdi
	if (!(ctx->flags & CAP_SYNC_OPS)) {
    73ee:	f6 46 36 20          	testb  $0x20,0x36(%rsi)
    73f2:	0f 84 e7 00 00 00    	je     74df <tc_session_setup+0x108>
	if (ctx->keylen != TC_AES_KEY_SIZE) {
    73f8:	66 83 7e 34 10       	cmpw   $0x10,0x34(%rsi)
    73fd:	0f 85 dc 00 00 00    	jne    74df <tc_session_setup+0x108>
	if (op_type == CRYPTO_CIPHER_OP_ENCRYPT) {
    7403:	41 ff c8             	dec    %r8d
    7406:	75 1c                	jne    7424 <tc_session_setup+0x4d>
		switch (mode) {
    7408:	83 f9 03             	cmp    $0x3,%ecx
    740b:	74 1c                	je     7429 <tc_session_setup+0x52>
    740d:	83 f9 04             	cmp    $0x4,%ecx
    7410:	74 2f                	je     7441 <tc_session_setup+0x6a>
    7412:	83 f9 02             	cmp    $0x2,%ecx
    7415:	0f 85 c4 00 00 00    	jne    74df <tc_session_setup+0x108>
			ctx->ops.cbc_crypt_hndlr = do_cbc_encrypt;
    741b:	48 8d 05 0e 03 00 00 	lea    0x30e(%rip),%rax        # 7730 <do_cbc_encrypt>
    7422:	eb 49                	jmp    746d <tc_session_setup+0x96>
		switch (mode) {
    7424:	83 f9 03             	cmp    $0x3,%ecx
    7427:	75 21                	jne    744a <tc_session_setup+0x73>
			if (ctx->mode_params.ctr_info.ctr_len != 32U) {
    7429:	83 7b 30 20          	cmpl   $0x20,0x30(%rbx)
		return -EINVAL;
    742d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			if (ctx->mode_params.ctr_info.ctr_len != 32U) {
    7432:	0f 85 a7 00 00 00    	jne    74df <tc_session_setup+0x108>
			ctx->ops.ctr_crypt_hndlr = do_ctr_op;
    7438:	48 8d 05 5a 02 00 00 	lea    0x25a(%rip),%rax        # 7699 <do_ctr_op>
    743f:	eb 2c                	jmp    746d <tc_session_setup+0x96>
			ctx->ops.ccm_crypt_hndlr = do_ccm_encrypt_mac;
    7441:	48 8d 05 a1 01 00 00 	lea    0x1a1(%rip),%rax        # 75e9 <do_ccm_encrypt_mac>
    7448:	eb 23                	jmp    746d <tc_session_setup+0x96>
		switch (mode) {
    744a:	83 f9 04             	cmp    $0x4,%ecx
    744d:	74 17                	je     7466 <tc_session_setup+0x8f>
    744f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    7454:	83 f9 02             	cmp    $0x2,%ecx
    7457:	0f 85 82 00 00 00    	jne    74df <tc_session_setup+0x108>
			ctx->ops.cbc_crypt_hndlr = do_cbc_decrypt;
    745d:	48 8d 05 3c 01 00 00 	lea    0x13c(%rip),%rax        # 75a0 <do_cbc_decrypt>
    7464:	eb 07                	jmp    746d <tc_session_setup+0x96>
			ctx->ops.ccm_crypt_hndlr = do_ccm_decrypt_auth;
    7466:	48 8d 05 77 00 00 00 	lea    0x77(%rip),%rax        # 74e4 <do_ccm_decrypt_auth>
    746d:	48 89 43 08          	mov    %rax,0x8(%rbx)
		if (tc_driver_state[i].in_use == 0) {
    7471:	48 63 05 e8 7c 00 00 	movslq 0x7ce8(%rip),%rax        # f160 <tc_driver_state>
	ctx->ops.cipher_mode = mode;
    7478:	89 0b                	mov    %ecx,(%rbx)
		if (tc_driver_state[i].in_use == 0) {
    747a:	85 c0                	test   %eax,%eax
    747c:	74 1f                	je     749d <tc_session_setup+0xc6>
    747e:	83 3d 8f 7d 00 00 00 	cmpl   $0x0,0x7d8f(%rip)        # f214 <tc_driver_state+0xb4>
		return -ENOSPC;
    7485:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
		if (tc_driver_state[i].in_use == 0) {
    748a:	75 53                	jne    74df <tc_session_setup+0x108>
			tc_driver_state[i].in_use = 1;
    748c:	c7 05 7e 7d 00 00 01 	movl   $0x1,0x7d7e(%rip)        # f214 <tc_driver_state+0xb4>
    7493:	00 00 00 
	for (i = 0; i < CRYPTO_MAX_SESSION; i++) {
    7496:	b8 01 00 00 00       	mov    $0x1,%eax
    749b:	eb 0a                	jmp    74a7 <tc_session_setup+0xd0>
			tc_driver_state[i].in_use = 1;
    749d:	c7 05 b9 7c 00 00 01 	movl   $0x1,0x7cb9(%rip)        # f160 <tc_driver_state>
    74a4:	00 00 00 
	data = &tc_driver_state[idx];
    74a7:	48 69 c0 b4 00 00 00 	imul   $0xb4,%rax,%rax
    74ae:	48 8d 15 ab 7c 00 00 	lea    0x7cab(%rip),%rdx        # f160 <tc_driver_state>
	if (tc_aes128_set_encrypt_key(&data->session_key, ctx->key.bit_stream)
    74b5:	48 8b 73 10          	mov    0x10(%rbx),%rsi
    74b9:	48 8d 7c 02 04       	lea    0x4(%rdx,%rax,1),%rdi
	data = &tc_driver_state[idx];
    74be:	48 8d 2c 10          	lea    (%rax,%rdx,1),%rbp
	if (tc_aes128_set_encrypt_key(&data->session_key, ctx->key.bit_stream)
    74c2:	e8 48 d3 ff ff       	callq  480f <tc_aes128_set_encrypt_key>
    74c7:	85 c0                	test   %eax,%eax
    74c9:	75 0e                	jne    74d9 <tc_session_setup+0x102>
		tc_driver_state[idx].in_use = 0;
    74cb:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%rbp)
		return -EIO;
    74d2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    74d7:	eb 06                	jmp    74df <tc_session_setup+0x108>
	ctx->drv_sessn_state = data;
    74d9:	48 89 6b 20          	mov    %rbp,0x20(%rbx)
	return 0;
    74dd:	31 c0                	xor    %eax,%eax
}
    74df:	5a                   	pop    %rdx
    74e0:	5b                   	pop    %rbx
    74e1:	5d                   	pop    %rbp
    74e2:	c3                   	retq   
    74e3:	c3                   	retq   

00000000000074e4 <do_ccm_decrypt_auth>:
{
    74e4:	f3 0f 1e fa          	endbr64 
    74e8:	41 55                	push   %r13
    74ea:	41 54                	push   %r12
    74ec:	49 89 f4             	mov    %rsi,%r12
    74ef:	55                   	push   %rbp
    74f0:	53                   	push   %rbx
    74f1:	48 89 fb             	mov    %rdi,%rbx
    74f4:	48 83 ec 28          	sub    $0x28,%rsp
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    74f8:	0f b7 4f 32          	movzwl 0x32(%rdi),%ecx
    74fc:	44 0f b7 47 30       	movzwl 0x30(%rdi),%r8d
{
    7501:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7508:	00 00 
    750a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    750f:	31 c0                	xor    %eax,%eax
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    7511:	48 8b 47 20          	mov    0x20(%rdi),%rax
    7515:	49 89 e5             	mov    %rsp,%r13
	struct cipher_pkt *op = aead_op->pkt;
    7518:	48 8b 2e             	mov    (%rsi),%rbp
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    751b:	4c 89 ef             	mov    %r13,%rdi
    751e:	48 8d 70 04          	lea    0x4(%rax),%rsi
    7522:	e8 1a da ff ff       	callq  4f41 <tc_ccm_config>
    7527:	85 c0                	test   %eax,%eax
    7529:	75 07                	jne    7532 <do_ccm_decrypt_auth+0x4e>
		return -EIO;
    752b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    7530:	eb 4e                	jmp    7580 <do_ccm_decrypt_auth+0x9c>
	if (aead_op->tag != op->in_buf + op->in_len) {
    7532:	48 63 45 08          	movslq 0x8(%rbp),%rax
    7536:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    753a:	48 89 c2             	mov    %rax,%rdx
    753d:	4c 01 c0             	add    %r8,%rax
    7540:	49 39 44 24 18       	cmp    %rax,0x18(%r12)
    7545:	75 e4                	jne    752b <do_ccm_decrypt_auth+0x47>
	if (tc_ccm_decryption_verification(op->out_buf, op->out_buf_max,
    7547:	4d 8b 54 24 08       	mov    0x8(%r12),%r10
    754c:	8b 75 18             	mov    0x18(%rbp),%esi
    754f:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
					   op->in_len + ccm_param->tag_len,
    7553:	0f b7 43 30          	movzwl 0x30(%rbx),%eax
	if (tc_ccm_decryption_verification(op->out_buf, op->out_buf_max,
    7557:	41 51                	push   %r9
    7559:	41 55                	push   %r13
    755b:	41 8b 4c 24 10       	mov    0x10(%r12),%ecx
    7560:	44 8d 0c 10          	lea    (%rax,%rdx,1),%r9d
    7564:	4c 89 d2             	mov    %r10,%rdx
    7567:	e8 d5 db ff ff       	callq  5141 <tc_ccm_decryption_verification>
    756c:	41 5a                	pop    %r10
    756e:	41 5b                	pop    %r11
    7570:	85 c0                	test   %eax,%eax
    7572:	74 b7                	je     752b <do_ccm_decrypt_auth+0x47>
	op->out_len = op->in_len + ccm_param->tag_len;
    7574:	0f b7 43 30          	movzwl 0x30(%rbx),%eax
    7578:	03 45 08             	add    0x8(%rbp),%eax
    757b:	89 45 1c             	mov    %eax,0x1c(%rbp)
	return 0;
    757e:	31 c0                	xor    %eax,%eax
}
    7580:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    7585:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    758c:	00 00 
    758e:	74 05                	je     7595 <do_ccm_decrypt_auth+0xb1>
    7590:	e8 1b af ff ff       	callq  24b0 <__stack_chk_fail@plt>
    7595:	48 83 c4 28          	add    $0x28,%rsp
    7599:	5b                   	pop    %rbx
    759a:	5d                   	pop    %rbp
    759b:	41 5c                	pop    %r12
    759d:	41 5d                	pop    %r13
    759f:	c3                   	retq   

00000000000075a0 <do_cbc_decrypt>:
{
    75a0:	f3 0f 1e fa          	endbr64 
	if (iv != op->in_buf) {
    75a4:	4c 8b 06             	mov    (%rsi),%r8
	struct tc_shim_drv_state *data =  ctx->drv_sessn_state;
    75a7:	48 8b 47 20          	mov    0x20(%rdi),%rax
	if (iv != op->in_buf) {
    75ab:	49 39 d0             	cmp    %rdx,%r8
    75ae:	75 33                	jne    75e3 <do_cbc_decrypt+0x43>
{
    75b0:	53                   	push   %rbx
    75b1:	48 89 f3             	mov    %rsi,%rbx
			op->in_len - TC_AES_BLOCK_SIZE,
    75b4:	8b 4e 08             	mov    0x8(%rsi),%ecx
			op->in_buf + TC_AES_BLOCK_SIZE,
    75b7:	49 8d 50 10          	lea    0x10(%r8),%rdx
	if (tc_cbc_mode_decrypt(op->out_buf,
    75bb:	8b 76 18             	mov    0x18(%rsi),%esi
    75be:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    75c2:	4c 8d 48 04          	lea    0x4(%rax),%r9
			op->in_len - TC_AES_BLOCK_SIZE,
    75c6:	83 e9 10             	sub    $0x10,%ecx
	if (tc_cbc_mode_decrypt(op->out_buf,
    75c9:	e8 f1 d5 ff ff       	callq  4bbf <tc_cbc_mode_decrypt>
    75ce:	85 c0                	test   %eax,%eax
    75d0:	75 07                	jne    75d9 <do_cbc_decrypt+0x39>
		return -EIO;
    75d2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    75d7:	eb 08                	jmp    75e1 <do_cbc_decrypt+0x41>
	op->out_len = op->in_len;
    75d9:	8b 43 08             	mov    0x8(%rbx),%eax
    75dc:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    75df:	31 c0                	xor    %eax,%eax
}
    75e1:	5b                   	pop    %rbx
    75e2:	c3                   	retq   
		return -EIO;
    75e3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    75e8:	c3                   	retq   

00000000000075e9 <do_ccm_encrypt_mac>:
{
    75e9:	f3 0f 1e fa          	endbr64 
    75ed:	41 54                	push   %r12
    75ef:	55                   	push   %rbp
    75f0:	48 89 f5             	mov    %rsi,%rbp
    75f3:	53                   	push   %rbx
    75f4:	48 83 ec 20          	sub    $0x20,%rsp
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    75f8:	0f b7 4f 32          	movzwl 0x32(%rdi),%ecx
    75fc:	44 0f b7 47 30       	movzwl 0x30(%rdi),%r8d
{
    7601:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7608:	00 00 
    760a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    760f:	31 c0                	xor    %eax,%eax
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    7611:	48 8b 47 20          	mov    0x20(%rdi),%rax
    7615:	49 89 e4             	mov    %rsp,%r12
	struct cipher_pkt *op = aead_op->pkt;
    7618:	48 8b 1e             	mov    (%rsi),%rbx
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    761b:	4c 89 e7             	mov    %r12,%rdi
    761e:	48 8d 70 04          	lea    0x4(%rax),%rsi
    7622:	e8 1a d9 ff ff       	callq  4f41 <tc_ccm_config>
    7627:	85 c0                	test   %eax,%eax
    7629:	75 07                	jne    7632 <do_ccm_encrypt_mac+0x49>
		return -EIO;
    762b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    7630:	eb 49                	jmp    767b <do_ccm_encrypt_mac+0x92>
	if (tc_ccm_generation_encryption(op->out_buf, op->out_buf_max,
    7632:	44 8b 4b 08          	mov    0x8(%rbx),%r9d
    7636:	8b 73 18             	mov    0x18(%rbx),%esi
    7639:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    763d:	8b 4d 10             	mov    0x10(%rbp),%ecx
    7640:	50                   	push   %rax
    7641:	48 8b 55 08          	mov    0x8(%rbp),%rdx
    7645:	4c 8b 03             	mov    (%rbx),%r8
    7648:	41 54                	push   %r12
    764a:	e8 3c d9 ff ff       	callq  4f8b <tc_ccm_generation_encryption>
    764f:	5a                   	pop    %rdx
    7650:	59                   	pop    %rcx
    7651:	85 c0                	test   %eax,%eax
    7653:	74 d6                	je     762b <do_ccm_encrypt_mac+0x42>
	if (aead_op->tag) {
    7655:	48 8b 45 18          	mov    0x18(%rbp),%rax
    7659:	48 85 c0             	test   %rax,%rax
    765c:	74 11                	je     766f <do_ccm_encrypt_mac+0x86>
		memcpy(aead_op->tag, op->out_buf + op->in_len, ccm.mlen);
    765e:	48 63 73 08          	movslq 0x8(%rbx),%rsi
    7662:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    7666:	48 89 c7             	mov    %rax,%rdi
    7669:	48 03 73 10          	add    0x10(%rbx),%rsi
    766d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	op->out_len = op->in_len + ccm.mlen;
    766f:	8b 44 24 10          	mov    0x10(%rsp),%eax
    7673:	03 43 08             	add    0x8(%rbx),%eax
    7676:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    7679:	31 c0                	xor    %eax,%eax
}
    767b:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    7680:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    7687:	00 00 
    7689:	74 05                	je     7690 <do_ccm_encrypt_mac+0xa7>
    768b:	e8 20 ae ff ff       	callq  24b0 <__stack_chk_fail@plt>
    7690:	48 83 c4 20          	add    $0x20,%rsp
    7694:	5b                   	pop    %rbx
    7695:	5d                   	pop    %rbp
    7696:	41 5c                	pop    %r12
    7698:	c3                   	retq   

0000000000007699 <do_ctr_op>:
{
    7699:	f3 0f 1e fa          	endbr64 
    769d:	55                   	push   %rbp
	uint8_t ctr[16] = {0};	/* CTR mode Counter =  iv:ctr */
    769e:	0f 57 c0             	xorps  %xmm0,%xmm0
    76a1:	b9 10 00 00 00       	mov    $0x10,%ecx
{
    76a6:	53                   	push   %rbx
    76a7:	48 89 f3             	mov    %rsi,%rbx
    76aa:	48 89 d6             	mov    %rdx,%rsi
    76ad:	48 83 ec 28          	sub    $0x28,%rsp
	int ivlen = ctx->keylen - (ctx->mode_params.ctr_info.ctr_len >> 3);
    76b1:	0f b7 57 34          	movzwl 0x34(%rdi),%edx
	struct tc_shim_drv_state *data =  ctx->drv_sessn_state;
    76b5:	48 8b 6f 20          	mov    0x20(%rdi),%rbp
{
    76b9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    76c0:	00 00 
    76c2:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    76c7:	31 c0                	xor    %eax,%eax
	int ivlen = ctx->keylen - (ctx->mode_params.ctr_info.ctr_len >> 3);
    76c9:	8b 47 30             	mov    0x30(%rdi),%eax
    76cc:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
	uint8_t ctr[16] = {0};	/* CTR mode Counter =  iv:ctr */
    76d1:	0f 11 44 24 08       	movups %xmm0,0x8(%rsp)
    76d6:	4c 89 c7             	mov    %r8,%rdi
	int ivlen = ctx->keylen - (ctx->mode_params.ctr_info.ctr_len >> 3);
    76d9:	c1 e8 03             	shr    $0x3,%eax
    76dc:	29 c2                	sub    %eax,%edx
	memcpy(ctr, iv, ivlen);
    76de:	48 63 d2             	movslq %edx,%rdx
    76e1:	e8 8a ae ff ff       	callq  2570 <__memcpy_chk@plt>
	if (tc_ctr_mode(op->out_buf, op->out_buf_max, op->in_buf,
    76e6:	8b 4b 08             	mov    0x8(%rbx),%ecx
    76e9:	8b 73 18             	mov    0x18(%rbx),%esi
    76ec:	4c 8d 4d 04          	lea    0x4(%rbp),%r9
    76f0:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    76f4:	48 8b 13             	mov    (%rbx),%rdx
    76f7:	49 89 c0             	mov    %rax,%r8
    76fa:	e8 8a d5 ff ff       	callq  4c89 <tc_ctr_mode>
    76ff:	41 89 c0             	mov    %eax,%r8d
    7702:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    7707:	45 85 c0             	test   %r8d,%r8d
    770a:	74 08                	je     7714 <do_ctr_op+0x7b>
	op->out_len = op->in_len;
    770c:	8b 43 08             	mov    0x8(%rbx),%eax
    770f:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    7712:	31 c0                	xor    %eax,%eax
}
    7714:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    7719:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    7720:	00 00 
    7722:	74 05                	je     7729 <do_ctr_op+0x90>
    7724:	e8 87 ad ff ff       	callq  24b0 <__stack_chk_fail@plt>
    7729:	48 83 c4 28          	add    $0x28,%rsp
    772d:	5b                   	pop    %rbx
    772e:	5d                   	pop    %rbp
    772f:	c3                   	retq   

0000000000007730 <do_cbc_encrypt>:
{
    7730:	f3 0f 1e fa          	endbr64 
    7734:	53                   	push   %rbx
    7735:	48 89 f3             	mov    %rsi,%rbx
	if (tc_cbc_mode_encrypt(op->out_buf,
    7738:	48 8b 47 20          	mov    0x20(%rdi),%rax
{
    773c:	49 89 d0             	mov    %rdx,%r8
	if (tc_cbc_mode_encrypt(op->out_buf,
    773f:	8b 4e 08             	mov    0x8(%rsi),%ecx
    7742:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    7746:	8b 76 18             	mov    0x18(%rsi),%esi
    7749:	48 8b 13             	mov    (%rbx),%rdx
    774c:	4c 8d 48 04          	lea    0x4(%rax),%r9
    7750:	e8 41 d3 ff ff       	callq  4a96 <tc_cbc_mode_encrypt>
    7755:	41 89 c0             	mov    %eax,%r8d
    7758:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    775d:	45 85 c0             	test   %r8d,%r8d
    7760:	74 08                	je     776a <do_cbc_encrypt+0x3a>
	op->out_len = op->in_len;
    7762:	8b 43 08             	mov    0x8(%rbx),%eax
    7765:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    7768:	31 c0                	xor    %eax,%eax
}
    776a:	5b                   	pop    %rbx
    776b:	c3                   	retq   

000000000000776c <np_uart_tty_poll_in>:
 * @retval 0 If a character arrived and was stored in p_char
 * @retval -1 If no character was available to read
 */
static int np_uart_tty_poll_in(const struct device *dev,
			       unsigned char *p_char)
{
    776c:	f3 0f 1e fa          	endbr64 
    7770:	50                   	push   %rax
	int n = -1;
	int in_f = ((struct native_uart_status *)dev->data)->in_fd;
    7771:	48 8b 47 20          	mov    0x20(%rdi),%rax
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
    7775:	ba 01 00 00 00       	mov    $0x1,%edx
    777a:	8b 78 04             	mov    0x4(%rax),%edi
    777d:	e8 8e ad ff ff       	callq  2510 <read@plt>
	n = read(in_f, p_char, 1);
	if (n == -1) {
		return -1;
	}
	return 0;
}
    7782:	5a                   	pop    %rdx
	if (n == -1) {
    7783:	ff c0                	inc    %eax
    7785:	0f 94 c0             	sete   %al
    7788:	0f b6 c0             	movzbl %al,%eax
    778b:	f7 d8                	neg    %eax
}
    778d:	c3                   	retq   

000000000000778e <np_cleanup_uart>:

	native_add_command_line_opts(uart_options);
}

static void np_cleanup_uart(void)
{
    778e:	f3 0f 1e fa          	endbr64 
	if (IS_ENABLED(CONFIG_NATIVE_UART_0_ON_OWN_PTY)) {
		if (native_uart_status_0.in_fd != 0) {
    7792:	8b 3d b4 7d 00 00    	mov    0x7db4(%rip),%edi        # f54c <native_uart_status_0+0x4>
    7798:	85 ff                	test   %edi,%edi
    779a:	74 05                	je     77a1 <np_cleanup_uart+0x13>
			close(native_uart_status_0.in_fd);
    779c:	e9 5f ad ff ff       	jmpq   2500 <close@plt>
#if defined(CONFIG_UART_NATIVE_POSIX_PORT_1_ENABLE)
	if (native_uart_status_1.in_fd != 0) {
		close(native_uart_status_1.in_fd);
	}
#endif
}
    77a1:	c3                   	retq   

00000000000077a2 <np_add_uart_options>:
{
    77a2:	f3 0f 1e fa          	endbr64 
	native_add_command_line_opts(uart_options);
    77a6:	48 8d 3d 93 4b 00 00 	lea    0x4b93(%rip),%rdi        # c340 <uart_options.7281>
    77ad:	e9 ea f9 ff ff       	jmpq   719c <native_add_command_line_opts>

00000000000077b2 <np_uart_0_init>:
{
    77b2:	f3 0f 1e fa          	endbr64 
    77b6:	55                   	push   %rbp
    77b7:	48 89 e5             	mov    %rsp,%rbp
    77ba:	41 57                	push   %r15
    77bc:	41 56                	push   %r14
    77be:	41 55                	push   %r13
    77c0:	41 54                	push   %r12
    77c2:	53                   	push   %rbx
    77c3:	48 83 ec 68          	sub    $0x68,%rsp
	d = (struct native_uart_status *)dev->data;
    77c7:	4c 8b 6f 20          	mov    0x20(%rdi),%r13
	master_pty = posix_openpt(O_RDWR | O_NOCTTY);
    77cb:	bf 02 01 00 00       	mov    $0x102,%edi
		int tty_fn = open_tty(d, DT_INST_LABEL(0),
    77d0:	44 8a 3d de 7d 00 00 	mov    0x7dde(%rip),%r15b        # f5b5 <auto_attach>
{
    77d7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    77de:	00 00 
    77e0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    77e4:	31 c0                	xor    %eax,%eax
	master_pty = posix_openpt(O_RDWR | O_NOCTTY);
    77e6:	e8 a5 ae ff ff       	callq  2690 <posix_openpt@plt>
    77eb:	89 c3                	mov    %eax,%ebx
	if (master_pty == -1) {
    77ed:	ff c0                	inc    %eax
    77ef:	75 0e                	jne    77ff <np_uart_0_init+0x4d>
		ERROR("Could not open a new TTY for the UART\n");
    77f1:	48 8d 3d 18 2b 00 00 	lea    0x2b18(%rip),%rdi        # a310 <default_cmd+0x10b0>
    77f8:	31 c0                	xor    %eax,%eax
    77fa:	e8 3e ef ff ff       	callq  673d <posix_print_error_and_exit>
	ret = grantpt(master_pty);
    77ff:	89 df                	mov    %ebx,%edi
    7801:	e8 2a ae ff ff       	callq  2630 <grantpt@plt>
	if (ret == -1) {
    7806:	ff c0                	inc    %eax
    7808:	75 21                	jne    782b <np_uart_0_init+0x79>
		err_nbr = errno;
    780a:	e8 f1 ab ff ff       	callq  2400 <__errno_location@plt>
		close(master_pty);
    780f:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    7811:	49 89 c4             	mov    %rax,%r12
		close(master_pty);
    7814:	e8 e7 ac ff ff       	callq  2500 <close@plt>
		ERROR("Could not grant access to the slave PTY side (%i)\n",
    7819:	41 8b 34 24          	mov    (%r12),%esi
    781d:	48 8d 3d 13 2b 00 00 	lea    0x2b13(%rip),%rdi        # a337 <default_cmd+0x10d7>
    7824:	31 c0                	xor    %eax,%eax
    7826:	e8 12 ef ff ff       	callq  673d <posix_print_error_and_exit>
	ret = unlockpt(master_pty);
    782b:	89 df                	mov    %ebx,%edi
    782d:	e8 2e ad ff ff       	callq  2560 <unlockpt@plt>
	if (ret == -1) {
    7832:	ff c0                	inc    %eax
    7834:	75 21                	jne    7857 <np_uart_0_init+0xa5>
		err_nbr = errno;
    7836:	e8 c5 ab ff ff       	callq  2400 <__errno_location@plt>
		close(master_pty);
    783b:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    783d:	49 89 c4             	mov    %rax,%r12
		close(master_pty);
    7840:	e8 bb ac ff ff       	callq  2500 <close@plt>
		ERROR("Could not unlock the slave PTY side (%i)\n", errno);
    7845:	41 8b 34 24          	mov    (%r12),%esi
    7849:	48 8d 3d 1a 2b 00 00 	lea    0x2b1a(%rip),%rdi        # a36a <default_cmd+0x110a>
    7850:	31 c0                	xor    %eax,%eax
    7852:	e8 e6 ee ff ff       	callq  673d <posix_print_error_and_exit>
	slave_pty_name = ptsname(master_pty);
    7857:	89 df                	mov    %ebx,%edi
    7859:	e8 32 ab ff ff       	callq  2390 <ptsname@plt>
    785e:	49 89 c4             	mov    %rax,%r12
	if (slave_pty_name == NULL) {
    7861:	48 85 c0             	test   %rax,%rax
    7864:	75 20                	jne    7886 <np_uart_0_init+0xd4>
		err_nbr = errno;
    7866:	e8 95 ab ff ff       	callq  2400 <__errno_location@plt>
		close(master_pty);
    786b:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    786d:	49 89 c6             	mov    %rax,%r14
		close(master_pty);
    7870:	e8 8b ac ff ff       	callq  2500 <close@plt>
		ERROR("Error getting slave PTY device name (%i)\n", errno);
    7875:	41 8b 36             	mov    (%r14),%esi
    7878:	48 8d 3d 15 2b 00 00 	lea    0x2b15(%rip),%rdi        # a394 <default_cmd+0x1134>
    787f:	31 c0                	xor    %eax,%eax
    7881:	e8 b7 ee ff ff       	callq  673d <posix_print_error_and_exit>
	flags = fcntl(master_pty, F_GETFL);
    7886:	be 03 00 00 00       	mov    $0x3,%esi
    788b:	89 df                	mov    %ebx,%edi
    788d:	31 c0                	xor    %eax,%eax
    788f:	e8 dc ab ff ff       	callq  2470 <fcntl@plt>
    7894:	41 89 c6             	mov    %eax,%r14d
	if (flags == -1) {
    7897:	83 f8 ff             	cmp    $0xffffffff,%eax
    789a:	75 2a                	jne    78c6 <np_uart_0_init+0x114>
		err_nbr = errno;
    789c:	e8 5f ab ff ff       	callq  2400 <__errno_location@plt>
		close(master_pty);
    78a1:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    78a3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		close(master_pty);
    78aa:	e8 51 ac ff ff       	callq  2500 <close@plt>
		ERROR("Could not read the master PTY file status flags (%i)\n",
    78af:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
    78b6:	48 8d 3d 01 2b 00 00 	lea    0x2b01(%rip),%rdi        # a3be <default_cmd+0x115e>
    78bd:	31 c0                	xor    %eax,%eax
    78bf:	8b 32                	mov    (%rdx),%esi
    78c1:	e8 77 ee ff ff       	callq  673d <posix_print_error_and_exit>
	ret = fcntl(master_pty, F_SETFL, flags | O_NONBLOCK);
    78c6:	44 89 f2             	mov    %r14d,%edx
    78c9:	31 c0                	xor    %eax,%eax
    78cb:	be 04 00 00 00       	mov    $0x4,%esi
    78d0:	89 df                	mov    %ebx,%edi
    78d2:	80 ce 08             	or     $0x8,%dh
    78d5:	e8 96 ab ff ff       	callq  2470 <fcntl@plt>
	if (ret == -1) {
    78da:	ff c0                	inc    %eax
    78dc:	75 20                	jne    78fe <np_uart_0_init+0x14c>
		err_nbr = errno;
    78de:	e8 1d ab ff ff       	callq  2400 <__errno_location@plt>
		close(master_pty);
    78e3:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    78e5:	49 89 c6             	mov    %rax,%r14
		close(master_pty);
    78e8:	e8 13 ac ff ff       	callq  2500 <close@plt>
		ERROR("Could not set the master PTY as non-blocking (%i)\n",
    78ed:	41 8b 36             	mov    (%r14),%esi
    78f0:	48 8d 3d fd 2a 00 00 	lea    0x2afd(%rip),%rdi        # a3f4 <default_cmd+0x1194>
    78f7:	31 c0                	xor    %eax,%eax
    78f9:	e8 3f ee ff ff       	callq  673d <posix_print_error_and_exit>
	ret = tcgetattr(master_pty, &ter);
    78fe:	4c 8d 75 8c          	lea    -0x74(%rbp),%r14
    7902:	89 df                	mov    %ebx,%edi
    7904:	4c 89 f6             	mov    %r14,%rsi
    7907:	e8 f4 ac ff ff       	callq  2600 <tcgetattr@plt>
	if (ret == -1) {
    790c:	ff c0                	inc    %eax
    790e:	75 0e                	jne    791e <np_uart_0_init+0x16c>
		ERROR("Could not read terminal driver settings\n");
    7910:	48 8d 3d 10 2b 00 00 	lea    0x2b10(%rip),%rdi        # a427 <default_cmd+0x11c7>
    7917:	31 c0                	xor    %eax,%eax
    7919:	e8 1f ee ff ff       	callq  673d <posix_print_error_and_exit>
	ret = tcsetattr(master_pty, TCSANOW, &ter);
    791e:	31 f6                	xor    %esi,%esi
    7920:	4c 89 f2             	mov    %r14,%rdx
    7923:	89 df                	mov    %ebx,%edi
	ter.c_lflag &= ~(ICANON | ISIG | IEXTEN | ECHO);
    7925:	81 65 98 f4 7f ff ff 	andl   $0xffff7ff4,-0x68(%rbp)
	ter.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR | INPCK
    792c:	48 b8 04 fa ff ff fe 	movabs $0xfffffffefffffa04,%rax
    7933:	ff ff ff 
	ter.c_cc[VTIME] = 0;
    7936:	66 c7 45 a2 00 00    	movw   $0x0,-0x5e(%rbp)
	ter.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR | INPCK
    793c:	48 21 45 8c          	and    %rax,-0x74(%rbp)
	ret = tcsetattr(master_pty, TCSANOW, &ter);
    7940:	e8 cb ac ff ff       	callq  2610 <tcsetattr@plt>
	if (ret == -1) {
    7945:	ff c0                	inc    %eax
    7947:	75 0e                	jne    7957 <np_uart_0_init+0x1a5>
		ERROR("Could not change terminal driver settings\n");
    7949:	48 8d 3d 00 2b 00 00 	lea    0x2b00(%rip),%rdi        # a450 <default_cmd+0x11f0>
    7950:	31 c0                	xor    %eax,%eax
    7952:	e8 e6 ed ff ff       	callq  673d <posix_print_error_and_exit>
	posix_print_trace("%s connected to pseudotty: %s\n",
    7957:	31 c0                	xor    %eax,%eax
    7959:	4c 89 e2             	mov    %r12,%rdx
    795c:	48 8d 35 ee 1b 00 00 	lea    0x1bee(%rip),%rsi        # 9551 <default_cmd+0x2f1>
    7963:	48 8d 3d 11 2b 00 00 	lea    0x2b11(%rip),%rdi        # a47b <default_cmd+0x121b>
    796a:	e8 76 ef ff ff       	callq  68e5 <posix_print_trace>
	if (do_auto_attach) {
    796f:	45 84 ff             	test   %r15b,%r15b
    7972:	0f 84 da 00 00 00    	je     7a52 <np_uart_0_init+0x2a0>
	if (auto_attach_cmd == NULL) {
    7978:	48 83 3d d0 7b 00 00 	cmpq   $0x0,0x7bd0(%rip)        # f550 <auto_attach_cmd>
    797f:	00 
{
    7980:	49 89 e6             	mov    %rsp,%r14
	if (auto_attach_cmd == NULL) {
    7983:	75 0e                	jne    7993 <np_uart_0_init+0x1e1>
		auto_attach_cmd = (char *)default_cmd;
    7985:	48 8d 05 d4 18 00 00 	lea    0x18d4(%rip),%rax        # 9260 <default_cmd>
    798c:	48 89 05 bd 7b 00 00 	mov    %rax,0x7bbd(%rip)        # f550 <auto_attach_cmd>
	char command[strlen(auto_attach_cmd) + strlen(slave_tty) + 1];
    7993:	4c 8b 0d b6 7b 00 00 	mov    0x7bb6(%rip),%r9        # f550 <auto_attach_cmd>
    799a:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    799e:	31 c0                	xor    %eax,%eax
    79a0:	48 89 f1             	mov    %rsi,%rcx
    79a3:	4c 89 cf             	mov    %r9,%rdi
    79a6:	f2 ae                	repnz scas %es:(%rdi),%al
    79a8:	4c 89 e7             	mov    %r12,%rdi
    79ab:	48 f7 d1             	not    %rcx
    79ae:	48 89 ca             	mov    %rcx,%rdx
    79b1:	48 89 f1             	mov    %rsi,%rcx
    79b4:	f2 ae                	repnz scas %es:(%rdi),%al
    79b6:	48 89 c8             	mov    %rcx,%rax
    79b9:	48 89 e1             	mov    %rsp,%rcx
    79bc:	48 f7 d0             	not    %rax
    79bf:	48 8d 54 02 0e       	lea    0xe(%rdx,%rax,1),%rdx
    79c4:	48 89 d0             	mov    %rdx,%rax
    79c7:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    79ce:	48 29 d1             	sub    %rdx,%rcx
    79d1:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    79d5:	48 89 ca             	mov    %rcx,%rdx
    79d8:	48 39 d4             	cmp    %rdx,%rsp
    79db:	74 12                	je     79ef <np_uart_0_init+0x23d>
    79dd:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
    79e4:	48 83 8c 24 f8 0f 00 	orq    $0x0,0xff8(%rsp)
    79eb:	00 00 
    79ed:	eb e9                	jmp    79d8 <np_uart_0_init+0x226>
    79ef:	25 ff 0f 00 00       	and    $0xfff,%eax
    79f4:	48 29 c4             	sub    %rax,%rsp
    79f7:	48 85 c0             	test   %rax,%rax
    79fa:	74 06                	je     7a02 <np_uart_0_init+0x250>
    79fc:	48 83 4c 04 f8 00    	orq    $0x0,-0x8(%rsp,%rax,1)
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
    7a02:	4d 89 e0             	mov    %r12,%r8
    7a05:	4c 89 c9             	mov    %r9,%rcx
    7a08:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    7a0c:	be 01 00 00 00       	mov    $0x1,%esi
    7a11:	48 89 e7             	mov    %rsp,%rdi
    7a14:	31 c0                	xor    %eax,%eax
    7a16:	e8 b5 ac ff ff       	callq  26d0 <__sprintf_chk@plt>
	int ret = system(command);
    7a1b:	48 89 e7             	mov    %rsp,%rdi
    7a1e:	e8 9d aa ff ff       	callq  24c0 <system@plt>
    7a23:	41 89 c4             	mov    %eax,%r12d
	if (ret != 0) {
    7a26:	85 c0                	test   %eax,%eax
    7a28:	74 25                	je     7a4f <np_uart_0_init+0x29d>
		WARN("Could not attach to the UART with \"%s\"\n", command);
    7a2a:	48 89 e6             	mov    %rsp,%rsi
    7a2d:	48 8d 3d 66 2a 00 00 	lea    0x2a66(%rip),%rdi        # a49a <default_cmd+0x123a>
    7a34:	31 c0                	xor    %eax,%eax
    7a36:	e8 db ed ff ff       	callq  6816 <posix_print_warning>
		WARN("The command returned %i\n", WEXITSTATUS(ret));
    7a3b:	44 89 e0             	mov    %r12d,%eax
    7a3e:	48 8d 3d 7d 2a 00 00 	lea    0x2a7d(%rip),%rdi        # a4c2 <default_cmd+0x1262>
    7a45:	0f b6 f4             	movzbl %ah,%esi
    7a48:	31 c0                	xor    %eax,%eax
    7a4a:	e8 c7 ed ff ff       	callq  6816 <posix_print_warning>
    7a4f:	4c 89 f4             	mov    %r14,%rsp
		np_uart_driver_api_0.poll_in = np_uart_tty_poll_in;
    7a52:	48 8d 05 13 fd ff ff 	lea    -0x2ed(%rip),%rax        # 776c <np_uart_tty_poll_in>
		d->in_fd = tty_fn;
    7a59:	41 89 5d 04          	mov    %ebx,0x4(%r13)
		d->out_fd = tty_fn;
    7a5d:	41 89 5d 00          	mov    %ebx,0x0(%r13)
		np_uart_driver_api_0.poll_in = np_uart_tty_poll_in;
    7a61:	48 89 05 98 49 00 00 	mov    %rax,0x4998(%rip)        # c400 <np_uart_driver_api_0>
}
    7a68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    7a6c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7a73:	00 00 
    7a75:	74 05                	je     7a7c <np_uart_0_init+0x2ca>
    7a77:	e8 34 aa ff ff       	callq  24b0 <__stack_chk_fail@plt>
    7a7c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    7a80:	31 c0                	xor    %eax,%eax
    7a82:	5b                   	pop    %rbx
    7a83:	41 5c                	pop    %r12
    7a85:	41 5d                	pop    %r13
    7a87:	41 5e                	pop    %r14
    7a89:	41 5f                	pop    %r15
    7a8b:	5d                   	pop    %rbp
    7a8c:	c3                   	retq   

0000000000007a8d <np_uart_poll_out>:
{
    7a8d:	f3 0f 1e fa          	endbr64 
    7a91:	48 83 ec 18          	sub    $0x18,%rsp
	ret = write(d->out_fd, &out_char, 1);
    7a95:	48 8b 47 20          	mov    0x20(%rdi),%rax
    7a99:	ba 01 00 00 00       	mov    $0x1,%edx
{
    7a9e:	40 88 74 24 0c       	mov    %sil,0xc(%rsp)
	ret = write(d->out_fd, &out_char, 1);
    7aa3:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
    7aa8:	8b 38                	mov    (%rax),%edi
    7aaa:	e8 e1 a9 ff ff       	callq  2490 <write@plt>
}
    7aaf:	48 83 c4 18          	add    $0x18,%rsp
    7ab3:	c3                   	retq   

0000000000007ab4 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
    7ab4:	f3 0f 1e fa          	endbr64 
	while (dev < __device_end) {
		device_pm_state_init(dev);
		z_object_init(dev);
		++dev;
	}
}
    7ab8:	c3                   	retq   

0000000000007ab9 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    7ab9:	f3 0f 1e fa          	endbr64 
    7abd:	41 55                	push   %r13
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    7abf:	48 8d 05 da 40 00 00 	lea    0x40da(%rip),%rax        # bba0 <levels.4940>
{
    7ac6:	41 54                	push   %r12
    7ac8:	49 89 c4             	mov    %rax,%r12
    7acb:	55                   	push   %rbp
    7acc:	53                   	push   %rbx
    7acd:	52                   	push   %rdx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    7ace:	48 63 d7             	movslq %edi,%rdx
    7ad1:	ff c7                	inc    %edi
    7ad3:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    7ad7:	48 63 df             	movslq %edi,%rbx
    7ada:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    7ade:	76 39                	jbe    7b19 <z_sys_init_run_level+0x60>
		const struct device *dev = entry->dev;
    7ae0:	4c 8b 6d 08          	mov    0x8(%rbp),%r13
		int rc = entry->init(dev);
    7ae4:	4c 89 ef             	mov    %r13,%rdi
    7ae7:	ff 55 00             	callq  *0x0(%rbp)

		if (dev != NULL) {
    7aea:	4d 85 ed             	test   %r13,%r13
    7aed:	74 24                	je     7b13 <z_sys_init_run_level+0x5a>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
    7aef:	49 8b 55 18          	mov    0x18(%r13),%rdx
    7af3:	85 c0                	test   %eax,%eax
    7af5:	74 18                	je     7b0f <z_sys_init_run_level+0x56>
				if (rc < 0) {
    7af7:	89 c1                	mov    %eax,%ecx
    7af9:	c1 f9 1f             	sar    $0x1f,%ecx
    7afc:	31 c8                	xor    %ecx,%eax
    7afe:	29 c8                	sub    %ecx,%eax
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    7b00:	b9 ff 00 00 00       	mov    $0xff,%ecx
    7b05:	3d ff 00 00 00       	cmp    $0xff,%eax
    7b0a:	0f 4f c1             	cmovg  %ecx,%eax
    7b0d:	88 02                	mov    %al,(%rdx)
			}
			dev->state->initialized = true;
    7b0f:	80 4a 01 01          	orb    $0x1,0x1(%rdx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    7b13:	48 83 c5 10          	add    $0x10,%rbp
    7b17:	eb c1                	jmp    7ada <z_sys_init_run_level+0x21>
		}
	}
}
    7b19:	58                   	pop    %rax
    7b1a:	5b                   	pop    %rbx
    7b1b:	5d                   	pop    %rbp
    7b1c:	41 5c                	pop    %r12
    7b1e:	41 5d                	pop    %r13
    7b20:	c3                   	retq   

0000000000007b21 <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
    7b21:	f3 0f 1e fa          	endbr64 
	return dev->state->initialized && (dev->state->init_res == 0U);
    7b25:	48 8b 47 18          	mov    0x18(%rdi),%rax
    7b29:	8b 00                	mov    (%rax),%eax
    7b2b:	66 25 ff 01          	and    $0x1ff,%ax
    7b2f:	66 3d 00 01          	cmp    $0x100,%ax
    7b33:	0f 94 c0             	sete   %al
}
    7b36:	c3                   	retq   

0000000000007b37 <z_impl_device_get_binding>:
{
    7b37:	f3 0f 1e fa          	endbr64 
    7b3b:	41 54                	push   %r12
    7b3d:	55                   	push   %rbp
    7b3e:	53                   	push   %rbx
	if ((name == NULL) || (name[0] == '\0')) {
    7b3f:	48 85 ff             	test   %rdi,%rdi
    7b42:	75 05                	jne    7b49 <z_impl_device_get_binding+0x12>
		return NULL;
    7b44:	45 31 e4             	xor    %r12d,%r12d
    7b47:	eb 61                	jmp    7baa <z_impl_device_get_binding+0x73>
	if ((name == NULL) || (name[0] == '\0')) {
    7b49:	80 3f 00             	cmpb   $0x0,(%rdi)
    7b4c:	48 89 fb             	mov    %rdi,%rbx
    7b4f:	74 f3                	je     7b44 <z_impl_device_get_binding+0xd>
	for (dev = __device_start; dev != __device_end; dev++) {
    7b51:	4c 8d 25 98 6d 00 00 	lea    0x6d98(%rip),%r12        # e8f0 <__device_dts_ord_10>
    7b58:	4c 89 e5             	mov    %r12,%rbp
    7b5b:	4c 3b 25 76 44 00 00 	cmp    0x4476(%rip),%r12        # bfd8 <_GLOBAL_OFFSET_TABLE_+0x200>
    7b62:	74 18                	je     7b7c <z_impl_device_get_binding+0x45>
		if (z_device_ready(dev) && (dev->name == name)) {
    7b64:	4c 89 e7             	mov    %r12,%rdi
    7b67:	e8 b5 ff ff ff       	callq  7b21 <z_device_ready>
    7b6c:	84 c0                	test   %al,%al
    7b6e:	74 06                	je     7b76 <z_impl_device_get_binding+0x3f>
    7b70:	49 39 1c 24          	cmp    %rbx,(%r12)
    7b74:	74 34                	je     7baa <z_impl_device_get_binding+0x73>
	for (dev = __device_start; dev != __device_end; dev++) {
    7b76:	49 83 c4 30          	add    $0x30,%r12
    7b7a:	eb df                	jmp    7b5b <z_impl_device_get_binding+0x24>
	for (dev = __device_start; dev != __device_end; dev++) {
    7b7c:	49 89 ec             	mov    %rbp,%r12
    7b7f:	4c 3b 25 52 44 00 00 	cmp    0x4452(%rip),%r12        # bfd8 <_GLOBAL_OFFSET_TABLE_+0x200>
    7b86:	74 bc                	je     7b44 <z_impl_device_get_binding+0xd>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    7b88:	4c 89 e7             	mov    %r12,%rdi
    7b8b:	e8 91 ff ff ff       	callq  7b21 <z_device_ready>
    7b90:	84 c0                	test   %al,%al
    7b92:	74 10                	je     7ba4 <z_impl_device_get_binding+0x6d>
    7b94:	49 8b 34 24          	mov    (%r12),%rsi
    7b98:	48 89 df             	mov    %rbx,%rdi
    7b9b:	e8 a0 a9 ff ff       	callq  2540 <strcmp@plt>
    7ba0:	85 c0                	test   %eax,%eax
    7ba2:	74 06                	je     7baa <z_impl_device_get_binding+0x73>
	for (dev = __device_start; dev != __device_end; dev++) {
    7ba4:	49 83 c4 30          	add    $0x30,%r12
    7ba8:	eb d5                	jmp    7b7f <z_impl_device_get_binding+0x48>
}
    7baa:	4c 89 e0             	mov    %r12,%rax
    7bad:	5b                   	pop    %rbx
    7bae:	5d                   	pop    %rbp
    7baf:	41 5c                	pop    %r12
    7bb1:	c3                   	retq   

0000000000007bb2 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    7bb2:	f3 0f 1e fa          	endbr64 
    7bb6:	50                   	push   %rax
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    7bb7:	48 8d 05 f8 79 00 00 	lea    0x79f8(%rip),%rax        # f5b6 <z_sys_post_kernel>

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    7bbe:	bf 02 00 00 00       	mov    $0x2,%edi
	z_sys_post_kernel = true;
    7bc3:	c6 00 01             	movb   $0x1,(%rax)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    7bc6:	e8 ee fe ff ff       	callq  7ab9 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    7bcb:	e8 d9 0d 00 00       	callq  89a9 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    7bd0:	bf 03 00 00 00       	mov    $0x3,%edi
    7bd5:	e8 df fe ff ff       	callq  7ab9 <z_sys_init_run_level>

	z_init_static_threads();
    7bda:	e8 15 0d 00 00       	callq  88f4 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    7bdf:	e8 18 b0 ff ff       	callq  2bfc <zephyr_app_main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    7be4:	48 8d 05 95 77 00 00 	lea    0x7795(%rip),%rax        # f380 <z_main_thread>
    7beb:	80 60 18 fe          	andb   $0xfe,0x18(%rax)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    7bef:	5a                   	pop    %rdx
    7bf0:	c3                   	retq   

0000000000007bf1 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    7bf1:	f3 0f 1e fa          	endbr64 
    7bf5:	41 55                	push   %r13
    7bf7:	41 54                	push   %r12
    7bf9:	55                   	push   %rbp
    7bfa:	53                   	push   %rbx
    7bfb:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    7c02:	48 8d 1d 17 78 00 00 	lea    0x7817(%rip),%rbx        # f420 <_kernel>
    7c09:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7c10:	00 00 
    7c12:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
    7c19:	00 
    7c1a:	31 c0                	xor    %eax,%eax
    7c1c:	48 89 e0             	mov    %rsp,%rax
	dummy_thread->base.user_options = K_ESSENTIAL;
    7c1f:	66 c7 44 24 18 01 01 	movw   $0x101,0x18(%rsp)
	_current_cpu->current = dummy_thread;
    7c26:	48 89 43 10          	mov    %rax,0x10(%rbx)
#endif
#if defined(CONFIG_MMU) && defined(CONFIG_USERSPACE)
	z_kernel_map_fixup();
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    7c2a:	e8 85 fe ff ff       	callq  7ab4 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    7c2f:	31 ff                	xor    %edi,%edi
    7c31:	e8 83 fe ff ff       	callq  7ab9 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    7c36:	bf 01 00 00 00       	mov    $0x1,%edi
    7c3b:	e8 79 fe ff ff       	callq  7ab9 <z_sys_init_run_level>
	z_sched_init();
    7c40:	e8 af 09 00 00       	callq  85f4 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    7c45:	45 31 c9             	xor    %r9d,%r9d
    7c48:	45 31 c0             	xor    %r8d,%r8d
    7c4b:	ba 00 04 00 00       	mov    $0x400,%edx
	_kernel.ready_q.cache = &z_main_thread;
    7c50:	48 8d 2d 29 77 00 00 	lea    0x7729(%rip),%rbp        # f380 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    7c57:	48 8d 05 22 29 00 00 	lea    0x2922(%rip),%rax        # a580 <default_cmd+0x1320>
    7c5e:	48 8d 35 13 60 00 00 	lea    0x6013(%rip),%rsi        # dc78 <z_main_stack>
    7c65:	48 8d 0d 46 ff ff ff 	lea    -0xba(%rip),%rcx        # 7bb2 <bg_thread_main>
	_kernel.ready_q.cache = &z_main_thread;
    7c6c:	48 89 6b 38          	mov    %rbp,0x38(%rbx)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    7c70:	48 89 ef             	mov    %rbp,%rdi
    7c73:	50                   	push   %rax
    7c74:	6a 01                	pushq  $0x1
    7c76:	6a 00                	pushq  $0x0
    7c78:	6a 00                	pushq  $0x0
    7c7a:	e8 d9 0b 00 00       	callq  8858 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7c7f:	80 65 19 fb          	andb   $0xfb,0x19(%rbp)
    7c83:	48 83 c4 20          	add    $0x20,%rsp
	z_ready_thread(&z_main_thread);
    7c87:	48 89 ef             	mov    %rbp,%rdi
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    7c8a:	49 89 c5             	mov    %rax,%r13
	z_ready_thread(&z_main_thread);
    7c8d:	e8 57 08 00 00       	callq  84e9 <z_ready_thread>
	z_setup_new_thread(thread, stack,
    7c92:	6a 00                	pushq  $0x0
    7c94:	45 31 c9             	xor    %r9d,%r9d
    7c97:	49 89 d8             	mov    %rbx,%r8
    7c9a:	6a 01                	pushq  $0x1
    7c9c:	4c 8d 25 3d 76 00 00 	lea    0x763d(%rip),%r12        # f2e0 <z_idle_threads>
    7ca3:	ba 00 01 00 00       	mov    $0x100,%edx
    7ca8:	48 8d 35 c9 5e 00 00 	lea    0x5ec9(%rip),%rsi        # db78 <z_idle_stacks>
    7caf:	6a 0f                	pushq  $0xf
    7cb1:	48 8d 0d 51 10 00 00 	lea    0x1051(%rip),%rcx        # 8d09 <idle>
    7cb8:	6a 00                	pushq  $0x0
    7cba:	4c 89 e7             	mov    %r12,%rdi
    7cbd:	e8 96 0b 00 00       	callq  8858 <z_setup_new_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    7cc2:	4c 89 63 18          	mov    %r12,0x18(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    7cc6:	4c 89 ee             	mov    %r13,%rsi
    7cc9:	48 89 ef             	mov    %rbp,%rdi
		_kernel.cpus[i].irq_stack =
    7ccc:	48 8d 05 a5 63 00 00 	lea    0x63a5(%rip),%rax        # e078 <z_interrupt_stacks>
		_kernel.cpus[i].id = i;
    7cd3:	c6 43 24 00          	movb   $0x0,0x24(%rbx)
	z_setup_new_thread(thread, stack,
    7cd7:	48 83 c4 20          	add    $0x20,%rsp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    7cdb:	48 8d 15 d0 fe ff ff 	lea    -0x130(%rip),%rdx        # 7bb2 <bg_thread_main>
    7ce2:	41 80 64 24 19 fb    	andb   $0xfb,0x19(%r12)
		_kernel.cpus[i].irq_stack =
    7ce8:	48 05 00 08 00 00    	add    $0x800,%rax
    7cee:	48 89 43 08          	mov    %rax,0x8(%rbx)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    7cf2:	48 8d 43 28          	lea    0x28(%rbx),%rax
    7cf6:	48 89 43 28          	mov    %rax,0x28(%rbx)
	list->tail = (sys_dnode_t *)list;
    7cfa:	48 89 43 30          	mov    %rax,0x30(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    7cfe:	e8 2b db ff ff       	callq  582e <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    7d03:	ba 27 01 00 00       	mov    $0x127,%edx
    7d08:	48 8d 35 76 28 00 00 	lea    0x2876(%rip),%rsi        # a585 <default_cmd+0x1325>
    7d0f:	31 c0                	xor    %eax,%eax
    7d11:	48 8d 3d 0f 1a 00 00 	lea    0x1a0f(%rip),%rdi        # 9727 <default_cmd+0x4c7>
    7d18:	e8 20 ea ff ff       	callq  673d <posix_print_error_and_exit>

0000000000007d1d <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
    7d1d:	f3 0f 1e fa          	endbr64 
    7d21:	41 57                	push   %r15
    7d23:	41 56                	push   %r14
    7d25:	49 89 d6             	mov    %rdx,%r14
    7d28:	41 55                	push   %r13
    7d2a:	41 54                	push   %r12
    7d2c:	49 89 fc             	mov    %rdi,%r12
    7d2f:	55                   	push   %rbp

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    7d30:	48 8d 6f 10          	lea    0x10(%rdi),%rbp
{
    7d34:	48 83 ec 10          	sub    $0x10,%rsp
    7d38:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
    7d3d:	e8 64 e6 ff ff       	callq  63a6 <posix_irq_lock>

	if (msgq->used_msgs < msgq->max_msgs) {
    7d42:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    7d47:	41 89 c5             	mov    %eax,%r13d
    7d4a:	41 8b 44 24 18       	mov    0x18(%r12),%eax
    7d4f:	41 39 44 24 40       	cmp    %eax,0x40(%r12)
    7d54:	73 6d                	jae    7dc3 <z_impl_k_msgq_put+0xa6>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    7d56:	4c 89 e7             	mov    %r12,%rdi
    7d59:	e8 49 08 00 00       	callq  85a7 <z_unpend_first_thread>
		if (pending_thread != NULL) {
    7d5e:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    7d63:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    7d68:	48 85 c0             	test   %rax,%rax
    7d6b:	74 25                	je     7d92 <z_impl_k_msgq_put+0x75>
    7d6d:	48 8b 78 20          	mov    0x20(%rax),%rdi
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
    7d71:	45 31 ff             	xor    %r15d,%r15d
    7d74:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
    7d76:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
			z_ready_thread(pending_thread);
    7d7d:	48 89 c7             	mov    %rax,%rdi
    7d80:	e8 64 07 00 00       	callq  84e9 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    7d85:	44 89 ee             	mov    %r13d,%esi
    7d88:	48 89 ef             	mov    %rbp,%rdi
    7d8b:	e8 5a 02 00 00       	callq  7fea <z_reschedule>
			return 0;
    7d90:	eb 71                	jmp    7e03 <z_impl_k_msgq_put+0xe6>
    7d92:	49 8b 7c 24 38       	mov    0x38(%r12),%rdi
    7d97:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    7d99:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    7d9e:	49 03 44 24 38       	add    0x38(%r12),%rax
    7da3:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
    7da8:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    7dad:	75 0a                	jne    7db9 <z_impl_k_msgq_put+0x9c>
				msgq->write_ptr = msgq->buffer_start;
    7daf:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    7db4:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			}
			msgq->used_msgs++;
    7db9:	41 ff 44 24 40       	incl   0x40(%r12)
		}
		result = 0;
    7dbe:	45 31 ff             	xor    %r15d,%r15d
    7dc1:	eb 38                	jmp    7dfb <z_impl_k_msgq_put+0xde>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for message space to become available */
		result = -ENOMSG;
    7dc3:	41 bf d6 ff ff ff    	mov    $0xffffffd6,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    7dc9:	4d 85 f6             	test   %r14,%r14
    7dcc:	74 2d                	je     7dfb <z_impl_k_msgq_put+0xde>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
    7dce:	48 8d 05 4b 76 00 00 	lea    0x764b(%rip),%rax        # f420 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    7dd5:	4c 89 f1             	mov    %r14,%rcx
    7dd8:	4c 89 e2             	mov    %r12,%rdx
    7ddb:	48 89 ef             	mov    %rbp,%rdi
		_current->base.swap_data = (void *) data;
    7dde:	48 8b 40 10          	mov    0x10(%rax),%rax
    7de2:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    7de6:	48 83 c4 10          	add    $0x10,%rsp
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    7dea:	44 89 ee             	mov    %r13d,%esi
}
    7ded:	5d                   	pop    %rbp
    7dee:	41 5c                	pop    %r12
    7df0:	41 5d                	pop    %r13
    7df2:	41 5e                	pop    %r14
    7df4:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    7df6:	e9 0c 04 00 00       	jmpq   8207 <z_pend_curr>
	posix_irq_unlock(key);
    7dfb:	44 89 ef             	mov    %r13d,%edi
    7dfe:	e8 b1 e5 ff ff       	callq  63b4 <posix_irq_unlock>
}
    7e03:	48 83 c4 10          	add    $0x10,%rsp
    7e07:	44 89 f8             	mov    %r15d,%eax
    7e0a:	5d                   	pop    %rbp
    7e0b:	41 5c                	pop    %r12
    7e0d:	41 5d                	pop    %r13
    7e0f:	41 5e                	pop    %r14
    7e11:	41 5f                	pop    %r15
    7e13:	c3                   	retq   

0000000000007e14 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    7e14:	f3 0f 1e fa          	endbr64 
    7e18:	41 57                	push   %r15
    7e1a:	41 56                	push   %r14
    7e1c:	49 89 d6             	mov    %rdx,%r14
    7e1f:	41 55                	push   %r13

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    7e21:	4c 8d 6f 10          	lea    0x10(%rdi),%r13
{
    7e25:	41 54                	push   %r12
    7e27:	49 89 fc             	mov    %rdi,%r12
    7e2a:	55                   	push   %rbp
    7e2b:	53                   	push   %rbx
    7e2c:	48 89 f3             	mov    %rsi,%rbx
    7e2f:	41 51                	push   %r9
	return posix_irq_lock();
    7e31:	e8 70 e5 ff ff       	callq  63a6 <posix_irq_lock>

	if (msgq->used_msgs > 0U) {
    7e36:	41 83 7c 24 40 00    	cmpl   $0x0,0x40(%r12)
    7e3c:	89 c5                	mov    %eax,%ebp
    7e3e:	0f 84 9f 00 00 00    	je     7ee3 <z_impl_k_msgq_get+0xcf>
    7e44:	49 8b 74 24 30       	mov    0x30(%r12),%rsi
    7e49:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    7e4e:	48 89 df             	mov    %rbx,%rdi
    7e51:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
    7e53:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    7e58:	49 03 44 24 30       	add    0x30(%r12),%rax
    7e5d:	49 89 44 24 30       	mov    %rax,0x30(%r12)
		if (msgq->read_ptr == msgq->buffer_end) {
    7e62:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    7e67:	75 0a                	jne    7e73 <z_impl_k_msgq_get+0x5f>
			msgq->read_ptr = msgq->buffer_start;
    7e69:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    7e6e:	49 89 44 24 30       	mov    %rax,0x30(%r12)
		}
		msgq->used_msgs--;
    7e73:	41 ff 4c 24 40       	decl   0x40(%r12)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    7e78:	4c 89 e7             	mov    %r12,%rdi
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
		}
		result = 0;
    7e7b:	45 31 ff             	xor    %r15d,%r15d
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    7e7e:	e8 24 07 00 00       	callq  85a7 <z_unpend_first_thread>
    7e83:	49 89 c0             	mov    %rax,%r8
		if (pending_thread != NULL) {
    7e86:	48 85 c0             	test   %rax,%rax
    7e89:	0f 84 8a 00 00 00    	je     7f19 <z_impl_k_msgq_get+0x105>
    7e8f:	48 8b 70 20          	mov    0x20(%rax),%rsi
    7e93:	49 8b 7c 24 38       	mov    0x38(%r12),%rdi
    7e98:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    7e9d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
			msgq->write_ptr += msgq->msg_size;
    7e9f:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    7ea4:	49 03 44 24 38       	add    0x38(%r12),%rax
    7ea9:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
    7eae:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    7eb3:	75 0a                	jne    7ebf <z_impl_k_msgq_get+0xab>
				msgq->write_ptr = msgq->buffer_start;
    7eb5:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    7eba:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			msgq->used_msgs++;
    7ebf:	41 ff 44 24 40       	incl   0x40(%r12)
			z_ready_thread(pending_thread);
    7ec4:	4c 89 c7             	mov    %r8,%rdi
			return 0;
    7ec7:	45 31 ff             	xor    %r15d,%r15d
    7eca:	41 c7 40 4c 00 00 00 	movl   $0x0,0x4c(%r8)
    7ed1:	00 
			z_ready_thread(pending_thread);
    7ed2:	e8 12 06 00 00       	callq  84e9 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    7ed7:	89 ee                	mov    %ebp,%esi
    7ed9:	4c 89 ef             	mov    %r13,%rdi
    7edc:	e8 09 01 00 00       	callq  7fea <z_reschedule>
			return 0;
    7ee1:	eb 3d                	jmp    7f20 <z_impl_k_msgq_get+0x10c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for a message to become available */
		result = -ENOMSG;
    7ee3:	41 bf d6 ff ff ff    	mov    $0xffffffd6,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    7ee9:	4d 85 f6             	test   %r14,%r14
    7eec:	74 2b                	je     7f19 <z_impl_k_msgq_get+0x105>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
    7eee:	48 8d 05 2b 75 00 00 	lea    0x752b(%rip),%rax        # f420 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    7ef5:	4c 89 f1             	mov    %r14,%rcx
    7ef8:	4c 89 e2             	mov    %r12,%rdx
    7efb:	89 ee                	mov    %ebp,%esi
    7efd:	4c 89 ef             	mov    %r13,%rdi
		_current->base.swap_data = data;
    7f00:	48 8b 40 10          	mov    0x10(%rax),%rax
    7f04:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    7f08:	41 58                	pop    %r8
    7f0a:	5b                   	pop    %rbx
    7f0b:	5d                   	pop    %rbp
    7f0c:	41 5c                	pop    %r12
    7f0e:	41 5d                	pop    %r13
    7f10:	41 5e                	pop    %r14
    7f12:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    7f14:	e9 ee 02 00 00       	jmpq   8207 <z_pend_curr>
	posix_irq_unlock(key);
    7f19:	89 ef                	mov    %ebp,%edi
    7f1b:	e8 94 e4 ff ff       	callq  63b4 <posix_irq_unlock>
}
    7f20:	5a                   	pop    %rdx
    7f21:	44 89 f8             	mov    %r15d,%eax
    7f24:	5b                   	pop    %rbx
    7f25:	5d                   	pop    %rbp
    7f26:	41 5c                	pop    %r12
    7f28:	41 5d                	pop    %r13
    7f2a:	41 5e                	pop    %r14
    7f2c:	41 5f                	pop    %r15
    7f2e:	c3                   	retq   

0000000000007f2f <z_sched_prio_cmp>:
 * Do not rely on the actual value returned aside from the above.
 * (Again, like memcmp.)
 */
int32_t z_sched_prio_cmp(struct k_thread *thread_1,
	struct k_thread *thread_2)
{
    7f2f:	f3 0f 1e fa          	endbr64 
	/* `prio` is <32b, so the below cannot overflow. */
	int32_t b1 = thread_1->base.prio;
    7f33:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
	int32_t b2 = thread_2->base.prio;
    7f37:	0f be 4e 1a          	movsbl 0x1a(%rsi),%ecx
		 * from UB on overflow to impdef.
		 */
		return (int32_t) (d2 - d1);
	}
#endif
	return 0;
    7f3b:	31 c0                	xor    %eax,%eax
	if (b1 != b2) {
    7f3d:	39 ca                	cmp    %ecx,%edx
    7f3f:	74 04                	je     7f45 <z_sched_prio_cmp+0x16>
		return b2 - b1;
    7f41:	89 c8                	mov    %ecx,%eax
    7f43:	29 d0                	sub    %edx,%eax
}
    7f45:	c3                   	retq   

0000000000007f46 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    7f46:	f3 0f 1e fa          	endbr64 
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    7f4a:	83 3d 53 76 00 00 00 	cmpl   $0x0,0x7653(%rip)        # f5a4 <slice_time>
    7f51:	74 20                	je     7f73 <z_reset_time_slice+0x2d>
{
    7f53:	50                   	push   %rax
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    7f54:	e8 21 c0 ff ff       	callq  3f7a <sys_clock_elapsed>
    7f59:	8b 3d 45 76 00 00    	mov    0x7645(%rip),%edi        # f5a4 <slice_time>
    7f5f:	48 8d 15 ba 74 00 00 	lea    0x74ba(%rip),%rdx        # f420 <_kernel>
		z_set_timeout_expiry(slice_time, false);
    7f66:	31 f6                	xor    %esi,%esi
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    7f68:	01 f8                	add    %edi,%eax
    7f6a:	89 42 20             	mov    %eax,0x20(%rdx)
	}
}
    7f6d:	5a                   	pop    %rdx
		z_set_timeout_expiry(slice_time, false);
    7f6e:	e9 5b 0c 00 00       	jmpq   8bce <z_set_timeout_expiry>
    7f73:	c3                   	retq   

0000000000007f74 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    7f74:	f3 0f 1e fa          	endbr64 
    7f78:	41 54                	push   %r12
    7f7a:	41 89 f4             	mov    %esi,%r12d
    7f7d:	55                   	push   %rbp
    7f7e:	53                   	push   %rbx
    7f7f:	89 fb                	mov    %edi,%ebx
	return posix_irq_lock();
    7f81:	e8 20 e4 ff ff       	callq  63a6 <posix_irq_lock>
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
    7f86:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    7f8b:	89 c5                	mov    %eax,%ebp
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    7f8d:	48 8d 05 8c 74 00 00 	lea    0x748c(%rip),%rax        # f420 <_kernel>
    7f94:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    7f9b:	89 d8                	mov    %ebx,%eax
		t += off;
    7f9d:	48 83 c0 09          	add    $0x9,%rax
		if (result32 && (t < BIT64(32))) {
    7fa1:	48 39 d0             	cmp    %rdx,%rax
    7fa4:	77 0e                	ja     7fb4 <k_sched_time_slice_set+0x40>
			return ((uint32_t)t) / (from_hz / to_hz);
    7fa6:	8d 43 09             	lea    0x9(%rbx),%eax
    7fa9:	b9 0a 00 00 00       	mov    $0xa,%ecx
    7fae:	31 d2                	xor    %edx,%edx
    7fb0:	f7 f1                	div    %ecx
    7fb2:	eb 0a                	jmp    7fbe <k_sched_time_slice_set+0x4a>
			return t / (from_hz / to_hz);
    7fb4:	b9 0a 00 00 00       	mov    $0xa,%ecx
    7fb9:	31 d2                	xor    %edx,%edx
    7fbb:	48 f7 f1             	div    %rcx
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    7fbe:	85 db                	test   %ebx,%ebx
    7fc0:	7e 0b                	jle    7fcd <k_sched_time_slice_set+0x59>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    7fc2:	83 f8 02             	cmp    $0x2,%eax
    7fc5:	ba 02 00 00 00       	mov    $0x2,%edx
    7fca:	0f 4c c2             	cmovl  %edx,%eax
		}
		slice_max_prio = prio;
    7fcd:	44 89 25 cc 75 00 00 	mov    %r12d,0x75cc(%rip)        # f5a0 <slice_max_prio>
			slice_time = MAX(2, slice_time);
    7fd4:	89 05 ca 75 00 00    	mov    %eax,0x75ca(%rip)        # f5a4 <slice_time>
		z_reset_time_slice();
    7fda:	e8 67 ff ff ff       	callq  7f46 <z_reset_time_slice>
	}
}
    7fdf:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    7fe0:	89 ef                	mov    %ebp,%edi
    7fe2:	5d                   	pop    %rbp
    7fe3:	41 5c                	pop    %r12
    7fe5:	e9 ca e3 ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000007fea <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    7fea:	f3 0f 1e fa          	endbr64 
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    7fee:	48 8d 05 2b 74 00 00 	lea    0x742b(%rip),%rax        # f420 <_kernel>
	if (resched(key.key) && need_swap()) {
    7ff5:	89 f2                	mov    %esi,%edx
{
    7ff7:	89 f7                	mov    %esi,%edi
	if (resched(key.key) && need_swap()) {
    7ff9:	0b 10                	or     (%rax),%edx
    7ffb:	75 11                	jne    800e <z_reschedule+0x24>
    7ffd:	48 8b 48 10          	mov    0x10(%rax),%rcx
    8001:	48 39 48 38          	cmp    %rcx,0x38(%rax)
    8005:	74 07                	je     800e <z_reschedule+0x24>
	ret = arch_swap(key);
    8007:	31 ff                	xor    %edi,%edi
    8009:	e9 d6 d7 ff ff       	jmpq   57e4 <arch_swap>
    800e:	e9 a1 e3 ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008013 <z_reschedule_irqlock>:
		k_spin_unlock(lock, key);
	}
}

void z_reschedule_irqlock(uint32_t key)
{
    8013:	f3 0f 1e fa          	endbr64 
	if (resched(key)) {
    8017:	48 8d 05 02 74 00 00 	lea    0x7402(%rip),%rax        # f420 <_kernel>
    801e:	89 fa                	mov    %edi,%edx
    8020:	0b 10                	or     (%rax),%edx
    8022:	75 07                	jne    802b <z_reschedule_irqlock+0x18>
    8024:	31 ff                	xor    %edi,%edi
    8026:	e9 b9 d7 ff ff       	jmpq   57e4 <arch_swap>
    802b:	e9 84 e3 ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008030 <z_reschedule_unlocked>:
{
    8030:	50                   	push   %rax
	return posix_irq_lock();
    8031:	e8 70 e3 ff ff       	callq  63a6 <posix_irq_lock>
}
    8036:	5a                   	pop    %rdx
    8037:	89 c7                	mov    %eax,%edi
	(void) z_reschedule_irqlock(arch_irq_lock());
    8039:	e9 d5 ff ff ff       	jmpq   8013 <z_reschedule_irqlock>

000000000000803e <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
    803e:	f3 0f 1e fa          	endbr64 
    8042:	50                   	push   %rax
    8043:	e8 5e e3 ff ff       	callq  63a6 <posix_irq_lock>
    8048:	89 c7                	mov    %eax,%edi
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    804a:	48 8d 05 cf 73 00 00 	lea    0x73cf(%rip),%rax        # f420 <_kernel>
    8051:	48 8b 40 10          	mov    0x10(%rax),%rax
    8055:	fe 48 1b             	decb   0x1b(%rax)
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    8058:	5a                   	pop    %rdx
	posix_irq_unlock(key);
    8059:	e9 56 e3 ff ff       	jmpq   63b4 <posix_irq_unlock>

000000000000805e <z_priq_dumb_remove>:

	sys_dlist_append(pq, &thread->base.qnode_dlist);
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    805e:	f3 0f 1e fa          	endbr64 
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    8062:	48 8b 56 08          	mov    0x8(%rsi),%rdx
	sys_dnode_t *const next = node->next;
    8066:	48 8b 06             	mov    (%rsi),%rax

	prev->next = next;
    8069:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
    806c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    8070:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	node->prev = NULL;
    8077:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
    807e:	00 
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    807f:	c3                   	retq   

0000000000008080 <unpend_thread_no_timeout>:
{
    8080:	53                   	push   %rbx
    8081:	48 89 fb             	mov    %rdi,%rbx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
    8084:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    8088:	48 89 de             	mov    %rbx,%rsi
    808b:	e8 ce ff ff ff       	callq  805e <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    8090:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
	thread->base.pended_on = NULL;
    8094:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    809b:	00 
}
    809c:	5b                   	pop    %rbx
    809d:	c3                   	retq   

000000000000809e <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    809e:	f3 0f 1e fa          	endbr64 
	return list->head == list;
    80a2:	48 8b 07             	mov    (%rdi),%rax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
    80a5:	48 85 c0             	test   %rax,%rax
    80a8:	74 05                	je     80af <z_priq_dumb_best+0x11>
    80aa:	48 39 c7             	cmp    %rax,%rdi
    80ad:	75 02                	jne    80b1 <z_priq_dumb_best+0x13>
	struct k_thread *thread = NULL;
    80af:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    80b1:	c3                   	retq   

00000000000080b2 <update_cache>:
{
    80b2:	41 54                	push   %r12
    80b4:	41 89 fc             	mov    %edi,%r12d
    80b7:	55                   	push   %rbp
	thread = _priq_run_best(&_kernel.ready_q.runq);
    80b8:	48 8d 2d 61 73 00 00 	lea    0x7361(%rip),%rbp        # f420 <_kernel>
{
    80bf:	53                   	push   %rbx
	thread = _priq_run_best(&_kernel.ready_q.runq);
    80c0:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    80c4:	e8 d5 ff ff ff       	callq  809e <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    80c9:	48 89 c3             	mov    %rax,%rbx
    80cc:	48 85 c0             	test   %rax,%rax
    80cf:	75 04                	jne    80d5 <update_cache+0x23>
    80d1:	48 8b 5d 18          	mov    0x18(%rbp),%rbx
	if (preempt_ok != 0) {
    80d5:	48 8b 45 10          	mov    0x10(%rbp),%rax
    80d9:	45 85 e4             	test   %r12d,%r12d
    80dc:	75 13                	jne    80f1 <update_cache+0x3f>
	if (z_is_thread_prevented_from_running(_current)) {
    80de:	f6 40 19 1f          	testb  $0x1f,0x19(%rax)
    80e2:	75 0d                	jne    80f1 <update_cache+0x3f>
	if (is_preempt(_current) || is_metairq(thread)) {
    80e4:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
    80e9:	76 06                	jbe    80f1 <update_cache+0x3f>
		_kernel.ready_q.cache = _current;
    80eb:	48 89 45 38          	mov    %rax,0x38(%rbp)
    80ef:	eb 0e                	jmp    80ff <update_cache+0x4d>
		if (thread != _current) {
    80f1:	48 39 c3             	cmp    %rax,%rbx
    80f4:	74 05                	je     80fb <update_cache+0x49>
			z_reset_time_slice();
    80f6:	e8 4b fe ff ff       	callq  7f46 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    80fb:	48 89 5d 38          	mov    %rbx,0x38(%rbp)
}
    80ff:	5b                   	pop    %rbx
    8100:	5d                   	pop    %rbp
    8101:	41 5c                	pop    %r12
    8103:	c3                   	retq   

0000000000008104 <unready_thread>:
{
    8104:	55                   	push   %rbp
    8105:	53                   	push   %rbx
    8106:	48 89 fb             	mov    %rdi,%rbx
    8109:	52                   	push   %rdx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    810a:	8a 47 19             	mov    0x19(%rdi),%al
	return (thread->base.thread_state & state) != 0U;
    810d:	48 8d 2d 0c 73 00 00 	lea    0x730c(%rip),%rbp        # f420 <_kernel>
	if (z_is_thread_queued(thread)) {
    8114:	84 c0                	test   %al,%al
    8116:	79 12                	jns    812a <unready_thread+0x26>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8118:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    811b:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    811e:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    8121:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    8125:	e8 34 ff ff ff       	callq  805e <z_priq_dumb_remove>
	update_cache(thread == _current);
    812a:	31 ff                	xor    %edi,%edi
    812c:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
}
    8130:	58                   	pop    %rax
	update_cache(thread == _current);
    8131:	40 0f 94 c7          	sete   %dil
}
    8135:	5b                   	pop    %rbx
    8136:	5d                   	pop    %rbp
	update_cache(thread == _current);
    8137:	e9 76 ff ff ff       	jmpq   80b2 <update_cache>

000000000000813c <add_to_waitq_locked>:
{
    813c:	41 54                	push   %r12
    813e:	55                   	push   %rbp
    813f:	48 89 f5             	mov    %rsi,%rbp
    8142:	53                   	push   %rbx
    8143:	48 89 fb             	mov    %rdi,%rbx
	unready_thread(thread);
    8146:	e8 b9 ff ff ff       	callq  8104 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    814b:	80 4b 19 02          	orb    $0x2,0x19(%rbx)
	if (wait_q != NULL) {
    814f:	48 85 ed             	test   %rbp,%rbp
    8152:	74 5a                	je     81ae <add_to_waitq_locked+0x72>
    8154:	4c 8b 65 00          	mov    0x0(%rbp),%r12
		thread->base.pended_on = wait_q;
    8158:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    815c:	4d 85 e4             	test   %r12,%r12
    815f:	74 05                	je     8166 <add_to_waitq_locked+0x2a>
    8161:	4c 39 e5             	cmp    %r12,%rbp
    8164:	75 14                	jne    817a <add_to_waitq_locked+0x3e>
	sys_dnode_t *const tail = list->tail;
    8166:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = list;
    816a:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = tail;
    816d:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    8171:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    8174:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    8178:	eb 34                	jmp    81ae <add_to_waitq_locked+0x72>
		if (z_sched_prio_cmp(thread, t) > 0) {
    817a:	4c 89 e6             	mov    %r12,%rsi
    817d:	48 89 df             	mov    %rbx,%rdi
    8180:	e8 aa fd ff ff       	callq  7f2f <z_sched_prio_cmp>
    8185:	85 c0                	test   %eax,%eax
    8187:	7e 16                	jle    819f <add_to_waitq_locked+0x63>
	sys_dnode_t *const prev = successor->prev;
    8189:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
    818e:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = prev;
    8191:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    8195:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    8198:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
    819d:	eb 0f                	jmp    81ae <add_to_waitq_locked+0x72>
	return (node == list->tail) ? NULL : node->next;
    819f:	4c 3b 65 08          	cmp    0x8(%rbp),%r12
    81a3:	74 c1                	je     8166 <add_to_waitq_locked+0x2a>
    81a5:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    81a9:	4d 85 e4             	test   %r12,%r12
    81ac:	eb b6                	jmp    8164 <add_to_waitq_locked+0x28>
}
    81ae:	5b                   	pop    %rbx
    81af:	5d                   	pop    %rbp
    81b0:	41 5c                	pop    %r12
    81b2:	c3                   	retq   

00000000000081b3 <pend>:
{
    81b3:	55                   	push   %rbp
    81b4:	53                   	push   %rbx
    81b5:	48 89 fb             	mov    %rdi,%rbx
    81b8:	48 83 ec 18          	sub    $0x18,%rsp
    81bc:	48 89 14 24          	mov    %rdx,(%rsp)
    81c0:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
    81c5:	e8 dc e1 ff ff       	callq  63a6 <posix_irq_lock>
		add_to_waitq_locked(thread, wait_q);
    81ca:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    81cf:	48 89 df             	mov    %rbx,%rdi
    81d2:	89 c5                	mov    %eax,%ebp
    81d4:	e8 63 ff ff ff       	callq  813c <add_to_waitq_locked>
	posix_irq_unlock(key);
    81d9:	89 ef                	mov    %ebp,%edi
    81db:	e8 d4 e1 ff ff       	callq  63b4 <posix_irq_unlock>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    81e0:	48 8b 14 24          	mov    (%rsp),%rdx
    81e4:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    81e8:	74 16                	je     8200 <pend+0x4d>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    81ea:	48 8d 35 74 03 00 00 	lea    0x374(%rip),%rsi        # 8565 <z_thread_timeout>
}
    81f1:	48 83 c4 18          	add    $0x18,%rsp
    81f5:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
    81f9:	5b                   	pop    %rbx
    81fa:	5d                   	pop    %rbp
    81fb:	e9 70 08 00 00       	jmpq   8a70 <z_add_timeout>
    8200:	48 83 c4 18          	add    $0x18,%rsp
    8204:	5b                   	pop    %rbx
    8205:	5d                   	pop    %rbp
    8206:	c3                   	retq   

0000000000008207 <z_pend_curr>:
{
    8207:	f3 0f 1e fa          	endbr64 
	pend(_current, wait_q, timeout);
    820b:	48 8d 05 0e 72 00 00 	lea    0x720e(%rip),%rax        # f420 <_kernel>
{
    8212:	55                   	push   %rbp
    8213:	89 f5                	mov    %esi,%ebp
    8215:	48 89 d6             	mov    %rdx,%rsi
    8218:	48 89 ca             	mov    %rcx,%rdx
	pend(_current, wait_q, timeout);
    821b:	48 8b 78 10          	mov    0x10(%rax),%rdi
    821f:	e8 8f ff ff ff       	callq  81b3 <pend>
    8224:	89 ef                	mov    %ebp,%edi
}
    8226:	5d                   	pop    %rbp
    8227:	e9 b8 d5 ff ff       	jmpq   57e4 <arch_swap>

000000000000822c <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
    822c:	41 55                	push   %r13
    822e:	41 54                	push   %r12
    8230:	55                   	push   %rbp
    8231:	53                   	push   %rbx
    8232:	48 89 fb             	mov    %rdi,%rbx
    8235:	50                   	push   %rax
		return 0;
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);

	expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    8236:	e8 c2 0a 00 00       	callq  8cfd <sys_clock_tick_get_32>
    823b:	89 c5                	mov    %eax,%ebp
	return posix_irq_lock();
    823d:	e8 64 e1 ff ff       	callq  63a6 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
    8242:	4c 8d 2d d7 71 00 00 	lea    0x71d7(%rip),%r13        # f420 <_kernel>
    8249:	41 89 c4             	mov    %eax,%r12d
    824c:	49 8b 7d 10          	mov    0x10(%r13),%rdi
    8250:	e8 af fe ff ff       	callq  8104 <unready_thread>
    8255:	49 8b 45 10          	mov    0x10(%r13),%rax
    8259:	48 8d 35 05 03 00 00 	lea    0x305(%rip),%rsi        # 8565 <z_thread_timeout>
    8260:	48 89 da             	mov    %rbx,%rdx

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    8263:	01 eb                	add    %ebp,%ebx
    8265:	48 8d 78 28          	lea    0x28(%rax),%rdi
    8269:	e8 02 08 00 00       	callq  8a70 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    826e:	49 8b 45 10          	mov    0x10(%r13),%rax
    8272:	44 89 e7             	mov    %r12d,%edi
	thread->base.thread_state |= _THREAD_SUSPENDED;
    8275:	80 48 19 10          	orb    $0x10,0x19(%rax)
    8279:	e8 66 d5 ff ff       	callq  57e4 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    827e:	e8 7a 0a 00 00       	callq  8cfd <sys_clock_tick_get_32>
	if (ticks > 0) {
    8283:	ba 00 00 00 00       	mov    $0x0,%edx
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    8288:	89 c0                	mov    %eax,%eax
    828a:	48 29 c3             	sub    %rax,%rbx
    828d:	48 89 d8             	mov    %rbx,%rax
    8290:	48 0f 48 c2          	cmovs  %rdx,%rax
		return ticks;
	}
#endif

	return 0;
}
    8294:	5a                   	pop    %rdx
    8295:	5b                   	pop    %rbx
    8296:	5d                   	pop    %rbp
    8297:	41 5c                	pop    %r12
    8299:	41 5d                	pop    %r13
    829b:	c3                   	retq   

000000000000829c <z_impl_k_thread_suspend>:
{
    829c:	f3 0f 1e fa          	endbr64 
    82a0:	41 54                	push   %r12
    82a2:	55                   	push   %rbp
    82a3:	53                   	push   %rbx
    82a4:	48 89 fb             	mov    %rdi,%rbx
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    82a7:	48 83 c7 28          	add    $0x28,%rdi
    82ab:	e8 dc 08 00 00       	callq  8b8c <z_abort_timeout>
    82b0:	e8 f1 e0 ff ff       	callq  63a6 <posix_irq_lock>
    82b5:	48 8d 2d 64 71 00 00 	lea    0x7164(%rip),%rbp        # f420 <_kernel>
    82bc:	41 89 c4             	mov    %eax,%r12d
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    82bf:	8a 43 19             	mov    0x19(%rbx),%al
		if (z_is_thread_queued(thread)) {
    82c2:	84 c0                	test   %al,%al
    82c4:	79 12                	jns    82d8 <z_impl_k_thread_suspend+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    82c6:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    82c9:	48 89 de             	mov    %rbx,%rsi
    82cc:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    82d0:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    82d3:	e8 86 fd ff ff       	callq  805e <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    82d8:	80 4b 19 10          	orb    $0x10,0x19(%rbx)
		update_cache(thread == _current);
    82dc:	31 ff                	xor    %edi,%edi
    82de:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    82e2:	40 0f 94 c7          	sete   %dil
    82e6:	e8 c7 fd ff ff       	callq  80b2 <update_cache>
	posix_irq_unlock(key);
    82eb:	44 89 e7             	mov    %r12d,%edi
    82ee:	e8 c1 e0 ff ff       	callq  63b4 <posix_irq_unlock>
	if (thread == _current) {
    82f3:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    82f7:	75 09                	jne    8302 <z_impl_k_thread_suspend+0x66>
}
    82f9:	5b                   	pop    %rbx
    82fa:	5d                   	pop    %rbp
    82fb:	41 5c                	pop    %r12
		z_reschedule_unlocked();
    82fd:	e9 2e fd ff ff       	jmpq   8030 <z_reschedule_unlocked>
}
    8302:	5b                   	pop    %rbx
    8303:	5d                   	pop    %rbp
    8304:	41 5c                	pop    %r12
    8306:	c3                   	retq   

0000000000008307 <k_sched_unlock>:
{
    8307:	f3 0f 1e fa          	endbr64 
    830b:	55                   	push   %rbp
	return posix_irq_lock();
    830c:	e8 95 e0 ff ff       	callq  63a6 <posix_irq_lock>
		update_cache(0);
    8311:	31 ff                	xor    %edi,%edi
    8313:	89 c5                	mov    %eax,%ebp
		++_current->base.sched_locked;
    8315:	48 8d 05 04 71 00 00 	lea    0x7104(%rip),%rax        # f420 <_kernel>
    831c:	48 8b 40 10          	mov    0x10(%rax),%rax
    8320:	fe 40 1b             	incb   0x1b(%rax)
		update_cache(0);
    8323:	e8 8a fd ff ff       	callq  80b2 <update_cache>
	posix_irq_unlock(key);
    8328:	89 ef                	mov    %ebp,%edi
    832a:	e8 85 e0 ff ff       	callq  63b4 <posix_irq_unlock>
}
    832f:	5d                   	pop    %rbp
	z_reschedule_unlocked();
    8330:	e9 fb fc ff ff       	jmpq   8030 <z_reschedule_unlocked>

0000000000008335 <move_thread_to_end_of_prio_q>:
{
    8335:	41 54                	push   %r12
    8337:	4c 8d 25 e2 70 00 00 	lea    0x70e2(%rip),%r12        # f420 <_kernel>
    833e:	55                   	push   %rbp
    833f:	53                   	push   %rbx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    8340:	8a 47 19             	mov    0x19(%rdi),%al
    8343:	48 89 fb             	mov    %rdi,%rbx
	if (z_is_thread_queued(thread)) {
    8346:	84 c0                	test   %al,%al
    8348:	79 13                	jns    835d <move_thread_to_end_of_prio_q+0x28>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    834a:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    834d:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8350:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    8353:	49 8d 7c 24 40       	lea    0x40(%r12),%rdi
    8358:	e8 01 fd ff ff       	callq  805e <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    835d:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	return list->head == list;
    8361:	49 8b 6c 24 40       	mov    0x40(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8366:	48 85 ed             	test   %rbp,%rbp
    8369:	74 0a                	je     8375 <move_thread_to_end_of_prio_q+0x40>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    836b:	49 8d 44 24 40       	lea    0x40(%r12),%rax
    8370:	48 39 c5             	cmp    %rax,%rbp
    8373:	75 1b                	jne    8390 <move_thread_to_end_of_prio_q+0x5b>
	sys_dnode_t *const tail = list->tail;
    8375:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	node->next = list;
    837a:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
    837f:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    8382:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    8386:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    8389:	49 89 5c 24 48       	mov    %rbx,0x48(%r12)
}
    838e:	eb 33                	jmp    83c3 <move_thread_to_end_of_prio_q+0x8e>
		if (z_sched_prio_cmp(thread, t) > 0) {
    8390:	48 89 ee             	mov    %rbp,%rsi
    8393:	48 89 df             	mov    %rbx,%rdi
    8396:	e8 94 fb ff ff       	callq  7f2f <z_sched_prio_cmp>
    839b:	85 c0                	test   %eax,%eax
    839d:	7e 14                	jle    83b3 <move_thread_to_end_of_prio_q+0x7e>
	sys_dnode_t *const prev = successor->prev;
    839f:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    83a3:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = prev;
    83a6:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    83aa:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    83ad:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    83b1:	eb 10                	jmp    83c3 <move_thread_to_end_of_prio_q+0x8e>
	return (node == list->tail) ? NULL : node->next;
    83b3:	49 39 6c 24 48       	cmp    %rbp,0x48(%r12)
    83b8:	74 bb                	je     8375 <move_thread_to_end_of_prio_q+0x40>
    83ba:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    83be:	48 85 ed             	test   %rbp,%rbp
    83c1:	eb b0                	jmp    8373 <move_thread_to_end_of_prio_q+0x3e>
	update_cache(thread == _current);
    83c3:	31 ff                	xor    %edi,%edi
    83c5:	49 39 5c 24 10       	cmp    %rbx,0x10(%r12)
}
    83ca:	5b                   	pop    %rbx
	update_cache(thread == _current);
    83cb:	40 0f 94 c7          	sete   %dil
}
    83cf:	5d                   	pop    %rbp
    83d0:	41 5c                	pop    %r12
	update_cache(thread == _current);
    83d2:	e9 db fc ff ff       	jmpq   80b2 <update_cache>

00000000000083d7 <z_time_slice>:
{
    83d7:	f3 0f 1e fa          	endbr64 
    83db:	55                   	push   %rbp
    83dc:	53                   	push   %rbx
    83dd:	89 fb                	mov    %edi,%ebx
    83df:	52                   	push   %rdx
	return posix_irq_lock();
    83e0:	e8 c1 df ff ff       	callq  63a6 <posix_irq_lock>
	if (slice_time && sliceable(_current)) {
    83e5:	83 3d b8 71 00 00 00 	cmpl   $0x0,0x71b8(%rip)        # f5a4 <slice_time>
    83ec:	89 c5                	mov    %eax,%ebp
    83ee:	48 8d 05 2b 70 00 00 	lea    0x702b(%rip),%rax        # f420 <_kernel>
    83f5:	74 40                	je     8437 <z_time_slice+0x60>
    83f7:	48 8b 78 10          	mov    0x10(%rax),%rdi
		&& !z_is_idle_thread_object(thread);
    83fb:	66 83 7f 1a 7f       	cmpw   $0x7f,0x1a(%rdi)
    8400:	77 35                	ja     8437 <z_time_slice+0x60>
		&& !z_is_thread_prevented_from_running(thread)
    8402:	f6 47 19 1f          	testb  $0x1f,0x19(%rdi)
    8406:	75 2f                	jne    8437 <z_time_slice+0x60>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    8408:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
		&& !z_is_idle_thread_object(thread);
    840c:	39 15 8e 71 00 00    	cmp    %edx,0x718e(%rip)        # f5a0 <slice_max_prio>
    8412:	7f 23                	jg     8437 <z_time_slice+0x60>
    8414:	48 3b 3d 95 3b 00 00 	cmp    0x3b95(%rip),%rdi        # bfb0 <_GLOBAL_OFFSET_TABLE_+0x1d8>
    841b:	74 1a                	je     8437 <z_time_slice+0x60>
		if (ticks >= _current_cpu->slice_ticks) {
    841d:	8b 50 20             	mov    0x20(%rax),%edx
    8420:	39 da                	cmp    %ebx,%edx
    8422:	7f 0c                	jg     8430 <z_time_slice+0x59>
			move_thread_to_end_of_prio_q(_current);
    8424:	e8 0c ff ff ff       	callq  8335 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    8429:	e8 18 fb ff ff       	callq  7f46 <z_reset_time_slice>
    842e:	eb 0e                	jmp    843e <z_time_slice+0x67>
			_current_cpu->slice_ticks -= ticks;
    8430:	29 da                	sub    %ebx,%edx
    8432:	89 50 20             	mov    %edx,0x20(%rax)
    8435:	eb 07                	jmp    843e <z_time_slice+0x67>
		_current_cpu->slice_ticks = 0;
    8437:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
}
    843e:	58                   	pop    %rax
	posix_irq_unlock(key);
    843f:	89 ef                	mov    %ebp,%edi
    8441:	5b                   	pop    %rbx
    8442:	5d                   	pop    %rbp
    8443:	e9 6c df ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008448 <ready_thread>:
    8448:	8a 47 19             	mov    0x19(%rdi),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    844b:	84 c0                	test   %al,%al
    844d:	0f 88 95 00 00 00    	js     84e8 <ready_thread+0xa0>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    8453:	a8 1f                	test   $0x1f,%al
    8455:	0f 85 8d 00 00 00    	jne    84e8 <ready_thread+0xa0>
{
    845b:	41 54                	push   %r12
    845d:	55                   	push   %rbp
    845e:	53                   	push   %rbx
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    845f:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
    8464:	48 89 fb             	mov    %rdi,%rbx
    8467:	75 7a                	jne    84e3 <ready_thread+0x9b>
	return list->head == list;
    8469:	4c 8d 25 b0 6f 00 00 	lea    0x6fb0(%rip),%r12        # f420 <_kernel>
	thread->base.thread_state |= _THREAD_QUEUED;
    8470:	83 c8 80             	or     $0xffffff80,%eax
    8473:	88 47 19             	mov    %al,0x19(%rdi)
    8476:	49 8b 6c 24 40       	mov    0x40(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    847b:	48 85 ed             	test   %rbp,%rbp
    847e:	74 0a                	je     848a <ready_thread+0x42>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8480:	49 8d 44 24 40       	lea    0x40(%r12),%rax
    8485:	48 39 c5             	cmp    %rax,%rbp
    8488:	75 1b                	jne    84a5 <ready_thread+0x5d>
	sys_dnode_t *const tail = list->tail;
    848a:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	node->next = list;
    848f:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
    8494:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    8497:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    849b:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    849e:	49 89 5c 24 48       	mov    %rbx,0x48(%r12)
}
    84a3:	eb 33                	jmp    84d8 <ready_thread+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
    84a5:	48 89 ee             	mov    %rbp,%rsi
    84a8:	48 89 df             	mov    %rbx,%rdi
    84ab:	e8 7f fa ff ff       	callq  7f2f <z_sched_prio_cmp>
    84b0:	85 c0                	test   %eax,%eax
    84b2:	7e 14                	jle    84c8 <ready_thread+0x80>
	sys_dnode_t *const prev = successor->prev;
    84b4:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    84b8:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = prev;
    84bb:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    84bf:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    84c2:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    84c6:	eb 10                	jmp    84d8 <ready_thread+0x90>
	return (node == list->tail) ? NULL : node->next;
    84c8:	49 39 6c 24 48       	cmp    %rbp,0x48(%r12)
    84cd:	74 bb                	je     848a <ready_thread+0x42>
    84cf:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    84d3:	48 85 ed             	test   %rbp,%rbp
    84d6:	eb b0                	jmp    8488 <ready_thread+0x40>
}
    84d8:	5b                   	pop    %rbx
		update_cache(0);
    84d9:	31 ff                	xor    %edi,%edi
}
    84db:	5d                   	pop    %rbp
    84dc:	41 5c                	pop    %r12
		update_cache(0);
    84de:	e9 cf fb ff ff       	jmpq   80b2 <update_cache>
}
    84e3:	5b                   	pop    %rbx
    84e4:	5d                   	pop    %rbp
    84e5:	41 5c                	pop    %r12
    84e7:	c3                   	retq   
    84e8:	c3                   	retq   

00000000000084e9 <z_ready_thread>:
{
    84e9:	f3 0f 1e fa          	endbr64 
    84ed:	55                   	push   %rbp
    84ee:	48 83 ec 10          	sub    $0x10,%rsp
    84f2:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    84f7:	e8 aa de ff ff       	callq  63a6 <posix_irq_lock>
			ready_thread(thread);
    84fc:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    8501:	89 c5                	mov    %eax,%ebp
    8503:	e8 40 ff ff ff       	callq  8448 <ready_thread>
}
    8508:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    850c:	89 ef                	mov    %ebp,%edi
    850e:	5d                   	pop    %rbp
    850f:	e9 a0 de ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008514 <z_sched_start>:
{
    8514:	f3 0f 1e fa          	endbr64 
    8518:	41 54                	push   %r12
    851a:	48 83 ec 10          	sub    $0x10,%rsp
    851e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    8523:	e8 7e de ff ff       	callq  63a6 <posix_irq_lock>
	if (z_has_thread_started(thread)) {
    8528:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    852d:	41 89 c4             	mov    %eax,%r12d
    8530:	8a 47 19             	mov    0x19(%rdi),%al
    8533:	a8 04                	test   $0x4,%al
    8535:	75 0e                	jne    8545 <z_sched_start+0x31>
}
    8537:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    853b:	44 89 e7             	mov    %r12d,%edi
    853e:	41 5c                	pop    %r12
    8540:	e9 6f de ff ff       	jmpq   63b4 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    8545:	83 e0 fb             	and    $0xfffffffb,%eax
    8548:	88 47 19             	mov    %al,0x19(%rdi)
	ready_thread(thread);
    854b:	e8 f8 fe ff ff       	callq  8448 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    8550:	48 8d 3d 60 70 00 00 	lea    0x7060(%rip),%rdi        # f5b7 <sched_spinlock>
}
    8557:	48 83 c4 10          	add    $0x10,%rsp
	z_reschedule(&sched_spinlock, key);
    855b:	44 89 e6             	mov    %r12d,%esi
}
    855e:	41 5c                	pop    %r12
	z_reschedule(&sched_spinlock, key);
    8560:	e9 85 fa ff ff       	jmpq   7fea <z_reschedule>

0000000000008565 <z_thread_timeout>:
{
    8565:	f3 0f 1e fa          	endbr64 
    8569:	41 54                	push   %r12
    856b:	55                   	push   %rbp
    856c:	53                   	push   %rbx
    856d:	48 89 fb             	mov    %rdi,%rbx
	return posix_irq_lock();
    8570:	e8 31 de ff ff       	callq  63a6 <posix_irq_lock>
    8575:	89 c5                	mov    %eax,%ebp
		if (!killed) {
    8577:	f6 43 f1 28          	testb  $0x28,-0xf(%rbx)
    857b:	75 1f                	jne    859c <z_thread_timeout+0x37>
			if (thread->base.pended_on != NULL) {
    857d:	48 83 7b e8 00       	cmpq   $0x0,-0x18(%rbx)
	struct k_thread *thread = CONTAINER_OF(timeout,
    8582:	4c 8d 63 d8          	lea    -0x28(%rbx),%r12
			if (thread->base.pended_on != NULL) {
    8586:	74 08                	je     8590 <z_thread_timeout+0x2b>
				unpend_thread_no_timeout(thread);
    8588:	4c 89 e7             	mov    %r12,%rdi
    858b:	e8 f0 fa ff ff       	callq  8080 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    8590:	80 63 f1 eb          	andb   $0xeb,-0xf(%rbx)
			ready_thread(thread);
    8594:	4c 89 e7             	mov    %r12,%rdi
    8597:	e8 ac fe ff ff       	callq  8448 <ready_thread>
}
    859c:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    859d:	89 ef                	mov    %ebp,%edi
    859f:	5d                   	pop    %rbp
    85a0:	41 5c                	pop    %r12
    85a2:	e9 0d de ff ff       	jmpq   63b4 <posix_irq_unlock>

00000000000085a7 <z_unpend_first_thread>:
{
    85a7:	f3 0f 1e fa          	endbr64 
    85ab:	41 54                	push   %r12
    85ad:	55                   	push   %rbp
    85ae:	48 83 ec 18          	sub    $0x18,%rsp
    85b2:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    85b7:	e8 ea dd ff ff       	callq  63a6 <posix_irq_lock>
		thread = _priq_wait_best(&wait_q->waitq);
    85bc:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    85c1:	89 c5                	mov    %eax,%ebp
    85c3:	e8 d6 fa ff ff       	callq  809e <z_priq_dumb_best>
    85c8:	49 89 c4             	mov    %rax,%r12
		if (thread != NULL) {
    85cb:	48 85 c0             	test   %rax,%rax
    85ce:	74 12                	je     85e2 <z_unpend_first_thread+0x3b>
			unpend_thread_no_timeout(thread);
    85d0:	48 89 c7             	mov    %rax,%rdi
    85d3:	e8 a8 fa ff ff       	callq  8080 <unpend_thread_no_timeout>
    85d8:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
    85dd:	e8 aa 05 00 00       	callq  8b8c <z_abort_timeout>
	posix_irq_unlock(key);
    85e2:	89 ef                	mov    %ebp,%edi
    85e4:	e8 cb dd ff ff       	callq  63b4 <posix_irq_unlock>
}
    85e9:	48 83 c4 18          	add    $0x18,%rsp
    85ed:	4c 89 e0             	mov    %r12,%rax
    85f0:	5d                   	pop    %rbp
    85f1:	41 5c                	pop    %r12
    85f3:	c3                   	retq   

00000000000085f4 <z_sched_init>:
{
    85f4:	f3 0f 1e fa          	endbr64 
	list->head = (sys_dnode_t *)list;
    85f8:	48 8d 05 21 6e 00 00 	lea    0x6e21(%rip),%rax        # f420 <_kernel>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    85ff:	31 f6                	xor    %esi,%esi
    8601:	31 ff                	xor    %edi,%edi
    8603:	48 8d 50 40          	lea    0x40(%rax),%rdx
    8607:	48 89 50 40          	mov    %rdx,0x40(%rax)
	list->tail = (sys_dnode_t *)list;
    860b:	48 89 50 48          	mov    %rdx,0x48(%rax)
    860f:	e9 60 f9 ff ff       	jmpq   7f74 <k_sched_time_slice_set>

0000000000008614 <z_impl_k_yield>:
{
    8614:	f3 0f 1e fa          	endbr64 
    8618:	41 55                	push   %r13
    861a:	41 54                	push   %r12
    861c:	55                   	push   %rbp
    861d:	53                   	push   %rbx
    861e:	52                   	push   %rdx
	if (!z_is_idle_thread_object(_current)) {
    861f:	48 8d 2d fa 6d 00 00 	lea    0x6dfa(%rip),%rbp        # f420 <_kernel>
    8626:	48 8d 05 b3 6c 00 00 	lea    0x6cb3(%rip),%rax        # f2e0 <z_idle_threads>
    862d:	48 39 45 10          	cmp    %rax,0x10(%rbp)
    8631:	0f 84 8e 00 00 00    	je     86c5 <z_impl_k_yield+0xb1>
	return posix_irq_lock();
    8637:	e8 6a dd ff ff       	callq  63a6 <posix_irq_lock>
			dequeue_thread(&_kernel.ready_q.runq,
    863c:	48 8b 75 10          	mov    0x10(%rbp),%rsi
		_priq_run_remove(pq, thread);
    8640:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    8644:	41 89 c5             	mov    %eax,%r13d
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8647:	80 66 19 7f          	andb   $0x7f,0x19(%rsi)
		_priq_run_remove(pq, thread);
    864b:	e8 0e fa ff ff       	callq  805e <z_priq_dumb_remove>
		queue_thread(&_kernel.ready_q.runq, _current);
    8650:	48 8b 5d 10          	mov    0x10(%rbp),%rbx
	thread->base.thread_state |= _THREAD_QUEUED;
    8654:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	return list->head == list;
    8658:	4c 8b 65 40          	mov    0x40(%rbp),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    865c:	4d 85 e4             	test   %r12,%r12
    865f:	74 09                	je     866a <z_impl_k_yield+0x56>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8661:	48 8d 45 40          	lea    0x40(%rbp),%rax
    8665:	49 39 c4             	cmp    %rax,%r12
    8668:	75 18                	jne    8682 <z_impl_k_yield+0x6e>
	sys_dnode_t *const tail = list->tail;
    866a:	48 8b 45 48          	mov    0x48(%rbp),%rax
	node->next = list;
    866e:	48 8d 55 40          	lea    0x40(%rbp),%rdx
    8672:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    8675:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    8679:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    867c:	48 89 5d 48          	mov    %rbx,0x48(%rbp)
}
    8680:	eb 34                	jmp    86b6 <z_impl_k_yield+0xa2>
		if (z_sched_prio_cmp(thread, t) > 0) {
    8682:	4c 89 e6             	mov    %r12,%rsi
    8685:	48 89 df             	mov    %rbx,%rdi
    8688:	e8 a2 f8 ff ff       	callq  7f2f <z_sched_prio_cmp>
    868d:	85 c0                	test   %eax,%eax
    868f:	7e 16                	jle    86a7 <z_impl_k_yield+0x93>
	sys_dnode_t *const prev = successor->prev;
    8691:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
    8696:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = prev;
    8699:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    869d:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    86a0:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
    86a5:	eb 0f                	jmp    86b6 <z_impl_k_yield+0xa2>
	return (node == list->tail) ? NULL : node->next;
    86a7:	4c 39 65 48          	cmp    %r12,0x48(%rbp)
    86ab:	74 bd                	je     866a <z_impl_k_yield+0x56>
    86ad:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    86b1:	4d 85 e4             	test   %r12,%r12
    86b4:	eb b2                	jmp    8668 <z_impl_k_yield+0x54>
		update_cache(1);
    86b6:	bf 01 00 00 00       	mov    $0x1,%edi
    86bb:	e8 f2 f9 ff ff       	callq  80b2 <update_cache>
    86c0:	44 89 ef             	mov    %r13d,%edi
    86c3:	eb 07                	jmp    86cc <z_impl_k_yield+0xb8>
    86c5:	e8 dc dc ff ff       	callq  63a6 <posix_irq_lock>
    86ca:	89 c7                	mov    %eax,%edi
}
    86cc:	58                   	pop    %rax
    86cd:	5b                   	pop    %rbx
    86ce:	5d                   	pop    %rbp
    86cf:	41 5c                	pop    %r12
    86d1:	41 5d                	pop    %r13
    86d3:	e9 0c d1 ff ff       	jmpq   57e4 <arch_swap>

00000000000086d8 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    86d8:	f3 0f 1e fa          	endbr64 
    86dc:	51                   	push   %rcx

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    86dd:	48 83 ff ff          	cmp    $0xffffffffffffffff,%rdi
    86e1:	75 15                	jne    86f8 <z_impl_k_sleep+0x20>
		k_thread_suspend(_current);
    86e3:	48 8d 05 36 6d 00 00 	lea    0x6d36(%rip),%rax        # f420 <_kernel>
    86ea:	48 8b 78 10          	mov    0x10(%rax),%rdi
	z_impl_k_thread_suspend(thread);
    86ee:	e8 a9 fb ff ff       	callq  829c <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    86f3:	83 c8 ff             	or     $0xffffffff,%eax
}
    86f6:	eb 16                	jmp    870e <z_impl_k_sleep+0x36>
	if (ticks == 0) {
    86f8:	48 85 ff             	test   %rdi,%rdi
    86fb:	75 09                	jne    8706 <z_impl_k_sleep+0x2e>
	z_impl_k_yield();
    86fd:	e8 12 ff ff ff       	callq  8614 <z_impl_k_yield>
		return 0;
    8702:	31 c0                	xor    %eax,%eax
}
    8704:	eb 05                	jmp    870b <z_impl_k_sleep+0x33>
    8706:	e8 21 fb ff ff       	callq  822c <z_tick_sleep.part.0>

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
    870b:	6b c0 0a             	imul   $0xa,%eax,%eax
}
    870e:	5a                   	pop    %rdx
    870f:	c3                   	retq   

0000000000008710 <z_impl_k_usleep>:
}
#include <syscalls/k_sleep_mrsh.c>
#endif

int32_t z_impl_k_usleep(int us)
{
    8710:	f3 0f 1e fa          	endbr64 
	int32_t ticks;

	ticks = k_us_to_ticks_ceil64(us);
    8714:	48 63 c7             	movslq %edi,%rax
    8717:	31 d2                	xor    %edx,%edx
{
    8719:	51                   	push   %rcx
    871a:	b9 10 27 00 00       	mov    $0x2710,%ecx
		t += off;
    871f:	48 05 0f 27 00 00    	add    $0x270f,%rax
			return t / (from_hz / to_hz);
    8725:	48 f7 f1             	div    %rcx
	ticks = z_tick_sleep(ticks);
    8728:	48 63 f8             	movslq %eax,%rdi
	if (ticks == 0) {
    872b:	48 85 ff             	test   %rdi,%rdi
    872e:	75 09                	jne    8739 <z_impl_k_usleep+0x29>
	z_impl_k_yield();
    8730:	e8 df fe ff ff       	callq  8614 <z_impl_k_yield>
		return 0;
    8735:	31 c0                	xor    %eax,%eax
}
    8737:	eb 05                	jmp    873e <z_impl_k_usleep+0x2e>
    8739:	e8 ee fa ff ff       	callq  822c <z_tick_sleep.part.0>
	return k_ticks_to_us_floor64(ticks);
    873e:	48 98                	cltq   
}
    8740:	5a                   	pop    %rdx
			return t * (to_hz / from_hz);
    8741:	48 69 c0 10 27 00 00 	imul   $0x2710,%rax,%rax
    8748:	c3                   	retq   

0000000000008749 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
    8749:	f3 0f 1e fa          	endbr64 
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    874d:	48 8d 05 cc 6c 00 00 	lea    0x6ccc(%rip),%rax        # f420 <_kernel>

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    8754:	48 8b 40 10          	mov    0x10(%rax),%rax
}
    8758:	c3                   	retq   

0000000000008759 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    8759:	f3 0f 1e fa          	endbr64 
    875d:	41 55                	push   %r13
    875f:	41 54                	push   %r12
    8761:	55                   	push   %rbp
    8762:	53                   	push   %rbx
    8763:	48 89 fb             	mov    %rdi,%rbx
    8766:	52                   	push   %rdx
    8767:	e8 3a dc ff ff       	callq  63a6 <posix_irq_lock>
    876c:	41 89 c4             	mov    %eax,%r12d
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    876f:	8a 43 19             	mov    0x19(%rbx),%al
    8772:	a8 08                	test   $0x8,%al
    8774:	0f 85 9b 00 00 00    	jne    8815 <z_thread_abort+0xbc>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    877a:	89 c2                	mov    %eax,%edx
    877c:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
    877f:	80 ca 08             	or     $0x8,%dl
    8782:	78 05                	js     8789 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    8784:	88 53 19             	mov    %dl,0x19(%rbx)
    8787:	eb 1c                	jmp    87a5 <z_thread_abort+0x4c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8789:	83 e0 5f             	and    $0x5f,%eax
		_priq_run_remove(pq, thread);
    878c:	48 89 de             	mov    %rbx,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    878f:	83 c8 08             	or     $0x8,%eax
    8792:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    8795:	48 8d 05 84 6c 00 00 	lea    0x6c84(%rip),%rax        # f420 <_kernel>
    879c:	48 8d 78 40          	lea    0x40(%rax),%rdi
    87a0:	e8 b9 f8 ff ff       	callq  805e <z_priq_dumb_remove>
		if (thread->base.pended_on != NULL) {
    87a5:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
    87aa:	74 08                	je     87b4 <z_thread_abort+0x5b>
			unpend_thread_no_timeout(thread);
    87ac:	48 89 df             	mov    %rbx,%rdi
    87af:	e8 cc f8 ff ff       	callq  8080 <unpend_thread_no_timeout>
    87b4:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    87b8:	4c 8d 6b 60          	lea    0x60(%rbx),%r13
    87bc:	e8 cb 03 00 00       	callq  8b8c <z_abort_timeout>
	return list->head == list;
    87c1:	48 8b 6b 60          	mov    0x60(%rbx),%rbp
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    87c5:	48 85 ed             	test   %rbp,%rbp
    87c8:	74 27                	je     87f1 <z_thread_abort+0x98>
    87ca:	4c 39 ed             	cmp    %r13,%rbp
    87cd:	74 22                	je     87f1 <z_thread_abort+0x98>
		unpend_thread_no_timeout(thread);
    87cf:	48 89 ef             	mov    %rbp,%rdi
    87d2:	e8 a9 f8 ff ff       	callq  8080 <unpend_thread_no_timeout>
    87d7:	48 8d 7d 28          	lea    0x28(%rbp),%rdi
    87db:	e8 ac 03 00 00       	callq  8b8c <z_abort_timeout>
	thread->callee_saved.retval = value;
    87e0:	c7 45 4c 00 00 00 00 	movl   $0x0,0x4c(%rbp)
		ready_thread(thread);
    87e7:	48 89 ef             	mov    %rbp,%rdi
    87ea:	e8 59 fc ff ff       	callq  8448 <ready_thread>
    87ef:	eb d0                	jmp    87c1 <z_thread_abort+0x68>
		update_cache(1);
    87f1:	bf 01 00 00 00       	mov    $0x1,%edi
    87f6:	e8 b7 f8 ff ff       	callq  80b2 <update_cache>
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
    87fb:	48 8d 05 1e 6c 00 00 	lea    0x6c1e(%rip),%rax        # f420 <_kernel>
    8802:	48 39 58 10          	cmp    %rbx,0x10(%rax)
    8806:	75 0d                	jne    8815 <z_thread_abort+0xbc>
    8808:	83 38 00             	cmpl   $0x0,(%rax)
    880b:	75 08                	jne    8815 <z_thread_abort+0xbc>
    880d:	44 89 e7             	mov    %r12d,%edi
    8810:	e8 cf cf ff ff       	callq  57e4 <arch_swap>
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    8815:	58                   	pop    %rax
	posix_irq_unlock(key);
    8816:	44 89 e7             	mov    %r12d,%edi
    8819:	5b                   	pop    %rbx
    881a:	5d                   	pop    %rbp
    881b:	41 5c                	pop    %r12
    881d:	41 5d                	pop    %r13
    881f:	e9 90 db ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008824 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    8824:	f3 0f 1e fa          	endbr64 
	z_sched_start(thread);
    8828:	e9 e7 fc ff ff       	jmpq   8514 <z_sched_start>

000000000000882d <z_init_thread_base>:
}
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    882d:	f3 0f 1e fa          	endbr64 
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    8831:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    8838:	00 
	thread_base->user_options = (uint8_t)options;
    8839:	88 4f 18             	mov    %cl,0x18(%rdi)
	thread_base->thread_state = (uint8_t)initial_state;
    883c:	88 57 19             	mov    %dl,0x19(%rdi)

	thread_base->prio = priority;
    883f:	40 88 77 1a          	mov    %sil,0x1a(%rdi)

	thread_base->sched_locked = 0U;
    8843:	c6 47 1b 00          	movb   $0x0,0x1b(%rdi)
	node->next = NULL;
    8847:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
    884e:	00 
	node->prev = NULL;
    884f:	48 c7 47 30 00 00 00 	movq   $0x0,0x30(%rdi)
    8856:	00 
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    8857:	c3                   	retq   

0000000000008858 <z_setup_new_thread>:
{
    8858:	f3 0f 1e fa          	endbr64 
    885c:	41 55                	push   %r13
	sys_dlist_init(&w->waitq);
    885e:	48 8d 47 60          	lea    0x60(%rdi),%rax
    8862:	49 89 cd             	mov    %rcx,%r13
    8865:	41 54                	push   %r12
    8867:	49 89 d4             	mov    %rdx,%r12
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    886a:	ba 04 00 00 00       	mov    $0x4,%edx
{
    886f:	55                   	push   %rbp
    8870:	48 89 f5             	mov    %rsi,%rbp
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    8873:	49 83 c4 07          	add    $0x7,%r12
{
    8877:	53                   	push   %rbx
    8878:	48 89 fb             	mov    %rdi,%rbx
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    887b:	49 83 e4 f8          	and    $0xfffffffffffffff8,%r12
	stack_ptr = (char *)stack + stack_obj_size;
    887f:	49 01 ec             	add    %rbp,%r12
{
    8882:	48 83 ec 18          	sub    $0x18,%rsp
	list->head = (sys_dnode_t *)list;
    8886:	48 89 47 60          	mov    %rax,0x60(%rdi)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    888a:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
    888e:	8b 74 24 48          	mov    0x48(%rsp),%esi
	list->tail = (sys_dnode_t *)list;
    8892:	48 89 47 68          	mov    %rax,0x68(%rdi)
{
    8896:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    889b:	4c 89 0c 24          	mov    %r9,(%rsp)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    889f:	e8 89 ff ff ff       	callq  882d <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    88a4:	4c 89 e9             	mov    %r13,%rcx
    88a7:	4c 89 e2             	mov    %r12,%rdx
    88aa:	48 89 ee             	mov    %rbp,%rsi
    88ad:	50                   	push   %rax
    88ae:	48 89 df             	mov    %rbx,%rdi
    88b1:	ff 74 24 48          	pushq  0x48(%rsp)
    88b5:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
    88ba:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    88bf:	e8 89 cf ff ff       	callq  584d <arch_new_thread>
	if (!_current) {
    88c4:	48 8d 05 55 6b 00 00 	lea    0x6b55(%rip),%rax        # f420 <_kernel>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    88cb:	5a                   	pop    %rdx
	new_thread->init_data = NULL;
    88cc:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    88d3:	00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    88d4:	59                   	pop    %rcx
	if (!_current) {
    88d5:	48 8b 40 10          	mov    0x10(%rax),%rax
    88d9:	48 85 c0             	test   %rax,%rax
    88dc:	74 04                	je     88e2 <z_setup_new_thread+0x8a>
	new_thread->resource_pool = _current->resource_pool;
    88de:	48 8b 40 78          	mov    0x78(%rax),%rax
	return stack_ptr;
    88e2:	48 89 43 78          	mov    %rax,0x78(%rbx)
}
    88e6:	48 83 c4 18          	add    $0x18,%rsp
    88ea:	4c 89 e0             	mov    %r12,%rax
    88ed:	5b                   	pop    %rbx
    88ee:	5d                   	pop    %rbp
    88ef:	41 5c                	pop    %r12
    88f1:	41 5d                	pop    %r13
    88f3:	c3                   	retq   

00000000000088f4 <z_init_static_threads>:
{
    88f4:	f3 0f 1e fa          	endbr64 
    88f8:	55                   	push   %rbp
    88f9:	53                   	push   %rbx
    88fa:	52                   	push   %rdx
	_FOREACH_STATIC_THREAD(thread_data) {
    88fb:	48 8d 1d 7e 60 00 00 	lea    0x607e(%rip),%rbx        # e980 <_k_thread_data_processing_tid>
    8902:	48 89 dd             	mov    %rbx,%rbp
    8905:	48 3b 1d ac 36 00 00 	cmp    0x36ac(%rip),%rbx        # bfb8 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    890c:	73 3a                	jae    8948 <z_init_static_threads+0x54>
		z_setup_new_thread(
    890e:	4c 8b 4b 28          	mov    0x28(%rbx),%r9
    8912:	4c 8b 43 20          	mov    0x20(%rbx),%r8
    8916:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    891a:	8b 53 10             	mov    0x10(%rbx),%edx
    891d:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    8921:	ff 73 50             	pushq  0x50(%rbx)
    8924:	8b 43 3c             	mov    0x3c(%rbx),%eax
    8927:	50                   	push   %rax
    8928:	8b 43 38             	mov    0x38(%rbx),%eax
    892b:	50                   	push   %rax
    892c:	ff 73 30             	pushq  0x30(%rbx)
    892f:	48 8b 3b             	mov    (%rbx),%rdi
    8932:	e8 21 ff ff ff       	callq  8858 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    8937:	48 8b 03             	mov    (%rbx),%rax
		z_setup_new_thread(
    893a:	48 83 c4 20          	add    $0x20,%rsp
		thread_data->init_thread->init_data = thread_data;
    893e:	48 89 58 58          	mov    %rbx,0x58(%rax)
	_FOREACH_STATIC_THREAD(thread_data) {
    8942:	48 83 c3 58          	add    $0x58,%rbx
    8946:	eb bd                	jmp    8905 <z_init_static_threads+0x11>
	k_sched_lock();
    8948:	e8 f1 f6 ff ff       	callq  803e <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    894d:	48 89 eb             	mov    %rbp,%rbx
					    K_MSEC(thread_data->init_delay));
    8950:	31 ed                	xor    %ebp,%ebp
	_FOREACH_STATIC_THREAD(thread_data) {
    8952:	48 3b 1d 5f 36 00 00 	cmp    0x365f(%rip),%rbx        # bfb8 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    8959:	73 46                	jae    89a1 <z_init_static_threads+0xad>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    895b:	8b 43 40             	mov    0x40(%rbx),%eax
    895e:	83 f8 ff             	cmp    $0xffffffff,%eax
    8961:	74 38                	je     899b <z_init_static_threads+0xa7>
					    K_MSEC(thread_data->init_delay));
    8963:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
    8965:	48 8b 3b             	mov    (%rbx),%rdi
					    K_MSEC(thread_data->init_delay));
    8968:	0f 48 c5             	cmovs  %ebp,%eax
    896b:	48 63 c8             	movslq %eax,%rcx
		t += off;
    896e:	48 8d 41 09          	lea    0x9(%rcx),%rax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    8972:	48 85 c9             	test   %rcx,%rcx
    8975:	75 07                	jne    897e <z_init_static_threads+0x8a>
	z_impl_k_thread_start(thread);
    8977:	e8 a8 fe ff ff       	callq  8824 <z_impl_k_thread_start>
}
    897c:	eb 1d                	jmp    899b <z_init_static_threads+0xa7>
			return t / (from_hz / to_hz);
    897e:	b9 0a 00 00 00       	mov    $0xa,%ecx
    8983:	31 d2                	xor    %edx,%edx
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    8985:	48 8d 35 d9 fb ff ff 	lea    -0x427(%rip),%rsi        # 8565 <z_thread_timeout>
    898c:	48 83 c7 28          	add    $0x28,%rdi
    8990:	48 f7 f1             	div    %rcx
    8993:	48 89 c2             	mov    %rax,%rdx
    8996:	e8 d5 00 00 00       	callq  8a70 <z_add_timeout>
	_FOREACH_STATIC_THREAD(thread_data) {
    899b:	48 83 c3 58          	add    $0x58,%rbx
    899f:	eb b1                	jmp    8952 <z_init_static_threads+0x5e>
}
    89a1:	58                   	pop    %rax
    89a2:	5b                   	pop    %rbx
    89a3:	5d                   	pop    %rbp
	k_sched_unlock();
    89a4:	e9 5e f9 ff ff       	jmpq   8307 <k_sched_unlock>

00000000000089a9 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    89a9:	f3 0f 1e fa          	endbr64 
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    89ad:	48 8d 15 05 0b 00 00 	lea    0xb05(%rip),%rdx        # 94b9 <default_cmd+0x259>
    89b4:	48 8d 35 eb 1b 00 00 	lea    0x1beb(%rip),%rsi        # a5a6 <default_cmd+0x1346>
    89bb:	31 c0                	xor    %eax,%eax
    89bd:	48 8d 3d 03 1c 00 00 	lea    0x1c03(%rip),%rdi        # a5c7 <default_cmd+0x1367>
    89c4:	e9 ad a6 ff ff       	jmpq   3076 <printk>

00000000000089c9 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    89c9:	83 3d d8 6b 00 00 00 	cmpl   $0x0,0x6bd8(%rip)        # f5a8 <announce_remaining>
    89d0:	75 05                	jne    89d7 <elapsed+0xe>
    89d2:	e9 a3 b5 ff ff       	jmpq   3f7a <sys_clock_elapsed>
}
    89d7:	31 c0                	xor    %eax,%eax
    89d9:	c3                   	retq   

00000000000089da <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    89da:	48 8b 07             	mov    (%rdi),%rax
    89dd:	48 85 ff             	test   %rdi,%rdi
    89e0:	74 16                	je     89f8 <remove_timeout+0x1e>
	return (node == list->tail) ? NULL : node->next;
    89e2:	48 3b 3d 4f 3a 00 00 	cmp    0x3a4f(%rip),%rdi        # c438 <timeout_list+0x8>
    89e9:	74 0d                	je     89f8 <remove_timeout+0x1e>
	if (next(t) != NULL) {
    89eb:	48 85 c0             	test   %rax,%rax
    89ee:	74 08                	je     89f8 <remove_timeout+0x1e>
		next(t)->dticks += t->dticks;
    89f0:	48 8b 57 18          	mov    0x18(%rdi),%rdx
    89f4:	48 01 50 18          	add    %rdx,0x18(%rax)
	sys_dnode_t *const prev = node->prev;
    89f8:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	prev->next = next;
    89fc:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
    89ff:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    8a03:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
    8a0a:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    8a11:	00 
}
    8a12:	c3                   	retq   

0000000000008a13 <next_timeout>:

static int32_t next_timeout(void)
{
    8a13:	53                   	push   %rbx
	return list->head == list;
    8a14:	48 8b 1d 15 3a 00 00 	mov    0x3a15(%rip),%rbx        # c430 <timeout_list>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8a1b:	48 8d 05 0e 3a 00 00 	lea    0x3a0e(%rip),%rax        # c430 <timeout_list>
    8a22:	48 39 c3             	cmp    %rax,%rbx
    8a25:	75 02                	jne    8a29 <next_timeout+0x16>
    8a27:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    8a29:	e8 9b ff ff ff       	callq  89c9 <elapsed>
    8a2e:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
    8a30:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    8a35:	48 85 db             	test   %rbx,%rbx
    8a38:	74 21                	je     8a5b <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    8a3a:	48 63 c2             	movslq %edx,%rax
    8a3d:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    8a41:	48 29 c2             	sub    %rax,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    8a44:	31 c0                	xor    %eax,%eax
    8a46:	48 85 d2             	test   %rdx,%rdx
    8a49:	7e 10                	jle    8a5b <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    8a4b:	48 81 fa ff ff ff 7f 	cmp    $0x7fffffff,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    8a52:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    8a57:	48 0f 4e c2          	cmovle %rdx,%rax

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    8a5b:	48 8d 15 be 69 00 00 	lea    0x69be(%rip),%rdx        # f420 <_kernel>
    8a62:	8b 52 20             	mov    0x20(%rdx),%edx
    8a65:	85 d2                	test   %edx,%edx
    8a67:	74 05                	je     8a6e <next_timeout+0x5b>
    8a69:	39 d0                	cmp    %edx,%eax
    8a6b:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    8a6e:	5b                   	pop    %rbx
    8a6f:	c3                   	retq   

0000000000008a70 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    8a70:	f3 0f 1e fa          	endbr64 
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    8a74:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    8a78:	0f 84 0d 01 00 00    	je     8b8b <z_add_timeout+0x11b>
{
    8a7e:	41 56                	push   %r14
    8a80:	49 89 f6             	mov    %rsi,%r14
    8a83:	41 55                	push   %r13
    8a85:	49 89 d5             	mov    %rdx,%r13
    8a88:	41 54                	push   %r12
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    8a8a:	49 c7 c4 fe ff ff ff 	mov    $0xfffffffffffffffe,%r12
{
    8a91:	55                   	push   %rbp
	k_ticks_t ticks = timeout.ticks + 1;
    8a92:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
{
    8a96:	53                   	push   %rbx
    8a97:	48 89 fb             	mov    %rdi,%rbx
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    8a9a:	49 39 ec             	cmp    %rbp,%r12
    8a9d:	78 17                	js     8ab6 <z_add_timeout+0x46>
		ticks = Z_TICK_ABS(timeout.ticks) - (curr_tick + elapsed());
    8a9f:	e8 25 ff ff ff       	callq  89c9 <elapsed>
    8aa4:	4c 89 e5             	mov    %r12,%rbp
    8aa7:	48 2b 2d aa 6a 00 00 	sub    0x6aaa(%rip),%rbp        # f558 <curr_tick>
    8aae:	4c 29 ed             	sub    %r13,%rbp
    8ab1:	48 98                	cltq   
    8ab3:	48 29 c5             	sub    %rax,%rbp
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    8ab6:	4c 89 73 10          	mov    %r14,0x10(%rbx)
	return posix_irq_lock();
    8aba:	e8 e7 d8 ff ff       	callq  63a6 <posix_irq_lock>
    8abf:	41 89 c4             	mov    %eax,%r12d
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    8ac2:	e8 02 ff ff ff       	callq  89c9 <elapsed>
	ticks = MAX(1, ticks);
    8ac7:	48 85 ed             	test   %rbp,%rbp
    8aca:	ba 01 00 00 00       	mov    $0x1,%edx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8acf:	48 8b 3d 62 39 00 00 	mov    0x3962(%rip),%rdi        # c438 <timeout_list+0x8>
    8ad6:	48 0f 4e ea          	cmovle %rdx,%rbp
		to->dticks = ticks + elapsed();
    8ada:	48 98                	cltq   
	return list->head == list;
    8adc:	48 8d 15 4d 39 00 00 	lea    0x394d(%rip),%rdx        # c430 <timeout_list>
    8ae3:	48 01 c5             	add    %rax,%rbp
    8ae6:	48 8b 05 43 39 00 00 	mov    0x3943(%rip),%rax        # c430 <timeout_list>
    8aed:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8af1:	48 39 d0             	cmp    %rdx,%rax
    8af4:	74 3e                	je     8b34 <z_add_timeout+0xc4>
		for (t = first(); t != NULL; t = next(t)) {
    8af6:	48 85 c0             	test   %rax,%rax
    8af9:	74 39                	je     8b34 <z_add_timeout+0xc4>
			if (t->dticks > to->dticks) {
    8afb:	48 8b 70 18          	mov    0x18(%rax),%rsi
    8aff:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    8b03:	48 39 ce             	cmp    %rcx,%rsi
    8b06:	7e 1b                	jle    8b23 <z_add_timeout+0xb3>
				t->dticks -= to->dticks;
    8b08:	48 29 ce             	sub    %rcx,%rsi
	sys_dnode_t *const prev = successor->prev;
    8b0b:	48 8b 48 08          	mov    0x8(%rax),%rcx
    8b0f:	48 89 70 18          	mov    %rsi,0x18(%rax)
	node->prev = prev;
    8b13:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	node->next = successor;
    8b17:	48 89 03             	mov    %rax,(%rbx)
	prev->next = node;
    8b1a:	48 89 19             	mov    %rbx,(%rcx)
	successor->prev = node;
    8b1d:	48 89 58 08          	mov    %rbx,0x8(%rax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    8b21:	eb 29                	jmp    8b4c <z_add_timeout+0xdc>
			to->dticks -= t->dticks;
    8b23:	48 29 f1             	sub    %rsi,%rcx
    8b26:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
	return (node == list->tail) ? NULL : node->next;
    8b2a:	48 39 f8             	cmp    %rdi,%rax
    8b2d:	74 05                	je     8b34 <z_add_timeout+0xc4>
    8b2f:	48 8b 00             	mov    (%rax),%rax
    8b32:	eb c2                	jmp    8af6 <z_add_timeout+0x86>
	sys_dnode_t *const tail = list->tail;
    8b34:	48 8b 05 fd 38 00 00 	mov    0x38fd(%rip),%rax        # c438 <timeout_list+0x8>
	node->next = list;
    8b3b:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    8b3e:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    8b42:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    8b45:	48 89 1d ec 38 00 00 	mov    %rbx,0x38ec(%rip)        # c438 <timeout_list+0x8>
	return list->head == list;
    8b4c:	48 8b 05 dd 38 00 00 	mov    0x38dd(%rip),%rax        # c430 <timeout_list>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    8b53:	48 39 c3             	cmp    %rax,%rbx
    8b56:	75 23                	jne    8b7b <z_add_timeout+0x10b>
    8b58:	48 39 d0             	cmp    %rdx,%rax
    8b5b:	74 1e                	je     8b7b <z_add_timeout+0x10b>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    8b5d:	e8 b1 fe ff ff       	callq  8a13 <next_timeout>
    8b62:	89 c7                	mov    %eax,%edi

			if (next_time == 0 ||
    8b64:	85 c0                	test   %eax,%eax
    8b66:	74 0c                	je     8b74 <z_add_timeout+0x104>
			    _current_cpu->slice_ticks != next_time) {
    8b68:	48 8d 05 b1 68 00 00 	lea    0x68b1(%rip),%rax        # f420 <_kernel>
			if (next_time == 0 ||
    8b6f:	39 78 20             	cmp    %edi,0x20(%rax)
    8b72:	74 07                	je     8b7b <z_add_timeout+0x10b>
				sys_clock_set_timeout(next_time, false);
    8b74:	31 f6                	xor    %esi,%esi
    8b76:	e8 d8 b3 ff ff       	callq  3f53 <sys_clock_set_timeout>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    8b7b:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    8b7c:	44 89 e7             	mov    %r12d,%edi
    8b7f:	5d                   	pop    %rbp
    8b80:	41 5c                	pop    %r12
    8b82:	41 5d                	pop    %r13
    8b84:	41 5e                	pop    %r14
    8b86:	e9 29 d8 ff ff       	jmpq   63b4 <posix_irq_unlock>
    8b8b:	c3                   	retq   

0000000000008b8c <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    8b8c:	f3 0f 1e fa          	endbr64 
    8b90:	41 54                	push   %r12
    8b92:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
    8b98:	48 83 ec 10          	sub    $0x10,%rsp
    8b9c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    8ba1:	e8 00 d8 ff ff       	callq  63a6 <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    8ba6:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    8bab:	41 89 c0             	mov    %eax,%r8d
    8bae:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    8bb2:	74 08                	je     8bbc <z_abort_timeout+0x30>
			remove_timeout(to);
    8bb4:	e8 21 fe ff ff       	callq  89da <remove_timeout>
			ret = 0;
    8bb9:	45 31 e4             	xor    %r12d,%r12d
	posix_irq_unlock(key);
    8bbc:	44 89 c7             	mov    %r8d,%edi
    8bbf:	e8 f0 d7 ff ff       	callq  63b4 <posix_irq_unlock>
		}
	}

	return ret;
}
    8bc4:	48 83 c4 10          	add    $0x10,%rsp
    8bc8:	44 89 e0             	mov    %r12d,%eax
    8bcb:	41 5c                	pop    %r12
    8bcd:	c3                   	retq   

0000000000008bce <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    8bce:	f3 0f 1e fa          	endbr64 
    8bd2:	41 54                	push   %r12
    8bd4:	55                   	push   %rbp
    8bd5:	89 fd                	mov    %edi,%ebp
    8bd7:	53                   	push   %rbx
    8bd8:	89 f3                	mov    %esi,%ebx
	return posix_irq_lock();
    8bda:	e8 c7 d7 ff ff       	callq  63a6 <posix_irq_lock>
    8bdf:	41 89 c4             	mov    %eax,%r12d
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    8be2:	e8 2c fe ff ff       	callq  8a13 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
    8be7:	83 f8 ff             	cmp    $0xffffffff,%eax
    8bea:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
    8bed:	39 e8                	cmp    %ebp,%eax
    8bef:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    8bf2:	08 d1                	or     %dl,%cl
    8bf4:	74 14                	je     8c0a <z_set_timeout_expiry+0x3c>
    8bf6:	83 f8 01             	cmp    $0x1,%eax
    8bf9:	7e 0f                	jle    8c0a <z_set_timeout_expiry+0x3c>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    8bfb:	39 e8                	cmp    %ebp,%eax
    8bfd:	89 ef                	mov    %ebp,%edi
    8bff:	0f b6 f3             	movzbl %bl,%esi
    8c02:	0f 4e f8             	cmovle %eax,%edi
    8c05:	e8 49 b3 ff ff       	callq  3f53 <sys_clock_set_timeout>
		}
	}
}
    8c0a:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    8c0b:	44 89 e7             	mov    %r12d,%edi
    8c0e:	5d                   	pop    %rbp
    8c0f:	41 5c                	pop    %r12
    8c11:	e9 9e d7 ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008c16 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    8c16:	f3 0f 1e fa          	endbr64 
    8c1a:	41 54                	push   %r12
    8c1c:	4c 8d 25 0d 38 00 00 	lea    0x380d(%rip),%r12        # c430 <timeout_list>
    8c23:	55                   	push   %rbp
    8c24:	53                   	push   %rbx
    8c25:	89 fb                	mov    %edi,%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    8c27:	e8 ab f7 ff ff       	callq  83d7 <z_time_slice>
	return posix_irq_lock();
    8c2c:	e8 75 d7 ff ff       	callq  63a6 <posix_irq_lock>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    8c31:	89 1d 71 69 00 00    	mov    %ebx,0x6971(%rip)        # f5a8 <announce_remaining>
    8c37:	89 c5                	mov    %eax,%ebp
    8c39:	48 63 15 68 69 00 00 	movslq 0x6968(%rip),%rdx        # f5a8 <announce_remaining>
    8c40:	49 8b 1c 24          	mov    (%r12),%rbx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    8c44:	48 8b 35 0d 69 00 00 	mov    0x690d(%rip),%rsi        # f558 <curr_tick>
    8c4b:	48 89 d1             	mov    %rdx,%rcx

	while (first() != NULL && first()->dticks <= announce_remaining) {
    8c4e:	48 85 db             	test   %rbx,%rbx
    8c51:	74 50                	je     8ca3 <sys_clock_announce+0x8d>
    8c53:	4c 39 e3             	cmp    %r12,%rbx
    8c56:	74 4b                	je     8ca3 <sys_clock_announce+0x8d>
    8c58:	48 8b 43 18          	mov    0x18(%rbx),%rax
    8c5c:	48 39 d0             	cmp    %rdx,%rax
    8c5f:	7f 3b                	jg     8c9c <sys_clock_announce+0x86>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
    8c61:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    8c68:	00 
		curr_tick += dt;
    8c69:	48 63 d0             	movslq %eax,%rdx
		announce_remaining -= dt;
    8c6c:	29 c1                	sub    %eax,%ecx
		remove_timeout(t);
    8c6e:	48 89 df             	mov    %rbx,%rdi
		curr_tick += dt;
    8c71:	48 01 f2             	add    %rsi,%rdx
		announce_remaining -= dt;
    8c74:	89 0d 2e 69 00 00    	mov    %ecx,0x692e(%rip)        # f5a8 <announce_remaining>
		curr_tick += dt;
    8c7a:	48 89 15 d7 68 00 00 	mov    %rdx,0x68d7(%rip)        # f558 <curr_tick>
		remove_timeout(t);
    8c81:	e8 54 fd ff ff       	callq  89da <remove_timeout>
	posix_irq_unlock(key);
    8c86:	89 ef                	mov    %ebp,%edi
    8c88:	e8 27 d7 ff ff       	callq  63b4 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    8c8d:	48 89 df             	mov    %rbx,%rdi
    8c90:	ff 53 10             	callq  *0x10(%rbx)
	return posix_irq_lock();
    8c93:	e8 0e d7 ff ff       	callq  63a6 <posix_irq_lock>
    8c98:	89 c5                	mov    %eax,%ebp
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    8c9a:	eb 9d                	jmp    8c39 <sys_clock_announce+0x23>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    8c9c:	48 29 d0             	sub    %rdx,%rax
    8c9f:	48 89 43 18          	mov    %rax,0x18(%rbx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    8ca3:	c7 05 fb 68 00 00 00 	movl   $0x0,0x68fb(%rip)        # f5a8 <announce_remaining>
    8caa:	00 00 00 
	curr_tick += announce_remaining;
    8cad:	48 01 f2             	add    %rsi,%rdx
    8cb0:	48 89 15 a1 68 00 00 	mov    %rdx,0x68a1(%rip)        # f558 <curr_tick>

	sys_clock_set_timeout(next_timeout(), false);
    8cb7:	e8 57 fd ff ff       	callq  8a13 <next_timeout>
    8cbc:	31 f6                	xor    %esi,%esi
    8cbe:	89 c7                	mov    %eax,%edi
    8cc0:	e8 8e b2 ff ff       	callq  3f53 <sys_clock_set_timeout>

	k_spin_unlock(&timeout_lock, key);
}
    8cc5:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    8cc6:	89 ef                	mov    %ebp,%edi
    8cc8:	5d                   	pop    %rbp
    8cc9:	41 5c                	pop    %r12
    8ccb:	e9 e4 d6 ff ff       	jmpq   63b4 <posix_irq_unlock>

0000000000008cd0 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    8cd0:	f3 0f 1e fa          	endbr64 
    8cd4:	41 54                	push   %r12
    8cd6:	55                   	push   %rbp
    8cd7:	50                   	push   %rax
	return posix_irq_lock();
    8cd8:	e8 c9 d6 ff ff       	callq  63a6 <posix_irq_lock>
    8cdd:	89 c5                	mov    %eax,%ebp
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    8cdf:	e8 96 b2 ff ff       	callq  3f7a <sys_clock_elapsed>
	posix_irq_unlock(key);
    8ce4:	89 ef                	mov    %ebp,%edi
    8ce6:	41 89 c4             	mov    %eax,%r12d
    8ce9:	4c 03 25 68 68 00 00 	add    0x6868(%rip),%r12        # f558 <curr_tick>
    8cf0:	e8 bf d6 ff ff       	callq  63b4 <posix_irq_unlock>
	}
	return t;
}
    8cf5:	4c 89 e0             	mov    %r12,%rax
    8cf8:	5a                   	pop    %rdx
    8cf9:	5d                   	pop    %rbp
    8cfa:	41 5c                	pop    %r12
    8cfc:	c3                   	retq   

0000000000008cfd <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    8cfd:	f3 0f 1e fa          	endbr64 
    8d01:	50                   	push   %rax
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    8d02:	e8 c9 ff ff ff       	callq  8cd0 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    8d07:	5a                   	pop    %rdx
    8d08:	c3                   	retq   

0000000000008d09 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    8d09:	f3 0f 1e fa          	endbr64 
    8d0d:	50                   	push   %rax
	return posix_irq_lock();
    8d0e:	e8 93 d6 ff ff       	callq  63a6 <posix_irq_lock>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    8d13:	e8 27 c6 ff ff       	callq  533f <arch_cpu_idle>
    8d18:	eb f4                	jmp    8d0e <idle+0x5>

0000000000008d1a <k_heap_init>:
#include <ksched.h>
#include <wait_q.h>
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
    8d1a:	f3 0f 1e fa          	endbr64 
    8d1e:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = (sys_dnode_t *)list;
    8d22:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
    8d26:	48 89 47 20          	mov    %rax,0x20(%rdi)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    8d2a:	e9 ce a4 ff ff       	jmpq   31fd <sys_heap_init>

0000000000008d2f <statics_init>:
}

static int statics_init(const struct device *unused)
{
    8d2f:	f3 0f 1e fa          	endbr64 
    8d33:	53                   	push   %rbx
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    8d34:	48 8d 1d 4d 5d 00 00 	lea    0x5d4d(%rip),%rbx        # ea88 <processing_msgq>
    8d3b:	48 3b 1d 7e 32 00 00 	cmp    0x327e(%rip),%rbx        # bfc0 <_GLOBAL_OFFSET_TABLE_+0x1e8>
    8d42:	73 16                	jae    8d5a <statics_init+0x2b>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    8d44:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    8d48:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    8d4c:	48 89 df             	mov    %rbx,%rdi
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    8d4f:	48 83 c3 28          	add    $0x28,%rbx
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    8d53:	e8 c2 ff ff ff       	callq  8d1a <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    8d58:	eb e1                	jmp    8d3b <statics_init+0xc>
	}
	return 0;
}
    8d5a:	31 c0                	xor    %eax,%eax
    8d5c:	5b                   	pop    %rbx
    8d5d:	c3                   	retq   

0000000000008d5e <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
    8d5e:	f3 0f 1e fa          	endbr64 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
    8d62:	c3                   	retq   

Disassembly of section .fini:

0000000000008d64 <_fini>:
    8d64:	f3 0f 1e fa          	endbr64 
    8d68:	48 83 ec 08          	sub    $0x8,%rsp
    8d6c:	48 83 c4 08          	add    $0x8,%rsp
    8d70:	c3                   	retq   
