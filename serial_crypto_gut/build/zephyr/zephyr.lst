
zephyr.elf:     file format elf64-x86-64


Disassembly of section .init:

0000000000003000 <_init>:
    3000:	f3 0f 1e fa          	endbr64 
    3004:	48 83 ec 08          	sub    $0x8,%rsp
    3008:	48 8b 05 c1 9f 00 00 	mov    0x9fc1(%rip),%rax        # cfd0 <__gmon_start__>
    300f:	48 85 c0             	test   %rax,%rax
    3012:	74 02                	je     3016 <_init+0x16>
    3014:	ff d0                	callq  *%rax
    3016:	48 83 c4 08          	add    $0x8,%rsp
    301a:	c3                   	retq   

Disassembly of section .plt:

0000000000003020 <.plt>:
    3020:	ff 35 ba 9d 00 00    	pushq  0x9dba(%rip)        # cde0 <_GLOBAL_OFFSET_TABLE_+0x8>
    3026:	f2 ff 25 bb 9d 00 00 	bnd jmpq *0x9dbb(%rip)        # cde8 <_GLOBAL_OFFSET_TABLE_+0x10>
    302d:	0f 1f 00             	nopl   (%rax)
    3030:	f3 0f 1e fa          	endbr64 
    3034:	68 00 00 00 00       	pushq  $0x0
    3039:	f2 e9 e1 ff ff ff    	bnd jmpq 3020 <.plt>
    303f:	90                   	nop
    3040:	f3 0f 1e fa          	endbr64 
    3044:	68 01 00 00 00       	pushq  $0x1
    3049:	f2 e9 d1 ff ff ff    	bnd jmpq 3020 <.plt>
    304f:	90                   	nop
    3050:	f3 0f 1e fa          	endbr64 
    3054:	68 02 00 00 00       	pushq  $0x2
    3059:	f2 e9 c1 ff ff ff    	bnd jmpq 3020 <.plt>
    305f:	90                   	nop
    3060:	f3 0f 1e fa          	endbr64 
    3064:	68 03 00 00 00       	pushq  $0x3
    3069:	f2 e9 b1 ff ff ff    	bnd jmpq 3020 <.plt>
    306f:	90                   	nop
    3070:	f3 0f 1e fa          	endbr64 
    3074:	68 04 00 00 00       	pushq  $0x4
    3079:	f2 e9 a1 ff ff ff    	bnd jmpq 3020 <.plt>
    307f:	90                   	nop
    3080:	f3 0f 1e fa          	endbr64 
    3084:	68 05 00 00 00       	pushq  $0x5
    3089:	f2 e9 91 ff ff ff    	bnd jmpq 3020 <.plt>
    308f:	90                   	nop
    3090:	f3 0f 1e fa          	endbr64 
    3094:	68 06 00 00 00       	pushq  $0x6
    3099:	f2 e9 81 ff ff ff    	bnd jmpq 3020 <.plt>
    309f:	90                   	nop
    30a0:	f3 0f 1e fa          	endbr64 
    30a4:	68 07 00 00 00       	pushq  $0x7
    30a9:	f2 e9 71 ff ff ff    	bnd jmpq 3020 <.plt>
    30af:	90                   	nop
    30b0:	f3 0f 1e fa          	endbr64 
    30b4:	68 08 00 00 00       	pushq  $0x8
    30b9:	f2 e9 61 ff ff ff    	bnd jmpq 3020 <.plt>
    30bf:	90                   	nop
    30c0:	f3 0f 1e fa          	endbr64 
    30c4:	68 09 00 00 00       	pushq  $0x9
    30c9:	f2 e9 51 ff ff ff    	bnd jmpq 3020 <.plt>
    30cf:	90                   	nop
    30d0:	f3 0f 1e fa          	endbr64 
    30d4:	68 0a 00 00 00       	pushq  $0xa
    30d9:	f2 e9 41 ff ff ff    	bnd jmpq 3020 <.plt>
    30df:	90                   	nop
    30e0:	f3 0f 1e fa          	endbr64 
    30e4:	68 0b 00 00 00       	pushq  $0xb
    30e9:	f2 e9 31 ff ff ff    	bnd jmpq 3020 <.plt>
    30ef:	90                   	nop
    30f0:	f3 0f 1e fa          	endbr64 
    30f4:	68 0c 00 00 00       	pushq  $0xc
    30f9:	f2 e9 21 ff ff ff    	bnd jmpq 3020 <.plt>
    30ff:	90                   	nop
    3100:	f3 0f 1e fa          	endbr64 
    3104:	68 0d 00 00 00       	pushq  $0xd
    3109:	f2 e9 11 ff ff ff    	bnd jmpq 3020 <.plt>
    310f:	90                   	nop
    3110:	f3 0f 1e fa          	endbr64 
    3114:	68 0e 00 00 00       	pushq  $0xe
    3119:	f2 e9 01 ff ff ff    	bnd jmpq 3020 <.plt>
    311f:	90                   	nop
    3120:	f3 0f 1e fa          	endbr64 
    3124:	68 0f 00 00 00       	pushq  $0xf
    3129:	f2 e9 f1 fe ff ff    	bnd jmpq 3020 <.plt>
    312f:	90                   	nop
    3130:	f3 0f 1e fa          	endbr64 
    3134:	68 10 00 00 00       	pushq  $0x10
    3139:	f2 e9 e1 fe ff ff    	bnd jmpq 3020 <.plt>
    313f:	90                   	nop
    3140:	f3 0f 1e fa          	endbr64 
    3144:	68 11 00 00 00       	pushq  $0x11
    3149:	f2 e9 d1 fe ff ff    	bnd jmpq 3020 <.plt>
    314f:	90                   	nop
    3150:	f3 0f 1e fa          	endbr64 
    3154:	68 12 00 00 00       	pushq  $0x12
    3159:	f2 e9 c1 fe ff ff    	bnd jmpq 3020 <.plt>
    315f:	90                   	nop
    3160:	f3 0f 1e fa          	endbr64 
    3164:	68 13 00 00 00       	pushq  $0x13
    3169:	f2 e9 b1 fe ff ff    	bnd jmpq 3020 <.plt>
    316f:	90                   	nop
    3170:	f3 0f 1e fa          	endbr64 
    3174:	68 14 00 00 00       	pushq  $0x14
    3179:	f2 e9 a1 fe ff ff    	bnd jmpq 3020 <.plt>
    317f:	90                   	nop
    3180:	f3 0f 1e fa          	endbr64 
    3184:	68 15 00 00 00       	pushq  $0x15
    3189:	f2 e9 91 fe ff ff    	bnd jmpq 3020 <.plt>
    318f:	90                   	nop
    3190:	f3 0f 1e fa          	endbr64 
    3194:	68 16 00 00 00       	pushq  $0x16
    3199:	f2 e9 81 fe ff ff    	bnd jmpq 3020 <.plt>
    319f:	90                   	nop
    31a0:	f3 0f 1e fa          	endbr64 
    31a4:	68 17 00 00 00       	pushq  $0x17
    31a9:	f2 e9 71 fe ff ff    	bnd jmpq 3020 <.plt>
    31af:	90                   	nop
    31b0:	f3 0f 1e fa          	endbr64 
    31b4:	68 18 00 00 00       	pushq  $0x18
    31b9:	f2 e9 61 fe ff ff    	bnd jmpq 3020 <.plt>
    31bf:	90                   	nop
    31c0:	f3 0f 1e fa          	endbr64 
    31c4:	68 19 00 00 00       	pushq  $0x19
    31c9:	f2 e9 51 fe ff ff    	bnd jmpq 3020 <.plt>
    31cf:	90                   	nop
    31d0:	f3 0f 1e fa          	endbr64 
    31d4:	68 1a 00 00 00       	pushq  $0x1a
    31d9:	f2 e9 41 fe ff ff    	bnd jmpq 3020 <.plt>
    31df:	90                   	nop
    31e0:	f3 0f 1e fa          	endbr64 
    31e4:	68 1b 00 00 00       	pushq  $0x1b
    31e9:	f2 e9 31 fe ff ff    	bnd jmpq 3020 <.plt>
    31ef:	90                   	nop
    31f0:	f3 0f 1e fa          	endbr64 
    31f4:	68 1c 00 00 00       	pushq  $0x1c
    31f9:	f2 e9 21 fe ff ff    	bnd jmpq 3020 <.plt>
    31ff:	90                   	nop
    3200:	f3 0f 1e fa          	endbr64 
    3204:	68 1d 00 00 00       	pushq  $0x1d
    3209:	f2 e9 11 fe ff ff    	bnd jmpq 3020 <.plt>
    320f:	90                   	nop
    3210:	f3 0f 1e fa          	endbr64 
    3214:	68 1e 00 00 00       	pushq  $0x1e
    3219:	f2 e9 01 fe ff ff    	bnd jmpq 3020 <.plt>
    321f:	90                   	nop
    3220:	f3 0f 1e fa          	endbr64 
    3224:	68 1f 00 00 00       	pushq  $0x1f
    3229:	f2 e9 f1 fd ff ff    	bnd jmpq 3020 <.plt>
    322f:	90                   	nop
    3230:	f3 0f 1e fa          	endbr64 
    3234:	68 20 00 00 00       	pushq  $0x20
    3239:	f2 e9 e1 fd ff ff    	bnd jmpq 3020 <.plt>
    323f:	90                   	nop
    3240:	f3 0f 1e fa          	endbr64 
    3244:	68 21 00 00 00       	pushq  $0x21
    3249:	f2 e9 d1 fd ff ff    	bnd jmpq 3020 <.plt>
    324f:	90                   	nop
    3250:	f3 0f 1e fa          	endbr64 
    3254:	68 22 00 00 00       	pushq  $0x22
    3259:	f2 e9 c1 fd ff ff    	bnd jmpq 3020 <.plt>
    325f:	90                   	nop
    3260:	f3 0f 1e fa          	endbr64 
    3264:	68 23 00 00 00       	pushq  $0x23
    3269:	f2 e9 b1 fd ff ff    	bnd jmpq 3020 <.plt>
    326f:	90                   	nop
    3270:	f3 0f 1e fa          	endbr64 
    3274:	68 24 00 00 00       	pushq  $0x24
    3279:	f2 e9 a1 fd ff ff    	bnd jmpq 3020 <.plt>
    327f:	90                   	nop
    3280:	f3 0f 1e fa          	endbr64 
    3284:	68 25 00 00 00       	pushq  $0x25
    3289:	f2 e9 91 fd ff ff    	bnd jmpq 3020 <.plt>
    328f:	90                   	nop
    3290:	f3 0f 1e fa          	endbr64 
    3294:	68 26 00 00 00       	pushq  $0x26
    3299:	f2 e9 81 fd ff ff    	bnd jmpq 3020 <.plt>
    329f:	90                   	nop
    32a0:	f3 0f 1e fa          	endbr64 
    32a4:	68 27 00 00 00       	pushq  $0x27
    32a9:	f2 e9 71 fd ff ff    	bnd jmpq 3020 <.plt>
    32af:	90                   	nop
    32b0:	f3 0f 1e fa          	endbr64 
    32b4:	68 28 00 00 00       	pushq  $0x28
    32b9:	f2 e9 61 fd ff ff    	bnd jmpq 3020 <.plt>
    32bf:	90                   	nop
    32c0:	f3 0f 1e fa          	endbr64 
    32c4:	68 29 00 00 00       	pushq  $0x29
    32c9:	f2 e9 51 fd ff ff    	bnd jmpq 3020 <.plt>
    32cf:	90                   	nop
    32d0:	f3 0f 1e fa          	endbr64 
    32d4:	68 2a 00 00 00       	pushq  $0x2a
    32d9:	f2 e9 41 fd ff ff    	bnd jmpq 3020 <.plt>
    32df:	90                   	nop
    32e0:	f3 0f 1e fa          	endbr64 
    32e4:	68 2b 00 00 00       	pushq  $0x2b
    32e9:	f2 e9 31 fd ff ff    	bnd jmpq 3020 <.plt>
    32ef:	90                   	nop
    32f0:	f3 0f 1e fa          	endbr64 
    32f4:	68 2c 00 00 00       	pushq  $0x2c
    32f9:	f2 e9 21 fd ff ff    	bnd jmpq 3020 <.plt>
    32ff:	90                   	nop
    3300:	f3 0f 1e fa          	endbr64 
    3304:	68 2d 00 00 00       	pushq  $0x2d
    3309:	f2 e9 11 fd ff ff    	bnd jmpq 3020 <.plt>
    330f:	90                   	nop
    3310:	f3 0f 1e fa          	endbr64 
    3314:	68 2e 00 00 00       	pushq  $0x2e
    3319:	f2 e9 01 fd ff ff    	bnd jmpq 3020 <.plt>
    331f:	90                   	nop
    3320:	f3 0f 1e fa          	endbr64 
    3324:	68 2f 00 00 00       	pushq  $0x2f
    3329:	f2 e9 f1 fc ff ff    	bnd jmpq 3020 <.plt>
    332f:	90                   	nop
    3330:	f3 0f 1e fa          	endbr64 
    3334:	68 30 00 00 00       	pushq  $0x30
    3339:	f2 e9 e1 fc ff ff    	bnd jmpq 3020 <.plt>
    333f:	90                   	nop
    3340:	f3 0f 1e fa          	endbr64 
    3344:	68 31 00 00 00       	pushq  $0x31
    3349:	f2 e9 d1 fc ff ff    	bnd jmpq 3020 <.plt>
    334f:	90                   	nop
    3350:	f3 0f 1e fa          	endbr64 
    3354:	68 32 00 00 00       	pushq  $0x32
    3359:	f2 e9 c1 fc ff ff    	bnd jmpq 3020 <.plt>
    335f:	90                   	nop
    3360:	f3 0f 1e fa          	endbr64 
    3364:	68 33 00 00 00       	pushq  $0x33
    3369:	f2 e9 b1 fc ff ff    	bnd jmpq 3020 <.plt>
    336f:	90                   	nop
    3370:	f3 0f 1e fa          	endbr64 
    3374:	68 34 00 00 00       	pushq  $0x34
    3379:	f2 e9 a1 fc ff ff    	bnd jmpq 3020 <.plt>
    337f:	90                   	nop

Disassembly of section .plt.got:

0000000000003380 <__cxa_finalize@plt>:
    3380:	f3 0f 1e fa          	endbr64 
    3384:	f2 ff 25 5d 9c 00 00 	bnd jmpq *0x9c5d(%rip)        # cfe8 <__cxa_finalize@GLIBC_2.2.5>
    338b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .plt.sec:

0000000000003390 <ptsname@plt>:
    3390:	f3 0f 1e fa          	endbr64 
    3394:	f2 ff 25 55 9a 00 00 	bnd jmpq *0x9a55(%rip)        # cdf0 <ptsname@GLIBC_2.2.5>
    339b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000033a0 <__snprintf_chk@plt>:
    33a0:	f3 0f 1e fa          	endbr64 
    33a4:	f2 ff 25 4d 9a 00 00 	bnd jmpq *0x9a4d(%rip)        # cdf8 <__snprintf_chk@GLIBC_2.3.4>
    33ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000033b0 <free@plt>:
    33b0:	f3 0f 1e fa          	endbr64 
    33b4:	f2 ff 25 45 9a 00 00 	bnd jmpq *0x9a45(%rip)        # ce00 <free@GLIBC_2.2.5>
    33bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000033c0 <pthread_create@plt>:
    33c0:	f3 0f 1e fa          	endbr64 
    33c4:	f2 ff 25 3d 9a 00 00 	bnd jmpq *0x9a3d(%rip)        # ce08 <pthread_create@GLIBC_2.2.5>
    33cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000033d0 <strcasecmp@plt>:
    33d0:	f3 0f 1e fa          	endbr64 
    33d4:	f2 ff 25 35 9a 00 00 	bnd jmpq *0x9a35(%rip)        # ce10 <strcasecmp@GLIBC_2.2.5>
    33db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000033e0 <pthread_detach@plt>:
    33e0:	f3 0f 1e fa          	endbr64 
    33e4:	f2 ff 25 2d 9a 00 00 	bnd jmpq *0x9a2d(%rip)        # ce18 <pthread_detach@GLIBC_2.2.5>
    33eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000033f0 <__vfprintf_chk@plt>:
    33f0:	f3 0f 1e fa          	endbr64 
    33f4:	f2 ff 25 25 9a 00 00 	bnd jmpq *0x9a25(%rip)        # ce20 <__vfprintf_chk@GLIBC_2.3.4>
    33fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003400 <__errno_location@plt>:
    3400:	f3 0f 1e fa          	endbr64 
    3404:	f2 ff 25 1d 9a 00 00 	bnd jmpq *0x9a1d(%rip)        # ce28 <__errno_location@GLIBC_2.2.5>
    340b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003410 <pthread_cond_broadcast@plt>:
    3410:	f3 0f 1e fa          	endbr64 
    3414:	f2 ff 25 15 9a 00 00 	bnd jmpq *0x9a15(%rip)        # ce30 <pthread_cond_broadcast@GLIBC_2.3.2>
    341b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003420 <pthread_cancel@plt>:
    3420:	f3 0f 1e fa          	endbr64 
    3424:	f2 ff 25 0d 9a 00 00 	bnd jmpq *0x9a0d(%rip)        # ce38 <pthread_cancel@GLIBC_2.2.5>
    342b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003430 <isatty@plt>:
    3430:	f3 0f 1e fa          	endbr64 
    3434:	f2 ff 25 05 9a 00 00 	bnd jmpq *0x9a05(%rip)        # ce40 <isatty@GLIBC_2.2.5>
    343b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003440 <sigaction@plt>:
    3440:	f3 0f 1e fa          	endbr64 
    3444:	f2 ff 25 fd 99 00 00 	bnd jmpq *0x99fd(%rip)        # ce48 <sigaction@GLIBC_2.2.5>
    344b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003450 <__pthread_register_cancel@plt>:
    3450:	f3 0f 1e fa          	endbr64 
    3454:	f2 ff 25 f5 99 00 00 	bnd jmpq *0x99f5(%rip)        # ce50 <__pthread_register_cancel@GLIBC_2.3.3>
    345b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003460 <strtod@plt>:
    3460:	f3 0f 1e fa          	endbr64 
    3464:	f2 ff 25 ed 99 00 00 	bnd jmpq *0x99ed(%rip)        # ce58 <strtod@GLIBC_2.2.5>
    346b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003470 <fcntl@plt>:
    3470:	f3 0f 1e fa          	endbr64 
    3474:	f2 ff 25 e5 99 00 00 	bnd jmpq *0x99e5(%rip)        # ce60 <fcntl@GLIBC_2.2.5>
    347b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003480 <clock_gettime@plt>:
    3480:	f3 0f 1e fa          	endbr64 
    3484:	f2 ff 25 dd 99 00 00 	bnd jmpq *0x99dd(%rip)        # ce68 <clock_gettime@GLIBC_2.17>
    348b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003490 <write@plt>:
    3490:	f3 0f 1e fa          	endbr64 
    3494:	f2 ff 25 d5 99 00 00 	bnd jmpq *0x99d5(%rip)        # ce70 <write@GLIBC_2.2.5>
    349b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034a0 <pthread_cond_wait@plt>:
    34a0:	f3 0f 1e fa          	endbr64 
    34a4:	f2 ff 25 cd 99 00 00 	bnd jmpq *0x99cd(%rip)        # ce78 <pthread_cond_wait@GLIBC_2.3.2>
    34ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034b0 <__stack_chk_fail@plt>:
    34b0:	f3 0f 1e fa          	endbr64 
    34b4:	f2 ff 25 c5 99 00 00 	bnd jmpq *0x99c5(%rip)        # ce80 <__stack_chk_fail@GLIBC_2.4>
    34bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034c0 <system@plt>:
    34c0:	f3 0f 1e fa          	endbr64 
    34c4:	f2 ff 25 bd 99 00 00 	bnd jmpq *0x99bd(%rip)        # ce88 <system@GLIBC_2.2.5>
    34cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034d0 <snprintf@plt>:
    34d0:	f3 0f 1e fa          	endbr64 
    34d4:	f2 ff 25 b5 99 00 00 	bnd jmpq *0x99b5(%rip)        # ce90 <snprintf@GLIBC_2.2.5>
    34db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034e0 <nanosleep@plt>:
    34e0:	f3 0f 1e fa          	endbr64 
    34e4:	f2 ff 25 ad 99 00 00 	bnd jmpq *0x99ad(%rip)        # ce98 <nanosleep@GLIBC_2.2.5>
    34eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034f0 <strnlen@plt>:
    34f0:	f3 0f 1e fa          	endbr64 
    34f4:	f2 ff 25 a5 99 00 00 	bnd jmpq *0x99a5(%rip)        # cea0 <strnlen@GLIBC_2.2.5>
    34fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003500 <close@plt>:
    3500:	f3 0f 1e fa          	endbr64 
    3504:	f2 ff 25 9d 99 00 00 	bnd jmpq *0x999d(%rip)        # cea8 <close@GLIBC_2.2.5>
    350b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003510 <read@plt>:
    3510:	f3 0f 1e fa          	endbr64 
    3514:	f2 ff 25 95 99 00 00 	bnd jmpq *0x9995(%rip)        # ceb0 <read@GLIBC_2.2.5>
    351b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003520 <strtoull@plt>:
    3520:	f3 0f 1e fa          	endbr64 
    3524:	f2 ff 25 8d 99 00 00 	bnd jmpq *0x998d(%rip)        # ceb8 <strtoull@GLIBC_2.2.5>
    352b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003530 <calloc@plt>:
    3530:	f3 0f 1e fa          	endbr64 
    3534:	f2 ff 25 85 99 00 00 	bnd jmpq *0x9985(%rip)        # cec0 <calloc@GLIBC_2.2.5>
    353b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003540 <strcmp@plt>:
    3540:	f3 0f 1e fa          	endbr64 
    3544:	f2 ff 25 7d 99 00 00 	bnd jmpq *0x997d(%rip)        # cec8 <strcmp@GLIBC_2.2.5>
    354b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003550 <strtoll@plt>:
    3550:	f3 0f 1e fa          	endbr64 
    3554:	f2 ff 25 75 99 00 00 	bnd jmpq *0x9975(%rip)        # ced0 <strtoll@GLIBC_2.2.5>
    355b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003560 <unlockpt@plt>:
    3560:	f3 0f 1e fa          	endbr64 
    3564:	f2 ff 25 6d 99 00 00 	bnd jmpq *0x996d(%rip)        # ced8 <unlockpt@GLIBC_2.2.5>
    356b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003570 <__memcpy_chk@plt>:
    3570:	f3 0f 1e fa          	endbr64 
    3574:	f2 ff 25 65 99 00 00 	bnd jmpq *0x9965(%rip)        # cee0 <__memcpy_chk@GLIBC_2.3.4>
    357b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003580 <sigemptyset@plt>:
    3580:	f3 0f 1e fa          	endbr64 
    3584:	f2 ff 25 5d 99 00 00 	bnd jmpq *0x995d(%rip)        # cee8 <sigemptyset@GLIBC_2.2.5>
    358b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003590 <strtol@plt>:
    3590:	f3 0f 1e fa          	endbr64 
    3594:	f2 ff 25 55 99 00 00 	bnd jmpq *0x9955(%rip)        # cef0 <strtol@GLIBC_2.2.5>
    359b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000035a0 <pthread_mutex_unlock@plt>:
    35a0:	f3 0f 1e fa          	endbr64 
    35a4:	f2 ff 25 4d 99 00 00 	bnd jmpq *0x994d(%rip)        # cef8 <pthread_mutex_unlock@GLIBC_2.2.5>
    35ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000035b0 <pthread_exit@plt>:
    35b0:	f3 0f 1e fa          	endbr64 
    35b4:	f2 ff 25 45 99 00 00 	bnd jmpq *0x9945(%rip)        # cf00 <pthread_exit@GLIBC_2.2.5>
    35bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000035c0 <malloc@plt>:
    35c0:	f3 0f 1e fa          	endbr64 
    35c4:	f2 ff 25 3d 99 00 00 	bnd jmpq *0x993d(%rip)        # cf08 <malloc@GLIBC_2.2.5>
    35cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000035d0 <realloc@plt>:
    35d0:	f3 0f 1e fa          	endbr64 
    35d4:	f2 ff 25 35 99 00 00 	bnd jmpq *0x9935(%rip)        # cf10 <realloc@GLIBC_2.2.5>
    35db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000035e0 <setvbuf@plt>:
    35e0:	f3 0f 1e fa          	endbr64 
    35e4:	f2 ff 25 2d 99 00 00 	bnd jmpq *0x992d(%rip)        # cf18 <setvbuf@GLIBC_2.2.5>
    35eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000035f0 <pthread_self@plt>:
    35f0:	f3 0f 1e fa          	endbr64 
    35f4:	f2 ff 25 25 99 00 00 	bnd jmpq *0x9925(%rip)        # cf20 <pthread_self@GLIBC_2.2.5>
    35fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003600 <tcgetattr@plt>:
    3600:	f3 0f 1e fa          	endbr64 
    3604:	f2 ff 25 1d 99 00 00 	bnd jmpq *0x991d(%rip)        # cf28 <tcgetattr@GLIBC_2.2.5>
    360b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003610 <tcsetattr@plt>:
    3610:	f3 0f 1e fa          	endbr64 
    3614:	f2 ff 25 15 99 00 00 	bnd jmpq *0x9915(%rip)        # cf30 <tcsetattr@GLIBC_2.2.5>
    361b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003620 <strtoul@plt>:
    3620:	f3 0f 1e fa          	endbr64 
    3624:	f2 ff 25 0d 99 00 00 	bnd jmpq *0x990d(%rip)        # cf38 <strtoul@GLIBC_2.2.5>
    362b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003630 <grantpt@plt>:
    3630:	f3 0f 1e fa          	endbr64 
    3634:	f2 ff 25 05 99 00 00 	bnd jmpq *0x9905(%rip)        # cf40 <grantpt@GLIBC_2.2.5>
    363b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003640 <__memset_chk@plt>:
    3640:	f3 0f 1e fa          	endbr64 
    3644:	f2 ff 25 fd 98 00 00 	bnd jmpq *0x98fd(%rip)        # cf48 <__memset_chk@GLIBC_2.3.4>
    364b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003650 <__pthread_unwind_next@plt>:
    3650:	f3 0f 1e fa          	endbr64 
    3654:	f2 ff 25 f5 98 00 00 	bnd jmpq *0x98f5(%rip)        # cf50 <__pthread_unwind_next@GLIBC_2.3.3>
    365b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003660 <exit@plt>:
    3660:	f3 0f 1e fa          	endbr64 
    3664:	f2 ff 25 ed 98 00 00 	bnd jmpq *0x98ed(%rip)        # cf58 <exit@GLIBC_2.2.5>
    366b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003670 <__fprintf_chk@plt>:
    3670:	f3 0f 1e fa          	endbr64 
    3674:	f2 ff 25 e5 98 00 00 	bnd jmpq *0x98e5(%rip)        # cf60 <__fprintf_chk@GLIBC_2.3.4>
    367b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003680 <__sigsetjmp@plt>:
    3680:	f3 0f 1e fa          	endbr64 
    3684:	f2 ff 25 dd 98 00 00 	bnd jmpq *0x98dd(%rip)        # cf68 <__sigsetjmp@GLIBC_2.2.5>
    368b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003690 <posix_openpt@plt>:
    3690:	f3 0f 1e fa          	endbr64 
    3694:	f2 ff 25 d5 98 00 00 	bnd jmpq *0x98d5(%rip)        # cf70 <posix_openpt@GLIBC_2.2.5>
    369b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000036a0 <sleep@plt>:
    36a0:	f3 0f 1e fa          	endbr64 
    36a4:	f2 ff 25 cd 98 00 00 	bnd jmpq *0x98cd(%rip)        # cf78 <sleep@GLIBC_2.2.5>
    36ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000036b0 <pthread_mutex_lock@plt>:
    36b0:	f3 0f 1e fa          	endbr64 
    36b4:	f2 ff 25 c5 98 00 00 	bnd jmpq *0x98c5(%rip)        # cf80 <pthread_mutex_lock@GLIBC_2.2.5>
    36bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000036c0 <__ctype_b_loc@plt>:
    36c0:	f3 0f 1e fa          	endbr64 
    36c4:	f2 ff 25 bd 98 00 00 	bnd jmpq *0x98bd(%rip)        # cf88 <__ctype_b_loc@GLIBC_2.3>
    36cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000036d0 <__sprintf_chk@plt>:
    36d0:	f3 0f 1e fa          	endbr64 
    36d4:	f2 ff 25 b5 98 00 00 	bnd jmpq *0x98b5(%rip)        # cf90 <__sprintf_chk@GLIBC_2.3.4>
    36db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .text:

00000000000036e0 <_start>:
    36e0:	f3 0f 1e fa          	endbr64 
    36e4:	31 ed                	xor    %ebp,%ebp
    36e6:	49 89 d1             	mov    %rdx,%r9
    36e9:	5e                   	pop    %rsi
    36ea:	48 89 e2             	mov    %rsp,%rdx
    36ed:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    36f1:	50                   	push   %rax
    36f2:	54                   	push   %rsp
    36f3:	4c 8d 05 46 01 00 00 	lea    0x146(%rip),%r8        # 3840 <__libc_csu_fini>
    36fa:	48 8d 0d cf 00 00 00 	lea    0xcf(%rip),%rcx        # 37d0 <__libc_csu_init>
    3701:	48 8d 3d 24 41 00 00 	lea    0x4124(%rip),%rdi        # 782c <main>
    3708:	ff 15 ba 98 00 00    	callq  *0x98ba(%rip)        # cfc8 <__libc_start_main@GLIBC_2.2.5>
    370e:	f4                   	hlt    
    370f:	90                   	nop

0000000000003710 <deregister_tm_clones>:
    3710:	48 8d 3d 69 9d 00 00 	lea    0x9d69(%rip),%rdi        # d480 <__TMC_END__>
    3717:	48 8d 05 62 9d 00 00 	lea    0x9d62(%rip),%rax        # d480 <__TMC_END__>
    371e:	48 39 f8             	cmp    %rdi,%rax
    3721:	74 15                	je     3738 <deregister_tm_clones+0x28>
    3723:	48 8b 05 76 98 00 00 	mov    0x9876(%rip),%rax        # cfa0 <_ITM_deregisterTMCloneTable>
    372a:	48 85 c0             	test   %rax,%rax
    372d:	74 09                	je     3738 <deregister_tm_clones+0x28>
    372f:	ff e0                	jmpq   *%rax
    3731:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    3738:	c3                   	retq   
    3739:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003740 <register_tm_clones>:
    3740:	48 8d 3d 39 9d 00 00 	lea    0x9d39(%rip),%rdi        # d480 <__TMC_END__>
    3747:	48 8d 35 32 9d 00 00 	lea    0x9d32(%rip),%rsi        # d480 <__TMC_END__>
    374e:	48 29 fe             	sub    %rdi,%rsi
    3751:	48 89 f0             	mov    %rsi,%rax
    3754:	48 c1 ee 3f          	shr    $0x3f,%rsi
    3758:	48 c1 f8 03          	sar    $0x3,%rax
    375c:	48 01 c6             	add    %rax,%rsi
    375f:	48 d1 fe             	sar    %rsi
    3762:	74 14                	je     3778 <register_tm_clones+0x38>
    3764:	48 8b 05 75 98 00 00 	mov    0x9875(%rip),%rax        # cfe0 <_ITM_registerTMCloneTable>
    376b:	48 85 c0             	test   %rax,%rax
    376e:	74 08                	je     3778 <register_tm_clones+0x38>
    3770:	ff e0                	jmpq   *%rax
    3772:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    3778:	c3                   	retq   
    3779:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003780 <__do_global_dtors_aux>:
    3780:	f3 0f 1e fa          	endbr64 
    3784:	80 3d 01 cf 00 00 00 	cmpb   $0x0,0xcf01(%rip)        # 1068c <completed.8060>
    378b:	75 2b                	jne    37b8 <__do_global_dtors_aux+0x38>
    378d:	55                   	push   %rbp
    378e:	48 83 3d 52 98 00 00 	cmpq   $0x0,0x9852(%rip)        # cfe8 <__cxa_finalize@GLIBC_2.2.5>
    3795:	00 
    3796:	48 89 e5             	mov    %rsp,%rbp
    3799:	74 0c                	je     37a7 <__do_global_dtors_aux+0x27>
    379b:	48 8b 3d 9e 9c 00 00 	mov    0x9c9e(%rip),%rdi        # d440 <__dso_handle>
    37a2:	e8 d9 fb ff ff       	callq  3380 <__cxa_finalize@plt>
    37a7:	e8 64 ff ff ff       	callq  3710 <deregister_tm_clones>
    37ac:	c6 05 d9 ce 00 00 01 	movb   $0x1,0xced9(%rip)        # 1068c <completed.8060>
    37b3:	5d                   	pop    %rbp
    37b4:	c3                   	retq   
    37b5:	0f 1f 00             	nopl   (%rax)
    37b8:	c3                   	retq   
    37b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000037c0 <frame_dummy>:
    37c0:	f3 0f 1e fa          	endbr64 
    37c4:	e9 77 ff ff ff       	jmpq   3740 <register_tm_clones>
    37c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000037d0 <__libc_csu_init>:
    37d0:	f3 0f 1e fa          	endbr64 
    37d4:	41 57                	push   %r15
    37d6:	4c 8d 3d 73 93 00 00 	lea    0x9373(%rip),%r15        # cb50 <__frame_dummy_init_array_entry>
    37dd:	41 56                	push   %r14
    37df:	49 89 d6             	mov    %rdx,%r14
    37e2:	41 55                	push   %r13
    37e4:	49 89 f5             	mov    %rsi,%r13
    37e7:	41 54                	push   %r12
    37e9:	41 89 fc             	mov    %edi,%r12d
    37ec:	55                   	push   %rbp
    37ed:	48 8d 2d 64 93 00 00 	lea    0x9364(%rip),%rbp        # cb58 <__do_global_dtors_aux_fini_array_entry>
    37f4:	53                   	push   %rbx
    37f5:	4c 29 fd             	sub    %r15,%rbp
    37f8:	48 83 ec 08          	sub    $0x8,%rsp
    37fc:	e8 ff f7 ff ff       	callq  3000 <_init>
    3801:	48 c1 fd 03          	sar    $0x3,%rbp
    3805:	74 1f                	je     3826 <__libc_csu_init+0x56>
    3807:	31 db                	xor    %ebx,%ebx
    3809:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    3810:	4c 89 f2             	mov    %r14,%rdx
    3813:	4c 89 ee             	mov    %r13,%rsi
    3816:	44 89 e7             	mov    %r12d,%edi
    3819:	41 ff 14 df          	callq  *(%r15,%rbx,8)
    381d:	48 83 c3 01          	add    $0x1,%rbx
    3821:	48 39 dd             	cmp    %rbx,%rbp
    3824:	75 ea                	jne    3810 <__libc_csu_init+0x40>
    3826:	48 83 c4 08          	add    $0x8,%rsp
    382a:	5b                   	pop    %rbx
    382b:	5d                   	pop    %rbp
    382c:	41 5c                	pop    %r12
    382e:	41 5d                	pop    %r13
    3830:	41 5e                	pop    %r14
    3832:	41 5f                	pop    %r15
    3834:	c3                   	retq   
    3835:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    383c:	00 00 00 00 

0000000000003840 <__libc_csu_fini>:
    3840:	f3 0f 1e fa          	endbr64 
    3844:	c3                   	retq   

0000000000003845 <z_impl_uart_poll_in>:
				      unsigned char *p_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	return api->poll_in(dev, p_char);
    3845:	48 8b 47 10          	mov    0x10(%rdi),%rax
    3849:	ff 20                	jmpq   *(%rax)

000000000000384b <k_msgq_put.constprop.0>:
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_PUT);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_put(msgq, data, timeout);
    384b:	e9 86 56 00 00       	jmpq   8ed6 <z_impl_k_msgq_put>

0000000000003850 <k_usleep.constprop.0>:
	return z_impl_k_usleep(us);
    3850:	bf 01 00 00 00       	mov    $0x1,%edi
    3855:	e9 6f 60 00 00       	jmpq   98c9 <z_impl_k_usleep>

000000000000385a <uart_out>:
	}

	return; // sollte nie geschehen
}

void uart_out(void *ptr1, void *ptr2, void *ptr3){
    385a:	f3 0f 1e fa          	endbr64 
    385e:	41 57                	push   %r15
	// ## setup area ##
	ARG_UNUSED(ptr1);
	ARG_UNUSED(ptr2);
	ARG_UNUSED(ptr3);

	char *output=malloc(DATA_SIZE_MAX*sizeof(char));
    3860:	bf ff 00 00 00       	mov    $0xff,%edi
void uart_out(void *ptr1, void *ptr2, void *ptr3){
    3865:	41 56                	push   %r14
    3867:	41 55                	push   %r13
    3869:	41 54                	push   %r12
    386b:	55                   	push   %rbp
    386c:	53                   	push   %rbx
    386d:	50                   	push   %rax
	char *output=malloc(DATA_SIZE_MAX*sizeof(char));
    386e:	e8 4d fd ff ff       	callq  35c0 <malloc@plt>
    3873:	48 89 c5             	mov    %rax,%rbp

	// ## main loop ##
	for(;;){
		memset(output, 0, strlen(output)); // Inhalt resetten
    3876:	31 c0                	xor    %eax,%eax
    3878:	48 89 ef             	mov    %rbp,%rdi
    387b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    387f:	31 f6                	xor    %esi,%esi
    3881:	f2 ae                	repnz scas %es:(%rdi),%al
    3883:	48 89 ef             	mov    %rbp,%rdi
    3886:	48 89 c8             	mov    %rcx,%rax
    3889:	b9 ff 00 00 00       	mov    $0xff,%ecx
    388e:	48 f7 d0             	not    %rax
    3891:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3895:	e8 a6 fd ff ff       	callq  3640 <__memset_chk@plt>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
    389a:	48 8d 3d 17 c3 00 00 	lea    0xc317(%rip),%rdi        # fbb8 <uart_msgq>
    38a1:	31 d2                	xor    %edx,%edx
    38a3:	48 89 ee             	mov    %rbp,%rsi
    38a6:	e8 22 57 00 00       	callq  8fcd <z_impl_k_msgq_get>
    38ab:	41 89 c5             	mov    %eax,%r13d
		if(k_msgq_get(&uart_msgq, output, K_NO_WAIT)==0){ // Abfrage der uart message queue
    38ae:	85 c0                	test   %eax,%eax
    38b0:	0f 85 b6 00 00 00    	jne    396c <uart_out+0x112>
			printk("Going to send data to the uart: <%s>\n", output);
    38b6:	48 89 ee             	mov    %rbp,%rsi
    38b9:	48 8d 3d 08 6b 00 00 	lea    0x6b08(%rip),%rdi        # a3c8 <default_cmd+0x168>
    38c0:	31 c0                	xor    %eax,%eax
    38c2:	e8 68 09 00 00       	callq  422f <printk>
			for(int i=0; i<strlen(output); i++){ // Send data byte by byte
    38c7:	31 db                	xor    %ebx,%ebx
    38c9:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    38cd:	48 89 ef             	mov    %rbp,%rdi
    38d0:	4d 63 fd             	movslq %r13d,%r15
    38d3:	89 d8                	mov    %ebx,%eax
    38d5:	f2 ae                	repnz scas %es:(%rdi),%al
    38d7:	48 f7 d1             	not    %rcx
    38da:	48 ff c9             	dec    %rcx
    38dd:	49 39 cf             	cmp    %rcx,%r15
    38e0:	73 7e                	jae    3960 <uart_out+0x106>
				uart_poll_out(uart_dev, *(output+i));
    38e2:	4c 8d 35 77 cc 00 00 	lea    0xcc77(%rip),%r14        # 10560 <uart_dev>
    38e9:	4e 8d 64 3d 00       	lea    0x0(%rbp,%r15,1),%r12
    38ee:	41 0f b6 34 24       	movzbl (%r12),%esi
    38f3:	49 8b 3e             	mov    (%r14),%rdi
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    38f6:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    38fa:	ff 52 08             	callq  *0x8(%rdx)
				printk("Sent byte: <0x%x>\n", *(output+i));
    38fd:	41 0f be 34 24       	movsbl (%r12),%esi
    3902:	48 8d 3d e5 6a 00 00 	lea    0x6ae5(%rip),%rdi        # a3ee <default_cmd+0x18e>
    3909:	31 c0                	xor    %eax,%eax
    390b:	e8 1f 09 00 00       	callq  422f <printk>
				if(i==strlen(output)-1 && send_termination==true){
    3910:	89 d8                	mov    %ebx,%eax
    3912:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3916:	48 89 ef             	mov    %rbp,%rdi
    3919:	f2 ae                	repnz scas %es:(%rdi),%al
    391b:	48 89 cb             	mov    %rcx,%rbx
    391e:	48 f7 d3             	not    %rbx
    3921:	48 83 eb 02          	sub    $0x2,%rbx
    3925:	4c 39 fb             	cmp    %r15,%rbx
    3928:	75 29                	jne    3953 <uart_out+0xf9>
    392a:	48 8d 1d 5d cd 00 00 	lea    0xcd5d(%rip),%rbx        # 1068e <send_termination>
    3931:	80 3b 00             	cmpb   $0x0,(%rbx)
    3934:	74 1d                	je     3953 <uart_out+0xf9>
					uart_poll_out(uart_dev, 0);
    3936:	49 8b 3e             	mov    (%r14),%rdi
    3939:	48 8b 47 10          	mov    0x10(%rdi),%rax
    393d:	31 f6                	xor    %esi,%esi
    393f:	ff 50 08             	callq  *0x8(%rax)
					printk("Sent 0-termination\n");
    3942:	48 8d 3d b8 6a 00 00 	lea    0x6ab8(%rip),%rdi        # a401 <default_cmd+0x1a1>
    3949:	31 c0                	xor    %eax,%eax
    394b:	e8 df 08 00 00       	callq  422f <printk>
					send_termination = false;
    3950:	c6 03 00             	movb   $0x0,(%rbx)
				}
				k_usleep(1); // Abgeben des Prozessors
    3953:	e8 f8 fe ff ff       	callq  3850 <k_usleep.constprop.0>
			for(int i=0; i<strlen(output); i++){ // Send data byte by byte
    3958:	41 ff c5             	inc    %r13d
    395b:	e9 67 ff ff ff       	jmpq   38c7 <uart_out+0x6d>
			}
			printk("Finished transmission\n\n");
    3960:	48 8d 3d ae 6a 00 00 	lea    0x6aae(%rip),%rdi        # a415 <default_cmd+0x1b5>
    3967:	e8 c3 08 00 00       	callq  422f <printk>
		}
		k_usleep(1); // Abgeben des Prozessors
    396c:	e8 df fe ff ff       	callq  3850 <k_usleep.constprop.0>
		memset(output, 0, strlen(output)); // Inhalt resetten
    3971:	e9 00 ff ff ff       	jmpq   3876 <uart_out+0x1c>

0000000000003976 <uart_in>:
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    3976:	f3 0f 1e fa          	endbr64 
    397a:	41 57                	push   %r15
	uint8_t *data = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    397c:	bf ff 00 00 00       	mov    $0xff,%edi
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    3981:	41 56                	push   %r14
    3983:	41 55                	push   %r13
    3985:	4c 8d 2d 1c 69 00 00 	lea    0x691c(%rip),%r13        # a2a8 <default_cmd+0x48>
    398c:	41 54                	push   %r12
	uint8_t len = 0;
    398e:	45 31 e4             	xor    %r12d,%r12d
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    3991:	55                   	push   %rbp
    3992:	53                   	push   %rbx
    3993:	48 83 ec 18          	sub    $0x18,%rsp
    3997:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    399e:	00 00 
    39a0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    39a5:	31 c0                	xor    %eax,%eax
	uint8_t *data = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    39a7:	e8 14 fc ff ff       	callq  35c0 <malloc@plt>
    39ac:	48 89 c5             	mov    %rax,%rbp
		switch(state){
    39af:	48 8d 1d 8e cc 00 00 	lea    0xcc8e(%rip),%rbx        # 10644 <state>
    39b6:	83 3b 06             	cmpl   $0x6,(%rbx)
    39b9:	0f 87 fc 02 00 00    	ja     3cbb <uart_in+0x345>
    39bf:	8b 03                	mov    (%rbx),%eax
    39c1:	49 63 44 85 00       	movslq 0x0(%r13,%rax,4),%rax
    39c6:	4c 01 e8             	add    %r13,%rax
    39c9:	3e ff e0             	notrack jmpq *%rax
				if(!uart_poll_in(uart_dev, &input)){
    39cc:	48 8d 05 8d cb 00 00 	lea    0xcb8d(%rip),%rax        # 10560 <uart_dev>
    39d3:	48 8b 38             	mov    (%rax),%rdi
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&p_char, K_SYSCALL_UART_POLL_IN);
	}
#endif
	compiler_barrier();
	return z_impl_uart_poll_in(dev, p_char);
    39d6:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
    39db:	e8 65 fe ff ff       	callq  3845 <z_impl_uart_poll_in>
    39e0:	85 c0                	test   %eax,%eax
    39e2:	0f 85 d3 02 00 00    	jne    3cbb <uart_in+0x345>
					printk("received command: %c\n", (char)input);
    39e8:	0f be 74 24 07       	movsbl 0x7(%rsp),%esi
    39ed:	48 8d 3d 39 6a 00 00 	lea    0x6a39(%rip),%rdi        # a42d <default_cmd+0x1cd>
    39f4:	e8 36 08 00 00       	callq  422f <printk>
					switch(input){
    39f9:	8a 44 24 07          	mov    0x7(%rsp),%al
    39fd:	3c 49                	cmp    $0x49,%al
    39ff:	0f 84 8f 00 00 00    	je     3a94 <uart_in+0x11e>
    3a05:	77 25                	ja     3a2c <uart_in+0xb6>
    3a07:	3c 2e                	cmp    $0x2e,%al
    3a09:	74 46                	je     3a51 <uart_in+0xdb>
    3a0b:	3c 44                	cmp    $0x44,%al
    3a0d:	0f 85 a8 02 00 00    	jne    3cbb <uart_in+0x345>
							printk("Changing state to st_decrypt\n\n");
    3a13:	48 8d 3d 5c 6a 00 00 	lea    0x6a5c(%rip),%rdi        # a476 <default_cmd+0x216>
    3a1a:	31 c0                	xor    %eax,%eax
    3a1c:	e8 0e 08 00 00       	callq  422f <printk>
							state = st_decrypt;
    3a21:	c7 03 02 00 00 00    	movl   $0x2,(%rbx)
							break;
    3a27:	e9 8f 02 00 00       	jmpq   3cbb <uart_in+0x345>
    3a2c:	3c 4b                	cmp    $0x4b,%al
    3a2e:	74 4b                	je     3a7b <uart_in+0x105>
    3a30:	3c 50                	cmp    $0x50,%al
    3a32:	0f 85 83 02 00 00    	jne    3cbb <uart_in+0x345>
							printk("Changing state to st_avail\n\n");
    3a38:	48 8d 3d 1a 6a 00 00 	lea    0x6a1a(%rip),%rdi        # a459 <default_cmd+0x1f9>
    3a3f:	31 c0                	xor    %eax,%eax
    3a41:	e8 e9 07 00 00       	callq  422f <printk>
							state = st_avail;
    3a46:	c7 03 01 00 00 00    	movl   $0x1,(%rbx)
							break;
    3a4c:	e9 6a 02 00 00       	jmpq   3cbb <uart_in+0x345>
							printk("Sending '.' back\n\n");
    3a51:	48 8d 3d eb 69 00 00 	lea    0x69eb(%rip),%rdi        # a443 <default_cmd+0x1e3>
    3a58:	31 c0                	xor    %eax,%eax
    3a5a:	e8 d0 07 00 00       	callq  422f <printk>
							k_msgq_put(&uart_msgq, ".\n", K_FOREVER);
    3a5f:	48 8d 3d 52 c1 00 00 	lea    0xc152(%rip),%rdi        # fbb8 <uart_msgq>
    3a66:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    3a6a:	48 8d 35 e5 69 00 00 	lea    0x69e5(%rip),%rsi        # a456 <default_cmd+0x1f6>
    3a71:	e8 d5 fd ff ff       	callq  384b <k_msgq_put.constprop.0>
							break;
    3a76:	e9 40 02 00 00       	jmpq   3cbb <uart_in+0x345>
							printk("Changing state to st_key\n\n");
    3a7b:	48 8d 3d 13 6a 00 00 	lea    0x6a13(%rip),%rdi        # a495 <default_cmd+0x235>
    3a82:	31 c0                	xor    %eax,%eax
    3a84:	e8 a6 07 00 00       	callq  422f <printk>
							state = st_key;
    3a89:	c7 03 05 00 00 00    	movl   $0x5,(%rbx)
							break;
    3a8f:	e9 27 02 00 00       	jmpq   3cbb <uart_in+0x345>
							printk("Changing state to st_iv\n\n");
    3a94:	48 8d 3d 15 6a 00 00 	lea    0x6a15(%rip),%rdi        # a4b0 <default_cmd+0x250>
    3a9b:	31 c0                	xor    %eax,%eax
    3a9d:	e8 8d 07 00 00       	callq  422f <printk>
							state = st_iv;
    3aa2:	c7 03 06 00 00 00    	movl   $0x6,(%rbx)
    3aa8:	e9 0e 02 00 00       	jmpq   3cbb <uart_in+0x345>
				if(!uart_poll_in(uart_dev, &input)){
    3aad:	48 8d 05 ac ca 00 00 	lea    0xcaac(%rip),%rax        # 10560 <uart_dev>
    3ab4:	48 8b 38             	mov    (%rax),%rdi
    3ab7:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
    3abc:	e8 84 fd ff ff       	callq  3845 <z_impl_uart_poll_in>
    3ac1:	85 c0                	test   %eax,%eax
    3ac3:	0f 85 f2 01 00 00    	jne    3cbb <uart_in+0x345>
					op = op_decrypt;
    3ac9:	48 8d 05 70 cb 00 00 	lea    0xcb70(%rip),%rax        # 10640 <op>
					len = input;
    3ad0:	0f b6 74 24 07       	movzbl 0x7(%rsp),%esi
					printk("Length of incoming ciphertext is %i\n", len);
    3ad5:	48 8d 3d ee 69 00 00 	lea    0x69ee(%rip),%rdi        # a4ca <default_cmd+0x26a>
					op = op_decrypt;
    3adc:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
					printk("Length of incoming ciphertext is %i\n", len);
    3ae2:	31 c0                	xor    %eax,%eax
					len = input;
    3ae4:	41 89 f4             	mov    %esi,%r12d
					printk("Length of incoming ciphertext is %i\n", len);
    3ae7:	e8 43 07 00 00       	callq  422f <printk>
					printk("Changing state to st_data\n\n");
    3aec:	48 8d 3d fc 69 00 00 	lea    0x69fc(%rip),%rdi        # a4ef <default_cmd+0x28f>
    3af3:	31 c0                	xor    %eax,%eax
    3af5:	e8 35 07 00 00       	callq  422f <printk>
					state = st_data;
    3afa:	c7 03 03 00 00 00    	movl   $0x3,(%rbx)
    3b00:	e9 b6 01 00 00       	jmpq   3cbb <uart_in+0x345>
				memset(data, 0, strlen(data));
    3b05:	31 c0                	xor    %eax,%eax
    3b07:	48 89 ef             	mov    %rbp,%rdi
    3b0a:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3b0e:	31 f6                	xor    %esi,%esi
    3b10:	f2 ae                	repnz scas %es:(%rdi),%al
    3b12:	48 89 ef             	mov    %rbp,%rdi
				for(uint8_t i=0; len!=0; len--){
    3b15:	45 31 f6             	xor    %r14d,%r14d
				memset(data, 0, strlen(data));
    3b18:	48 f7 d1             	not    %rcx
    3b1b:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    3b1f:	b9 ff 00 00 00       	mov    $0xff,%ecx
    3b24:	e8 17 fb ff ff       	callq  3640 <__memset_chk@plt>
				for(uint8_t i=0; len!=0; len--){
    3b29:	48 8d 05 30 ca 00 00 	lea    0xca30(%rip),%rax        # 10560 <uart_dev>
    3b30:	45 84 e4             	test   %r12b,%r12b
    3b33:	4c 8d 7c 24 07       	lea    0x7(%rsp),%r15
    3b38:	48 8b 38             	mov    (%rax),%rdi
    3b3b:	74 40                	je     3b7d <uart_in+0x207>
    3b3d:	4c 89 fe             	mov    %r15,%rsi
    3b40:	e8 00 fd ff ff       	callq  3845 <z_impl_uart_poll_in>
					if(!uart_poll_in(uart_dev, &input)){
    3b45:	85 c0                	test   %eax,%eax
    3b47:	75 22                	jne    3b6b <uart_in+0x1f5>
						printk("received data: <0x%x>\n", input);
    3b49:	0f b6 74 24 07       	movzbl 0x7(%rsp),%esi
    3b4e:	48 8d 3d b6 69 00 00 	lea    0x69b6(%rip),%rdi        # a50b <default_cmd+0x2ab>
    3b55:	e8 d5 06 00 00       	callq  422f <printk>
						*(data+i) = input;
    3b5a:	8a 54 24 07          	mov    0x7(%rsp),%dl
    3b5e:	41 0f b6 c6          	movzbl %r14b,%eax
						i++;
    3b62:	41 ff c6             	inc    %r14d
						*(data+i) = input;
    3b65:	88 54 05 00          	mov    %dl,0x0(%rbp,%rax,1)
						i++;
    3b69:	eb 03                	jmp    3b6e <uart_in+0x1f8>
						len++;
    3b6b:	41 ff c4             	inc    %r12d
					k_usleep(1); //  Prozessor abgeben
    3b6e:	e8 dd fc ff ff       	callq  3850 <k_usleep.constprop.0>
				for(uint8_t i=0; len!=0; len--){
    3b73:	41 ff cc             	dec    %r12d
    3b76:	eb b1                	jmp    3b29 <uart_in+0x1b3>
					k_usleep(1); // Prozessor abgeben
    3b78:	e8 d3 fc ff ff       	callq  3850 <k_usleep.constprop.0>
					if(!uart_poll_in(uart_dev, &input)){
    3b7d:	48 8d 05 dc c9 00 00 	lea    0xc9dc(%rip),%rax        # 10560 <uart_dev>
    3b84:	48 8b 38             	mov    (%rax),%rdi
    3b87:	4c 89 fe             	mov    %r15,%rsi
    3b8a:	e8 b6 fc ff ff       	callq  3845 <z_impl_uart_poll_in>
    3b8f:	85 c0                	test   %eax,%eax
    3b91:	75 e5                	jne    3b78 <uart_in+0x202>
						switch(op){
    3b93:	48 8d 05 a6 ca 00 00 	lea    0xcaa6(%rip),%rax        # 10640 <op>
    3b9a:	8b 00                	mov    (%rax),%eax
    3b9c:	83 f8 01             	cmp    $0x1,%eax
    3b9f:	74 4c                	je     3bed <uart_in+0x277>
    3ba1:	83 f8 02             	cmp    $0x2,%eax
    3ba4:	0f 84 80 00 00 00    	je     3c2a <uart_in+0x2b4>
    3baa:	85 c0                	test   %eax,%eax
    3bac:	0f 85 b2 00 00 00    	jne    3c64 <uart_in+0x2ee>
								printk("Sending data <%s> to processing thread\n", data);
    3bb2:	48 89 ee             	mov    %rbp,%rsi
    3bb5:	48 8d 3d 66 69 00 00 	lea    0x6966(%rip),%rdi        # a522 <default_cmd+0x2c2>
    3bbc:	e8 6e 06 00 00       	callq  422f <printk>
								k_msgq_put(&processing_msgq, data, K_FOREVER);
    3bc1:	48 8d 3d a8 bf 00 00 	lea    0xbfa8(%rip),%rdi        # fb70 <processing_msgq>
    3bc8:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    3bcc:	48 89 ee             	mov    %rbp,%rsi
    3bcf:	e8 77 fc ff ff       	callq  384b <k_msgq_put.constprop.0>
								printk("Changing state to st_op_decrypt\n\n");
    3bd4:	48 8d 3d 6f 69 00 00 	lea    0x696f(%rip),%rdi        # a54a <default_cmd+0x2ea>
    3bdb:	31 c0                	xor    %eax,%eax
    3bdd:	e8 4d 06 00 00       	callq  422f <printk>
								state = st_op_decrypt;
    3be2:	c7 03 04 00 00 00    	movl   $0x4,(%rbx)
								break;
    3be8:	e9 ce 00 00 00       	jmpq   3cbb <uart_in+0x345>
								printk("Sending key <%s> to processing thread\n", data);
    3bed:	48 89 ee             	mov    %rbp,%rsi
    3bf0:	48 8d 3d 75 69 00 00 	lea    0x6975(%rip),%rdi        # a56c <default_cmd+0x30c>
    3bf7:	31 c0                	xor    %eax,%eax
    3bf9:	e8 31 06 00 00       	callq  422f <printk>
								k_msgq_put(&key_iv_msgq, data, K_FOREVER);
    3bfe:	48 8d 3d 23 bf 00 00 	lea    0xbf23(%rip),%rdi        # fb28 <key_iv_msgq>
    3c05:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    3c09:	48 89 ee             	mov    %rbp,%rsi
    3c0c:	e8 3a fc ff ff       	callq  384b <k_msgq_put.constprop.0>
								printk("Changing state to st_op_key\n\n");
    3c11:	48 8d 3d 7b 69 00 00 	lea    0x697b(%rip),%rdi        # a593 <default_cmd+0x333>
    3c18:	31 c0                	xor    %eax,%eax
    3c1a:	e8 10 06 00 00       	callq  422f <printk>
								state = st_op_key;
    3c1f:	c7 03 07 00 00 00    	movl   $0x7,(%rbx)
								break;
    3c25:	e9 91 00 00 00       	jmpq   3cbb <uart_in+0x345>
								printk("Sending iv <%s> to processing thread\n", data);
    3c2a:	48 89 ee             	mov    %rbp,%rsi
    3c2d:	48 8d 3d 7d 69 00 00 	lea    0x697d(%rip),%rdi        # a5b1 <default_cmd+0x351>
    3c34:	31 c0                	xor    %eax,%eax
    3c36:	e8 f4 05 00 00       	callq  422f <printk>
								k_msgq_put(&key_iv_msgq, data, K_FOREVER);
    3c3b:	48 8d 3d e6 be 00 00 	lea    0xbee6(%rip),%rdi        # fb28 <key_iv_msgq>
    3c42:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    3c46:	48 89 ee             	mov    %rbp,%rsi
    3c49:	e8 fd fb ff ff       	callq  384b <k_msgq_put.constprop.0>
								printk("Changing state to st_op_iv\n\n");
    3c4e:	48 8d 3d 82 69 00 00 	lea    0x6982(%rip),%rdi        # a5d7 <default_cmd+0x377>
    3c55:	31 c0                	xor    %eax,%eax
    3c57:	e8 d3 05 00 00       	callq  422f <printk>
								state = st_op_iv;
    3c5c:	c7 03 08 00 00 00    	movl   $0x8,(%rbx)
								break;
    3c62:	eb 57                	jmp    3cbb <uart_in+0x345>
								printk("Error: unknwown operand!\n");
    3c64:	48 8d 3d 89 69 00 00 	lea    0x6989(%rip),%rdi        # a5f4 <default_cmd+0x394>
    3c6b:	31 c0                	xor    %eax,%eax
    3c6d:	e8 bd 05 00 00       	callq  422f <printk>
								printk("Changing state to st_init\n\n");
    3c72:	48 8d 3d 95 69 00 00 	lea    0x6995(%rip),%rdi        # a60e <default_cmd+0x3ae>
    3c79:	31 c0                	xor    %eax,%eax
    3c7b:	e8 af 05 00 00       	callq  422f <printk>
								state = st_init;
    3c80:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
						break;
    3c86:	eb 33                	jmp    3cbb <uart_in+0x345>
				op = op_key;
    3c88:	48 8d 05 b1 c9 00 00 	lea    0xc9b1(%rip),%rax        # 10640 <op>
    3c8f:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
				printk("Changing state to st_data\n\n");
    3c95:	eb 0d                	jmp    3ca4 <uart_in+0x32e>
				op = op_iv;
    3c97:	48 8d 05 a2 c9 00 00 	lea    0xc9a2(%rip),%rax        # 10640 <op>
    3c9e:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
				printk("Changing state to st_data\n\n");
    3ca4:	48 8d 3d 44 68 00 00 	lea    0x6844(%rip),%rdi        # a4ef <default_cmd+0x28f>
    3cab:	31 c0                	xor    %eax,%eax
				len = KEY_IV_LEN;
    3cad:	41 b4 10             	mov    $0x10,%r12b
				printk("Changing state to st_data\n\n");
    3cb0:	e8 7a 05 00 00       	callq  422f <printk>
				state = st_data;
    3cb5:	c7 03 03 00 00 00    	movl   $0x3,(%rbx)
		k_usleep(1); // Prozessor abgeben
    3cbb:	e8 90 fb ff ff       	callq  3850 <k_usleep.constprop.0>
		switch(state){
    3cc0:	e9 ea fc ff ff       	jmpq   39af <uart_in+0x39>

0000000000003cc5 <validate_hw_compatibility>:
	return;
}

int validate_hw_compatibility(void)
// ubernommen aus Krypto-Sample von Zephyr
{
    3cc5:	f3 0f 1e fa          	endbr64 
    3cc9:	51                   	push   %rcx
        uint32_t flags = 0U;

        flags = cipher_query_hwcaps(crypto_dev);
    3cca:	48 8d 05 7f c8 00 00 	lea    0xc87f(%rip),%rax        # 10550 <crypto_dev>
    3cd1:	48 8b 38             	mov    (%rax),%rdi
	struct crypto_driver_api *api;
	int tmp;

	api = (struct crypto_driver_api *) dev->api;

	tmp = api->query_hw_caps(dev);
    3cd4:	48 8b 47 10          	mov    0x10(%rdi),%rax
    3cd8:	ff 10                	callq  *(%rax)
        if ((flags & CAP_RAW_KEY) == 0U) {
                return -1;
        }

        if ((flags & CAP_SYNC_OPS) == 0U) {
                return -1;
    3cda:	41 83 c8 ff          	or     $0xffffffff,%r8d
        if ((flags & CAP_SYNC_OPS) == 0U) {
    3cde:	89 c2                	mov    %eax,%edx
    3ce0:	83 e2 22             	and    $0x22,%edx
    3ce3:	83 fa 22             	cmp    $0x22,%edx
    3ce6:	75 14                	jne    3cfc <validate_hw_compatibility+0x37>
        }

        if ((flags & CAP_SEPARATE_IO_BUFS) == 0U) {
    3ce8:	a8 10                	test   $0x10,%al
    3cea:	74 10                	je     3cfc <validate_hw_compatibility+0x37>
                return -1;
        }

        cap_flags = CAP_RAW_KEY | CAP_SYNC_OPS | CAP_SEPARATE_IO_BUFS;
    3cec:	48 8d 05 55 c9 00 00 	lea    0xc955(%rip),%rax        # 10648 <cap_flags>

        return 0;
    3cf3:	45 31 c0             	xor    %r8d,%r8d
        cap_flags = CAP_RAW_KEY | CAP_SYNC_OPS | CAP_SEPARATE_IO_BUFS;
    3cf6:	c7 00 32 00 00 00    	movl   $0x32,(%rax)
}
    3cfc:	44 89 c0             	mov    %r8d,%eax
    3cff:	5a                   	pop    %rdx
    3d00:	c3                   	retq   

0000000000003d01 <zephyr_app_main>:
void main(void){
    3d01:	f3 0f 1e fa          	endbr64 
    3d05:	53                   	push   %rbx
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    3d06:	48 8d 3d 1d 69 00 00 	lea    0x691d(%rip),%rdi        # a62a <default_cmd+0x3ca>
    3d0d:	e8 de 4f 00 00       	callq  8cf0 <z_impl_device_get_binding>
	uart_dev = device_get_binding(DT_LABEL(UART_DEVICE));
    3d12:	48 8d 1d 47 c8 00 00 	lea    0xc847(%rip),%rbx        # 10560 <uart_dev>
		printk("UART not found\n");
    3d19:	48 8d 3d 11 69 00 00 	lea    0x6911(%rip),%rdi        # a631 <default_cmd+0x3d1>
	uart_dev = device_get_binding(DT_LABEL(UART_DEVICE));
    3d20:	48 89 03             	mov    %rax,(%rbx)
	if(!uart_dev){
    3d23:	48 85 c0             	test   %rax,%rax
    3d26:	74 75                	je     3d9d <zephyr_app_main+0x9c>
	printk("UART found\n");
    3d28:	31 c0                	xor    %eax,%eax
    3d2a:	48 8d 3d 10 69 00 00 	lea    0x6910(%rip),%rdi        # a641 <default_cmd+0x3e1>
    3d31:	e8 f9 04 00 00       	callq  422f <printk>
	uartconf.baudrate = 9600;
    3d36:	48 8d 35 1b c8 00 00 	lea    0xc81b(%rip),%rsi        # 10558 <uartconf>
	if(!uart_configure(uart_dev, &uartconf)){
    3d3d:	48 8b 3b             	mov    (%rbx),%rdi
	uartconf.baudrate = 9600;
    3d40:	48 b8 80 25 00 00 00 	movabs $0x3010000002580,%rax
    3d47:	01 03 00 
    3d4a:	48 89 06             	mov    %rax,(%rsi)
					const struct uart_config *cfg)
{
	const struct uart_driver_api *api =
				(const struct uart_driver_api *)dev->api;

	if (api->configure == NULL) {
    3d4d:	48 8b 47 10          	mov    0x10(%rdi),%rax
    3d51:	48 8b 40 18          	mov    0x18(%rax),%rax
    3d55:	48 85 c0             	test   %rax,%rax
    3d58:	74 0d                	je     3d67 <zephyr_app_main+0x66>
		return -ENOSYS;
	}
	return api->configure(dev, cfg);
    3d5a:	ff d0                	callq  *%rax
		printk("Configuration of UART failed\n");
    3d5c:	48 8d 3d ea 68 00 00 	lea    0x68ea(%rip),%rdi        # a64d <default_cmd+0x3ed>
	if(!uart_configure(uart_dev, &uartconf)){
    3d63:	85 c0                	test   %eax,%eax
    3d65:	74 36                	je     3d9d <zephyr_app_main+0x9c>
	printk("UART configured\n");
    3d67:	48 8d 3d fd 68 00 00 	lea    0x68fd(%rip),%rdi        # a66b <default_cmd+0x40b>
    3d6e:	31 c0                	xor    %eax,%eax
    3d70:	e8 ba 04 00 00       	callq  422f <printk>
    3d75:	48 8d 3d 00 69 00 00 	lea    0x6900(%rip),%rdi        # a67c <default_cmd+0x41c>
    3d7c:	e8 6f 4f 00 00       	callq  8cf0 <z_impl_device_get_binding>
	crypto_dev = device_get_binding(CRYPTO_DRV_NAME);
    3d81:	48 8d 15 c8 c7 00 00 	lea    0xc7c8(%rip),%rdx        # 10550 <crypto_dev>
    3d88:	48 89 02             	mov    %rax,(%rdx)
	if(validate_hw_compatibility()!=0){
    3d8b:	e8 35 ff ff ff       	callq  3cc5 <validate_hw_compatibility>
    3d90:	85 c0                	test   %eax,%eax
    3d92:	74 0f                	je     3da3 <zephyr_app_main+0xa2>
		printk("Crypto device not compatible\n");
    3d94:	48 8d 3d eb 68 00 00 	lea    0x68eb(%rip),%rdi        # a686 <default_cmd+0x426>
    3d9b:	31 c0                	xor    %eax,%eax
}
    3d9d:	5b                   	pop    %rbx
		printk("Crypto device not compatible\n");
    3d9e:	e9 8c 04 00 00       	jmpq   422f <printk>
	printk("Crypto device is compatible\n");
    3da3:	48 8d 3d fa 68 00 00 	lea    0x68fa(%rip),%rdi        # a6a4 <default_cmd+0x444>
    3daa:	31 c0                	xor    %eax,%eax
		printk("\nmain is waiting for death\n"); // "main is alive" ist mir irgendwie zu langweilig...
    3dac:	48 8d 1d 0e 69 00 00 	lea    0x690e(%rip),%rbx        # a6c1 <default_cmd+0x461>
	printk("Crypto device is compatible\n");
    3db3:	e8 77 04 00 00       	callq  422f <printk>
		printk("\nmain is waiting for death\n"); // "main is alive" ist mir irgendwie zu langweilig...
    3db8:	48 89 df             	mov    %rbx,%rdi
    3dbb:	31 c0                	xor    %eax,%eax
    3dbd:	e8 6d 04 00 00       	callq  422f <printk>
	return z_impl_k_sleep(timeout);
    3dc2:	bf e8 03 00 00       	mov    $0x3e8,%edi
    3dc7:	e8 c5 5a 00 00       	callq  9891 <z_impl_k_sleep>
    3dcc:	eb ea                	jmp    3db8 <zephyr_app_main+0xb7>

0000000000003dce <cbc_mode>:

void cbc_mode(uint8_t *key, uint8_t *iv, uint8_t *ciphertext, uint8_t **plaintext_addr)
// uebernommen aus Krypto-Sample von Zephyr und von Mitterhuber
{
    3dce:	f3 0f 1e fa          	endbr64 
    3dd2:	41 57                	push   %r15
    3dd4:	49 89 ff             	mov    %rdi,%r15
	uint8_t *iv_ciphertext = malloc((DATA_SIZE_MAX+KEY_IV_LEN)*sizeof(uint8_t));
    3dd7:	bf 0f 01 00 00       	mov    $0x10f,%edi
{
    3ddc:	41 56                	push   %r14
    3dde:	41 55                	push   %r13
    3de0:	49 89 d5             	mov    %rdx,%r13
    3de3:	41 54                	push   %r12
    3de5:	55                   	push   %rbp
    3de6:	48 89 cd             	mov    %rcx,%rbp
    3de9:	53                   	push   %rbx
    3dea:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    3df1:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    3df6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3dfd:	00 00 
    3dff:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    3e04:	31 c0                	xor    %eax,%eax
	uint8_t *iv_ciphertext = malloc((DATA_SIZE_MAX+KEY_IV_LEN)*sizeof(uint8_t));
    3e06:	e8 b5 f7 ff ff       	callq  35c0 <malloc@plt>
	uint8_t *plaintext = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3e0b:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *iv_ciphertext = malloc((DATA_SIZE_MAX+KEY_IV_LEN)*sizeof(uint8_t));
    3e10:	49 89 c6             	mov    %rax,%r14
	uint8_t *plaintext = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3e13:	e8 a8 f7 ff ff       	callq  35c0 <malloc@plt>
	xerror = false;

	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    3e18:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    3e1d:	45 31 d2             	xor    %r10d,%r10d
    3e20:	45 31 c0             	xor    %r8d,%r8d
	xerror = false;
    3e23:	4c 8d 25 63 c8 00 00 	lea    0xc863(%rip),%r12        # 1068d <xerror>
	uint8_t *plaintext = malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3e2a:	48 89 c3             	mov    %rax,%rbx
	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    3e2d:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	xerror = false;
    3e31:	41 c6 04 24 00       	movb   $0x0,(%r12)
	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    3e36:	48 89 d1             	mov    %rdx,%rcx
    3e39:	4c 89 ef             	mov    %r13,%rdi
    3e3c:	44 89 c0             	mov    %r8d,%eax
    3e3f:	4d 63 ca             	movslq %r10d,%r9
    3e42:	f2 ae                	repnz scas %es:(%rdi),%al
    3e44:	48 f7 d1             	not    %rcx
    3e47:	48 83 c1 0f          	add    $0xf,%rcx
    3e4b:	49 39 c9             	cmp    %rcx,%r9
    3e4e:	73 1c                	jae    3e6c <cbc_mode+0x9e>
		if(i<KEY_IV_LEN){
    3e50:	4b 8d 04 0e          	lea    (%r14,%r9,1),%rax
    3e54:	41 83 fa 0f          	cmp    $0xf,%r10d
    3e58:	7f 06                	jg     3e60 <cbc_mode+0x92>
			*(iv_ciphertext+i) = *(iv+i);
    3e5a:	42 8a 0c 0e          	mov    (%rsi,%r9,1),%cl
    3e5e:	eb 05                	jmp    3e65 <cbc_mode+0x97>
		}
		else{
			*(iv_ciphertext+i) = *(ciphertext+i-KEY_IV_LEN);
    3e60:	43 8a 4c 0d f0       	mov    -0x10(%r13,%r9,1),%cl
    3e65:	88 08                	mov    %cl,(%rax)
	for(int i=0; i<strlen(ciphertext)+KEY_IV_LEN; i++){
    3e67:	41 ff c2             	inc    %r10d
    3e6a:	eb ca                	jmp    3e36 <cbc_mode+0x68>
		}
	}

        struct cipher_ctx ini = {
    3e6c:	31 c0                	xor    %eax,%eax
    3e6e:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
    3e73:	b9 0d 00 00 00       	mov    $0xd,%ecx
    3e78:	66 c7 44 24 74 10 00 	movw   $0x10,0x74(%rsp)
    3e7f:	f3 ab                	rep stos %eax,%es:(%rdi)
    3e81:	48 8d 0d c0 c7 00 00 	lea    0xc7c0(%rip),%rcx        # 10648 <cap_flags>
                .keylen = KEY_IV_LEN,
                .key.bit_stream = key,
                .flags = cap_flags,
        };

        struct cipher_pkt decrypt = {
    3e88:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
        struct cipher_ctx ini = {
    3e8d:	4c 89 7c 24 50       	mov    %r15,0x50(%rsp)
        struct cipher_pkt decrypt = {
    3e92:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
                .in_len = strlen(ciphertext)+KEY_IV_LEN,
                .out_buf = plaintext,
                .out_buf_max = strlen(ciphertext),
        };

        if (cipher_begin_session(crypto_dev, &ini, CRYPTO_CIPHER_ALGO_AES,
    3e97:	4c 8d 3d b2 c6 00 00 	lea    0xc6b2(%rip),%r15        # 10550 <crypto_dev>
        struct cipher_ctx ini = {
    3e9e:	8b 09                	mov    (%rcx),%ecx
    3ea0:	66 89 4c 24 76       	mov    %cx,0x76(%rsp)
        struct cipher_pkt decrypt = {
    3ea5:	b9 08 00 00 00       	mov    $0x8,%ecx
    3eaa:	f3 ab                	rep stos %eax,%es:(%rdi)
                .in_len = strlen(ciphertext)+KEY_IV_LEN,
    3eac:	44 89 c0             	mov    %r8d,%eax
    3eaf:	4c 89 ef             	mov    %r13,%rdi
    3eb2:	48 89 d1             	mov    %rdx,%rcx
    3eb5:	f2 ae                	repnz scas %es:(%rdi),%al
        struct cipher_pkt decrypt = {
    3eb7:	48 89 5c 24 28       	mov    %rbx,0x28(%rsp)
                .out_buf_max = strlen(ciphertext),
    3ebc:	4c 89 ef             	mov    %r13,%rdi
	flags = (ctx->flags & (CAP_SYNC_OPS | CAP_ASYNC_OPS));
	__ASSERT(flags != 0U, "sync/async type missing");
	__ASSERT(flags != (CAP_SYNC_OPS |  CAP_ASYNC_OPS),
			"conflicting options for sync/async");

	return api->begin_session(dev, ctx, algo, mode, optype);
    3ebf:	4c 8d 6c 24 40       	lea    0x40(%rsp),%r13
    3ec4:	4c 89 ee             	mov    %r13,%rsi
                .in_len = strlen(ciphertext)+KEY_IV_LEN,
    3ec7:	48 f7 d1             	not    %rcx
    3eca:	83 c1 0f             	add    $0xf,%ecx
    3ecd:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
                .out_buf_max = strlen(ciphertext),
    3ed1:	48 89 d1             	mov    %rdx,%rcx
    3ed4:	ba 01 00 00 00       	mov    $0x1,%edx
    3ed9:	f2 ae                	repnz scas %es:(%rdi),%al
        if (cipher_begin_session(crypto_dev, &ini, CRYPTO_CIPHER_ALGO_AES,
    3edb:	49 8b 3f             	mov    (%r15),%rdi
	ctx->ops.cipher_mode = mode;
    3ede:	c7 44 24 40 02 00 00 	movl   $0x2,0x40(%rsp)
    3ee5:	00 
	api = (struct crypto_driver_api *) dev->api;
    3ee6:	48 8b 47 10          	mov    0x10(%rdi),%rax
	ctx->device = dev;
    3eea:	48 89 7c 24 58       	mov    %rdi,0x58(%rsp)
                .out_buf_max = strlen(ciphertext),
    3eef:	49 89 c8             	mov    %rcx,%r8
	return api->begin_session(dev, ctx, algo, mode, optype);
    3ef2:	b9 02 00 00 00       	mov    $0x2,%ecx
    3ef7:	49 f7 d0             	not    %r8
    3efa:	49 ff c8             	dec    %r8
        struct cipher_pkt decrypt = {
    3efd:	44 89 44 24 30       	mov    %r8d,0x30(%rsp)
    3f02:	45 31 c0             	xor    %r8d,%r8d
    3f05:	ff 50 08             	callq  *0x8(%rax)
        if (cipher_begin_session(crypto_dev, &ini, CRYPTO_CIPHER_ALGO_AES,
    3f08:	85 c0                	test   %eax,%eax
    3f0a:	75 37                	jne    3f43 <cbc_mode+0x175>
				struct cipher_pkt *pkt, uint8_t *iv)
{
	__ASSERT(ctx->ops.cipher_mode == CRYPTO_CIPHER_MODE_CBC, "CBC mode "
		 "session invoking a different mode handler");

	pkt->ctx = ctx;
    3f0c:	4c 89 6c 24 38       	mov    %r13,0x38(%rsp)
	return ctx->ops.cbc_crypt_hndlr(ctx, pkt, iv);
    3f11:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    3f16:	4c 89 f2             	mov    %r14,%rdx
    3f19:	4c 89 ef             	mov    %r13,%rdi
    3f1c:	ff 54 24 48          	callq  *0x48(%rsp)
		k_msgq_put(&uart_msgq, "XERROR\n", K_FOREVER);
		xerror = true;
		goto out;
        }

        if (cipher_cbc_op(&ini, &decrypt, iv_ciphertext)!=0){
    3f20:	85 c0                	test   %eax,%eax
    3f22:	74 3d                	je     3f61 <cbc_mode+0x193>
                printk("CBC mode DECRYPT - Failed\n");
    3f24:	48 8d 3d ba 67 00 00 	lea    0x67ba(%rip),%rdi        # a6e5 <default_cmd+0x485>
    3f2b:	31 c0                	xor    %eax,%eax
    3f2d:	e8 fd 02 00 00       	callq  422f <printk>
		printk("Plaintext is: %s\n", plaintext);
    3f32:	48 89 de             	mov    %rbx,%rsi
    3f35:	48 8d 3d c4 67 00 00 	lea    0x67c4(%rip),%rdi        # a700 <default_cmd+0x4a0>
    3f3c:	31 c0                	xor    %eax,%eax
    3f3e:	e8 ec 02 00 00       	callq  422f <printk>
		k_msgq_put(&uart_msgq, "XERROR\n", K_FOREVER);
    3f43:	48 8d 3d 6e bc 00 00 	lea    0xbc6e(%rip),%rdi        # fbb8 <uart_msgq>
    3f4a:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    3f4e:	48 8d 35 88 67 00 00 	lea    0x6788(%rip),%rsi        # a6dd <default_cmd+0x47d>
    3f55:	e8 f1 f8 ff ff       	callq  384b <k_msgq_put.constprop.0>
		xerror = true;
    3f5a:	41 c6 04 24 01       	movb   $0x1,(%r12)
                goto out;
    3f5f:	eb 23                	jmp    3f84 <cbc_mode+0x1b6>
        }

       	printk("Output length (decryption): %d\n", decrypt.out_len);
    3f61:	8b 74 24 34          	mov    0x34(%rsp),%esi
    3f65:	48 8d 3d a6 67 00 00 	lea    0x67a6(%rip),%rdi        # a712 <default_cmd+0x4b2>
    3f6c:	31 c0                	xor    %eax,%eax
    3f6e:	e8 bc 02 00 00       	callq  422f <printk>
	printk("plaintext: %s\n", plaintext);
    3f73:	48 89 de             	mov    %rbx,%rsi
    3f76:	48 8d 3d b5 67 00 00 	lea    0x67b5(%rip),%rdi        # a732 <default_cmd+0x4d2>
    3f7d:	31 c0                	xor    %eax,%eax
    3f7f:	e8 ab 02 00 00       	callq  422f <printk>

out:
        cipher_free_session(crypto_dev, &ini);
    3f84:	49 8b 3f             	mov    (%r15),%rdi
	return api->free_session(dev, ctx);
    3f87:	4c 89 ee             	mov    %r13,%rsi
    3f8a:	48 8b 47 10          	mov    0x10(%rdi),%rax
    3f8e:	ff 50 10             	callq  *0x10(%rax)
	*plaintext_addr = plaintext;
    3f91:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
}
    3f95:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    3f9a:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3fa1:	00 00 
    3fa3:	74 05                	je     3faa <cbc_mode+0x1dc>
    3fa5:	e8 06 f5 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    3faa:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    3fb1:	5b                   	pop    %rbx
    3fb2:	5d                   	pop    %rbp
    3fb3:	41 5c                	pop    %r12
    3fb5:	41 5d                	pop    %r13
    3fb7:	41 5e                	pop    %r14
    3fb9:	41 5f                	pop    %r15
    3fbb:	c3                   	retq   

0000000000003fbc <processing>:
void processing(void *ptr1, void *ptr2, void *ptr3){
    3fbc:	f3 0f 1e fa          	endbr64 
    3fc0:	41 57                	push   %r15
	uint8_t *plaintext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3fc2:	bf ff 00 00 00       	mov    $0xff,%edi
void processing(void *ptr1, void *ptr2, void *ptr3){
    3fc7:	41 56                	push   %r14
	iv = "BBBBBBBBBBBBBBBB"; // Default-IV
    3fc9:	4c 8d 35 71 67 00 00 	lea    0x6771(%rip),%r14        # a741 <default_cmd+0x4e1>
void processing(void *ptr1, void *ptr2, void *ptr3){
    3fd0:	41 55                	push   %r13
	key = "BBBBBBBBBBBBBBBB"; // Default-Key
    3fd2:	4d 89 f7             	mov    %r14,%r15
void processing(void *ptr1, void *ptr2, void *ptr3){
    3fd5:	41 54                	push   %r12
    3fd7:	55                   	push   %rbp
    3fd8:	53                   	push   %rbx
    3fd9:	48 83 ec 28          	sub    $0x28,%rsp
    3fdd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3fe4:	00 00 
    3fe6:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    3feb:	31 c0                	xor    %eax,%eax
	uint8_t *plaintext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3fed:	e8 ce f5 ff ff       	callq  35c0 <malloc@plt>
	uint8_t *plaintext_temp=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3ff2:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *plaintext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3ff7:	48 89 c3             	mov    %rax,%rbx
	uint8_t *plaintext_temp=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3ffa:	e8 c1 f5 ff ff       	callq  35c0 <malloc@plt>
	uint8_t *ciphertext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    3fff:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *plaintext_temp=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    4004:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	uint8_t *ciphertext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    4009:	e8 b2 f5 ff ff       	callq  35c0 <malloc@plt>
	void *buf = malloc(DATA_SIZE_MAX);
    400e:	bf ff 00 00 00       	mov    $0xff,%edi
	uint8_t *ciphertext=malloc(DATA_SIZE_MAX*sizeof(uint8_t));
    4013:	49 89 c4             	mov    %rax,%r12
	void *buf = malloc(DATA_SIZE_MAX);
    4016:	e8 a5 f5 ff ff       	callq  35c0 <malloc@plt>
		switch(state){
    401b:	4c 8d 2d 22 c6 00 00 	lea    0xc622(%rip),%r13        # 10644 <state>
	void *buf = malloc(DATA_SIZE_MAX);
    4022:	48 89 c5             	mov    %rax,%rbp
		switch(state){
    4025:	41 8b 45 00          	mov    0x0(%r13),%eax
    4029:	83 f8 07             	cmp    $0x7,%eax
    402c:	0f 84 07 01 00 00    	je     4139 <processing+0x17d>
    4032:	7f 0f                	jg     4043 <processing+0x87>
    4034:	83 f8 01             	cmp    $0x1,%eax
    4037:	74 18                	je     4051 <processing+0x95>
    4039:	83 f8 04             	cmp    $0x4,%eax
    403c:	74 23                	je     4061 <processing+0xa5>
    403e:	e9 6c 01 00 00       	jmpq   41af <processing+0x1f3>
    4043:	83 f8 08             	cmp    $0x8,%eax
    4046:	0f 84 29 01 00 00    	je     4175 <processing+0x1b9>
    404c:	e9 5e 01 00 00       	jmpq   41af <processing+0x1f3>
				k_msgq_put(&uart_msgq, "PROCESSING AVAILABLE\n", K_FOREVER);
    4051:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    4055:	48 8d 35 f6 66 00 00 	lea    0x66f6(%rip),%rsi        # a752 <default_cmd+0x4f2>
    405c:	e9 b4 00 00 00       	jmpq   4115 <processing+0x159>
	return z_impl_k_msgq_get(msgq, data, timeout);
    4061:	48 8d 3d 08 bb 00 00 	lea    0xbb08(%rip),%rdi        # fb70 <processing_msgq>
    4068:	31 d2                	xor    %edx,%edx
    406a:	4c 89 e6             	mov    %r12,%rsi
    406d:	e8 5b 4f 00 00       	callq  8fcd <z_impl_k_msgq_get>
				if(k_msgq_get(&processing_msgq, (void*)ciphertext, K_NO_WAIT)==0){
    4072:	85 c0                	test   %eax,%eax
    4074:	0f 85 35 01 00 00    	jne    41af <processing+0x1f3>
    407a:	89 44 24 0c          	mov    %eax,0xc(%rsp)
					printk("Going to decrypt ciphertext: <%s>\n", ciphertext);
    407e:	4c 89 e6             	mov    %r12,%rsi
    4081:	31 c0                	xor    %eax,%eax
    4083:	48 8d 3d de 66 00 00 	lea    0x66de(%rip),%rdi        # a768 <default_cmd+0x508>
    408a:	e8 a0 01 00 00       	callq  422f <printk>
					cbc_mode(key, iv, ciphertext, &plaintext_temp);
    408f:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
    4094:	4c 89 e2             	mov    %r12,%rdx
    4097:	4c 89 f6             	mov    %r14,%rsi
    409a:	4c 89 ff             	mov    %r15,%rdi
    409d:	e8 2c fd ff ff       	callq  3dce <cbc_mode>
					if(xerror == false){ // Send data to uart_out
    40a2:	48 8d 05 e4 c5 00 00 	lea    0xc5e4(%rip),%rax        # 1068d <xerror>
    40a9:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
    40ae:	80 38 00             	cmpb   $0x0,(%rax)
    40b1:	75 6e                	jne    4121 <processing+0x165>
						send_termination = true;
    40b3:	48 8d 05 d4 c5 00 00 	lea    0xc5d4(%rip),%rax        # 1068e <send_termination>
						for(int i=0; i<strlen(plaintext_temp)+2; i++){
    40ba:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
    40bf:	49 83 c9 ff          	or     $0xffffffffffffffff,%r9
						send_termination = true;
    40c3:	c6 00 01             	movb   $0x1,(%rax)
						for(int i=0; i<strlen(plaintext_temp)+2; i++){
    40c6:	31 c0                	xor    %eax,%eax
    40c8:	4c 89 c9             	mov    %r9,%rcx
    40cb:	48 89 f7             	mov    %rsi,%rdi
    40ce:	49 63 d0             	movslq %r8d,%rdx
    40d1:	f2 ae                	repnz scas %es:(%rdi),%al
    40d3:	48 f7 d9             	neg    %rcx
    40d6:	48 39 ca             	cmp    %rcx,%rdx
    40d9:	73 22                	jae    40fd <processing+0x141>
							if(i==0) *(plaintext+i) = 'D';
    40db:	45 85 c0             	test   %r8d,%r8d
    40de:	75 05                	jne    40e5 <processing+0x129>
    40e0:	c6 03 44             	movb   $0x44,(%rbx)
    40e3:	eb 13                	jmp    40f8 <processing+0x13c>
							else if(i==1) *(plaintext+i) = ' ';
    40e5:	41 83 f8 01          	cmp    $0x1,%r8d
    40e9:	75 06                	jne    40f1 <processing+0x135>
    40eb:	c6 43 01 20          	movb   $0x20,0x1(%rbx)
    40ef:	eb 07                	jmp    40f8 <processing+0x13c>
							else *(plaintext+i) = *(plaintext_temp+i-2);
    40f1:	8a 4c 16 fe          	mov    -0x2(%rsi,%rdx,1),%cl
    40f5:	88 0c 13             	mov    %cl,(%rbx,%rdx,1)
						for(int i=0; i<strlen(plaintext_temp)+2; i++){
    40f8:	41 ff c0             	inc    %r8d
    40fb:	eb cb                	jmp    40c8 <processing+0x10c>
						printk("Sending plaintext <%s> to uart_out\n", plaintext);
    40fd:	48 89 de             	mov    %rbx,%rsi
    4100:	48 8d 3d 84 66 00 00 	lea    0x6684(%rip),%rdi        # a78b <default_cmd+0x52b>
    4107:	31 c0                	xor    %eax,%eax
    4109:	e8 21 01 00 00       	callq  422f <printk>
						k_msgq_put(&uart_msgq, plaintext, K_FOREVER);
    410e:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    4112:	48 89 de             	mov    %rbx,%rsi
    4115:	48 8d 3d 9c ba 00 00 	lea    0xba9c(%rip),%rdi        # fbb8 <uart_msgq>
    411c:	e8 2a f7 ff ff       	callq  384b <k_msgq_put.constprop.0>
					printk("Changing state to st_init\n\n");
    4121:	48 8d 3d e6 64 00 00 	lea    0x64e6(%rip),%rdi        # a60e <default_cmd+0x3ae>
    4128:	31 c0                	xor    %eax,%eax
    412a:	e8 00 01 00 00       	callq  422f <printk>
					state = st_init;
    412f:	41 c7 45 00 00 00 00 	movl   $0x0,0x0(%r13)
    4136:	00 
				break;
    4137:	eb 76                	jmp    41af <processing+0x1f3>
    4139:	48 8d 3d e8 b9 00 00 	lea    0xb9e8(%rip),%rdi        # fb28 <key_iv_msgq>
    4140:	31 d2                	xor    %edx,%edx
    4142:	48 89 ee             	mov    %rbp,%rsi
    4145:	e8 83 4e 00 00       	callq  8fcd <z_impl_k_msgq_get>
				if(k_msgq_get(&key_iv_msgq, buf, K_NO_WAIT)==0){
    414a:	85 c0                	test   %eax,%eax
    414c:	75 61                	jne    41af <processing+0x1f3>
				printk("Set new key\n");
    414e:	48 8d 3d 5a 66 00 00 	lea    0x665a(%rip),%rdi        # a7af <default_cmd+0x54f>
				key = buf;
    4155:	49 89 ef             	mov    %rbp,%r15
				printk("Set new key\n");
    4158:	e8 d2 00 00 00       	callq  422f <printk>
				printk("Changing state to st_init\n");
    415d:	48 8d 3d 58 66 00 00 	lea    0x6658(%rip),%rdi        # a7bc <default_cmd+0x55c>
    4164:	31 c0                	xor    %eax,%eax
    4166:	e8 c4 00 00 00       	callq  422f <printk>
				state = st_init;
    416b:	41 c7 45 00 00 00 00 	movl   $0x0,0x0(%r13)
    4172:	00 
				break;
    4173:	eb 3a                	jmp    41af <processing+0x1f3>
    4175:	48 8d 3d ac b9 00 00 	lea    0xb9ac(%rip),%rdi        # fb28 <key_iv_msgq>
    417c:	31 d2                	xor    %edx,%edx
    417e:	48 89 ee             	mov    %rbp,%rsi
    4181:	e8 47 4e 00 00       	callq  8fcd <z_impl_k_msgq_get>
				if(k_msgq_get(&key_iv_msgq, buf, K_NO_WAIT)==0){
    4186:	85 c0                	test   %eax,%eax
    4188:	75 25                	jne    41af <processing+0x1f3>
				printk("Set new iv\n");
    418a:	48 8d 3d 46 66 00 00 	lea    0x6646(%rip),%rdi        # a7d7 <default_cmd+0x577>
				iv = buf;
    4191:	49 89 ee             	mov    %rbp,%r14
				printk("Set new iv\n");
    4194:	e8 96 00 00 00       	callq  422f <printk>
				printk("Chaning state to st_init\n");
    4199:	48 8d 3d 43 66 00 00 	lea    0x6643(%rip),%rdi        # a7e3 <default_cmd+0x583>
    41a0:	31 c0                	xor    %eax,%eax
    41a2:	e8 88 00 00 00       	callq  422f <printk>
				state = st_init;
    41a7:	41 c7 45 00 00 00 00 	movl   $0x0,0x0(%r13)
    41ae:	00 
		k_usleep(1); // Abgeben des Prozessors
    41af:	e8 9c f6 ff ff       	callq  3850 <k_usleep.constprop.0>
		switch(state){
    41b4:	e9 6c fe ff ff       	jmpq   4025 <processing+0x69>

00000000000041b9 <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
    41b9:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    41bd:	31 c0                	xor    %eax,%eax
    41bf:	c3                   	retq   

00000000000041c0 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    41c0:	f3 0f 1e fa          	endbr64 
	struct out_context *ctx = ctx_p;

	ctx->count++;
	return _char_out(c);
    41c4:	48 8d 05 7d 92 00 00 	lea    0x927d(%rip),%rax        # d448 <_char_out>
	ctx->count++;
    41cb:	ff 06                	incl   (%rsi)
	return _char_out(c);
    41cd:	ff 20                	jmpq   *(%rax)

00000000000041cf <__printk_hook_install>:
{
    41cf:	f3 0f 1e fa          	endbr64 
	_char_out = fn;
    41d3:	48 8d 05 6e 92 00 00 	lea    0x926e(%rip),%rax        # d448 <_char_out>
    41da:	48 89 38             	mov    %rdi,(%rax)
}
    41dd:	c3                   	retq   

00000000000041de <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    41de:	f3 0f 1e fa          	endbr64 
    41e2:	48 83 ec 18          	sub    $0x18,%rsp
    41e6:	48 89 fa             	mov    %rdi,%rdx
    41e9:	48 89 f1             	mov    %rsi,%rcx
    41ec:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    41f3:	00 00 
    41f5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    41fa:	31 c0                	xor    %eax,%eax
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    41fc:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
    4201:	48 8d 3d b8 ff ff ff 	lea    -0x48(%rip),%rdi        # 41c0 <char_out>
	struct out_context ctx = { 0 };
    4208:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
    420f:	00 
	cbvprintf(char_out, &ctx, fmt, ap);
    4210:	e8 84 03 00 00       	callq  4599 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    4215:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    421a:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4221:	00 00 
    4223:	74 05                	je     422a <vprintk+0x4c>
    4225:	e8 86 f2 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    422a:	48 83 c4 18          	add    $0x18,%rsp
    422e:	c3                   	retq   

000000000000422f <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
    422f:	f3 0f 1e fa          	endbr64 
    4233:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    423a:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    423f:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4244:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    4249:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    424e:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    4253:	84 c0                	test   %al,%al
    4255:	74 37                	je     428e <printk+0x5f>
    4257:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    425c:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    4261:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    4266:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    426d:	00 
    426e:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    4275:	00 
    4276:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    427d:	00 
    427e:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4285:	00 
    4286:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    428d:	00 
    428e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4295:	00 00 
    4297:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    429c:	31 c0                	xor    %eax,%eax
	va_list ap;

	va_start(ap, fmt);
    429e:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    42a5:	00 

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    42a6:	48 89 e6             	mov    %rsp,%rsi
	va_start(ap, fmt);
    42a9:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    42b0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    42b5:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    42ba:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    42bf:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    42c6:	00 
		vprintk(fmt, ap);
    42c7:	e8 12 ff ff ff       	callq  41de <vprintk>
	}
	va_end(ap);
}
    42cc:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    42d1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    42d8:	00 00 
    42da:	74 05                	je     42e1 <printk+0xb2>
    42dc:	e8 cf f1 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    42e1:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    42e8:	c3                   	retq   

00000000000042e9 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    42e9:	f3 0f 1e fa          	endbr64 
    42ed:	50                   	push   %rax
    42ee:	58                   	pop    %rax
    42ef:	49 89 f8             	mov    %rdi,%r8
    42f2:	50                   	push   %rax
    42f3:	48 89 f7             	mov    %rsi,%rdi
    42f6:	48 89 d6             	mov    %rdx,%rsi
    42f9:	48 89 ca             	mov    %rcx,%rdx
	entry(p1, p2, p3);
    42fc:	41 ff d0             	callq  *%r8
	return z_impl_k_current_get();
    42ff:	e8 fe 55 00 00       	callq  9902 <z_impl_k_current_get>
    4304:	48 89 c7             	mov    %rax,%rdi
	z_impl_k_thread_abort(thread);
    4307:	e8 06 26 00 00       	callq  6912 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    430c:	ba 26 00 00 00       	mov    $0x26,%edx
    4311:	48 8d 35 0d 65 00 00 	lea    0x650d(%rip),%rsi        # a825 <default_cmd+0x5c5>
    4318:	31 c0                	xor    %eax,%eax
    431a:	48 8d 3d 2d 65 00 00 	lea    0x652d(%rip),%rdi        # a84e <default_cmd+0x5ee>
    4321:	e8 d0 35 00 00       	callq  78f6 <posix_print_error_and_exit>

0000000000004326 <chunk_size>:

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    4326:	89 f6                	mov    %esi,%esi
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    4328:	8b 44 f7 04          	mov    0x4(%rdi,%rsi,8),%eax
    432c:	d1 e8                	shr    %eax
}
    432e:	c3                   	retq   

000000000000432f <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    432f:	89 f6                	mov    %esi,%esi
{
    4331:	41 89 d0             	mov    %edx,%r8d
	void *cmem = &buf[c];
    4334:	48 8d 04 f7          	lea    (%rdi,%rsi,8),%rax

	if (big_heap(h)) {
		if (used) {
    4338:	8b 48 04             	mov    0x4(%rax),%ecx
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
    433b:	89 ca                	mov    %ecx,%edx
    433d:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
    4340:	45 84 c0             	test   %r8b,%r8b
    4343:	74 05                	je     434a <set_chunk_used+0x1b>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    4345:	83 c9 01             	or     $0x1,%ecx
    4348:	89 ca                	mov    %ecx,%edx
    434a:	89 50 04             	mov    %edx,0x4(%rax)
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    434d:	c3                   	retq   

000000000000434e <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    434e:	89 f2                	mov    %esi,%edx
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    4350:	e8 d1 ff ff ff       	callq  4326 <chunk_size>
	if (!solo_free_header(h, c)) {
    4355:	83 f8 01             	cmp    $0x1,%eax
    4358:	74 5b                	je     43b5 <free_list_add+0x67>
	return chunksz * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    435a:	ff c8                	dec    %eax
	return 31 - __builtin_clz(usable_sz);
    435c:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    4361:	0f bd c0             	bsr    %eax,%eax
    4364:	83 f0 1f             	xor    $0x1f,%eax
    4367:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
    4369:	48 63 c1             	movslq %ecx,%rax
    436c:	4c 8d 14 87          	lea    (%rdi,%rax,4),%r10
    4370:	89 d0                	mov    %edx,%eax
    4372:	41 8b 72 10          	mov    0x10(%r10),%esi
    4376:	48 8d 04 c5 08 00 00 	lea    0x8(,%rax,8),%rax
    437d:	00 
    437e:	4c 8d 0c 07          	lea    (%rdi,%rax,1),%r9
    4382:	4c 8d 44 07 04       	lea    0x4(%rdi,%rax,1),%r8
    4387:	85 f6                	test   %esi,%esi
    4389:	75 15                	jne    43a0 <free_list_add+0x52>
		h->avail_buckets |= (1 << bidx);
    438b:	b8 01 00 00 00       	mov    $0x1,%eax
    4390:	d3 e0                	shl    %cl,%eax
    4392:	09 47 0c             	or     %eax,0xc(%rdi)
		b->next = c;
    4395:	41 89 52 10          	mov    %edx,0x10(%r10)
		((uint32_t *)cmem)[f] = val;
    4399:	41 89 11             	mov    %edx,(%r9)
    439c:	41 89 10             	mov    %edx,(%r8)
}
    439f:	c3                   	retq   
	void *cmem = &buf[c];
    43a0:	89 f0                	mov    %esi,%eax
		return ((uint32_t *)cmem)[f];
    43a2:	48 8d 4c c7 08       	lea    0x8(%rdi,%rax,8),%rcx
    43a7:	8b 01                	mov    (%rcx),%eax
		((uint32_t *)cmem)[f] = val;
    43a9:	41 89 01             	mov    %eax,(%r9)
    43ac:	41 89 30             	mov    %esi,(%r8)
    43af:	89 54 c7 0c          	mov    %edx,0xc(%rdi,%rax,8)
    43b3:	89 11                	mov    %edx,(%rcx)
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
	}
}
    43b5:	c3                   	retq   

00000000000043b6 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    43b6:	f3 0f 1e fa          	endbr64 
    43ba:	49 89 f8             	mov    %rdi,%r8
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    43bd:	4c 8d 4c 16 f8       	lea    -0x8(%rsi,%rdx,1),%r9
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    43c2:	48 8d 7e 07          	lea    0x7(%rsi),%rdi
	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    43c6:	ba 20 00 00 00       	mov    $0x20,%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    43cb:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    43cf:	49 83 e1 f8          	and    $0xfffffffffffffff8,%r9
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    43d3:	49 29 f9             	sub    %rdi,%r9
	heap->heap = h;
    43d6:	49 89 38             	mov    %rdi,(%r8)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    43d9:	49 c1 e9 03          	shr    $0x3,%r9
	h->avail_buckets = 0;
    43dd:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    43e4:	41 8d 41 ff          	lea    -0x1(%r9),%eax
	h->end_chunk = heap_sz;
    43e8:	44 89 4f 08          	mov    %r9d,0x8(%rdi)
	return 31 - __builtin_clz(usable_sz);
    43ec:	0f bd c0             	bsr    %eax,%eax
    43ef:	83 f0 1f             	xor    $0x1f,%eax
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    43f2:	29 c2                	sub    %eax,%edx
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    43f4:	48 63 c2             	movslq %edx,%rax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    43f7:	4c 8d 14 85 17 00 00 	lea    0x17(,%rax,4),%r10
    43fe:	00 
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    43ff:	31 c0                	xor    %eax,%eax
    4401:	49 c1 ea 03          	shr    $0x3,%r10
    4405:	39 c2                	cmp    %eax,%edx
    4407:	7e 0d                	jle    4416 <sys_heap_init+0x60>
		h->buckets[i].next = 0;
    4409:	c7 44 87 10 00 00 00 	movl   $0x0,0x10(%rdi,%rax,4)
    4410:	00 
	for (int i = 0; i < nb_buckets; i++) {
    4411:	48 ff c0             	inc    %rax
    4414:	eb ef                	jmp    4405 <sys_heap_init+0x4f>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    4416:	43 8d 04 12          	lea    (%r10,%r10,1),%eax
		((uint32_t *)cmem)[f] = val;
    441a:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
    4420:	ba 01 00 00 00       	mov    $0x1,%edx
    4425:	31 f6                	xor    %esi,%esi
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    4427:	89 47 04             	mov    %eax,0x4(%rdi)
    442a:	e8 00 ff ff ff       	callq  432f <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    442f:	44 89 ca             	mov    %r9d,%edx
		((uint32_t *)cmem)[f] = val;
    4432:	46 89 14 d7          	mov    %r10d,(%rdi,%r10,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
    4436:	44 89 ce             	mov    %r9d,%esi
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    4439:	44 29 d2             	sub    %r10d,%edx
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    443c:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
    443f:	42 89 44 d7 04       	mov    %eax,0x4(%rdi,%r10,8)
	void *cmem = &buf[c];
    4444:	44 89 c8             	mov    %r9d,%eax
		((uint32_t *)cmem)[f] = val;
    4447:	89 14 c7             	mov    %edx,(%rdi,%rax,8)
	set_chunk_used(h, heap_sz, true);
    444a:	ba 01 00 00 00       	mov    $0x1,%edx
    444f:	c7 44 c7 04 00 00 00 	movl   $0x0,0x4(%rdi,%rax,8)
    4456:	00 
    4457:	e8 d3 fe ff ff       	callq  432f <set_chunk_used>

	free_list_add(h, chunk0_size);
    445c:	44 89 d6             	mov    %r10d,%esi
    445f:	e9 ea fe ff ff       	jmpq   434e <free_list_add>

0000000000004464 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    4464:	41 56                	push   %r14
    4466:	49 89 f6             	mov    %rsi,%r14
    4469:	41 55                	push   %r13
    446b:	49 89 fd             	mov    %rdi,%r13
    446e:	41 54                	push   %r12
    4470:	49 89 cc             	mov    %rcx,%r12
    4473:	55                   	push   %rbp
    4474:	48 89 d5             	mov    %rdx,%rbp
    4477:	53                   	push   %rbx
	size_t count = 0;
    4478:	31 db                	xor    %ebx,%ebx

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    447a:	48 8d 44 1d 00       	lea    0x0(%rbp,%rbx,1),%rax
    447f:	49 39 c4             	cmp    %rax,%r12
    4482:	76 16                	jbe    449a <outs+0x36>
		int rc = out((int)*sp++, ctx);
    4484:	31 c0                	xor    %eax,%eax
    4486:	0f be 7c 1d 00       	movsbl 0x0(%rbp,%rbx,1),%edi
    448b:	4c 89 f6             	mov    %r14,%rsi
    448e:	41 ff d5             	callq  *%r13

		if (rc < 0) {
    4491:	85 c0                	test   %eax,%eax
    4493:	78 17                	js     44ac <outs+0x48>
			return rc;
		}
		++count;
    4495:	48 ff c3             	inc    %rbx
    4498:	eb e0                	jmp    447a <outs+0x16>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    449a:	4d 85 e4             	test   %r12,%r12
    449d:	74 04                	je     44a3 <outs+0x3f>
	}

	return (int)count;
    449f:	89 d8                	mov    %ebx,%eax
    44a1:	eb 09                	jmp    44ac <outs+0x48>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    44a3:	80 7c 1d 00 00       	cmpb   $0x0,0x0(%rbp,%rbx,1)
    44a8:	75 da                	jne    4484 <outs+0x20>
    44aa:	eb f3                	jmp    449f <outs+0x3b>
}
    44ac:	5b                   	pop    %rbx
    44ad:	5d                   	pop    %rbp
    44ae:	41 5c                	pop    %r12
    44b0:	41 5d                	pop    %r13
    44b2:	41 5e                	pop    %r14
    44b4:	c3                   	retq   

00000000000044b5 <extract_decimal>:
{
    44b5:	55                   	push   %rbp
    44b6:	53                   	push   %rbx
    44b7:	48 89 fb             	mov    %rdi,%rbx
    44ba:	51                   	push   %rcx
	const char *sp = *str;
    44bb:	48 8b 2f             	mov    (%rdi),%rbp
	while (isdigit((int)(unsigned char)*sp)) {
    44be:	e8 fd f1 ff ff       	callq  36c0 <__ctype_b_loc@plt>
    44c3:	48 8b 08             	mov    (%rax),%rcx
	size_t val = 0;
    44c6:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
    44c8:	48 0f be 55 00       	movsbq 0x0(%rbp),%rdx
    44cd:	0f b6 f2             	movzbl %dl,%esi
    44d0:	f6 44 71 01 08       	testb  $0x8,0x1(%rcx,%rsi,2)
    44d5:	74 0e                	je     44e5 <extract_decimal+0x30>
		val = 10U * val + *sp++ - '0';
    44d7:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    44db:	48 ff c5             	inc    %rbp
    44de:	48 8d 44 10 d0       	lea    -0x30(%rax,%rdx,1),%rax
    44e3:	eb e3                	jmp    44c8 <extract_decimal+0x13>
	*str = sp;
    44e5:	48 89 2b             	mov    %rbp,(%rbx)
}
    44e8:	5a                   	pop    %rdx
    44e9:	5b                   	pop    %rbx
    44ea:	5d                   	pop    %rbp
    44eb:	c3                   	retq   

00000000000044ec <encode_uint>:
{
    44ec:	41 55                	push   %r13
    44ee:	49 89 fd             	mov    %rdi,%r13
    44f1:	41 54                	push   %r12
    44f3:	49 89 cc             	mov    %rcx,%r12
    44f6:	55                   	push   %rbp
    44f7:	48 89 d5             	mov    %rdx,%rbp
    44fa:	53                   	push   %rbx
    44fb:	48 89 f3             	mov    %rsi,%rbx
    44fe:	41 50                	push   %r8
	bool upcase = isupper((int)conv->specifier);
    4500:	e8 bb f1 ff ff       	callq  36c0 <__ctype_b_loc@plt>
    4505:	0f b6 4b 03          	movzbl 0x3(%rbx),%ecx
    4509:	49 89 c0             	mov    %rax,%r8
    450c:	49 8b 10             	mov    (%r8),%rdx
    450f:	48 89 c8             	mov    %rcx,%rax
	switch (specifier) {
    4512:	41 b8 08 00 00 00    	mov    $0x8,%r8d
    4518:	66 8b 0c 4a          	mov    (%rdx,%rcx,2),%cx
    451c:	66 81 e1 00 01       	and    $0x100,%cx
    4521:	3c 6f                	cmp    $0x6f,%al
    4523:	74 3b                	je     4560 <encode_uint+0x74>
    4525:	77 04                	ja     452b <encode_uint+0x3f>
		return 16;
    4527:	3c 58                	cmp    $0x58,%al
    4529:	eb 05                	jmp    4530 <encode_uint+0x44>
	switch (specifier) {
    452b:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
    452e:	3c 70                	cmp    $0x70,%al
    4530:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
    4536:	b8 10 00 00 00       	mov    $0x10,%eax
    453b:	4c 0f 44 c0          	cmove  %rax,%r8
	char *bp = bps + (bpe - bps);
    453f:	eb 1f                	jmp    4560 <encode_uint+0x74>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    4541:	8d 72 57             	lea    0x57(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    4544:	66 85 c9             	test   %cx,%cx
    4547:	74 03                	je     454c <encode_uint+0x60>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    4549:	8d 72 37             	lea    0x37(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    454c:	49 ff cc             	dec    %r12
    454f:	41 88 34 24          	mov    %sil,(%r12)
	} while ((value != 0) && (bps < bp));
    4553:	4d 39 c5             	cmp    %r8,%r13
    4556:	72 1b                	jb     4573 <encode_uint+0x87>
    4558:	49 39 ec             	cmp    %rbp,%r12
    455b:	76 16                	jbe    4573 <encode_uint+0x87>
		value /= radix;
    455d:	49 89 c5             	mov    %rax,%r13
		unsigned int lsv = (unsigned int)(value % radix);
    4560:	4c 89 e8             	mov    %r13,%rax
    4563:	31 d2                	xor    %edx,%edx
    4565:	49 f7 f0             	div    %r8
		*--bp = (lsv <= 9) ? ('0' + lsv)
    4568:	8d 72 30             	lea    0x30(%rdx),%esi
    456b:	48 83 fa 09          	cmp    $0x9,%rdx
    456f:	76 db                	jbe    454c <encode_uint+0x60>
    4571:	eb ce                	jmp    4541 <encode_uint+0x55>
	if (conv->flag_hash) {
    4573:	f6 03 20             	testb  $0x20,(%rbx)
    4576:	74 16                	je     458e <encode_uint+0xa2>
		if (radix == 8) {
    4578:	49 83 f8 08          	cmp    $0x8,%r8
    457c:	75 06                	jne    4584 <encode_uint+0x98>
			conv->altform_0 = true;
    457e:	80 4b 02 08          	orb    $0x8,0x2(%rbx)
    4582:	eb 0a                	jmp    458e <encode_uint+0xa2>
		} else if (radix == 16) {
    4584:	49 83 f8 10          	cmp    $0x10,%r8
    4588:	75 04                	jne    458e <encode_uint+0xa2>
			conv->altform_0c = true;
    458a:	80 4b 02 10          	orb    $0x10,0x2(%rbx)
}
    458e:	5a                   	pop    %rdx
    458f:	4c 89 e0             	mov    %r12,%rax
    4592:	5b                   	pop    %rbx
    4593:	5d                   	pop    %rbp
    4594:	41 5c                	pop    %r12
    4596:	41 5d                	pop    %r13
    4598:	c3                   	retq   

0000000000004599 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    4599:	f3 0f 1e fa          	endbr64 
    459d:	41 57                	push   %r15
    459f:	49 89 f7             	mov    %rsi,%r15
    45a2:	41 56                	push   %r14
    45a4:	49 89 fe             	mov    %rdi,%r14
    45a7:	41 55                	push   %r13
    45a9:	49 89 d5             	mov    %rdx,%r13
    45ac:	41 54                	push   %r12
    45ae:	49 89 cc             	mov    %rcx,%r12
    45b1:	55                   	push   %rbp
    45b2:	53                   	push   %rbx
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    45b3:	31 db                	xor    %ebx,%ebx
{
    45b5:	48 83 ec 78          	sub    $0x78,%rsp
    45b9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    45c0:	00 00 
    45c2:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    45c7:	31 c0                	xor    %eax,%eax
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    45c9:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
    45ce:	40 84 ff             	test   %dil,%dil
    45d1:	0f 84 d2 09 00 00    	je     4fa9 <cbvprintf+0xa10>
		if (*fp != '%') {
    45d7:	49 8d 6d 01          	lea    0x1(%r13),%rbp
			OUTC(*fp++);
    45db:	4c 89 fe             	mov    %r15,%rsi
		if (*fp != '%') {
    45de:	40 80 ff 25          	cmp    $0x25,%dil
    45e2:	0f 85 89 06 00 00    	jne    4c71 <cbvprintf+0x6d8>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    45e8:	31 c0                	xor    %eax,%eax
    45ea:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    45ef:	b9 08 00 00 00       	mov    $0x8,%ecx
    45f4:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (*sp == '%') {
    45f6:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
    45fb:	41 80 7d 01 25       	cmpb   $0x25,0x1(%r13)
    4600:	75 1c                	jne    461e <cbvprintf+0x85>
		conv->specifier = *sp++;
    4602:	c6 44 24 43 25       	movb   $0x25,0x43(%rsp)
    4607:	49 8d 6d 02          	lea    0x2(%r13),%rbp
		return sp;
    460b:	e9 df 02 00 00       	jmpq   48ef <cbvprintf+0x356>
		switch (*sp) {
    4610:	7e 15                	jle    4627 <cbvprintf+0x8e>
    4612:	3c 2d                	cmp    $0x2d,%al
    4614:	75 1b                	jne    4631 <cbvprintf+0x98>
			conv->flag_dash = true;
    4616:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
			++sp;
    461b:	48 ff c5             	inc    %rbp
		switch (*sp) {
    461e:	8a 45 00             	mov    0x0(%rbp),%al
    4621:	3c 2b                	cmp    $0x2b,%al
    4623:	75 eb                	jne    4610 <cbvprintf+0x77>
    4625:	eb 25                	jmp    464c <cbvprintf+0xb3>
    4627:	3c 20                	cmp    $0x20,%al
    4629:	74 28                	je     4653 <cbvprintf+0xba>
    462b:	3c 23                	cmp    $0x23,%al
    462d:	74 2b                	je     465a <cbvprintf+0xc1>
    462f:	eb 04                	jmp    4635 <cbvprintf+0x9c>
    4631:	3c 30                	cmp    $0x30,%al
    4633:	74 2c                	je     4661 <cbvprintf+0xc8>
	if (conv->flag_zero && conv->flag_dash) {
    4635:	8a 44 24 40          	mov    0x40(%rsp),%al
    4639:	89 c2                	mov    %eax,%edx
    463b:	83 e2 44             	and    $0x44,%edx
    463e:	80 fa 44             	cmp    $0x44,%dl
    4641:	75 25                	jne    4668 <cbvprintf+0xcf>
		conv->flag_zero = false;
    4643:	83 e0 bf             	and    $0xffffffbf,%eax
    4646:	88 44 24 40          	mov    %al,0x40(%rsp)
    464a:	eb 1c                	jmp    4668 <cbvprintf+0xcf>
			conv->flag_plus = true;
    464c:	80 4c 24 40 08       	orb    $0x8,0x40(%rsp)
			break;
    4651:	eb c8                	jmp    461b <cbvprintf+0x82>
			conv->flag_space = true;
    4653:	80 4c 24 40 10       	orb    $0x10,0x40(%rsp)
			break;
    4658:	eb c1                	jmp    461b <cbvprintf+0x82>
			conv->flag_hash = true;
    465a:	80 4c 24 40 20       	orb    $0x20,0x40(%rsp)
			break;
    465f:	eb ba                	jmp    461b <cbvprintf+0x82>
			conv->flag_zero = true;
    4661:	80 4c 24 40 40       	orb    $0x40,0x40(%rsp)
			break;
    4666:	eb b3                	jmp    461b <cbvprintf+0x82>
	conv->width_present = true;
    4668:	80 4c 24 40 80       	orb    $0x80,0x40(%rsp)
    466d:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	if (*sp == '*') {
    4672:	80 7d 00 2a          	cmpb   $0x2a,0x0(%rbp)
    4676:	75 0a                	jne    4682 <cbvprintf+0xe9>
		conv->width_star = true;
    4678:	80 4c 24 41 01       	orb    $0x1,0x41(%rsp)
		return ++sp;
    467d:	48 ff c5             	inc    %rbp
    4680:	eb 5d                	jmp    46df <cbvprintf+0x146>
	size_t width = extract_decimal(&sp);
    4682:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    4687:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    468c:	e8 24 fe ff ff       	callq  44b5 <extract_decimal>
	if (sp != wp) {
    4691:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    4696:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    469b:	48 39 e9             	cmp    %rbp,%rcx
    469e:	74 3f                	je     46df <cbvprintf+0x146>
		conv->width_present = true;
    46a0:	8a 54 24 40          	mov    0x40(%rsp),%dl
		conv->width_value = width;
    46a4:	89 44 24 44          	mov    %eax,0x44(%rsp)
				      || (width != (size_t)conv->width_value));
    46a8:	bf 01 00 00 00       	mov    $0x1,%edi
		conv->width_present = true;
    46ad:	83 ca 80             	or     $0xffffff80,%edx
    46b0:	88 54 24 40          	mov    %dl,0x40(%rsp)
		conv->unsupported |= ((conv->width_value < 0)
    46b4:	d0 ea                	shr    %dl
    46b6:	83 e2 01             	and    $0x1,%edx
				      || (width != (size_t)conv->width_value));
    46b9:	85 c0                	test   %eax,%eax
    46bb:	78 0e                	js     46cb <cbvprintf+0x132>
    46bd:	48 63 f8             	movslq %eax,%rdi
    46c0:	48 39 c7             	cmp    %rax,%rdi
    46c3:	40 0f 95 c7          	setne  %dil
    46c7:	40 0f b6 ff          	movzbl %dil,%edi
		conv->unsupported |= ((conv->width_value < 0)
    46cb:	8a 44 24 40          	mov    0x40(%rsp),%al
    46cf:	09 fa                	or     %edi,%edx
    46d1:	48 89 cd             	mov    %rcx,%rbp
    46d4:	01 d2                	add    %edx,%edx
    46d6:	83 e0 fd             	and    $0xfffffffd,%eax
    46d9:	09 c2                	or     %eax,%edx
    46db:	88 54 24 40          	mov    %dl,0x40(%rsp)
	sp = extract_prec(conv, sp);
    46df:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	conv->prec_present = (*sp == '.');
    46e4:	8a 4d 00             	mov    0x0(%rbp),%cl
    46e7:	80 f9 2e             	cmp    $0x2e,%cl
    46ea:	0f 94 c0             	sete   %al
    46ed:	8d 14 00             	lea    (%rax,%rax,1),%edx
    46f0:	8a 44 24 41          	mov    0x41(%rsp),%al
    46f4:	83 e0 fd             	and    $0xfffffffd,%eax
    46f7:	09 d0                	or     %edx,%eax
    46f9:	88 44 24 41          	mov    %al,0x41(%rsp)
	if (!conv->prec_present) {
    46fd:	80 f9 2e             	cmp    $0x2e,%cl
    4700:	75 6b                	jne    476d <cbvprintf+0x1d4>
	++sp;
    4702:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    4706:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
	if (*sp == '*') {
    470b:	80 7d 01 2a          	cmpb   $0x2a,0x1(%rbp)
    470f:	75 0d                	jne    471e <cbvprintf+0x185>
		conv->prec_star = true;
    4711:	83 c8 04             	or     $0x4,%eax
		return ++sp;
    4714:	48 83 c5 02          	add    $0x2,%rbp
		conv->prec_star = true;
    4718:	88 44 24 41          	mov    %al,0x41(%rsp)
		return ++sp;
    471c:	eb 4f                	jmp    476d <cbvprintf+0x1d4>
	size_t prec = extract_decimal(&sp);
    471e:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    4723:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    4728:	e8 88 fd ff ff       	callq  44b5 <extract_decimal>
			      || (prec != (size_t)conv->prec_value));
    472d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    4732:	b9 01 00 00 00       	mov    $0x1,%ecx
	size_t prec = extract_decimal(&sp);
    4737:	48 89 c2             	mov    %rax,%rdx
	conv->prec_value = prec;
    473a:	89 44 24 48          	mov    %eax,0x48(%rsp)
	conv->unsupported |= ((conv->prec_value < 0)
    473e:	8a 44 24 40          	mov    0x40(%rsp),%al
    4742:	d0 e8                	shr    %al
    4744:	83 e0 01             	and    $0x1,%eax
			      || (prec != (size_t)conv->prec_value));
    4747:	85 d2                	test   %edx,%edx
    4749:	78 0c                	js     4757 <cbvprintf+0x1be>
    474b:	48 63 ca             	movslq %edx,%rcx
    474e:	48 39 d1             	cmp    %rdx,%rcx
    4751:	0f 95 c1             	setne  %cl
    4754:	0f b6 c9             	movzbl %cl,%ecx
	conv->unsupported |= ((conv->prec_value < 0)
    4757:	8a 54 24 40          	mov    0x40(%rsp),%dl
    475b:	09 c8                	or     %ecx,%eax
	return sp;
    475d:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
	conv->unsupported |= ((conv->prec_value < 0)
    4762:	01 c0                	add    %eax,%eax
    4764:	83 e2 fd             	and    $0xfffffffd,%edx
    4767:	09 d0                	or     %edx,%eax
    4769:	88 44 24 40          	mov    %al,0x40(%rsp)
	switch (*sp) {
    476d:	8a 4d 00             	mov    0x0(%rbp),%cl
    4770:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    4774:	80 f9 6c             	cmp    $0x6c,%cl
    4777:	74 54                	je     47cd <cbvprintf+0x234>
    4779:	7f 22                	jg     479d <cbvprintf+0x204>
    477b:	80 f9 68             	cmp    $0x68,%cl
    477e:	74 33                	je     47b3 <cbvprintf+0x21a>
    4780:	80 f9 6a             	cmp    $0x6a,%cl
    4783:	74 6e                	je     47f3 <cbvprintf+0x25a>
    4785:	80 f9 4c             	cmp    $0x4c,%cl
    4788:	75 7d                	jne    4807 <cbvprintf+0x26e>
		conv->unsupported = true;
    478a:	8b 44 24 40          	mov    0x40(%rsp),%eax
    478e:	66 25 fd 87          	and    $0x87fd,%ax
    4792:	66 0d 02 40          	or     $0x4002,%ax
    4796:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
		break;
    479b:	eb 72                	jmp    480f <cbvprintf+0x276>
	switch (*sp) {
    479d:	80 f9 74             	cmp    $0x74,%cl
    47a0:	8a 44 24 41          	mov    0x41(%rsp),%al
    47a4:	74 59                	je     47ff <cbvprintf+0x266>
    47a6:	80 f9 7a             	cmp    $0x7a,%cl
    47a9:	75 5c                	jne    4807 <cbvprintf+0x26e>
		conv->length_mod = LENGTH_Z;
    47ab:	83 e0 87             	and    $0xffffff87,%eax
    47ae:	83 c8 30             	or     $0x30,%eax
    47b1:	eb 3a                	jmp    47ed <cbvprintf+0x254>
		if (*++sp == 'h') {
    47b3:	80 7d 01 68          	cmpb   $0x68,0x1(%rbp)
    47b7:	8a 44 24 41          	mov    0x41(%rsp),%al
    47bb:	75 08                	jne    47c5 <cbvprintf+0x22c>
			conv->length_mod = LENGTH_HH;
    47bd:	83 e0 87             	and    $0xffffff87,%eax
    47c0:	83 c8 08             	or     $0x8,%eax
    47c3:	eb 18                	jmp    47dd <cbvprintf+0x244>
			conv->length_mod = LENGTH_H;
    47c5:	83 e0 87             	and    $0xffffff87,%eax
    47c8:	83 c8 10             	or     $0x10,%eax
    47cb:	eb 20                	jmp    47ed <cbvprintf+0x254>
		if (*++sp == 'l') {
    47cd:	80 7d 01 6c          	cmpb   $0x6c,0x1(%rbp)
    47d1:	8a 44 24 41          	mov    0x41(%rsp),%al
    47d5:	75 10                	jne    47e7 <cbvprintf+0x24e>
			conv->length_mod = LENGTH_LL;
    47d7:	83 e0 87             	and    $0xffffff87,%eax
    47da:	83 c8 20             	or     $0x20,%eax
    47dd:	88 44 24 41          	mov    %al,0x41(%rsp)
			++sp;
    47e1:	48 8d 55 02          	lea    0x2(%rbp),%rdx
    47e5:	eb 28                	jmp    480f <cbvprintf+0x276>
			conv->length_mod = LENGTH_L;
    47e7:	83 e0 87             	and    $0xffffff87,%eax
    47ea:	83 c8 18             	or     $0x18,%eax
    47ed:	88 44 24 41          	mov    %al,0x41(%rsp)
    47f1:	eb 1c                	jmp    480f <cbvprintf+0x276>
		conv->length_mod = LENGTH_J;
    47f3:	8a 44 24 41          	mov    0x41(%rsp),%al
    47f7:	83 e0 87             	and    $0xffffff87,%eax
    47fa:	83 c8 28             	or     $0x28,%eax
    47fd:	eb ee                	jmp    47ed <cbvprintf+0x254>
		conv->length_mod = LENGTH_T;
    47ff:	83 e0 87             	and    $0xffffff87,%eax
    4802:	83 c8 38             	or     $0x38,%eax
    4805:	eb e6                	jmp    47ed <cbvprintf+0x254>
		conv->length_mod = LENGTH_NONE;
    4807:	80 64 24 41 87       	andb   $0x87,0x41(%rsp)
		break;
    480c:	48 89 ea             	mov    %rbp,%rdx
	conv->specifier = *sp++;
    480f:	8a 02                	mov    (%rdx),%al
    4811:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
    4815:	8a 54 24 41          	mov    0x41(%rsp),%dl
    4819:	88 44 24 43          	mov    %al,0x43(%rsp)
	switch (conv->specifier) {
    481d:	3c 78                	cmp    $0x78,%al
    481f:	0f 8f ab 00 00 00    	jg     48d0 <cbvprintf+0x337>
    4825:	3c 57                	cmp    $0x57,%al
    4827:	7f 11                	jg     483a <cbvprintf+0x2a1>
    4829:	3c 41                	cmp    $0x41,%al
    482b:	74 62                	je     488f <cbvprintf+0x2f6>
    482d:	83 e8 45             	sub    $0x45,%eax
    4830:	3c 02                	cmp    $0x2,%al
    4832:	0f 87 98 00 00 00    	ja     48d0 <cbvprintf+0x337>
    4838:	eb 55                	jmp    488f <cbvprintf+0x2f6>
    483a:	8d 48 a8             	lea    -0x58(%rax),%ecx
    483d:	80 f9 20             	cmp    $0x20,%cl
    4840:	0f 87 8a 00 00 00    	ja     48d0 <cbvprintf+0x337>
    4846:	48 8d 3d 77 5a 00 00 	lea    0x5a77(%rip),%rdi        # a2c4 <default_cmd+0x64>
    484d:	0f b6 c9             	movzbl %cl,%ecx
    4850:	48 63 0c 8f          	movslq (%rdi,%rcx,4),%rcx
    4854:	48 01 f9             	add    %rdi,%rcx
    4857:	3e ff e1             	notrack jmpq *%rcx
		conv->specifier_cat = SPECIFIER_SINT;
    485a:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    485e:	83 e1 f8             	and    $0xfffffff8,%ecx
    4861:	83 c9 01             	or     $0x1,%ecx
    4864:	eb 0a                	jmp    4870 <cbvprintf+0x2d7>
		conv->specifier_cat = SPECIFIER_UINT;
    4866:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    486a:	83 e1 f8             	and    $0xfffffff8,%ecx
    486d:	83 c9 02             	or     $0x2,%ecx
    4870:	f3 0f 1e fa          	endbr64 
		if (conv->length_mod == LENGTH_UPPER_L) {
    4874:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
    4877:	88 4c 24 42          	mov    %cl,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    487b:	80 fa 40             	cmp    $0x40,%dl
    487e:	75 05                	jne    4885 <cbvprintf+0x2ec>
			conv->invalid = true;
    4880:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    4885:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
    4887:	3c 63                	cmp    $0x63,%al
    4889:	75 4c                	jne    48d7 <cbvprintf+0x33e>
			unsupported = (conv->length_mod != LENGTH_NONE);
    488b:	84 d2                	test   %dl,%dl
    488d:	eb 3c                	jmp    48cb <cbvprintf+0x332>
		conv->specifier_cat = SPECIFIER_FP;
    488f:	8a 44 24 42          	mov    0x42(%rsp),%al
			unsupported = true;
    4893:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
    4895:	83 e0 f8             	and    $0xfffffff8,%eax
    4898:	83 c8 04             	or     $0x4,%eax
    489b:	88 44 24 42          	mov    %al,0x42(%rsp)
			break;
    489f:	eb 36                	jmp    48d7 <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    48a1:	8a 44 24 42          	mov    0x42(%rsp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
    48a5:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
    48a8:	83 e0 f8             	and    $0xfffffff8,%eax
    48ab:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    48ae:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    48b1:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    48b5:	0f 94 c1             	sete   %cl
    48b8:	eb 1d                	jmp    48d7 <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    48ba:	8a 44 24 42          	mov    0x42(%rsp),%al
    48be:	83 e0 f8             	and    $0xfffffff8,%eax
    48c1:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
    48c4:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    48c7:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod != LENGTH_NONE) {
    48cb:	0f 95 c1             	setne  %cl
    48ce:	eb 07                	jmp    48d7 <cbvprintf+0x33e>
		conv->invalid = true;
    48d0:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    48d5:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
    48d7:	8a 54 24 40          	mov    0x40(%rsp),%dl
    48db:	89 d0                	mov    %edx,%eax
    48dd:	83 e2 fd             	and    $0xfffffffd,%edx
    48e0:	d0 e8                	shr    %al
    48e2:	83 e0 01             	and    $0x1,%eax
    48e5:	09 c8                	or     %ecx,%eax
    48e7:	01 c0                	add    %eax,%eax
    48e9:	09 d0                	or     %edx,%eax
    48eb:	88 44 24 40          	mov    %al,0x40(%rsp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set with if present.
		 */
		if (conv->width_star) {
    48ef:	8a 4c 24 41          	mov    0x41(%rsp),%cl
    48f3:	f6 c1 01             	test   $0x1,%cl
    48f6:	74 3c                	je     4934 <cbvprintf+0x39b>
			width = va_arg(ap, int);
    48f8:	41 8b 14 24          	mov    (%r12),%edx
    48fc:	83 fa 2f             	cmp    $0x2f,%edx
    48ff:	77 10                	ja     4911 <cbvprintf+0x378>
    4901:	89 d0                	mov    %edx,%eax
    4903:	83 c2 08             	add    $0x8,%edx
    4906:	49 03 44 24 10       	add    0x10(%r12),%rax
    490b:	41 89 14 24          	mov    %edx,(%r12)
    490f:	eb 0e                	jmp    491f <cbvprintf+0x386>
    4911:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4916:	48 8d 50 08          	lea    0x8(%rax),%rdx
    491a:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    491f:	8b 00                	mov    (%rax),%eax
    4921:	89 44 24 08          	mov    %eax,0x8(%rsp)

			if (width < 0) {
    4925:	85 c0                	test   %eax,%eax
    4927:	79 22                	jns    494b <cbvprintf+0x3b2>
				conv->flag_dash = true;
    4929:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
				width = -width;
    492e:	f7 5c 24 08          	negl   0x8(%rsp)
    4932:	eb 17                	jmp    494b <cbvprintf+0x3b2>
			}
		} else if (conv->width_present) {
    4934:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
		int width = -1;
    4939:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%rsp)
    4940:	ff 
		} else if (conv->width_present) {
    4941:	79 08                	jns    494b <cbvprintf+0x3b2>
			width = conv->width_value;
    4943:	8b 44 24 44          	mov    0x44(%rsp),%eax
    4947:	89 44 24 08          	mov    %eax,0x8(%rsp)

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    494b:	f6 c1 04             	test   $0x4,%cl
    494e:	74 3a                	je     498a <cbvprintf+0x3f1>
			int arg = va_arg(ap, int);
    4950:	41 8b 14 24          	mov    (%r12),%edx
    4954:	83 fa 2f             	cmp    $0x2f,%edx
    4957:	77 10                	ja     4969 <cbvprintf+0x3d0>
    4959:	89 d0                	mov    %edx,%eax
    495b:	83 c2 08             	add    $0x8,%edx
    495e:	49 03 44 24 10       	add    0x10(%r12),%rax
    4963:	41 89 14 24          	mov    %edx,(%r12)
    4967:	eb 0e                	jmp    4977 <cbvprintf+0x3de>
    4969:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    496e:	48 8d 50 08          	lea    0x8(%rax),%rdx
    4972:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    4977:	44 8b 10             	mov    (%rax),%r10d

			if (arg < 0) {
    497a:	45 85 d2             	test   %r10d,%r10d
    497d:	79 19                	jns    4998 <cbvprintf+0x3ff>
				conv->prec_present = false;
    497f:	80 64 24 41 fd       	andb   $0xfd,0x41(%rsp)
		int precision = -1;
    4984:	41 83 ca ff          	or     $0xffffffff,%r10d
    4988:	eb 0e                	jmp    4998 <cbvprintf+0x3ff>
    498a:	41 83 ca ff          	or     $0xffffffff,%r10d
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
    498e:	80 e1 02             	and    $0x2,%cl
    4991:	74 05                	je     4998 <cbvprintf+0x3ff>
			precision = conv->prec_value;
    4993:	44 8b 54 24 48       	mov    0x48(%rsp),%r10d
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    4998:	8a 54 24 41          	mov    0x41(%rsp),%dl
			= (enum specifier_cat_enum)conv->specifier_cat;
    499c:	8a 44 24 42          	mov    0x42(%rsp),%al
		conv->pad0_value = 0;
    49a0:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
    49a7:	00 00 
			= (enum length_mod_enum)conv->length_mod;
    49a9:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
    49ac:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
    49af:	83 e2 0f             	and    $0xf,%edx
		enum length_mod_enum length_mod
    49b2:	0f b6 ca             	movzbl %dl,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    49b5:	83 f8 01             	cmp    $0x1,%eax
    49b8:	0f 85 d8 00 00 00    	jne    4a96 <cbvprintf+0x4fd>
			switch (length_mod) {
    49be:	41 8b 04 24          	mov    (%r12),%eax
    49c2:	80 fa 05             	cmp    $0x5,%dl
    49c5:	0f 84 1e 01 00 00    	je     4ae9 <cbvprintf+0x550>
    49cb:	77 10                	ja     49dd <cbvprintf+0x444>
    49cd:	80 fa 03             	cmp    $0x3,%dl
    49d0:	74 3f                	je     4a11 <cbvprintf+0x478>
    49d2:	80 fa 04             	cmp    $0x4,%dl
    49d5:	0f 84 0e 01 00 00    	je     4ae9 <cbvprintf+0x550>
    49db:	eb 0c                	jmp    49e9 <cbvprintf+0x450>
    49dd:	8d 7a 0a             	lea    0xa(%rdx),%edi
    49e0:	83 e7 0f             	and    $0xf,%edi
    49e3:	40 80 ff 01          	cmp    $0x1,%dil
    49e7:	76 5e                	jbe    4a47 <cbvprintf+0x4ae>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
    49e9:	83 f8 2f             	cmp    $0x2f,%eax
    49ec:	77 10                	ja     49fe <cbvprintf+0x465>
    49ee:	89 c7                	mov    %eax,%edi
    49f0:	83 c0 08             	add    $0x8,%eax
    49f3:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    49f8:	41 89 04 24          	mov    %eax,(%r12)
    49fc:	eb 0e                	jmp    4a0c <cbvprintf+0x473>
    49fe:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    4a03:	48 8d 47 08          	lea    0x8(%rdi),%rax
    4a07:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    4a0c:	48 63 07             	movslq (%rdi),%rax
    4a0f:	eb 5c                	jmp    4a6d <cbvprintf+0x4d4>
				break;
			case LENGTH_L:
				if (WCHAR_IS_SIGNED
    4a11:	80 7c 24 43 63       	cmpb   $0x63,0x43(%rsp)
    4a16:	0f 85 cd 00 00 00    	jne    4ae9 <cbvprintf+0x550>
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
    4a1c:	83 f8 2f             	cmp    $0x2f,%eax
    4a1f:	77 10                	ja     4a31 <cbvprintf+0x498>
    4a21:	89 c1                	mov    %eax,%ecx
    4a23:	83 c0 08             	add    $0x8,%eax
    4a26:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    4a2b:	41 89 04 24          	mov    %eax,(%r12)
    4a2f:	eb 0e                	jmp    4a3f <cbvprintf+0x4a6>
    4a31:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    4a36:	48 8d 41 08          	lea    0x8(%rcx),%rax
    4a3a:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    4a3f:	48 63 01             	movslq (%rcx),%rax
    4a42:	e9 b1 01 00 00       	jmpq   4bf8 <cbvprintf+0x65f>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    4a47:	83 f8 2f             	cmp    $0x2f,%eax
    4a4a:	77 10                	ja     4a5c <cbvprintf+0x4c3>
    4a4c:	89 c7                	mov    %eax,%edi
    4a4e:	83 c0 08             	add    $0x8,%eax
    4a51:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    4a56:	41 89 04 24          	mov    %eax,(%r12)
    4a5a:	eb 0e                	jmp    4a6a <cbvprintf+0x4d1>
    4a5c:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    4a61:	48 8d 47 08          	lea    0x8(%rdi),%rax
    4a65:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    4a6a:	48 8b 07             	mov    (%rdi),%rax
				value->sint =
    4a6d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    4a72:	83 f9 01             	cmp    $0x1,%ecx
    4a75:	75 0b                	jne    4a82 <cbvprintf+0x4e9>
				value->sint = (char)value->sint;
    4a77:	48 0f be 44 24 30    	movsbq 0x30(%rsp),%rax
    4a7d:	e9 76 01 00 00       	jmpq   4bf8 <cbvprintf+0x65f>
			} else if (length_mod == LENGTH_H) {
    4a82:	83 f9 02             	cmp    $0x2,%ecx
    4a85:	0f 85 72 01 00 00    	jne    4bfd <cbvprintf+0x664>
				value->sint = (short)value->sint;
    4a8b:	48 0f bf 44 24 30    	movswq 0x30(%rsp),%rax
    4a91:	e9 62 01 00 00       	jmpq   4bf8 <cbvprintf+0x65f>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    4a96:	83 f8 02             	cmp    $0x2,%eax
    4a99:	0f 85 ca 00 00 00    	jne    4b69 <cbvprintf+0x5d0>
			switch (length_mod) {
    4a9f:	41 8b 04 24          	mov    (%r12),%eax
    4aa3:	80 fa 05             	cmp    $0x5,%dl
    4aa6:	74 41                	je     4ae9 <cbvprintf+0x550>
    4aa8:	77 0c                	ja     4ab6 <cbvprintf+0x51d>
    4aaa:	80 fa 03             	cmp    $0x3,%dl
    4aad:	74 3a                	je     4ae9 <cbvprintf+0x550>
    4aaf:	80 fa 04             	cmp    $0x4,%dl
    4ab2:	74 35                	je     4ae9 <cbvprintf+0x550>
    4ab4:	eb 0c                	jmp    4ac2 <cbvprintf+0x529>
    4ab6:	8d 7a 0a             	lea    0xa(%rdx),%edi
    4ab9:	83 e7 0f             	and    $0xf,%edi
    4abc:	40 80 ff 01          	cmp    $0x1,%dil
    4ac0:	76 52                	jbe    4b14 <cbvprintf+0x57b>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->uint = va_arg(ap, unsigned int);
    4ac2:	83 f8 2f             	cmp    $0x2f,%eax
    4ac5:	77 10                	ja     4ad7 <cbvprintf+0x53e>
    4ac7:	89 c7                	mov    %eax,%edi
    4ac9:	83 c0 08             	add    $0x8,%eax
    4acc:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    4ad1:	41 89 04 24          	mov    %eax,(%r12)
    4ad5:	eb 0e                	jmp    4ae5 <cbvprintf+0x54c>
    4ad7:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    4adc:	48 8d 47 08          	lea    0x8(%rdi),%rax
    4ae0:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    4ae5:	8b 07                	mov    (%rdi),%eax
    4ae7:	eb 51                	jmp    4b3a <cbvprintf+0x5a1>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
    4ae9:	83 f8 2f             	cmp    $0x2f,%eax
    4aec:	77 10                	ja     4afe <cbvprintf+0x565>
    4aee:	89 c1                	mov    %eax,%ecx
    4af0:	83 c0 08             	add    $0x8,%eax
    4af3:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    4af8:	41 89 04 24          	mov    %eax,(%r12)
    4afc:	eb 0e                	jmp    4b0c <cbvprintf+0x573>
    4afe:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    4b03:	48 8d 41 08          	lea    0x8(%rcx),%rax
    4b07:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    4b0c:	48 8b 01             	mov    (%rcx),%rax
    4b0f:	e9 e4 00 00 00       	jmpq   4bf8 <cbvprintf+0x65f>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    4b14:	83 f8 2f             	cmp    $0x2f,%eax
    4b17:	77 10                	ja     4b29 <cbvprintf+0x590>
    4b19:	89 c7                	mov    %eax,%edi
    4b1b:	83 c0 08             	add    $0x8,%eax
    4b1e:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    4b23:	41 89 04 24          	mov    %eax,(%r12)
    4b27:	eb 0e                	jmp    4b37 <cbvprintf+0x59e>
    4b29:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    4b2e:	48 8d 47 08          	lea    0x8(%rdi),%rax
    4b32:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    4b37:	48 8b 07             	mov    (%rdi),%rax
				value->uint =
    4b3a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    4b3f:	83 f9 01             	cmp    $0x1,%ecx
    4b42:	75 0e                	jne    4b52 <cbvprintf+0x5b9>
				value->uint = (unsigned char)value->uint;
    4b44:	48 81 64 24 30 ff 00 	andq   $0xff,0x30(%rsp)
    4b4b:	00 00 
    4b4d:	e9 ab 00 00 00       	jmpq   4bfd <cbvprintf+0x664>
			} else if (length_mod == LENGTH_H) {
    4b52:	83 f9 02             	cmp    $0x2,%ecx
    4b55:	0f 85 a2 00 00 00    	jne    4bfd <cbvprintf+0x664>
				value->uint = (unsigned short)value->uint;
    4b5b:	48 81 64 24 30 ff ff 	andq   $0xffff,0x30(%rsp)
    4b62:	00 00 
    4b64:	e9 94 00 00 00       	jmpq   4bfd <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    4b69:	83 f8 04             	cmp    $0x4,%eax
    4b6c:	75 5b                	jne    4bc9 <cbvprintf+0x630>
			if (length_mod == LENGTH_UPPER_L) {
    4b6e:	83 f9 08             	cmp    $0x8,%ecx
    4b71:	75 1e                	jne    4b91 <cbvprintf+0x5f8>
				value->ldbl = va_arg(ap, long double);
    4b73:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4b78:	48 83 c0 0f          	add    $0xf,%rax
    4b7c:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    4b80:	48 8d 48 10          	lea    0x10(%rax),%rcx
    4b84:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    4b89:	db 28                	fldt   (%rax)
    4b8b:	db 7c 24 30          	fstpt  0x30(%rsp)
    4b8f:	eb 6c                	jmp    4bfd <cbvprintf+0x664>
			} else {
				value->dbl = va_arg(ap, double);
    4b91:	41 8b 4c 24 04       	mov    0x4(%r12),%ecx
    4b96:	81 f9 af 00 00 00    	cmp    $0xaf,%ecx
    4b9c:	77 11                	ja     4baf <cbvprintf+0x616>
    4b9e:	89 c8                	mov    %ecx,%eax
    4ba0:	83 c1 10             	add    $0x10,%ecx
    4ba3:	49 03 44 24 10       	add    0x10(%r12),%rax
    4ba8:	41 89 4c 24 04       	mov    %ecx,0x4(%r12)
    4bad:	eb 0e                	jmp    4bbd <cbvprintf+0x624>
    4baf:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4bb4:	48 8d 48 08          	lea    0x8(%rax),%rcx
    4bb8:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    4bbd:	f2 0f 10 00          	movsd  (%rax),%xmm0
    4bc1:	f2 0f 11 44 24 30    	movsd  %xmm0,0x30(%rsp)
    4bc7:	eb 34                	jmp    4bfd <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    4bc9:	83 f8 03             	cmp    $0x3,%eax
    4bcc:	75 2f                	jne    4bfd <cbvprintf+0x664>
			value->ptr = va_arg(ap, void *);
    4bce:	41 8b 0c 24          	mov    (%r12),%ecx
    4bd2:	83 f9 2f             	cmp    $0x2f,%ecx
    4bd5:	77 10                	ja     4be7 <cbvprintf+0x64e>
    4bd7:	89 c8                	mov    %ecx,%eax
    4bd9:	83 c1 08             	add    $0x8,%ecx
    4bdc:	49 03 44 24 10       	add    0x10(%r12),%rax
    4be1:	41 89 0c 24          	mov    %ecx,(%r12)
    4be5:	eb 0e                	jmp    4bf5 <cbvprintf+0x65c>
    4be7:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4bec:	48 8d 48 08          	lea    0x8(%rax),%rcx
    4bf0:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    4bf5:	48 8b 00             	mov    (%rax),%rax
    4bf8:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    4bfd:	8a 4c 24 40          	mov    0x40(%rsp),%cl
    4c01:	f6 c1 03             	test   $0x3,%cl
    4c04:	74 23                	je     4c29 <cbvprintf+0x690>
			OUTS(sp, fp);
    4c06:	48 89 e9             	mov    %rbp,%rcx
    4c09:	4c 89 ea             	mov    %r13,%rdx
    4c0c:	4c 89 fe             	mov    %r15,%rsi
    4c0f:	4c 89 f7             	mov    %r14,%rdi
    4c12:	e8 4d f8 ff ff       	callq  4464 <outs>
    4c17:	85 c0                	test   %eax,%eax
    4c19:	0f 88 8c 03 00 00    	js     4fab <cbvprintf+0xa12>
    4c1f:	48 98                	cltq   
    4c21:	48 01 c3             	add    %rax,%rbx
			continue;
    4c24:	e9 78 03 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    4c29:	8a 44 24 43          	mov    0x43(%rsp),%al
    4c2d:	3c 78                	cmp    $0x78,%al
    4c2f:	0f 87 6c 03 00 00    	ja     4fa1 <cbvprintf+0xa08>
    4c35:	3c 62                	cmp    $0x62,%al
    4c37:	77 11                	ja     4c4a <cbvprintf+0x6b1>
    4c39:	3c 25                	cmp    $0x25,%al
    4c3b:	74 2c                	je     4c69 <cbvprintf+0x6d0>
    4c3d:	3c 58                	cmp    $0x58,%al
    4c3f:	0f 84 c6 00 00 00    	je     4d0b <cbvprintf+0x772>
    4c45:	e9 57 03 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
    4c4a:	83 e8 63             	sub    $0x63,%eax
    4c4d:	3c 15                	cmp    $0x15,%al
    4c4f:	0f 87 4c 03 00 00    	ja     4fa1 <cbvprintf+0xa08>
    4c55:	48 8d 3d ec 56 00 00 	lea    0x56ec(%rip),%rdi        # a348 <default_cmd+0xe8>
    4c5c:	0f b6 c0             	movzbl %al,%eax
    4c5f:	48 63 04 87          	movslq (%rdi,%rax,4),%rax
    4c63:	48 01 f8             	add    %rdi,%rax
    4c66:	3e ff e0             	notrack jmpq *%rax
		case '%':
			OUTC('%');
    4c69:	4c 89 fe             	mov    %r15,%rsi
    4c6c:	bf 25 00 00 00       	mov    $0x25,%edi
    4c71:	31 c0                	xor    %eax,%eax
    4c73:	41 ff d6             	callq  *%r14
    4c76:	85 c0                	test   %eax,%eax
    4c78:	0f 88 2d 03 00 00    	js     4fab <cbvprintf+0xa12>
    4c7e:	48 ff c3             	inc    %rbx
			break;
    4c81:	e9 1b 03 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
		case 's': {
			bps = (const char *)value->ptr;
    4c86:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13

			size_t len;

			if (precision >= 0) {
    4c8b:	45 85 d2             	test   %r10d,%r10d
    4c8e:	78 0d                	js     4c9d <cbvprintf+0x704>
				len = strnlen(bps, precision);
    4c90:	49 63 f2             	movslq %r10d,%rsi
    4c93:	4c 89 ef             	mov    %r13,%rdi
    4c96:	e8 55 e8 ff ff       	callq  34f0 <strnlen@plt>
    4c9b:	eb 14                	jmp    4cb1 <cbvprintf+0x718>
			} else {
				len = strlen(bps);
    4c9d:	31 c0                	xor    %eax,%eax
    4c9f:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    4ca3:	4c 89 ef             	mov    %r13,%rdi
    4ca6:	f2 ae                	repnz scas %es:(%rdi),%al
    4ca8:	48 89 c8             	mov    %rcx,%rax
    4cab:	48 f7 d0             	not    %rax
    4cae:	48 ff c8             	dec    %rax
			}

			bpe = bps + len;
    4cb1:	4c 01 e8             	add    %r13,%rax
		char sign = 0;
    4cb4:	45 31 c9             	xor    %r9d,%r9d
			bpe = bps + len;
    4cb7:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			precision = -1;

			break;
    4cbc:	e9 55 01 00 00       	jmpq   4e16 <cbvprintf+0x87d>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    4cc1:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			bpe = buf + 1;
			break;
    4cc6:	45 31 c9             	xor    %r9d,%r9d
			bps = buf;
    4cc9:	4c 8d 6c 24 52       	lea    0x52(%rsp),%r13
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    4cce:	88 44 24 52          	mov    %al,0x52(%rsp)
			bpe = buf + 1;
    4cd2:	48 8d 44 24 53       	lea    0x53(%rsp),%rax
    4cd7:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			break;
    4cdc:	e9 3e 01 00 00       	jmpq   4e1f <cbvprintf+0x886>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
    4ce1:	41 b1 2b             	mov    $0x2b,%r9b
			if (conv->flag_plus) {
    4ce4:	f6 c1 08             	test   $0x8,%cl
    4ce7:	75 0b                	jne    4cf4 <cbvprintf+0x75b>
			} else if (conv->flag_space) {
				sign = ' ';
    4ce9:	80 e1 10             	and    $0x10,%cl
    4cec:	41 0f 95 c1          	setne  %r9b
    4cf0:	41 c1 e1 05          	shl    $0x5,%r9d

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    4cf4:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			if (sint < 0) {
    4cf9:	48 85 c0             	test   %rax,%rax
    4cfc:	79 10                	jns    4d0e <cbvprintf+0x775>
				sign = '-';
				value->uint = (uint_value_type)-sint;
    4cfe:	48 f7 d8             	neg    %rax
				sign = '-';
    4d01:	41 b1 2d             	mov    $0x2d,%r9b
				value->uint = (uint_value_type)-sint;
    4d04:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    4d09:	eb 03                	jmp    4d0e <cbvprintf+0x775>
		switch (conv->specifier) {
    4d0b:	45 31 c9             	xor    %r9d,%r9d
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    4d0e:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    4d13:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    4d18:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    4d1d:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    4d22:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    4d27:	e8 c0 f7 ff ff       	callq  44ec <encode_uint>
    4d2c:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
    4d31:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    4d36:	49 89 c5             	mov    %rax,%r13
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    4d39:	45 85 d2             	test   %r10d,%r10d
    4d3c:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
    4d41:	0f 88 ca 00 00 00    	js     4e11 <cbvprintf+0x878>
				size_t len = bpe - bps;
    4d47:	48 89 c1             	mov    %rax,%rcx
				 * conversions with precision.
				 */
				conv->flag_zero = false;

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    4d4a:	49 63 d2             	movslq %r10d,%rdx
				conv->flag_zero = false;
    4d4d:	80 64 24 40 bf       	andb   $0xbf,0x40(%rsp)
				size_t len = bpe - bps;
    4d52:	4c 29 e9             	sub    %r13,%rcx
		const char *bpe = buf + sizeof(buf);
    4d55:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
				if (len < (size_t)precision) {
    4d5a:	48 39 ca             	cmp    %rcx,%rdx
    4d5d:	0f 86 b3 00 00 00    	jbe    4e16 <cbvprintf+0x87d>
					conv->pad0_value = precision - (int)len;
    4d63:	41 29 ca             	sub    %ecx,%r10d
    4d66:	44 89 54 24 44       	mov    %r10d,0x44(%rsp)
    4d6b:	e9 a6 00 00 00       	jmpq   4e16 <cbvprintf+0x87d>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    4d70:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    4d75:	48 8d 05 fc 5a 00 00 	lea    0x5afc(%rip),%rax        # a878 <default_cmd+0x618>
    4d7c:	45 31 c9             	xor    %r9d,%r9d
    4d7f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			bps = "(nil)";
    4d84:	4c 8d 68 fb          	lea    -0x5(%rax),%r13
			if (value->ptr != NULL) {
    4d88:	48 85 ff             	test   %rdi,%rdi
    4d8b:	0f 84 8e 00 00 00    	je     4e1f <cbvprintf+0x886>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    4d91:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    4d96:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    4d9b:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    4da0:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    4da5:	e8 42 f7 ff ff       	callq  44ec <encode_uint>
				goto prec_int_pad0;
    4daa:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    4daf:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
				bps = encode_uint((uintptr_t)value->ptr, conv,
    4db4:	49 89 c5             	mov    %rax,%r13
				conv->altform_0c = true;
    4db7:	66 8b 44 24 42       	mov    0x42(%rsp),%ax
    4dbc:	66 25 ef 00          	and    $0xef,%ax
    4dc0:	66 0d 10 78          	or     $0x7810,%ax
    4dc4:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
				goto prec_int_pad0;
    4dc9:	e9 6b ff ff ff       	jmpq   4d39 <cbvprintf+0x7a0>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    4dce:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    4dd3:	48 63 c3             	movslq %ebx,%rax
    4dd6:	80 fa 07             	cmp    $0x7,%dl
    4dd9:	0f 87 c2 01 00 00    	ja     4fa1 <cbvprintf+0xa08>
    4ddf:	48 8d 35 ba 55 00 00 	lea    0x55ba(%rip),%rsi        # a3a0 <default_cmd+0x140>
    4de6:	0f b6 d2             	movzbl %dl,%edx
    4de9:	48 63 14 96          	movslq (%rsi,%rdx,4),%rdx
    4ded:	48 01 f2             	add    %rsi,%rdx
    4df0:	3e ff e2             	notrack jmpq *%rdx
		*(int *)dp = count;
    4df3:	89 01                	mov    %eax,(%rcx)
		break;
    4df5:	e9 a7 01 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
		*(signed char *)dp = (signed char)count;
    4dfa:	88 19                	mov    %bl,(%rcx)
		break;
    4dfc:	e9 a0 01 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
		*(short *)dp = (short)count;
    4e01:	66 89 19             	mov    %bx,(%rcx)
		break;
    4e04:	e9 98 01 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    4e09:	48 89 01             	mov    %rax,(%rcx)
		break;
    4e0c:	e9 90 01 00 00       	jmpq   4fa1 <cbvprintf+0xa08>
		const char *bpe = buf + sizeof(buf);
    4e11:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    4e16:	4d 85 ed             	test   %r13,%r13
    4e19:	0f 84 82 01 00 00    	je     4fa1 <cbvprintf+0xa08>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    4e1f:	48 8b 44 24 10       	mov    0x10(%rsp),%rax

		if (sign != 0) {
			nj_len += 1U;
		}

		if (conv->altform_0c) {
    4e24:	8a 4c 24 42          	mov    0x42(%rsp),%cl
		size_t nj_len = (bpe - bps);
    4e28:	4c 29 e8             	sub    %r13,%rax
			nj_len += 1U;
    4e2b:	41 80 f9 01          	cmp    $0x1,%r9b
    4e2f:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		if (conv->altform_0c) {
    4e33:	f6 c1 10             	test   $0x10,%cl
    4e36:	74 06                	je     4e3e <cbvprintf+0x8a5>
			nj_len += 2U;
    4e38:	48 83 c0 02          	add    $0x2,%rax
    4e3c:	eb 0c                	jmp    4e4a <cbvprintf+0x8b1>
		} else if (conv->altform_0) {
    4e3e:	89 ca                	mov    %ecx,%edx
    4e40:	83 e2 08             	and    $0x8,%edx
			nj_len += 1U;
    4e43:	80 fa 01             	cmp    $0x1,%dl
    4e46:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		}

		nj_len += conv->pad0_value;
    4e4a:	48 63 54 24 44       	movslq 0x44(%rsp),%rdx
    4e4f:	48 01 d0             	add    %rdx,%rax
		if (conv->pad_fp) {
    4e52:	80 e1 40             	and    $0x40,%cl
    4e55:	74 08                	je     4e5f <cbvprintf+0x8c6>
			nj_len += conv->pad0_pre_exp;
    4e57:	48 63 54 24 48       	movslq 0x48(%rsp),%rdx
    4e5c:	48 01 d0             	add    %rdx,%rax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    4e5f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%rsp)
    4e64:	7e 73                	jle    4ed9 <cbvprintf+0x940>
			width -= (int)nj_len;
    4e66:	29 44 24 08          	sub    %eax,0x8(%rsp)

			if (!conv->flag_dash) {
    4e6a:	8a 44 24 40          	mov    0x40(%rsp),%al
    4e6e:	a8 04                	test   $0x4,%al
    4e70:	75 67                	jne    4ed9 <cbvprintf+0x940>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    4e72:	a8 40                	test   $0x40,%al
    4e74:	74 21                	je     4e97 <cbvprintf+0x8fe>
					if (sign != 0) {
    4e76:	45 84 c9             	test   %r9b,%r9b
    4e79:	74 20                	je     4e9b <cbvprintf+0x902>
						OUTC(sign);
    4e7b:	31 c0                	xor    %eax,%eax
    4e7d:	41 0f be f9          	movsbl %r9b,%edi
    4e81:	4c 89 fe             	mov    %r15,%rsi
    4e84:	41 ff d6             	callq  *%r14
    4e87:	85 c0                	test   %eax,%eax
    4e89:	0f 88 1c 01 00 00    	js     4fab <cbvprintf+0xa12>
    4e8f:	48 ff c3             	inc    %rbx
						sign = 0;
    4e92:	45 31 c9             	xor    %r9d,%r9d
    4e95:	eb 04                	jmp    4e9b <cbvprintf+0x902>
				char pad = ' ';
    4e97:	b0 20                	mov    $0x20,%al
    4e99:	eb 02                	jmp    4e9d <cbvprintf+0x904>
					}
					pad = '0';
    4e9b:	b0 30                	mov    $0x30,%al
    4e9d:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
				}

				while (width-- > 0) {
					OUTC(pad);
    4ea1:	0f be d0             	movsbl %al,%edx
				while (width-- > 0) {
    4ea4:	ff 4c 24 08          	decl   0x8(%rsp)
    4ea8:	85 c9                	test   %ecx,%ecx
    4eaa:	7e 2d                	jle    4ed9 <cbvprintf+0x940>
					OUTC(pad);
    4eac:	31 c0                	xor    %eax,%eax
    4eae:	44 88 4c 24 1f       	mov    %r9b,0x1f(%rsp)
    4eb3:	4c 89 fe             	mov    %r15,%rsi
    4eb6:	89 d7                	mov    %edx,%edi
    4eb8:	89 54 24 18          	mov    %edx,0x18(%rsp)
    4ebc:	41 ff d6             	callq  *%r14
    4ebf:	85 c0                	test   %eax,%eax
    4ec1:	0f 88 e4 00 00 00    	js     4fab <cbvprintf+0xa12>
				while (width-- > 0) {
    4ec7:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
    4ecb:	8b 54 24 18          	mov    0x18(%rsp),%edx
					OUTC(pad);
    4ecf:	48 ff c3             	inc    %rbx
    4ed2:	44 8a 4c 24 1f       	mov    0x1f(%rsp),%r9b
    4ed7:	eb cb                	jmp    4ea4 <cbvprintf+0x90b>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    4ed9:	45 84 c9             	test   %r9b,%r9b
    4edc:	74 17                	je     4ef5 <cbvprintf+0x95c>
			OUTC(sign);
    4ede:	31 c0                	xor    %eax,%eax
    4ee0:	41 0f be f9          	movsbl %r9b,%edi
    4ee4:	4c 89 fe             	mov    %r15,%rsi
    4ee7:	41 ff d6             	callq  *%r14
    4eea:	85 c0                	test   %eax,%eax
    4eec:	0f 88 b9 00 00 00    	js     4fab <cbvprintf+0xa12>
    4ef2:	48 ff c3             	inc    %rbx
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    4ef5:	8a 44 24 42          	mov    0x42(%rsp),%al
    4ef9:	a8 10                	test   $0x10,%al
    4efb:	75 04                	jne    4f01 <cbvprintf+0x968>
    4efd:	a8 08                	test   $0x8,%al
    4eff:	74 18                	je     4f19 <cbvprintf+0x980>
				OUTC('0');
    4f01:	31 c0                	xor    %eax,%eax
    4f03:	4c 89 fe             	mov    %r15,%rsi
    4f06:	bf 30 00 00 00       	mov    $0x30,%edi
    4f0b:	41 ff d6             	callq  *%r14
    4f0e:	85 c0                	test   %eax,%eax
    4f10:	0f 88 95 00 00 00    	js     4fab <cbvprintf+0xa12>
    4f16:	48 ff c3             	inc    %rbx
			}

			if (conv->altform_0c) {
    4f19:	f6 44 24 42 10       	testb  $0x10,0x42(%rsp)
    4f1e:	74 14                	je     4f34 <cbvprintf+0x99b>
				OUTC(conv->specifier);
    4f20:	31 c0                	xor    %eax,%eax
    4f22:	0f b6 7c 24 43       	movzbl 0x43(%rsp),%edi
    4f27:	4c 89 fe             	mov    %r15,%rsi
    4f2a:	41 ff d6             	callq  *%r14
    4f2d:	85 c0                	test   %eax,%eax
    4f2f:	78 7a                	js     4fab <cbvprintf+0xa12>
    4f31:	48 ff c3             	inc    %rbx
			}

			pad_len = conv->pad0_value;
			while (pad_len-- > 0) {
    4f34:	8b 44 24 44          	mov    0x44(%rsp),%eax
    4f38:	01 d8                	add    %ebx,%eax
    4f3a:	89 44 24 18          	mov    %eax,0x18(%rsp)
    4f3e:	8b 44 24 18          	mov    0x18(%rsp),%eax
    4f42:	29 d8                	sub    %ebx,%eax
    4f44:	85 c0                	test   %eax,%eax
    4f46:	7e 16                	jle    4f5e <cbvprintf+0x9c5>
				OUTC('0');
    4f48:	31 c0                	xor    %eax,%eax
    4f4a:	4c 89 fe             	mov    %r15,%rsi
    4f4d:	bf 30 00 00 00       	mov    $0x30,%edi
    4f52:	41 ff d6             	callq  *%r14
    4f55:	85 c0                	test   %eax,%eax
    4f57:	78 52                	js     4fab <cbvprintf+0xa12>
    4f59:	48 ff c3             	inc    %rbx
    4f5c:	eb e0                	jmp    4f3e <cbvprintf+0x9a5>
			}

			OUTS(bps, bpe);
    4f5e:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    4f63:	4c 89 ea             	mov    %r13,%rdx
    4f66:	4c 89 fe             	mov    %r15,%rsi
    4f69:	4c 89 f7             	mov    %r14,%rdi
    4f6c:	e8 f3 f4 ff ff       	callq  4464 <outs>
    4f71:	85 c0                	test   %eax,%eax
    4f73:	78 36                	js     4fab <cbvprintf+0xa12>
    4f75:	44 8b 6c 24 08       	mov    0x8(%rsp),%r13d
    4f7a:	48 98                	cltq   
    4f7c:	48 01 c3             	add    %rax,%rbx
    4f7f:	41 01 dd             	add    %ebx,%r13d
		}

		/* Finish left justification */
		while (width > 0) {
    4f82:	44 89 e8             	mov    %r13d,%eax
    4f85:	29 d8                	sub    %ebx,%eax
    4f87:	85 c0                	test   %eax,%eax
    4f89:	7e 16                	jle    4fa1 <cbvprintf+0xa08>
			OUTC(' ');
    4f8b:	31 c0                	xor    %eax,%eax
    4f8d:	4c 89 fe             	mov    %r15,%rsi
    4f90:	bf 20 00 00 00       	mov    $0x20,%edi
    4f95:	41 ff d6             	callq  *%r14
    4f98:	85 c0                	test   %eax,%eax
    4f9a:	78 0f                	js     4fab <cbvprintf+0xa12>
    4f9c:	48 ff c3             	inc    %rbx
			--width;
    4f9f:	eb e1                	jmp    4f82 <cbvprintf+0x9e9>
			OUTS(bps, bpe);
    4fa1:	49 89 ed             	mov    %rbp,%r13
    4fa4:	e9 20 f6 ff ff       	jmpq   45c9 <cbvprintf+0x30>
		}
	}

	return count;
    4fa9:	89 d8                	mov    %ebx,%eax
#undef OUTS
#undef OUTC
}
    4fab:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
    4fb0:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    4fb7:	00 00 
    4fb9:	74 05                	je     4fc0 <cbvprintf+0xa27>
    4fbb:	e8 f0 e4 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    4fc0:	48 83 c4 78          	add    $0x78,%rsp
    4fc4:	5b                   	pop    %rbx
    4fc5:	5d                   	pop    %rbp
    4fc6:	41 5c                	pop    %r12
    4fc8:	41 5d                	pop    %r13
    4fca:	41 5e                	pop    %r14
    4fcc:	41 5f                	pop    %r15
    4fce:	c3                   	retq   

0000000000004fcf <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
    4fcf:	f3 0f 1e fa          	endbr64 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    4fd3:	c3                   	retq   

0000000000004fd4 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    4fd4:	f3 0f 1e fa          	endbr64 
    4fd8:	50                   	push   %rax
    4fd9:	48 8d 3d 4a 56 00 00 	lea    0x564a(%rip),%rdi        # a62a <default_cmd+0x3ca>
    4fe0:	e8 0b 3d 00 00       	callq  8cf0 <z_impl_device_get_binding>
	__printk_hook_install(console_out);
    4fe5:	48 8d 3d 10 00 00 00 	lea    0x10(%rip),%rdi        # 4ffc <console_out>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    4fec:	48 89 05 75 b5 00 00 	mov    %rax,0xb575(%rip)        # 10568 <uart_console_dev>
	__printk_hook_install(console_out);
    4ff3:	e8 d7 f1 ff ff       	callq  41cf <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
    4ff8:	31 c0                	xor    %eax,%eax
    4ffa:	5a                   	pop    %rdx
    4ffb:	c3                   	retq   

0000000000004ffc <console_out>:
{
    4ffc:	f3 0f 1e fa          	endbr64 
    5000:	41 54                	push   %r12
    5002:	41 89 fc             	mov    %edi,%r12d
	if ('\n' == c) {
    5005:	83 ff 0a             	cmp    $0xa,%edi
    5008:	75 13                	jne    501d <console_out+0x21>
    500a:	48 8b 3d 57 b5 00 00 	mov    0xb557(%rip),%rdi        # 10568 <uart_console_dev>
	api->poll_out(dev, out_char);
    5011:	48 8b 47 10          	mov    0x10(%rdi),%rax
    5015:	be 0d 00 00 00       	mov    $0xd,%esi
    501a:	ff 50 08             	callq  *0x8(%rax)
	uart_poll_out(uart_console_dev, c);
    501d:	48 8b 3d 44 b5 00 00 	mov    0xb544(%rip),%rdi        # 10568 <uart_console_dev>
    5024:	48 8b 47 10          	mov    0x10(%rdi),%rax
    5028:	41 0f b6 f4          	movzbl %r12b,%esi
    502c:	ff 50 08             	callq  *0x8(%rax)
}
    502f:	44 89 e0             	mov    %r12d,%eax
    5032:	41 5c                	pop    %r12
    5034:	c3                   	retq   

0000000000005035 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
    5035:	f3 0f 1e fa          	endbr64 
    5039:	50                   	push   %rax
	setvbuf(stdout, NULL, _IOLBF, 512);
    503a:	48 8b 05 67 7f 00 00 	mov    0x7f67(%rip),%rax        # cfa8 <stdout@GLIBC_2.2.5>
    5041:	b9 00 02 00 00       	mov    $0x200,%ecx
    5046:	31 f6                	xor    %esi,%esi
    5048:	ba 01 00 00 00       	mov    $0x1,%edx
    504d:	48 8b 38             	mov    (%rax),%rdi
    5050:	e8 8b e5 ff ff       	callq  35e0 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
    5055:	48 8b 05 94 7f 00 00 	mov    0x7f94(%rip),%rax        # cff0 <stderr@GLIBC_2.2.5>
    505c:	ba 01 00 00 00       	mov    $0x1,%edx
    5061:	31 f6                	xor    %esi,%esi
    5063:	b9 00 02 00 00       	mov    $0x200,%ecx
    5068:	48 8b 38             	mov    (%rax),%rdi
    506b:	e8 70 e5 ff ff       	callq  35e0 <setvbuf@plt>
	__printk_hook_install(putchar);
    5070:	48 8b 3d 21 7f 00 00 	mov    0x7f21(%rip),%rdi        # cf98 <putchar@GLIBC_2.2.5>
    5077:	e8 53 f1 ff ff       	callq  41cf <__printk_hook_install>
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    507c:	31 c0                	xor    %eax,%eax
    507e:	5a                   	pop    %rdx
    507f:	c3                   	retq   

0000000000005080 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
    5080:	f3 0f 1e fa          	endbr64 
    5084:	50                   	push   %rax
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
    5085:	e8 75 1e 00 00       	callq  6eff <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    508a:	48 8b 35 df b4 00 00 	mov    0xb4df(%rip),%rsi        # 10570 <last_tick_time>
    5091:	48 8b 0d e0 b4 00 00 	mov    0xb4e0(%rip),%rcx        # 10578 <tick_period>
    5098:	31 d2                	xor    %edx,%edx
    509a:	48 29 f0             	sub    %rsi,%rax
    509d:	48 f7 f1             	div    %rcx

	last_tick_time += elapsed_ticks*tick_period;
    50a0:	48 63 d0             	movslq %eax,%rdx
	sys_clock_announce(elapsed_ticks);
    50a3:	89 c7                	mov    %eax,%edi
	last_tick_time += elapsed_ticks*tick_period;
    50a5:	48 0f af d1          	imul   %rcx,%rdx
    50a9:	48 01 f2             	add    %rsi,%rdx
    50ac:	48 89 15 bd b4 00 00 	mov    %rdx,0xb4bd(%rip)        # 10570 <last_tick_time>
}
    50b3:	5a                   	pop    %rdx
	sys_clock_announce(elapsed_ticks);
    50b4:	e9 16 4d 00 00       	jmpq   9dcf <sys_clock_announce>

00000000000050b9 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int sys_clock_driver_init(const struct device *dev)
{
    50b9:	f3 0f 1e fa          	endbr64 
    50bd:	50                   	push   %rax
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    50be:	48 c7 05 af b4 00 00 	movq   $0x2710,0xb4af(%rip)        # 10578 <tick_period>
    50c5:	10 27 00 00 

	last_tick_time = hwm_get_time();
    50c9:	e8 31 1e 00 00       	callq  6eff <hwm_get_time>
	hwtimer_enable(tick_period);
    50ce:	48 8b 3d a3 b4 00 00 	mov    0xb4a3(%rip),%rdi        # 10578 <tick_period>
	last_tick_time = hwm_get_time();
    50d5:	48 89 05 94 b4 00 00 	mov    %rax,0xb494(%rip)        # 10570 <last_tick_time>
	hwtimer_enable(tick_period);
    50dc:	e8 bf 20 00 00       	callq  71a0 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    50e1:	31 c9                	xor    %ecx,%ecx
    50e3:	48 8d 15 96 ff ff ff 	lea    -0x6a(%rip),%rdx        # 5080 <np_timer_isr>
    50ea:	31 f6                	xor    %esi,%esi
    50ec:	31 ff                	xor    %edi,%edi
    50ee:	e8 97 24 00 00       	callq  758a <posix_isr_declare>
    50f3:	31 d2                	xor    %edx,%edx
    50f5:	be 01 00 00 00       	mov    $0x1,%esi
    50fa:	31 ff                	xor    %edi,%edi
    50fc:	e8 ae 24 00 00       	callq  75af <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    5101:	31 ff                	xor    %edi,%edi
    5103:	e8 00 14 00 00       	callq  6508 <arch_irq_enable>

	return 0;
}
    5108:	31 c0                	xor    %eax,%eax
    510a:	5a                   	pop    %rdx
    510b:	c3                   	retq   

000000000000510c <sys_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    510c:	f3 0f 1e fa          	endbr64 

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with sys_clock_announce() is INT_MAX
	 */
	if (ticks == K_TICKS_FOREVER) {
		silent_ticks = INT64_MAX;
    5110:	49 b8 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%r8
    5117:	ff ff 7f 
	if (ticks == K_TICKS_FOREVER) {
    511a:	83 ff ff             	cmp    $0xffffffff,%edi
    511d:	74 0c                	je     512b <sys_clock_set_timeout+0x1f>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    511f:	45 31 c0             	xor    %r8d,%r8d
	} else if (ticks > 0) {
    5122:	85 ff                	test   %edi,%edi
    5124:	7e 05                	jle    512b <sys_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
    5126:	ff cf                	dec    %edi
    5128:	4c 63 c7             	movslq %edi,%r8
	}
	hwtimer_set_silent_ticks(silent_ticks);
    512b:	4c 89 c7             	mov    %r8,%rdi
    512e:	e9 1f 22 00 00       	jmpq   7352 <hwtimer_set_silent_ticks>

0000000000005133 <sys_clock_elapsed>:
 * last call to sys_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
uint32_t sys_clock_elapsed(void)
{
    5133:	f3 0f 1e fa          	endbr64 
    5137:	50                   	push   %rax
	return (hwm_get_time() - last_tick_time)/tick_period;
    5138:	e8 c2 1d 00 00       	callq  6eff <hwm_get_time>
    513d:	31 d2                	xor    %edx,%edx
    513f:	48 2b 05 2a b4 00 00 	sub    0xb42a(%rip),%rax        # 10570 <last_tick_time>
    5146:	48 f7 35 2b b4 00 00 	divq   0xb42b(%rip)        # 10578 <tick_period>
}
    514d:	5a                   	pop    %rdx
    514e:	c3                   	retq   

000000000000514f <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
    514f:	f3 0f 1e fa          	endbr64 
    5153:	41 89 f1             	mov    %esi,%r9d
    5156:	89 c8                	mov    %ecx,%eax
    5158:	48 89 d6             	mov    %rdx,%rsi
	if (from_len <= to_len) {
    515b:	44 39 c9             	cmp    %r9d,%ecx
    515e:	77 05                	ja     5165 <_copy+0x16>
		(void)memcpy(to, from, from_len);
    5160:	89 c9                	mov    %ecx,%ecx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    5162:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		return from_len;
    5164:	c3                   	retq   
	} else {
		return TC_CRYPTO_FAIL;
    5165:	31 c0                	xor    %eax,%eax
	}
}
    5167:	c3                   	retq   

0000000000005168 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
    5168:	f3 0f 1e fa          	endbr64 
	(void)memset(to, val, len);
    516c:	89 d1                	mov    %edx,%ecx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    516e:	89 f0                	mov    %esi,%eax
    5170:	f3 aa                	rep stos %al,%es:(%rdi)
}
    5172:	c3                   	retq   

0000000000005173 <_double_byte>:

/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
    5173:	f3 0f 1e fa          	endbr64 
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
    5177:	89 f8                	mov    %edi,%eax
    5179:	b2 1b                	mov    $0x1b,%dl
    517b:	01 ff                	add    %edi,%edi
    517d:	c0 e8 07             	shr    $0x7,%al
    5180:	0f af c2             	imul   %edx,%eax
    5183:	31 f8                	xor    %edi,%eax
}
    5185:	c3                   	retq   

0000000000005186 <_compare>:

int _compare(const uint8_t *a, const uint8_t *b, size_t size)
{
    5186:	f3 0f 1e fa          	endbr64 
	const uint8_t *tempa = a;
	const uint8_t *tempb = b;
	uint8_t result = 0;

	for (unsigned int i = 0; i < size; i++) {
    518a:	45 31 c0             	xor    %r8d,%r8d
	uint8_t result = 0;
    518d:	31 c0                	xor    %eax,%eax
	for (unsigned int i = 0; i < size; i++) {
    518f:	44 89 c1             	mov    %r8d,%ecx
    5192:	48 39 d1             	cmp    %rdx,%rcx
    5195:	73 12                	jae    51a9 <_compare+0x23>
		result |= tempa[i] ^ tempb[i];
    5197:	44 8a 0c 0f          	mov    (%rdi,%rcx,1),%r9b
    519b:	44 32 0c 0e          	xor    (%rsi,%rcx,1),%r9b
	for (unsigned int i = 0; i < size; i++) {
    519f:	41 ff c0             	inc    %r8d
		result |= tempa[i] ^ tempb[i];
    51a2:	44 89 c9             	mov    %r9d,%ecx
    51a5:	09 c8                	or     %ecx,%eax
	for (unsigned int i = 0; i < size; i++) {
    51a7:	eb e6                	jmp    518f <_compare+0x9>
	}
	return result;
    51a9:	0f b6 c0             	movzbl %al,%eax
}
    51ac:	c3                   	retq   

00000000000051ad <add_round_key>:
	(void)_copy(s, sizeof(t), t, sizeof(t));
}

static inline void add_round_key(uint8_t *s, const unsigned int *k)
{
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    51ad:	8a 46 03             	mov    0x3(%rsi),%al
    51b0:	30 07                	xor    %al,(%rdi)
    51b2:	8a 46 02             	mov    0x2(%rsi),%al
    51b5:	30 47 01             	xor    %al,0x1(%rdi)
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    51b8:	8a 46 01             	mov    0x1(%rsi),%al
    51bb:	30 47 02             	xor    %al,0x2(%rdi)
    51be:	8b 06                	mov    (%rsi),%eax
    51c0:	30 47 03             	xor    %al,0x3(%rdi)
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    51c3:	0f b6 46 07          	movzbl 0x7(%rsi),%eax
    51c7:	30 47 04             	xor    %al,0x4(%rdi)
    51ca:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    51ce:	30 47 05             	xor    %al,0x5(%rdi)
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    51d1:	8a 46 05             	mov    0x5(%rsi),%al
    51d4:	30 47 06             	xor    %al,0x6(%rdi)
    51d7:	8b 46 04             	mov    0x4(%rsi),%eax
    51da:	30 47 07             	xor    %al,0x7(%rdi)
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    51dd:	0f b6 46 0b          	movzbl 0xb(%rsi),%eax
    51e1:	30 47 08             	xor    %al,0x8(%rdi)
    51e4:	0f b7 46 0a          	movzwl 0xa(%rsi),%eax
    51e8:	30 47 09             	xor    %al,0x9(%rdi)
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    51eb:	8a 46 09             	mov    0x9(%rsi),%al
    51ee:	30 47 0a             	xor    %al,0xa(%rdi)
    51f1:	8b 46 08             	mov    0x8(%rsi),%eax
    51f4:	30 47 0b             	xor    %al,0xb(%rdi)
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    51f7:	0f b6 46 0f          	movzbl 0xf(%rsi),%eax
    51fb:	30 47 0c             	xor    %al,0xc(%rdi)
    51fe:	0f b7 46 0e          	movzwl 0xe(%rsi),%eax
    5202:	30 47 0d             	xor    %al,0xd(%rdi)
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    5205:	8a 46 0d             	mov    0xd(%rsi),%al
    5208:	30 47 0e             	xor    %al,0xe(%rdi)
    520b:	8b 46 0c             	mov    0xc(%rsi),%eax
    520e:	30 47 0f             	xor    %al,0xf(%rdi)
}
    5211:	c3                   	retq   

0000000000005212 <inv_shift_rows>:
 * This inv_shift_rows also implements the matrix flip required for
 * inv_mix_columns, but performs it here to reduce the number of memory
 * operations.
 */
static inline void inv_shift_rows(uint8_t *s)
{
    5212:	48 83 ec 28          	sub    $0x28,%rsp

	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
	t[4]  = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
	t[8]  = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
	(void)_copy(s, sizeof(t), t, sizeof(t));
    5216:	b9 10 00 00 00       	mov    $0x10,%ecx
    521b:	be 10 00 00 00       	mov    $0x10,%esi
{
    5220:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5227:	00 00 
    5229:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    522e:	31 c0                	xor    %eax,%eax
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
    5230:	8a 07                	mov    (%rdi),%al
	(void)_copy(s, sizeof(t), t, sizeof(t));
    5232:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
    5237:	88 44 24 08          	mov    %al,0x8(%rsp)
    523b:	8a 47 0d             	mov    0xd(%rdi),%al
    523e:	88 44 24 09          	mov    %al,0x9(%rsp)
    5242:	8a 47 0a             	mov    0xa(%rdi),%al
    5245:	88 44 24 0a          	mov    %al,0xa(%rsp)
    5249:	8a 47 07             	mov    0x7(%rdi),%al
    524c:	88 44 24 0b          	mov    %al,0xb(%rsp)
	t[4]  = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
    5250:	8a 47 04             	mov    0x4(%rdi),%al
    5253:	88 44 24 0c          	mov    %al,0xc(%rsp)
    5257:	8a 47 01             	mov    0x1(%rdi),%al
    525a:	88 44 24 0d          	mov    %al,0xd(%rsp)
    525e:	8a 47 0e             	mov    0xe(%rdi),%al
    5261:	88 44 24 0e          	mov    %al,0xe(%rsp)
    5265:	8a 47 0b             	mov    0xb(%rdi),%al
    5268:	88 44 24 0f          	mov    %al,0xf(%rsp)
	t[8]  = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
    526c:	8a 47 08             	mov    0x8(%rdi),%al
    526f:	88 44 24 10          	mov    %al,0x10(%rsp)
    5273:	8a 47 05             	mov    0x5(%rdi),%al
    5276:	88 44 24 11          	mov    %al,0x11(%rsp)
    527a:	8a 47 02             	mov    0x2(%rdi),%al
    527d:	88 44 24 12          	mov    %al,0x12(%rsp)
    5281:	8a 47 0f             	mov    0xf(%rdi),%al
    5284:	88 44 24 13          	mov    %al,0x13(%rsp)
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
    5288:	8a 47 0c             	mov    0xc(%rdi),%al
    528b:	88 44 24 14          	mov    %al,0x14(%rsp)
    528f:	8a 47 09             	mov    0x9(%rdi),%al
    5292:	88 44 24 15          	mov    %al,0x15(%rsp)
    5296:	8a 47 06             	mov    0x6(%rdi),%al
    5299:	88 44 24 16          	mov    %al,0x16(%rsp)
    529d:	8a 47 03             	mov    0x3(%rdi),%al
    52a0:	88 44 24 17          	mov    %al,0x17(%rsp)
	(void)_copy(s, sizeof(t), t, sizeof(t));
    52a4:	e8 a6 fe ff ff       	callq  514f <_copy>
}
    52a9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    52ae:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    52b5:	00 00 
    52b7:	74 05                	je     52be <inv_shift_rows+0xac>
    52b9:	e8 f2 e1 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    52be:	48 83 c4 28          	add    $0x28,%rsp
    52c2:	c3                   	retq   

00000000000052c3 <mult_row_column>:
{
    52c3:	41 57                	push   %r15
    52c5:	41 56                	push   %r14
    52c7:	41 55                	push   %r13
    52c9:	41 54                	push   %r12
    52cb:	55                   	push   %rbp
    52cc:	48 89 fd             	mov    %rdi,%rbp
    52cf:	53                   	push   %rbx
    52d0:	48 89 f3             	mov    %rsi,%rbx
    52d3:	48 83 ec 18          	sub    $0x18,%rsp
	out[0] = multe(in[0]) ^ multb(in[1]) ^ multd(in[2]) ^ mult9(in[3]);
    52d7:	0f b6 3e             	movzbl (%rsi),%edi
    52da:	e8 94 fe ff ff       	callq  5173 <_double_byte>
    52df:	0f b6 f8             	movzbl %al,%edi
    52e2:	e8 8c fe ff ff       	callq  5173 <_double_byte>
    52e7:	0f b6 f8             	movzbl %al,%edi
    52ea:	e8 84 fe ff ff       	callq  5173 <_double_byte>
    52ef:	0f b6 3b             	movzbl (%rbx),%edi
    52f2:	41 89 c7             	mov    %eax,%r15d
    52f5:	e8 79 fe ff ff       	callq  5173 <_double_byte>
    52fa:	0f b6 f8             	movzbl %al,%edi
    52fd:	e8 71 fe ff ff       	callq  5173 <_double_byte>
    5302:	0f b6 3b             	movzbl (%rbx),%edi
    5305:	41 89 c6             	mov    %eax,%r14d
    5308:	e8 66 fe ff ff       	callq  5173 <_double_byte>
    530d:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    5311:	41 89 c5             	mov    %eax,%r13d
    5314:	e8 5a fe ff ff       	callq  5173 <_double_byte>
    5319:	0f b6 f8             	movzbl %al,%edi
    531c:	e8 52 fe ff ff       	callq  5173 <_double_byte>
    5321:	0f b6 f8             	movzbl %al,%edi
    5324:	e8 4a fe ff ff       	callq  5173 <_double_byte>
    5329:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    532d:	41 89 c4             	mov    %eax,%r12d
    5330:	e8 3e fe ff ff       	callq  5173 <_double_byte>
    5335:	8a 53 01             	mov    0x1(%rbx),%dl
    5338:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    533c:	88 44 24 0c          	mov    %al,0xc(%rsp)
    5340:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    5344:	e8 2a fe ff ff       	callq  5173 <_double_byte>
    5349:	0f b6 f8             	movzbl %al,%edi
    534c:	e8 22 fe ff ff       	callq  5173 <_double_byte>
    5351:	0f b6 f8             	movzbl %al,%edi
    5354:	e8 1a fe ff ff       	callq  5173 <_double_byte>
    5359:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    535d:	88 44 24 0d          	mov    %al,0xd(%rsp)
    5361:	e8 0d fe ff ff       	callq  5173 <_double_byte>
    5366:	0f b6 f8             	movzbl %al,%edi
    5369:	e8 05 fe ff ff       	callq  5173 <_double_byte>
    536e:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    5372:	8a 54 24 0f          	mov    0xf(%rsp),%dl
    5376:	32 53 02             	xor    0x2(%rbx),%dl
    5379:	88 44 24 0e          	mov    %al,0xe(%rsp)
    537d:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    5381:	e8 ed fd ff ff       	callq  5173 <_double_byte>
    5386:	0f b6 f8             	movzbl %al,%edi
    5389:	e8 e5 fd ff ff       	callq  5173 <_double_byte>
    538e:	0f b6 f8             	movzbl %al,%edi
    5391:	e8 dd fd ff ff       	callq  5173 <_double_byte>
    5396:	8a 54 24 0f          	mov    0xf(%rsp),%dl
    539a:	41 89 c0             	mov    %eax,%r8d
    539d:	8a 43 03             	mov    0x3(%rbx),%al
    53a0:	31 d0                	xor    %edx,%eax
    53a2:	44 31 f8             	xor    %r15d,%eax
    53a5:	44 31 f0             	xor    %r14d,%eax
    53a8:	44 31 e8             	xor    %r13d,%eax
    53ab:	44 31 e0             	xor    %r12d,%eax
    53ae:	33 44 24 0c          	xor    0xc(%rsp),%eax
    53b2:	32 44 24 0d          	xor    0xd(%rsp),%al
    53b6:	32 44 24 0e          	xor    0xe(%rsp),%al
    53ba:	44 31 c0             	xor    %r8d,%eax
    53bd:	88 45 00             	mov    %al,0x0(%rbp)
	out[1] = mult9(in[0]) ^ multe(in[1]) ^ multb(in[2]) ^ multd(in[3]);
    53c0:	0f b6 3b             	movzbl (%rbx),%edi
    53c3:	e8 ab fd ff ff       	callq  5173 <_double_byte>
    53c8:	0f b6 f8             	movzbl %al,%edi
    53cb:	e8 a3 fd ff ff       	callq  5173 <_double_byte>
    53d0:	0f b6 f8             	movzbl %al,%edi
    53d3:	e8 9b fd ff ff       	callq  5173 <_double_byte>
    53d8:	8a 13                	mov    (%rbx),%dl
    53da:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    53de:	41 89 c7             	mov    %eax,%r15d
    53e1:	88 54 24 0e          	mov    %dl,0xe(%rsp)
    53e5:	e8 89 fd ff ff       	callq  5173 <_double_byte>
    53ea:	0f b6 f8             	movzbl %al,%edi
    53ed:	e8 81 fd ff ff       	callq  5173 <_double_byte>
    53f2:	0f b6 f8             	movzbl %al,%edi
    53f5:	e8 79 fd ff ff       	callq  5173 <_double_byte>
    53fa:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    53fe:	41 89 c6             	mov    %eax,%r14d
    5401:	e8 6d fd ff ff       	callq  5173 <_double_byte>
    5406:	0f b6 f8             	movzbl %al,%edi
    5409:	e8 65 fd ff ff       	callq  5173 <_double_byte>
    540e:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    5412:	41 89 c5             	mov    %eax,%r13d
    5415:	e8 59 fd ff ff       	callq  5173 <_double_byte>
    541a:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    541e:	41 89 c4             	mov    %eax,%r12d
    5421:	e8 4d fd ff ff       	callq  5173 <_double_byte>
    5426:	0f b6 f8             	movzbl %al,%edi
    5429:	e8 45 fd ff ff       	callq  5173 <_double_byte>
    542e:	0f b6 f8             	movzbl %al,%edi
    5431:	e8 3d fd ff ff       	callq  5173 <_double_byte>
    5436:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    543a:	88 44 24 0c          	mov    %al,0xc(%rsp)
    543e:	e8 30 fd ff ff       	callq  5173 <_double_byte>
    5443:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    5447:	8a 54 24 0e          	mov    0xe(%rsp),%dl
    544b:	32 53 02             	xor    0x2(%rbx),%dl
    544e:	88 44 24 0d          	mov    %al,0xd(%rsp)
    5452:	88 54 24 0f          	mov    %dl,0xf(%rsp)
    5456:	e8 18 fd ff ff       	callq  5173 <_double_byte>
    545b:	0f b6 f8             	movzbl %al,%edi
    545e:	e8 10 fd ff ff       	callq  5173 <_double_byte>
    5463:	0f b6 f8             	movzbl %al,%edi
    5466:	e8 08 fd ff ff       	callq  5173 <_double_byte>
    546b:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    546f:	88 44 24 0e          	mov    %al,0xe(%rsp)
    5473:	e8 fb fc ff ff       	callq  5173 <_double_byte>
    5478:	0f b6 f8             	movzbl %al,%edi
    547b:	e8 f3 fc ff ff       	callq  5173 <_double_byte>
    5480:	8a 54 24 0f          	mov    0xf(%rsp),%dl
    5484:	41 89 c0             	mov    %eax,%r8d
    5487:	8a 43 03             	mov    0x3(%rbx),%al
    548a:	31 d0                	xor    %edx,%eax
    548c:	44 31 f8             	xor    %r15d,%eax
    548f:	44 31 f0             	xor    %r14d,%eax
    5492:	44 31 e8             	xor    %r13d,%eax
    5495:	44 31 e0             	xor    %r12d,%eax
    5498:	33 44 24 0c          	xor    0xc(%rsp),%eax
    549c:	32 44 24 0d          	xor    0xd(%rsp),%al
    54a0:	32 44 24 0e          	xor    0xe(%rsp),%al
    54a4:	44 31 c0             	xor    %r8d,%eax
    54a7:	88 45 01             	mov    %al,0x1(%rbp)
	out[2] = multd(in[0]) ^ mult9(in[1]) ^ multe(in[2]) ^ multb(in[3]);
    54aa:	0f b6 3b             	movzbl (%rbx),%edi
    54ad:	e8 c1 fc ff ff       	callq  5173 <_double_byte>
    54b2:	0f b6 f8             	movzbl %al,%edi
    54b5:	e8 b9 fc ff ff       	callq  5173 <_double_byte>
    54ba:	0f b6 f8             	movzbl %al,%edi
    54bd:	e8 b1 fc ff ff       	callq  5173 <_double_byte>
    54c2:	0f b6 3b             	movzbl (%rbx),%edi
    54c5:	41 89 c7             	mov    %eax,%r15d
    54c8:	e8 a6 fc ff ff       	callq  5173 <_double_byte>
    54cd:	0f b6 f8             	movzbl %al,%edi
    54d0:	e8 9e fc ff ff       	callq  5173 <_double_byte>
    54d5:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    54d9:	44 8a 23             	mov    (%rbx),%r12b
    54dc:	41 89 c6             	mov    %eax,%r14d
    54df:	e8 8f fc ff ff       	callq  5173 <_double_byte>
    54e4:	0f b6 f8             	movzbl %al,%edi
    54e7:	e8 87 fc ff ff       	callq  5173 <_double_byte>
    54ec:	0f b6 f8             	movzbl %al,%edi
    54ef:	e8 7f fc ff ff       	callq  5173 <_double_byte>
    54f4:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    54f8:	44 32 63 01          	xor    0x1(%rbx),%r12b
    54fc:	41 89 c5             	mov    %eax,%r13d
    54ff:	e8 6f fc ff ff       	callq  5173 <_double_byte>
    5504:	0f b6 f8             	movzbl %al,%edi
    5507:	e8 67 fc ff ff       	callq  5173 <_double_byte>
    550c:	0f b6 f8             	movzbl %al,%edi
    550f:	e8 5f fc ff ff       	callq  5173 <_double_byte>
    5514:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    5518:	88 44 24 0c          	mov    %al,0xc(%rsp)
    551c:	e8 52 fc ff ff       	callq  5173 <_double_byte>
    5521:	0f b6 f8             	movzbl %al,%edi
    5524:	e8 4a fc ff ff       	callq  5173 <_double_byte>
    5529:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    552d:	88 44 24 0d          	mov    %al,0xd(%rsp)
    5531:	e8 3d fc ff ff       	callq  5173 <_double_byte>
    5536:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    553a:	88 44 24 0e          	mov    %al,0xe(%rsp)
    553e:	e8 30 fc ff ff       	callq  5173 <_double_byte>
    5543:	0f b6 f8             	movzbl %al,%edi
    5546:	e8 28 fc ff ff       	callq  5173 <_double_byte>
    554b:	0f b6 f8             	movzbl %al,%edi
    554e:	e8 20 fc ff ff       	callq  5173 <_double_byte>
    5553:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    5557:	88 44 24 0f          	mov    %al,0xf(%rsp)
    555b:	e8 13 fc ff ff       	callq  5173 <_double_byte>
    5560:	41 89 c0             	mov    %eax,%r8d
    5563:	8a 43 03             	mov    0x3(%rbx),%al
    5566:	44 31 e0             	xor    %r12d,%eax
    5569:	44 31 f8             	xor    %r15d,%eax
    556c:	44 31 f0             	xor    %r14d,%eax
    556f:	44 31 e8             	xor    %r13d,%eax
    5572:	33 44 24 0c          	xor    0xc(%rsp),%eax
    5576:	32 44 24 0d          	xor    0xd(%rsp),%al
    557a:	32 44 24 0e          	xor    0xe(%rsp),%al
    557e:	32 44 24 0f          	xor    0xf(%rsp),%al
    5582:	44 31 c0             	xor    %r8d,%eax
    5585:	88 45 02             	mov    %al,0x2(%rbp)
	out[3] = multb(in[0]) ^ multd(in[1]) ^ mult9(in[2]) ^ multe(in[3]);
    5588:	0f b6 3b             	movzbl (%rbx),%edi
    558b:	e8 e3 fb ff ff       	callq  5173 <_double_byte>
    5590:	0f b6 f8             	movzbl %al,%edi
    5593:	e8 db fb ff ff       	callq  5173 <_double_byte>
    5598:	0f b6 f8             	movzbl %al,%edi
    559b:	e8 d3 fb ff ff       	callq  5173 <_double_byte>
    55a0:	0f b6 3b             	movzbl (%rbx),%edi
    55a3:	41 89 c4             	mov    %eax,%r12d
    55a6:	e8 c8 fb ff ff       	callq  5173 <_double_byte>
    55ab:	8a 13                	mov    (%rbx),%dl
    55ad:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    55b1:	41 89 c7             	mov    %eax,%r15d
    55b4:	88 54 24 0c          	mov    %dl,0xc(%rsp)
    55b8:	e8 b6 fb ff ff       	callq  5173 <_double_byte>
    55bd:	0f b6 f8             	movzbl %al,%edi
    55c0:	e8 ae fb ff ff       	callq  5173 <_double_byte>
    55c5:	0f b6 f8             	movzbl %al,%edi
    55c8:	e8 a6 fb ff ff       	callq  5173 <_double_byte>
    55cd:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    55d1:	41 89 c6             	mov    %eax,%r14d
    55d4:	e8 9a fb ff ff       	callq  5173 <_double_byte>
    55d9:	0f b6 f8             	movzbl %al,%edi
    55dc:	e8 92 fb ff ff       	callq  5173 <_double_byte>
    55e1:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    55e5:	8a 54 24 0c          	mov    0xc(%rsp),%dl
    55e9:	32 53 01             	xor    0x1(%rbx),%dl
    55ec:	41 89 c5             	mov    %eax,%r13d
    55ef:	88 54 24 0c          	mov    %dl,0xc(%rsp)
    55f3:	e8 7b fb ff ff       	callq  5173 <_double_byte>
    55f8:	0f b6 f8             	movzbl %al,%edi
    55fb:	e8 73 fb ff ff       	callq  5173 <_double_byte>
    5600:	0f b6 f8             	movzbl %al,%edi
    5603:	e8 6b fb ff ff       	callq  5173 <_double_byte>
    5608:	8a 54 24 0c          	mov    0xc(%rsp),%dl
    560c:	32 53 02             	xor    0x2(%rbx),%dl
    560f:	41 31 d4             	xor    %edx,%r12d
    5612:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    5616:	45 31 fc             	xor    %r15d,%r12d
    5619:	45 31 f4             	xor    %r14d,%r12d
    561c:	45 31 ec             	xor    %r13d,%r12d
    561f:	41 31 c4             	xor    %eax,%r12d
    5622:	e8 4c fb ff ff       	callq  5173 <_double_byte>
    5627:	0f b6 f8             	movzbl %al,%edi
    562a:	e8 44 fb ff ff       	callq  5173 <_double_byte>
    562f:	0f b6 f8             	movzbl %al,%edi
    5632:	e8 3c fb ff ff       	callq  5173 <_double_byte>
    5637:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    563b:	41 89 c5             	mov    %eax,%r13d
    563e:	e8 30 fb ff ff       	callq  5173 <_double_byte>
    5643:	45 31 ec             	xor    %r13d,%r12d
    5646:	0f b6 f8             	movzbl %al,%edi
    5649:	e8 25 fb ff ff       	callq  5173 <_double_byte>
    564e:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    5652:	41 89 c6             	mov    %eax,%r14d
    5655:	e8 19 fb ff ff       	callq  5173 <_double_byte>
    565a:	45 31 f4             	xor    %r14d,%r12d
    565d:	41 31 c4             	xor    %eax,%r12d
    5660:	44 88 65 03          	mov    %r12b,0x3(%rbp)
}
    5664:	48 83 c4 18          	add    $0x18,%rsp
    5668:	5b                   	pop    %rbx
    5669:	5d                   	pop    %rbp
    566a:	41 5c                	pop    %r12
    566c:	41 5d                	pop    %r13
    566e:	41 5e                	pop    %r14
    5670:	41 5f                	pop    %r15
    5672:	c3                   	retq   

0000000000005673 <tc_aes_decrypt>:

int tc_aes_decrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    5673:	f3 0f 1e fa          	endbr64 
    5677:	41 57                	push   %r15
    5679:	41 56                	push   %r14
    567b:	41 55                	push   %r13
    567d:	41 54                	push   %r12
    567f:	49 89 d4             	mov    %rdx,%r12
    5682:	55                   	push   %rbp
    5683:	53                   	push   %rbx
    5684:	48 83 ec 48          	sub    $0x48,%rsp
    5688:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    568d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5694:	00 00 
    5696:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    569b:	31 c0                	xor    %eax,%eax

	if (out == (uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    569d:	48 85 d2             	test   %rdx,%rdx
    56a0:	0f 94 c2             	sete   %dl
	} else if (in == (const uint8_t *) 0) {
    56a3:	48 85 f6             	test   %rsi,%rsi
    56a6:	0f 94 c0             	sete   %al
	} else if (s == (TCAesKeySched_t) 0) {
    56a9:	08 c2                	or     %al,%dl
    56ab:	0f 85 21 01 00 00    	jne    57d2 <tc_aes_decrypt+0x15f>
    56b1:	48 85 ff             	test   %rdi,%rdi
    56b4:	0f 84 18 01 00 00    	je     57d2 <tc_aes_decrypt+0x15f>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    56ba:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
    56bf:	48 89 f2             	mov    %rsi,%rdx
    56c2:	b9 10 00 00 00       	mov    $0x10,%ecx
    56c7:	be 10 00 00 00       	mov    $0x10,%esi
    56cc:	48 89 ef             	mov    %rbp,%rdi
    56cf:	4d 8d b4 24 90 00 00 	lea    0x90(%r12),%r14
    56d6:	00 
		s[i] = inv_sbox[s[i]];
    56d7:	4c 8d 3d 22 49 00 00 	lea    0x4922(%rip),%r15        # a000 <inv_sbox>
	(void)_copy(state, sizeof(state), in, sizeof(state));
    56de:	e8 6c fa ff ff       	callq  514f <_copy>

	add_round_key(state, s->words + Nb*Nr);
    56e3:	49 8d b4 24 a0 00 00 	lea    0xa0(%r12),%rsi
    56ea:	00 
    56eb:	48 89 ef             	mov    %rbp,%rdi
    56ee:	e8 ba fa ff ff       	callq  51ad <add_round_key>

	for (i = Nr - 1; i > 0; --i) {
		inv_shift_rows(state);
    56f3:	48 89 ef             	mov    %rbp,%rdi
    56f6:	49 89 ed             	mov    %rbp,%r13
    56f9:	48 8d 5c 24 28       	lea    0x28(%rsp),%rbx
    56fe:	e8 0f fb ff ff       	callq  5212 <inv_shift_rows>
    5703:	48 89 e8             	mov    %rbp,%rax
		s[i] = inv_sbox[s[i]];
    5706:	0f b6 10             	movzbl (%rax),%edx
    5709:	48 ff c0             	inc    %rax
    570c:	41 8a 14 17          	mov    (%r15,%rdx,1),%dl
    5710:	88 50 ff             	mov    %dl,-0x1(%rax)
	for (i = 0; i < (Nb*Nk); ++i) {
    5713:	48 39 d8             	cmp    %rbx,%rax
    5716:	75 ee                	jne    5706 <tc_aes_decrypt+0x93>
		inv_sub_bytes(state);
		add_round_key(state, s->words + Nb*i);
    5718:	4c 89 f6             	mov    %r14,%rsi
    571b:	48 89 ef             	mov    %rbp,%rdi
    571e:	49 83 ee 10          	sub    $0x10,%r14
    5722:	e8 86 fa ff ff       	callq  51ad <add_round_key>
	mult_row_column(t, s);
    5727:	48 89 ee             	mov    %rbp,%rsi
    572a:	48 89 df             	mov    %rbx,%rdi
    572d:	e8 91 fb ff ff       	callq  52c3 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    5732:	48 8d 74 24 1c       	lea    0x1c(%rsp),%rsi
    5737:	48 8d 7c 24 2c       	lea    0x2c(%rsp),%rdi
    573c:	e8 82 fb ff ff       	callq  52c3 <mult_row_column>
	mult_row_column(&t[2*Nb], s+(2*Nb));
    5741:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
    5746:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    574b:	e8 73 fb ff ff       	callq  52c3 <mult_row_column>
	mult_row_column(&t[3*Nb], s+(3*Nb));
    5750:	48 8d 74 24 24       	lea    0x24(%rsp),%rsi
    5755:	48 8d 7c 24 34       	lea    0x34(%rsp),%rdi
    575a:	e8 64 fb ff ff       	callq  52c3 <mult_row_column>
	(void)_copy(s, sizeof(t), t, sizeof(t));
    575f:	b9 10 00 00 00       	mov    $0x10,%ecx
    5764:	48 89 da             	mov    %rbx,%rdx
    5767:	48 89 ef             	mov    %rbp,%rdi
    576a:	be 10 00 00 00       	mov    $0x10,%esi
    576f:	e8 db f9 ff ff       	callq  514f <_copy>
	for (i = Nr - 1; i > 0; --i) {
    5774:	4d 39 e6             	cmp    %r12,%r14
    5777:	0f 85 76 ff ff ff    	jne    56f3 <tc_aes_decrypt+0x80>
		inv_mix_columns(state);
	}

	inv_shift_rows(state);
    577d:	48 89 ef             	mov    %rbp,%rdi
    5780:	e8 8d fa ff ff       	callq  5212 <inv_shift_rows>
		s[i] = inv_sbox[s[i]];
    5785:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
    578a:	49 ff c5             	inc    %r13
    578d:	41 8a 04 07          	mov    (%r15,%rax,1),%al
    5791:	41 88 45 ff          	mov    %al,-0x1(%r13)
	for (i = 0; i < (Nb*Nk); ++i) {
    5795:	49 39 dd             	cmp    %rbx,%r13
    5798:	75 eb                	jne    5785 <tc_aes_decrypt+0x112>
	inv_sub_bytes(state);
	add_round_key(state, s->words);
    579a:	4c 89 e6             	mov    %r12,%rsi
    579d:	48 89 ef             	mov    %rbp,%rdi
    57a0:	e8 08 fa ff ff       	callq  51ad <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    57a5:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    57aa:	b9 10 00 00 00       	mov    $0x10,%ecx
    57af:	48 89 ea             	mov    %rbp,%rdx
    57b2:	be 10 00 00 00       	mov    $0x10,%esi
    57b7:	e8 93 f9 ff ff       	callq  514f <_copy>

	/*zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    57bc:	ba 10 00 00 00       	mov    $0x10,%edx
    57c1:	31 f6                	xor    %esi,%esi
    57c3:	48 89 ef             	mov    %rbp,%rdi
    57c6:	e8 9d f9 ff ff       	callq  5168 <_set>


	return TC_CRYPTO_SUCCESS;
    57cb:	b8 01 00 00 00       	mov    $0x1,%eax
    57d0:	eb 02                	jmp    57d4 <tc_aes_decrypt+0x161>
		return TC_CRYPTO_FAIL;
    57d2:	31 c0                	xor    %eax,%eax
}
    57d4:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    57d9:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    57e0:	00 00 
    57e2:	74 05                	je     57e9 <tc_aes_decrypt+0x176>
    57e4:	e8 c7 dc ff ff       	callq  34b0 <__stack_chk_fail@plt>
    57e9:	48 83 c4 48          	add    $0x48,%rsp
    57ed:	5b                   	pop    %rbx
    57ee:	5d                   	pop    %rbp
    57ef:	41 5c                	pop    %r12
    57f1:	41 5d                	pop    %r13
    57f3:	41 5e                	pop    %r14
    57f5:	41 5f                	pop    %r15
    57f7:	c3                   	retq   

00000000000057f8 <add_round_key>:
	return TC_CRYPTO_SUCCESS;
}

static inline void add_round_key(uint8_t *s, const unsigned int *k)
{
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    57f8:	8a 46 03             	mov    0x3(%rsi),%al
    57fb:	30 07                	xor    %al,(%rdi)
    57fd:	8a 46 02             	mov    0x2(%rsi),%al
    5800:	30 47 01             	xor    %al,0x1(%rdi)
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    5803:	8a 46 01             	mov    0x1(%rsi),%al
    5806:	30 47 02             	xor    %al,0x2(%rdi)
    5809:	8b 06                	mov    (%rsi),%eax
    580b:	30 47 03             	xor    %al,0x3(%rdi)
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    580e:	0f b6 46 07          	movzbl 0x7(%rsi),%eax
    5812:	30 47 04             	xor    %al,0x4(%rdi)
    5815:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    5819:	30 47 05             	xor    %al,0x5(%rdi)
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    581c:	8a 46 05             	mov    0x5(%rsi),%al
    581f:	30 47 06             	xor    %al,0x6(%rdi)
    5822:	8b 46 04             	mov    0x4(%rsi),%eax
    5825:	30 47 07             	xor    %al,0x7(%rdi)
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    5828:	0f b6 46 0b          	movzbl 0xb(%rsi),%eax
    582c:	30 47 08             	xor    %al,0x8(%rdi)
    582f:	0f b7 46 0a          	movzwl 0xa(%rsi),%eax
    5833:	30 47 09             	xor    %al,0x9(%rdi)
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    5836:	8a 46 09             	mov    0x9(%rsi),%al
    5839:	30 47 0a             	xor    %al,0xa(%rdi)
    583c:	8b 46 08             	mov    0x8(%rsi),%eax
    583f:	30 47 0b             	xor    %al,0xb(%rdi)
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    5842:	0f b6 46 0f          	movzbl 0xf(%rsi),%eax
    5846:	30 47 0c             	xor    %al,0xc(%rdi)
    5849:	0f b7 46 0e          	movzwl 0xe(%rsi),%eax
    584d:	30 47 0d             	xor    %al,0xd(%rdi)
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    5850:	8a 46 0d             	mov    0xd(%rsi),%al
    5853:	30 47 0e             	xor    %al,0xe(%rdi)
    5856:	8b 46 0c             	mov    0xc(%rsi),%eax
    5859:	30 47 0f             	xor    %al,0xf(%rdi)
}
    585c:	c3                   	retq   

000000000000585d <shift_rows>:
/*
 * This shift_rows also implements the matrix flip required for mix_columns, but
 * performs it here to reduce the number of memory operations.
 */
static inline void shift_rows(uint8_t *s)
{
    585d:	48 83 ec 28          	sub    $0x28,%rsp

	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
    5861:	b9 10 00 00 00       	mov    $0x10,%ecx
    5866:	be 10 00 00 00       	mov    $0x10,%esi
{
    586b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5872:	00 00 
    5874:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5879:	31 c0                	xor    %eax,%eax
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    587b:	8a 07                	mov    (%rdi),%al
	(void) _copy(s, sizeof(t), t, sizeof(t));
    587d:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    5882:	88 44 24 08          	mov    %al,0x8(%rsp)
    5886:	8a 47 05             	mov    0x5(%rdi),%al
    5889:	88 44 24 09          	mov    %al,0x9(%rsp)
    588d:	8a 47 0a             	mov    0xa(%rdi),%al
    5890:	88 44 24 0a          	mov    %al,0xa(%rsp)
    5894:	8a 47 0f             	mov    0xf(%rdi),%al
    5897:	88 44 24 0b          	mov    %al,0xb(%rsp)
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
    589b:	8a 47 04             	mov    0x4(%rdi),%al
    589e:	88 44 24 0c          	mov    %al,0xc(%rsp)
    58a2:	8a 47 09             	mov    0x9(%rdi),%al
    58a5:	88 44 24 0d          	mov    %al,0xd(%rsp)
    58a9:	8a 47 0e             	mov    0xe(%rdi),%al
    58ac:	88 44 24 0e          	mov    %al,0xe(%rsp)
    58b0:	8a 47 03             	mov    0x3(%rdi),%al
    58b3:	88 44 24 0f          	mov    %al,0xf(%rsp)
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
    58b7:	8a 47 08             	mov    0x8(%rdi),%al
    58ba:	88 44 24 10          	mov    %al,0x10(%rsp)
    58be:	8a 47 0d             	mov    0xd(%rdi),%al
    58c1:	88 44 24 11          	mov    %al,0x11(%rsp)
    58c5:	8a 47 02             	mov    0x2(%rdi),%al
    58c8:	88 44 24 12          	mov    %al,0x12(%rsp)
    58cc:	8a 47 07             	mov    0x7(%rdi),%al
    58cf:	88 44 24 13          	mov    %al,0x13(%rsp)
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
    58d3:	8a 47 0c             	mov    0xc(%rdi),%al
    58d6:	88 44 24 14          	mov    %al,0x14(%rsp)
    58da:	8a 47 01             	mov    0x1(%rdi),%al
    58dd:	88 44 24 15          	mov    %al,0x15(%rsp)
    58e1:	8a 47 06             	mov    0x6(%rdi),%al
    58e4:	88 44 24 16          	mov    %al,0x16(%rsp)
    58e8:	8a 47 0b             	mov    0xb(%rdi),%al
    58eb:	88 44 24 17          	mov    %al,0x17(%rsp)
	(void) _copy(s, sizeof(t), t, sizeof(t));
    58ef:	e8 5b f8 ff ff       	callq  514f <_copy>
}
    58f4:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    58f9:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5900:	00 00 
    5902:	74 05                	je     5909 <shift_rows+0xac>
    5904:	e8 a7 db ff ff       	callq  34b0 <__stack_chk_fail@plt>
    5909:	48 83 c4 28          	add    $0x28,%rsp
    590d:	c3                   	retq   

000000000000590e <mult_row_column>:
{
    590e:	41 55                	push   %r13
    5910:	41 54                	push   %r12
    5912:	49 89 fc             	mov    %rdi,%r12
    5915:	55                   	push   %rbp
    5916:	53                   	push   %rbx
    5917:	48 89 f3             	mov    %rsi,%rbx
    591a:	50                   	push   %rax
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    591b:	0f b6 3e             	movzbl (%rsi),%edi
    591e:	e8 50 f8 ff ff       	callq  5173 <_double_byte>
    5923:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    5927:	89 c5                	mov    %eax,%ebp
    5929:	e8 45 f8 ff ff       	callq  5173 <_double_byte>
    592e:	41 89 c0             	mov    %eax,%r8d
    5931:	8a 43 01             	mov    0x1(%rbx),%al
    5934:	32 43 02             	xor    0x2(%rbx),%al
    5937:	32 43 03             	xor    0x3(%rbx),%al
    593a:	31 e8                	xor    %ebp,%eax
    593c:	44 31 c0             	xor    %r8d,%eax
    593f:	41 88 04 24          	mov    %al,(%r12)
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    5943:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
    5947:	40 8a 2b             	mov    (%rbx),%bpl
    594a:	e8 24 f8 ff ff       	callq  5173 <_double_byte>
    594f:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    5953:	41 89 c5             	mov    %eax,%r13d
    5956:	e8 18 f8 ff ff       	callq  5173 <_double_byte>
    595b:	41 89 c0             	mov    %eax,%r8d
    595e:	8a 43 02             	mov    0x2(%rbx),%al
    5961:	31 e8                	xor    %ebp,%eax
    5963:	32 43 03             	xor    0x3(%rbx),%al
    5966:	44 31 e8             	xor    %r13d,%eax
    5969:	44 31 c0             	xor    %r8d,%eax
    596c:	41 88 44 24 01       	mov    %al,0x1(%r12)
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    5971:	0f b6 7b 02          	movzbl 0x2(%rbx),%edi
    5975:	40 8a 2b             	mov    (%rbx),%bpl
    5978:	40 32 6b 01          	xor    0x1(%rbx),%bpl
    597c:	e8 f2 f7 ff ff       	callq  5173 <_double_byte>
    5981:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    5985:	41 89 c5             	mov    %eax,%r13d
    5988:	e8 e6 f7 ff ff       	callq  5173 <_double_byte>
    598d:	40 32 6b 03          	xor    0x3(%rbx),%bpl
    5991:	44 31 ed             	xor    %r13d,%ebp
    5994:	31 c5                	xor    %eax,%ebp
    5996:	41 88 6c 24 02       	mov    %bpl,0x2(%r12)
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    599b:	0f b6 3b             	movzbl (%rbx),%edi
    599e:	e8 d0 f7 ff ff       	callq  5173 <_double_byte>
    59a3:	0f b6 7b 03          	movzbl 0x3(%rbx),%edi
    59a7:	40 8a 2b             	mov    (%rbx),%bpl
    59aa:	40 32 6b 01          	xor    0x1(%rbx),%bpl
    59ae:	40 32 6b 02          	xor    0x2(%rbx),%bpl
    59b2:	31 c5                	xor    %eax,%ebp
    59b4:	e8 ba f7 ff ff       	callq  5173 <_double_byte>
    59b9:	31 c5                	xor    %eax,%ebp
    59bb:	41 88 6c 24 03       	mov    %bpl,0x3(%r12)
}
    59c0:	5a                   	pop    %rdx
    59c1:	5b                   	pop    %rbx
    59c2:	5d                   	pop    %rbp
    59c3:	41 5c                	pop    %r12
    59c5:	41 5d                	pop    %r13
    59c7:	c3                   	retq   

00000000000059c8 <tc_aes128_set_encrypt_key>:
{
    59c8:	f3 0f 1e fa          	endbr64 
    59cc:	48 83 ec 48          	sub    $0x48,%rsp
    59d0:	49 89 f8             	mov    %rdi,%r8
    59d3:	49 89 f1             	mov    %rsi,%r9
	const unsigned int rconst[11] = {
    59d6:	b9 0b 00 00 00       	mov    $0xb,%ecx
{
    59db:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    59e2:	00 00 
    59e4:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    59e9:	31 c0                	xor    %eax,%eax
	const unsigned int rconst[11] = {
    59eb:	48 8d 7c 24 0c       	lea    0xc(%rsp),%rdi
    59f0:	48 8d 35 09 47 00 00 	lea    0x4709(%rip),%rsi        # a100 <inv_sbox+0x100>
    59f7:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	} else if (k == (const uint8_t *) 0) {
    59f9:	4d 85 c0             	test   %r8,%r8
    59fc:	0f 84 ad 00 00 00    	je     5aaf <tc_aes128_set_encrypt_key+0xe7>
    5a02:	4d 85 c9             	test   %r9,%r9
    5a05:	0f 84 a4 00 00 00    	je     5aaf <tc_aes128_set_encrypt_key+0xe7>
    5a0b:	31 d2                	xor    %edx,%edx
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    5a0d:	41 0f b6 04 11       	movzbl (%r9,%rdx,1),%eax
    5a12:	41 0f b6 4c 11 01    	movzbl 0x1(%r9,%rdx,1),%ecx
    5a18:	c1 e0 18             	shl    $0x18,%eax
    5a1b:	c1 e1 10             	shl    $0x10,%ecx
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    5a1e:	09 c8                	or     %ecx,%eax
    5a20:	41 0f b6 4c 11 03    	movzbl 0x3(%r9,%rdx,1),%ecx
    5a26:	09 c8                	or     %ecx,%eax
    5a28:	41 0f b6 4c 11 02    	movzbl 0x2(%r9,%rdx,1),%ecx
    5a2e:	c1 e1 08             	shl    $0x8,%ecx
    5a31:	09 c8                	or     %ecx,%eax
    5a33:	41 89 04 10          	mov    %eax,(%r8,%rdx,1)
	for (i = 0; i < Nk; ++i) {
    5a37:	48 83 c2 04          	add    $0x4,%rdx
    5a3b:	48 83 fa 10          	cmp    $0x10,%rdx
    5a3f:	75 cc                	jne    5a0d <tc_aes128_set_encrypt_key+0x45>
    5a41:	be 04 00 00 00       	mov    $0x4,%esi
			t = subword(rotword(t)) ^ rconst[i/Nk];
    5a46:	48 8d 3d f3 46 00 00 	lea    0x46f3(%rip),%rdi        # a140 <sbox>
		t = s->words[i-1];
    5a4d:	41 8b 44 b0 fc       	mov    -0x4(%r8,%rsi,4),%eax
		if ((i % Nk) == 0) {
    5a52:	40 f6 c6 03          	test   $0x3,%sil
    5a56:	75 3e                	jne    5a96 <tc_aes128_set_encrypt_key+0xce>
	return (((a) >> 24)|((a) << 8));
    5a58:	c1 c0 08             	rol    $0x8,%eax
			t = subword(rotword(t)) ^ rconst[i/Nk];
    5a5b:	89 c2                	mov    %eax,%edx
    5a5d:	c1 ea 18             	shr    $0x18,%edx
    5a60:	0f b6 0c 17          	movzbl (%rdi,%rdx,1),%ecx
    5a64:	0f b6 d0             	movzbl %al,%edx
    5a67:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    5a6b:	c1 e1 18             	shl    $0x18,%ecx
    5a6e:	09 d1                	or     %edx,%ecx
    5a70:	89 c2                	mov    %eax,%edx
    5a72:	c1 ea 10             	shr    $0x10,%edx
    5a75:	0f b6 d2             	movzbl %dl,%edx
    5a78:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    5a7c:	c1 e2 10             	shl    $0x10,%edx
    5a7f:	09 d1                	or     %edx,%ecx
    5a81:	0f b6 d4             	movzbl %ah,%edx
    5a84:	0f b6 04 17          	movzbl (%rdi,%rdx,1),%eax
    5a88:	89 f2                	mov    %esi,%edx
    5a8a:	c1 ea 02             	shr    $0x2,%edx
    5a8d:	c1 e0 08             	shl    $0x8,%eax
    5a90:	09 c8                	or     %ecx,%eax
    5a92:	33 44 94 0c          	xor    0xc(%rsp,%rdx,4),%eax
		s->words[i] = s->words[i-Nk] ^ t;
    5a96:	41 33 44 b0 f0       	xor    -0x10(%r8,%rsi,4),%eax
    5a9b:	41 89 04 b0          	mov    %eax,(%r8,%rsi,4)
	for (; i < (Nb * (Nr + 1)); ++i) {
    5a9f:	48 ff c6             	inc    %rsi
    5aa2:	48 83 fe 2c          	cmp    $0x2c,%rsi
    5aa6:	75 a5                	jne    5a4d <tc_aes128_set_encrypt_key+0x85>
	return TC_CRYPTO_SUCCESS;
    5aa8:	b8 01 00 00 00       	mov    $0x1,%eax
    5aad:	eb 02                	jmp    5ab1 <tc_aes128_set_encrypt_key+0xe9>
		return TC_CRYPTO_FAIL;
    5aaf:	31 c0                	xor    %eax,%eax
}
    5ab1:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    5ab6:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5abd:	00 00 
    5abf:	74 05                	je     5ac6 <tc_aes128_set_encrypt_key+0xfe>
    5ac1:	e8 ea d9 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    5ac6:	48 83 c4 48          	add    $0x48,%rsp
    5aca:	c3                   	retq   

0000000000005acb <tc_aes_encrypt>:

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    5acb:	f3 0f 1e fa          	endbr64 
    5acf:	41 57                	push   %r15
    5ad1:	41 56                	push   %r14
    5ad3:	41 55                	push   %r13
    5ad5:	41 54                	push   %r12
    5ad7:	49 89 d4             	mov    %rdx,%r12
    5ada:	55                   	push   %rbp
    5adb:	53                   	push   %rbx
    5adc:	48 83 ec 38          	sub    $0x38,%rsp
    5ae0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5ae7:	00 00 
    5ae9:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    5aee:	31 c0                	xor    %eax,%eax
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    5af0:	48 85 f6             	test   %rsi,%rsi
    5af3:	0f 94 c2             	sete   %dl
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    5af6:	4d 85 e4             	test   %r12,%r12
    5af9:	0f 94 c0             	sete   %al
    5afc:	08 c2                	or     %al,%dl
    5afe:	0f 85 25 01 00 00    	jne    5c29 <tc_aes_encrypt+0x15e>
    5b04:	49 89 fd             	mov    %rdi,%r13
    5b07:	48 85 ff             	test   %rdi,%rdi
    5b0a:	0f 84 19 01 00 00    	je     5c29 <tc_aes_encrypt+0x15e>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    5b10:	48 8d 6c 24 08       	lea    0x8(%rsp),%rbp
    5b15:	48 89 f2             	mov    %rsi,%rdx
    5b18:	b9 10 00 00 00       	mov    $0x10,%ecx
    5b1d:	be 10 00 00 00       	mov    $0x10,%esi
    5b22:	48 89 ef             	mov    %rbp,%rdi
    5b25:	4d 8d 74 24 10       	lea    0x10(%r12),%r14
    5b2a:	e8 20 f6 ff ff       	callq  514f <_copy>
	add_round_key(state, s->words);
    5b2f:	4c 89 e6             	mov    %r12,%rsi
    5b32:	48 89 ef             	mov    %rbp,%rdi
    5b35:	49 81 c4 a0 00 00 00 	add    $0xa0,%r12
    5b3c:	e8 b7 fc ff ff       	callq  57f8 <add_round_key>
		s[i] = sbox[s[i]];
    5b41:	4c 8d 05 f8 45 00 00 	lea    0x45f8(%rip),%r8        # a140 <sbox>
	for (i = 0; i < (Nb * Nk); ++i) {
    5b48:	48 89 eb             	mov    %rbp,%rbx
    5b4b:	4c 8d 7c 24 18       	lea    0x18(%rsp),%r15
{
    5b50:	48 89 e8             	mov    %rbp,%rax
		s[i] = sbox[s[i]];
    5b53:	0f b6 10             	movzbl (%rax),%edx
    5b56:	48 ff c0             	inc    %rax
    5b59:	41 8a 14 10          	mov    (%r8,%rdx,1),%dl
    5b5d:	88 50 ff             	mov    %dl,-0x1(%rax)
	for (i = 0; i < (Nb * Nk); ++i) {
    5b60:	4c 39 f8             	cmp    %r15,%rax
    5b63:	75 ee                	jne    5b53 <tc_aes_encrypt+0x88>

	for (i = 0; i < (Nr - 1); ++i) {
		sub_bytes(state);
		shift_rows(state);
    5b65:	48 89 ef             	mov    %rbp,%rdi
    5b68:	e8 f0 fc ff ff       	callq  585d <shift_rows>
	mult_row_column(t, s);
    5b6d:	48 89 ee             	mov    %rbp,%rsi
    5b70:	4c 89 ff             	mov    %r15,%rdi
    5b73:	e8 96 fd ff ff       	callq  590e <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    5b78:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
    5b7d:	48 8d 7c 24 1c       	lea    0x1c(%rsp),%rdi
    5b82:	e8 87 fd ff ff       	callq  590e <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    5b87:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    5b8c:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    5b91:	e8 78 fd ff ff       	callq  590e <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    5b96:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
    5b9b:	48 8d 7c 24 24       	lea    0x24(%rsp),%rdi
    5ba0:	e8 69 fd ff ff       	callq  590e <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    5ba5:	b9 10 00 00 00       	mov    $0x10,%ecx
    5baa:	4c 89 fa             	mov    %r15,%rdx
    5bad:	48 89 ef             	mov    %rbp,%rdi
    5bb0:	be 10 00 00 00       	mov    $0x10,%esi
    5bb5:	e8 95 f5 ff ff       	callq  514f <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    5bba:	4c 89 f6             	mov    %r14,%rsi
    5bbd:	48 89 ef             	mov    %rbp,%rdi
    5bc0:	49 83 c6 10          	add    $0x10,%r14
    5bc4:	e8 2f fc ff ff       	callq  57f8 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    5bc9:	4d 39 e6             	cmp    %r12,%r14
    5bcc:	4c 8d 05 6d 45 00 00 	lea    0x456d(%rip),%r8        # a140 <sbox>
    5bd3:	0f 85 6f ff ff ff    	jne    5b48 <tc_aes_encrypt+0x7d>
		s[i] = sbox[s[i]];
    5bd9:	0f b6 03             	movzbl (%rbx),%eax
    5bdc:	48 ff c3             	inc    %rbx
    5bdf:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    5be3:	88 43 ff             	mov    %al,-0x1(%rbx)
	for (i = 0; i < (Nb * Nk); ++i) {
    5be6:	4c 39 fb             	cmp    %r15,%rbx
    5be9:	75 ee                	jne    5bd9 <tc_aes_encrypt+0x10e>
	}

	sub_bytes(state);
	shift_rows(state);
    5beb:	48 89 ef             	mov    %rbp,%rdi
    5bee:	e8 6a fc ff ff       	callq  585d <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    5bf3:	4c 89 e6             	mov    %r12,%rsi
    5bf6:	48 89 ef             	mov    %rbp,%rdi
    5bf9:	e8 fa fb ff ff       	callq  57f8 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    5bfe:	b9 10 00 00 00       	mov    $0x10,%ecx
    5c03:	48 89 ea             	mov    %rbp,%rdx
    5c06:	4c 89 ef             	mov    %r13,%rdi
    5c09:	be 10 00 00 00       	mov    $0x10,%esi
    5c0e:	e8 3c f5 ff ff       	callq  514f <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    5c13:	ba 10 00 00 00       	mov    $0x10,%edx
    5c18:	31 f6                	xor    %esi,%esi
    5c1a:	48 89 ef             	mov    %rbp,%rdi
    5c1d:	e8 46 f5 ff ff       	callq  5168 <_set>

	return TC_CRYPTO_SUCCESS;
    5c22:	b8 01 00 00 00       	mov    $0x1,%eax
    5c27:	eb 02                	jmp    5c2b <tc_aes_encrypt+0x160>
		return TC_CRYPTO_FAIL;
    5c29:	31 c0                	xor    %eax,%eax
}
    5c2b:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    5c30:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    5c37:	00 00 
    5c39:	74 05                	je     5c40 <tc_aes_encrypt+0x175>
    5c3b:	e8 70 d8 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    5c40:	48 83 c4 38          	add    $0x38,%rsp
    5c44:	5b                   	pop    %rbx
    5c45:	5d                   	pop    %rbp
    5c46:	41 5c                	pop    %r12
    5c48:	41 5d                	pop    %r13
    5c4a:	41 5e                	pop    %r14
    5c4c:	41 5f                	pop    %r15
    5c4e:	c3                   	retq   

0000000000005c4f <tc_cbc_mode_encrypt>:
#include <tinycrypt/utils.h>

int tc_cbc_mode_encrypt(uint8_t *out, unsigned int outlen, const uint8_t *in,
			    unsigned int inlen, const uint8_t *iv,
			    const TCAesKeySched_t sched)
{
    5c4f:	f3 0f 1e fa          	endbr64 
    5c53:	41 57                	push   %r15
    5c55:	41 56                	push   %r14
    5c57:	41 55                	push   %r13
    5c59:	41 54                	push   %r12
    5c5b:	55                   	push   %rbp
    5c5c:	53                   	push   %rbx
    5c5d:	48 83 ec 28          	sub    $0x28,%rsp
    5c61:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5c68:	00 00 
    5c6a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5c6f:	31 c0                	xor    %eax,%eax

	uint8_t buffer[TC_AES_BLOCK_SIZE];
	unsigned int n, m;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    5c71:	48 85 ff             	test   %rdi,%rdi
    5c74:	0f 84 d8 00 00 00    	je     5d52 <tc_cbc_mode_encrypt+0x103>
    5c7a:	49 89 d6             	mov    %rdx,%r14
    5c7d:	48 85 d2             	test   %rdx,%rdx
    5c80:	0f 84 cc 00 00 00    	je     5d52 <tc_cbc_mode_encrypt+0x103>
	    in == (const uint8_t *) 0 ||
	    sched == (TCAesKeySched_t) 0 ||
    5c86:	4d 85 c9             	test   %r9,%r9
    5c89:	89 cb                	mov    %ecx,%ebx
    5c8b:	4d 89 cc             	mov    %r9,%r12
    5c8e:	0f 94 c2             	sete   %dl
	    inlen == 0 ||
    5c91:	85 db                	test   %ebx,%ebx
    5c93:	0f 94 c0             	sete   %al
    5c96:	08 c2                	or     %al,%dl
    5c98:	0f 85 b4 00 00 00    	jne    5d52 <tc_cbc_mode_encrypt+0x103>
    5c9e:	85 f6                	test   %esi,%esi
    5ca0:	0f 84 ac 00 00 00    	je     5d52 <tc_cbc_mode_encrypt+0x103>
    5ca6:	89 da                	mov    %ebx,%edx
	    outlen == 0 ||
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
	    outlen != inlen + TC_AES_BLOCK_SIZE) {
		return TC_CRYPTO_FAIL;
    5ca8:	31 c0                	xor    %eax,%eax
    5caa:	09 f2                	or     %esi,%edx
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
    5cac:	83 e2 0f             	and    $0xf,%edx
    5caf:	0f 85 9f 00 00 00    	jne    5d54 <tc_cbc_mode_encrypt+0x105>
	    outlen != inlen + TC_AES_BLOCK_SIZE) {
    5cb5:	8d 4b 10             	lea    0x10(%rbx),%ecx
		return TC_CRYPTO_FAIL;
    5cb8:	89 d0                	mov    %edx,%eax
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
    5cba:	39 f1                	cmp    %esi,%ecx
    5cbc:	0f 85 92 00 00 00    	jne    5d54 <tc_cbc_mode_encrypt+0x105>
	}

	/* copy iv to the buffer */
	(void)_copy(buffer, TC_AES_BLOCK_SIZE, iv, TC_AES_BLOCK_SIZE);
    5cc2:	4c 8d 6c 24 08       	lea    0x8(%rsp),%r13
    5cc7:	48 89 fd             	mov    %rdi,%rbp
    5cca:	4d 89 c7             	mov    %r8,%r15
    5ccd:	4c 89 c2             	mov    %r8,%rdx
    5cd0:	b9 10 00 00 00       	mov    $0x10,%ecx
    5cd5:	be 10 00 00 00       	mov    $0x10,%esi
    5cda:	4c 89 ef             	mov    %r13,%rdi
    5cdd:	4c 01 f3             	add    %r14,%rbx
    5ce0:	e8 6a f4 ff ff       	callq  514f <_copy>
	/* copy iv to the output buffer */
	(void)_copy(out, TC_AES_BLOCK_SIZE, iv, TC_AES_BLOCK_SIZE);
    5ce5:	48 89 ef             	mov    %rbp,%rdi
    5ce8:	b9 10 00 00 00       	mov    $0x10,%ecx
    5ced:	4c 89 fa             	mov    %r15,%rdx
    5cf0:	be 10 00 00 00       	mov    $0x10,%esi
	out += TC_AES_BLOCK_SIZE;
    5cf5:	48 83 c5 10          	add    $0x10,%rbp
	(void)_copy(out, TC_AES_BLOCK_SIZE, iv, TC_AES_BLOCK_SIZE);
    5cf9:	e8 51 f4 ff ff       	callq  514f <_copy>

	for (n = m = 0; n < inlen; ++n) {
    5cfe:	31 c0                	xor    %eax,%eax
    5d00:	4c 39 f3             	cmp    %r14,%rbx
    5d03:	74 46                	je     5d4b <tc_cbc_mode_encrypt+0xfc>
		buffer[m++] ^= *in++;
    5d05:	89 c6                	mov    %eax,%esi
    5d07:	49 ff c6             	inc    %r14
    5d0a:	8d 48 01             	lea    0x1(%rax),%ecx
    5d0d:	8a 54 34 08          	mov    0x8(%rsp,%rsi,1),%dl
    5d11:	41 32 56 ff          	xor    -0x1(%r14),%dl
    5d15:	88 54 34 08          	mov    %dl,0x8(%rsp,%rsi,1)
		if (m == TC_AES_BLOCK_SIZE) {
    5d19:	83 f8 0f             	cmp    $0xf,%eax
    5d1c:	75 29                	jne    5d47 <tc_cbc_mode_encrypt+0xf8>
			(void)tc_aes_encrypt(buffer, buffer, sched);
    5d1e:	4c 89 e2             	mov    %r12,%rdx
    5d21:	4c 89 ee             	mov    %r13,%rsi
    5d24:	4c 89 ef             	mov    %r13,%rdi
    5d27:	e8 9f fd ff ff       	callq  5acb <tc_aes_encrypt>
			(void)_copy(out, TC_AES_BLOCK_SIZE,
    5d2c:	b9 10 00 00 00       	mov    $0x10,%ecx
    5d31:	48 89 ef             	mov    %rbp,%rdi
    5d34:	4c 89 ea             	mov    %r13,%rdx
    5d37:	be 10 00 00 00       	mov    $0x10,%esi
				    buffer, TC_AES_BLOCK_SIZE);
			out += TC_AES_BLOCK_SIZE;
    5d3c:	48 83 c5 10          	add    $0x10,%rbp
			(void)_copy(out, TC_AES_BLOCK_SIZE,
    5d40:	e8 0a f4 ff ff       	callq  514f <_copy>
			m = 0;
    5d45:	31 c9                	xor    %ecx,%ecx
	for (n = m = 0; n < inlen; ++n) {
    5d47:	89 c8                	mov    %ecx,%eax
    5d49:	eb b5                	jmp    5d00 <tc_cbc_mode_encrypt+0xb1>
		}
	}

	return TC_CRYPTO_SUCCESS;
    5d4b:	b8 01 00 00 00       	mov    $0x1,%eax
    5d50:	eb 02                	jmp    5d54 <tc_cbc_mode_encrypt+0x105>
		return TC_CRYPTO_FAIL;
    5d52:	31 c0                	xor    %eax,%eax
}
    5d54:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    5d59:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5d60:	00 00 
    5d62:	74 05                	je     5d69 <tc_cbc_mode_encrypt+0x11a>
    5d64:	e8 47 d7 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    5d69:	48 83 c4 28          	add    $0x28,%rsp
    5d6d:	5b                   	pop    %rbx
    5d6e:	5d                   	pop    %rbp
    5d6f:	41 5c                	pop    %r12
    5d71:	41 5d                	pop    %r13
    5d73:	41 5e                	pop    %r14
    5d75:	41 5f                	pop    %r15
    5d77:	c3                   	retq   

0000000000005d78 <tc_cbc_mode_decrypt>:

int tc_cbc_mode_decrypt(uint8_t *out, unsigned int outlen, const uint8_t *in,
			    unsigned int inlen, const uint8_t *iv,
			    const TCAesKeySched_t sched)
{
    5d78:	f3 0f 1e fa          	endbr64 
    5d7c:	41 57                	push   %r15
    5d7e:	41 56                	push   %r14
    5d80:	41 55                	push   %r13
    5d82:	41 54                	push   %r12
    5d84:	55                   	push   %rbp
    5d85:	53                   	push   %rbx
    5d86:	48 83 ec 38          	sub    $0x38,%rsp
    5d8a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5d91:	00 00 
    5d93:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    5d98:	31 c0                	xor    %eax,%eax
	uint8_t buffer[TC_AES_BLOCK_SIZE];
	const uint8_t *p;
	unsigned int n, m;

	/* sanity check the inputs */
	if (out == (uint8_t *) 0 ||
    5d9a:	48 85 ff             	test   %rdi,%rdi
    5d9d:	74 7d                	je     5e1c <tc_cbc_mode_decrypt+0xa4>
    5d9f:	49 89 d4             	mov    %rdx,%r12
    5da2:	48 85 d2             	test   %rdx,%rdx
    5da5:	74 75                	je     5e1c <tc_cbc_mode_decrypt+0xa4>
	    in == (const uint8_t *) 0 ||
	    sched == (TCAesKeySched_t) 0 ||
    5da7:	4d 85 c9             	test   %r9,%r9
    5daa:	4d 89 ce             	mov    %r9,%r14
    5dad:	0f 94 c2             	sete   %dl
	    inlen == 0 ||
    5db0:	85 c9                	test   %ecx,%ecx
    5db2:	0f 94 c0             	sete   %al
    5db5:	08 c2                	or     %al,%dl
    5db7:	75 63                	jne    5e1c <tc_cbc_mode_decrypt+0xa4>
    5db9:	85 f6                	test   %esi,%esi
    5dbb:	74 5f                	je     5e1c <tc_cbc_mode_decrypt+0xa4>
	    outlen == 0 ||
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
    5dbd:	89 c8                	mov    %ecx,%eax
    5dbf:	09 f0                	or     %esi,%eax
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
    5dc1:	a8 0f                	test   $0xf,%al
    5dc3:	75 57                	jne    5e1c <tc_cbc_mode_decrypt+0xa4>
    5dc5:	39 f1                	cmp    %esi,%ecx
    5dc7:	75 53                	jne    5e1c <tc_cbc_mode_decrypt+0xa4>
    5dc9:	89 f0                	mov    %esi,%eax
    5dcb:	49 89 fd             	mov    %rdi,%r13
    5dce:	4d 89 c7             	mov    %r8,%r15
    5dd1:	31 db                	xor    %ebx,%ebx
    5dd3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	 * that would not otherwise be possible.
	 */
	p = iv;
	for (n = m = 0; n < outlen; ++n) {
		if ((n % TC_AES_BLOCK_SIZE) == 0) {
			(void)tc_aes_decrypt(buffer, in, sched);
    5dd8:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
	for (n = m = 0; n < outlen; ++n) {
    5ddd:	31 c0                	xor    %eax,%eax
    5ddf:	48 39 5c 24 08       	cmp    %rbx,0x8(%rsp)
    5de4:	74 2f                	je     5e15 <tc_cbc_mode_decrypt+0x9d>
		if ((n % TC_AES_BLOCK_SIZE) == 0) {
    5de6:	f6 c3 0f             	test   $0xf,%bl
    5de9:	75 14                	jne    5dff <tc_cbc_mode_decrypt+0x87>
			(void)tc_aes_decrypt(buffer, in, sched);
    5deb:	4c 89 e6             	mov    %r12,%rsi
    5dee:	4c 89 f2             	mov    %r14,%rdx
    5df1:	48 89 ef             	mov    %rbp,%rdi
			in += TC_AES_BLOCK_SIZE;
    5df4:	49 83 c4 10          	add    $0x10,%r12
			(void)tc_aes_decrypt(buffer, in, sched);
    5df8:	e8 76 f8 ff ff       	callq  5673 <tc_aes_decrypt>
			m = 0;
    5dfd:	31 c0                	xor    %eax,%eax
		}
		*out++ = buffer[m++] ^ *p++;
    5dff:	89 c2                	mov    %eax,%edx
    5e01:	ff c0                	inc    %eax
    5e03:	8a 54 14 18          	mov    0x18(%rsp,%rdx,1),%dl
    5e07:	41 32 14 1f          	xor    (%r15,%rbx,1),%dl
    5e0b:	41 88 54 1d 00       	mov    %dl,0x0(%r13,%rbx,1)
	for (n = m = 0; n < outlen; ++n) {
    5e10:	48 ff c3             	inc    %rbx
    5e13:	eb ca                	jmp    5ddf <tc_cbc_mode_decrypt+0x67>
	}

	return TC_CRYPTO_SUCCESS;
    5e15:	b8 01 00 00 00       	mov    $0x1,%eax
    5e1a:	eb 02                	jmp    5e1e <tc_cbc_mode_decrypt+0xa6>
		return TC_CRYPTO_FAIL;
    5e1c:	31 c0                	xor    %eax,%eax
}
    5e1e:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    5e23:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5e2a:	00 00 
    5e2c:	74 05                	je     5e33 <tc_cbc_mode_decrypt+0xbb>
    5e2e:	e8 7d d6 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    5e33:	48 83 c4 38          	add    $0x38,%rsp
    5e37:	5b                   	pop    %rbx
    5e38:	5d                   	pop    %rbp
    5e39:	41 5c                	pop    %r12
    5e3b:	41 5d                	pop    %r13
    5e3d:	41 5e                	pop    %r14
    5e3f:	41 5f                	pop    %r15
    5e41:	c3                   	retq   

0000000000005e42 <tc_ctr_mode>:
#include <tinycrypt/ctr_mode.h>
#include <tinycrypt/utils.h>

int tc_ctr_mode(uint8_t *out, unsigned int outlen, const uint8_t *in,
		unsigned int inlen, uint8_t *ctr, const TCAesKeySched_t sched)
{
    5e42:	f3 0f 1e fa          	endbr64 
    5e46:	41 57                	push   %r15
    5e48:	41 56                	push   %r14
    5e4a:	41 55                	push   %r13
    5e4c:	41 54                	push   %r12
    5e4e:	55                   	push   %rbp
    5e4f:	53                   	push   %rbx
    5e50:	48 83 ec 58          	sub    $0x58,%rsp
    5e54:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5e5b:	00 00 
    5e5d:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    5e62:	31 c0                	xor    %eax,%eax
	uint8_t nonce[TC_AES_BLOCK_SIZE];
	unsigned int block_num;
	unsigned int i;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    5e64:	48 85 ff             	test   %rdi,%rdi
    5e67:	74 08                	je     5e71 <tc_ctr_mode+0x2f>
    5e69:	49 89 d4             	mov    %rdx,%r12
    5e6c:	48 85 d2             	test   %rdx,%rdx
    5e6f:	75 07                	jne    5e78 <tc_ctr_mode+0x36>
	    ctr == (uint8_t *) 0 ||
	    sched == (TCAesKeySched_t) 0 ||
	    inlen == 0 ||
	    outlen == 0 ||
	    outlen != inlen) {
		return TC_CRYPTO_FAIL;
    5e71:	31 c0                	xor    %eax,%eax
    5e73:	e9 cb 00 00 00       	jmpq   5f43 <tc_ctr_mode+0x101>
	    ctr == (uint8_t *) 0 ||
    5e78:	4d 85 c0             	test   %r8,%r8
    5e7b:	74 f4                	je     5e71 <tc_ctr_mode+0x2f>
    5e7d:	4d 89 cd             	mov    %r9,%r13
    5e80:	4d 85 c9             	test   %r9,%r9
    5e83:	74 ec                	je     5e71 <tc_ctr_mode+0x2f>
	    inlen == 0 ||
    5e85:	85 c9                	test   %ecx,%ecx
    5e87:	89 cb                	mov    %ecx,%ebx
    5e89:	0f 94 c2             	sete   %dl
	    outlen == 0 ||
    5e8c:	85 f6                	test   %esi,%esi
    5e8e:	0f 94 c0             	sete   %al
    5e91:	08 c2                	or     %al,%dl
    5e93:	75 dc                	jne    5e71 <tc_ctr_mode+0x2f>
    5e95:	39 f1                	cmp    %esi,%ecx
    5e97:	75 d8                	jne    5e71 <tc_ctr_mode+0x2f>
	}

	/* copy the ctr to the nonce */
	(void)_copy(nonce, sizeof(nonce), ctr, sizeof(nonce));
    5e99:	4c 8d 7c 24 38       	lea    0x38(%rsp),%r15
    5e9e:	4c 89 c2             	mov    %r8,%rdx
    5ea1:	48 89 fd             	mov    %rdi,%rbp
    5ea4:	b9 10 00 00 00       	mov    $0x10,%ecx
    5ea9:	4c 89 ff             	mov    %r15,%rdi
    5eac:	be 10 00 00 00       	mov    $0x10,%esi
    5eb1:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    5eb6:	e8 94 f2 ff ff       	callq  514f <_copy>

	/* select the last 4 bytes of the nonce to be incremented */
	block_num = (nonce[12] << 24) | (nonce[13] << 16) |
    5ebb:	89 d8                	mov    %ebx,%eax
    5ebd:	44 8b 4c 24 44       	mov    0x44(%rsp),%r9d
		    (nonce[14] << 8) | (nonce[15]);
	for (i = 0; i < inlen; ++i) {
    5ec2:	31 db                	xor    %ebx,%ebx
    5ec4:	48 89 04 24          	mov    %rax,(%rsp)
    5ec8:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
			/* encrypt data using the current nonce */
			if (tc_aes_encrypt(buffer, nonce, sched)) {
    5ecd:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    5ed2:	41 0f c9             	bswap  %r9d
	for (i = 0; i < inlen; ++i) {
    5ed5:	48 3b 1c 24          	cmp    (%rsp),%rbx
    5ed9:	74 5b                	je     5f36 <tc_ctr_mode+0xf4>
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
    5edb:	41 89 de             	mov    %ebx,%r14d
    5ede:	41 83 e6 0f          	and    $0xf,%r14d
    5ee2:	75 3d                	jne    5f21 <tc_ctr_mode+0xdf>
			if (tc_aes_encrypt(buffer, nonce, sched)) {
    5ee4:	4c 89 ea             	mov    %r13,%rdx
    5ee7:	4c 89 fe             	mov    %r15,%rsi
    5eea:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    5eef:	44 89 4c 24 14       	mov    %r9d,0x14(%rsp)
    5ef4:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    5ef9:	e8 cd fb ff ff       	callq  5acb <tc_aes_encrypt>
    5efe:	85 c0                	test   %eax,%eax
    5f00:	0f 84 6b ff ff ff    	je     5e71 <tc_ctr_mode+0x2f>
				block_num++;
    5f06:	44 8b 4c 24 14       	mov    0x14(%rsp),%r9d
				nonce[12] = (uint8_t)(block_num >> 24);
    5f0b:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    5f10:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
				block_num++;
    5f15:	41 ff c1             	inc    %r9d
				nonce[13] = (uint8_t)(block_num >> 16);
				nonce[14] = (uint8_t)(block_num >> 8);
				nonce[15] = (uint8_t)(block_num);
    5f18:	44 89 c8             	mov    %r9d,%eax
    5f1b:	0f c8                	bswap  %eax
				nonce[12] = (uint8_t)(block_num >> 24);
    5f1d:	89 44 24 44          	mov    %eax,0x44(%rsp)
			} else {
				return TC_CRYPTO_FAIL;
			}
		}
		/* update the output */
		*out++ = buffer[i%(TC_AES_BLOCK_SIZE)] ^ *in++;
    5f21:	45 89 f6             	mov    %r14d,%r14d
    5f24:	42 8a 44 34 28       	mov    0x28(%rsp,%r14,1),%al
    5f29:	41 32 04 1c          	xor    (%r12,%rbx,1),%al
    5f2d:	88 44 1d 00          	mov    %al,0x0(%rbp,%rbx,1)
	for (i = 0; i < inlen; ++i) {
    5f31:	48 ff c3             	inc    %rbx
    5f34:	eb 9f                	jmp    5ed5 <tc_ctr_mode+0x93>
	}

	/* update the counter */
	ctr[12] = nonce[12]; ctr[13] = nonce[13];
    5f36:	8b 44 24 44          	mov    0x44(%rsp),%eax
    5f3a:	41 89 40 0c          	mov    %eax,0xc(%r8)
	ctr[14] = nonce[14]; ctr[15] = nonce[15];

	return TC_CRYPTO_SUCCESS;
    5f3e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    5f43:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    5f48:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    5f4f:	00 00 
    5f51:	74 05                	je     5f58 <tc_ctr_mode+0x116>
    5f53:	e8 58 d5 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    5f58:	48 83 c4 58          	add    $0x58,%rsp
    5f5c:	5b                   	pop    %rbx
    5f5d:	5d                   	pop    %rbp
    5f5e:	41 5c                	pop    %r12
    5f60:	41 5d                	pop    %r13
    5f62:	41 5e                	pop    %r14
    5f64:	41 5f                	pop    %r15
    5f66:	c3                   	retq   

0000000000005f67 <ccm_cbc_mac>:
/**
 * Variation of CBC-MAC mode used in CCM.
 */
static void ccm_cbc_mac(uint8_t *T, const uint8_t *data, unsigned int dlen,
			unsigned int flag, TCAesKeySched_t sched)
{
    5f67:	41 56                	push   %r14
    5f69:	41 55                	push   %r13
    5f6b:	4d 89 c5             	mov    %r8,%r13
    5f6e:	41 54                	push   %r12
    5f70:	49 89 f4             	mov    %rsi,%r12
    5f73:	55                   	push   %rbp
    5f74:	89 d5                	mov    %edx,%ebp
    5f76:	53                   	push   %rbx
    5f77:	48 89 fb             	mov    %rdi,%rbx

	unsigned int i;

	if (flag > 0) {
    5f7a:	85 c9                	test   %ecx,%ecx
    5f7c:	74 34                	je     5fb2 <ccm_cbc_mac+0x4b>
		T[0] ^= (uint8_t)(dlen >> 8);
    5f7e:	89 d0                	mov    %edx,%eax
		T[1] ^= (uint8_t)(dlen);
    5f80:	30 57 01             	xor    %dl,0x1(%rdi)
		dlen += 2; i = 2;
    5f83:	83 c5 02             	add    $0x2,%ebp
    5f86:	b9 02 00 00 00       	mov    $0x2,%ecx
		T[0] ^= (uint8_t)(dlen >> 8);
    5f8b:	c1 e8 08             	shr    $0x8,%eax
    5f8e:	30 07                	xor    %al,(%rdi)
		dlen += 2; i = 2;
    5f90:	eb 20                	jmp    5fb2 <ccm_cbc_mac+0x4b>
	} else {
		i = 0;
	}

	while (i < dlen) {
		T[i++ % (Nb * Nk)] ^= *data++;
    5f92:	44 8d 71 01          	lea    0x1(%rcx),%r14d
    5f96:	83 e1 0f             	and    $0xf,%ecx
    5f99:	49 ff c4             	inc    %r12
    5f9c:	41 8a 44 24 ff       	mov    -0x1(%r12),%al
    5fa1:	30 04 0b             	xor    %al,(%rbx,%rcx,1)
		if (((i % (Nb * Nk)) == 0) || dlen == i) {
    5fa4:	41 f6 c6 0f          	test   $0xf,%r14b
    5fa8:	74 0e                	je     5fb8 <ccm_cbc_mac+0x51>
    5faa:	41 39 ee             	cmp    %ebp,%r14d
    5fad:	74 09                	je     5fb8 <ccm_cbc_mac+0x51>
		T[i++ % (Nb * Nk)] ^= *data++;
    5faf:	44 89 f1             	mov    %r14d,%ecx
	while (i < dlen) {
    5fb2:	39 e9                	cmp    %ebp,%ecx
    5fb4:	72 dc                	jb     5f92 <ccm_cbc_mac+0x2b>
    5fb6:	eb 10                	jmp    5fc8 <ccm_cbc_mac+0x61>
			(void) tc_aes_encrypt(T, T, sched);
    5fb8:	4c 89 ea             	mov    %r13,%rdx
    5fbb:	48 89 de             	mov    %rbx,%rsi
    5fbe:	48 89 df             	mov    %rbx,%rdi
    5fc1:	e8 05 fb ff ff       	callq  5acb <tc_aes_encrypt>
    5fc6:	eb e7                	jmp    5faf <ccm_cbc_mac+0x48>
		}
	}
}
    5fc8:	5b                   	pop    %rbx
    5fc9:	5d                   	pop    %rbp
    5fca:	41 5c                	pop    %r12
    5fcc:	41 5d                	pop    %r13
    5fce:	41 5e                	pop    %r14
    5fd0:	c3                   	retq   

0000000000005fd1 <ccm_ctr_mode.constprop.0>:
 * The CTR mode used by CCM is slightly different than the conventional CTR
 * mode (the counter is increased before encryption, instead of after
 * encryption). Besides, it is assumed that the counter is stored in the last
 * 2 bytes of the nonce.
 */
static int ccm_ctr_mode(uint8_t *out, unsigned int outlen, const uint8_t *in,
    5fd1:	41 57                	push   %r15
    5fd3:	41 56                	push   %r14
    5fd5:	41 55                	push   %r13
    5fd7:	41 54                	push   %r12
    5fd9:	55                   	push   %rbp
    5fda:	53                   	push   %rbx
    5fdb:	48 83 ec 58          	sub    $0x58,%rsp
    5fdf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5fe6:	00 00 
    5fe8:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    5fed:	31 c0                	xor    %eax,%eax
	uint8_t nonce[TC_AES_BLOCK_SIZE];
	uint16_t block_num;
	unsigned int i;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
    5fef:	48 85 ff             	test   %rdi,%rdi
    5ff2:	0f 84 dc 00 00 00    	je     60d4 <ccm_ctr_mode.constprop.0+0x103>
    5ff8:	49 89 d5             	mov    %rdx,%r13
    5ffb:	48 85 d2             	test   %rdx,%rdx
    5ffe:	0f 84 d0 00 00 00    	je     60d4 <ccm_ctr_mode.constprop.0+0x103>
    6004:	4d 89 ce             	mov    %r9,%r14
	    in == (uint8_t *) 0 ||
	    ctr == (uint8_t *) 0 ||
    6007:	4d 85 c9             	test   %r9,%r9
    600a:	0f 84 c6 00 00 00    	je     60d6 <ccm_ctr_mode.constprop.0+0x105>
	    sched == (TCAesKeySched_t) 0 ||
	    inlen == 0 ||
    6010:	85 c9                	test   %ecx,%ecx
    6012:	89 cb                	mov    %ecx,%ebx
    6014:	0f 94 c2             	sete   %dl
	    outlen == 0 ||
    6017:	85 f6                	test   %esi,%esi
    6019:	0f 94 c0             	sete   %al
    601c:	08 c2                	or     %al,%dl
    601e:	0f 85 b0 00 00 00    	jne    60d4 <ccm_ctr_mode.constprop.0+0x103>
    6024:	39 f1                	cmp    %esi,%ecx
    6026:	0f 85 a8 00 00 00    	jne    60d4 <ccm_ctr_mode.constprop.0+0x103>
	    outlen != inlen) {
		return TC_CRYPTO_FAIL;
	}

	/* copy the counter to the nonce */
	(void) _copy(nonce, sizeof(nonce), ctr, sizeof(nonce));
    602c:	4c 8d 7c 24 38       	lea    0x38(%rsp),%r15
    6031:	4c 89 c2             	mov    %r8,%rdx
    6034:	49 89 fc             	mov    %rdi,%r12
    6037:	b9 10 00 00 00       	mov    $0x10,%ecx
    603c:	4c 89 ff             	mov    %r15,%rdi
    603f:	be 10 00 00 00       	mov    $0x10,%esi
    6044:	4c 89 c5             	mov    %r8,%rbp
    6047:	e8 03 f1 ff ff       	callq  514f <_copy>

	/* select the last 2 bytes of the nonce to be incremented */
	block_num = (uint16_t) ((nonce[14] << 8)|(nonce[15]));
    604c:	44 0f b6 44 24 46    	movzbl 0x46(%rsp),%r8d
    6052:	0f b6 44 24 47       	movzbl 0x47(%rsp),%eax
	for (i = 0; i < inlen; ++i) {
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
			block_num++;
			nonce[14] = (uint8_t)(block_num >> 8);
			nonce[15] = (uint8_t)(block_num);
			if (!tc_aes_encrypt(buffer, nonce, sched)) {
    6057:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
	block_num = (uint16_t) ((nonce[14] << 8)|(nonce[15]));
    605c:	41 c1 e0 08          	shl    $0x8,%r8d
    6060:	41 09 c0             	or     %eax,%r8d
	for (i = 0; i < inlen; ++i) {
    6063:	89 d8                	mov    %ebx,%eax
    6065:	31 db                	xor    %ebx,%ebx
    6067:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    606c:	48 39 5c 24 08       	cmp    %rbx,0x8(%rsp)
    6071:	74 51                	je     60c4 <ccm_ctr_mode.constprop.0+0xf3>
		if ((i % (TC_AES_BLOCK_SIZE)) == 0) {
    6073:	89 d8                	mov    %ebx,%eax
    6075:	83 e0 0f             	and    $0xf,%eax
    6078:	89 44 24 18          	mov    %eax,0x18(%rsp)
    607c:	75 30                	jne    60ae <ccm_ctr_mode.constprop.0+0xdd>
			block_num++;
    607e:	41 ff c0             	inc    %r8d
			if (!tc_aes_encrypt(buffer, nonce, sched)) {
    6081:	4c 89 f2             	mov    %r14,%rdx
    6084:	4c 89 fe             	mov    %r15,%rsi
    6087:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
			nonce[14] = (uint8_t)(block_num >> 8);
    608c:	44 89 c0             	mov    %r8d,%eax
    608f:	44 89 44 24 1c       	mov    %r8d,0x1c(%rsp)
    6094:	86 e0                	xchg   %ah,%al
    6096:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
			if (!tc_aes_encrypt(buffer, nonce, sched)) {
    609b:	e8 2b fa ff ff       	callq  5acb <tc_aes_encrypt>
    60a0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    60a5:	44 8b 44 24 1c       	mov    0x1c(%rsp),%r8d
    60aa:	85 c0                	test   %eax,%eax
    60ac:	74 28                	je     60d6 <ccm_ctr_mode.constprop.0+0x105>
				return TC_CRYPTO_FAIL;
			}
		}
		/* update the output */
		*out++ = buffer[i % (TC_AES_BLOCK_SIZE)] ^ *in++;
    60ae:	8b 44 24 18          	mov    0x18(%rsp),%eax
    60b2:	8a 44 04 28          	mov    0x28(%rsp,%rax,1),%al
    60b6:	41 32 44 1d 00       	xor    0x0(%r13,%rbx,1),%al
    60bb:	41 88 04 1c          	mov    %al,(%r12,%rbx,1)
	for (i = 0; i < inlen; ++i) {
    60bf:	48 ff c3             	inc    %rbx
    60c2:	eb a8                	jmp    606c <ccm_ctr_mode.constprop.0+0x9b>
	}

	/* update the counter */
	ctr[14] = nonce[14]; ctr[15] = nonce[15];
    60c4:	66 8b 44 24 46       	mov    0x46(%rsp),%ax
    60c9:	66 89 45 0e          	mov    %ax,0xe(%rbp)

	return TC_CRYPTO_SUCCESS;
    60cd:	b8 01 00 00 00       	mov    $0x1,%eax
    60d2:	eb 02                	jmp    60d6 <ccm_ctr_mode.constprop.0+0x105>
		return TC_CRYPTO_FAIL;
    60d4:	31 c0                	xor    %eax,%eax
}
    60d6:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    60db:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    60e2:	00 00 
    60e4:	74 05                	je     60eb <ccm_ctr_mode.constprop.0+0x11a>
    60e6:	e8 c5 d3 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    60eb:	48 83 c4 58          	add    $0x58,%rsp
    60ef:	5b                   	pop    %rbx
    60f0:	5d                   	pop    %rbp
    60f1:	41 5c                	pop    %r12
    60f3:	41 5d                	pop    %r13
    60f5:	41 5e                	pop    %r14
    60f7:	41 5f                	pop    %r15
    60f9:	c3                   	retq   

00000000000060fa <tc_ccm_config>:
{
    60fa:	f3 0f 1e fa          	endbr64 
	if (c == (TCCcmMode_t) 0 ||
    60fe:	48 85 ff             	test   %rdi,%rdi
    6101:	0f 94 c0             	sete   %al
	    sched == (TCAesKeySched_t) 0 ||
    6104:	48 85 f6             	test   %rsi,%rsi
    6107:	41 0f 94 c1          	sete   %r9b
	if (c == (TCCcmMode_t) 0 ||
    610b:	44 09 c8             	or     %r9d,%eax
	    sched == (TCAesKeySched_t) 0 ||
    610e:	48 85 d2             	test   %rdx,%rdx
    6111:	41 0f 94 c1          	sete   %r9b
	} else if (nlen != 13) {
    6115:	44 08 c8             	or     %r9b,%al
    6118:	75 27                	jne    6141 <tc_ccm_config+0x47>
    611a:	83 f9 0d             	cmp    $0xd,%ecx
    611d:	75 22                	jne    6141 <tc_ccm_config+0x47>
	} else if ((mlen < 4) || (mlen > 16) || (mlen & 1)) {
    611f:	41 8d 48 fc          	lea    -0x4(%r8),%ecx
		return TC_CRYPTO_FAIL; /* The allowed nonce size is: 13. See documentation.*/
    6123:	31 c0                	xor    %eax,%eax
	} else if ((mlen < 4) || (mlen > 16) || (mlen & 1)) {
    6125:	83 f9 0c             	cmp    $0xc,%ecx
    6128:	77 19                	ja     6143 <tc_ccm_config+0x49>
    612a:	41 f6 c0 01          	test   $0x1,%r8b
    612e:	75 13                	jne    6143 <tc_ccm_config+0x49>
	c->mlen = mlen;
    6130:	44 89 47 10          	mov    %r8d,0x10(%rdi)
	return TC_CRYPTO_SUCCESS;
    6134:	b8 01 00 00 00       	mov    $0x1,%eax
	c->sched = sched;
    6139:	48 89 37             	mov    %rsi,(%rdi)
	c->nonce = nonce;
    613c:	48 89 57 08          	mov    %rdx,0x8(%rdi)
	return TC_CRYPTO_SUCCESS;
    6140:	c3                   	retq   
		return TC_CRYPTO_FAIL; /* The allowed nonce size is: 13. See documentation.*/
    6141:	31 c0                	xor    %eax,%eax
}
    6143:	c3                   	retq   

0000000000006144 <tc_ccm_generation_encryption>:

int tc_ccm_generation_encryption(uint8_t *out, unsigned int olen,
				 const uint8_t *associated_data,
				 unsigned int alen, const uint8_t *payload,
				 unsigned int plen, TCCcmMode_t c)
{
    6144:	f3 0f 1e fa          	endbr64 
    6148:	41 57                	push   %r15
    614a:	41 56                	push   %r14
    614c:	41 55                	push   %r13
    614e:	41 54                	push   %r12
    6150:	55                   	push   %rbp
    6151:	53                   	push   %rbx
    6152:	48 83 ec 48          	sub    $0x48,%rsp
    6156:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    615d:	00 00 
    615f:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    6164:	31 c0                	xor    %eax,%eax
    6166:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
    616d:	00 

	/* input sanity check: */
	if ((out == (uint8_t *) 0) ||
    616e:	48 85 ff             	test   %rdi,%rdi
    6171:	0f 84 59 01 00 00    	je     62d0 <tc_ccm_generation_encryption+0x18c>
    6177:	48 85 ed             	test   %rbp,%rbp
    617a:	0f 84 50 01 00 00    	je     62d0 <tc_ccm_generation_encryption+0x18c>
    6180:	44 89 cb             	mov    %r9d,%ebx
    6183:	49 89 fc             	mov    %rdi,%r12
    6186:	49 89 d3             	mov    %rdx,%r11
    6189:	41 89 ca             	mov    %ecx,%r10d
    618c:	4d 89 c6             	mov    %r8,%r14
		(c == (TCCcmMode_t) 0) ||
    618f:	85 db                	test   %ebx,%ebx
    6191:	74 0c                	je     619f <tc_ccm_generation_encryption+0x5b>
		((plen > 0) && (payload == (uint8_t *) 0)) ||
		((alen > 0) && (associated_data == (uint8_t *) 0)) ||
		(alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
		(plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
		(olen < (plen + c->mlen))) {  /* invalid output buffer size */
		return TC_CRYPTO_FAIL;
    6193:	45 31 c0             	xor    %r8d,%r8d
		(c == (TCCcmMode_t) 0) ||
    6196:	4d 85 f6             	test   %r14,%r14
    6199:	0f 84 34 01 00 00    	je     62d3 <tc_ccm_generation_encryption+0x18f>
		((plen > 0) && (payload == (uint8_t *) 0)) ||
    619f:	45 85 d2             	test   %r10d,%r10d
    61a2:	74 0c                	je     61b0 <tc_ccm_generation_encryption+0x6c>
		return TC_CRYPTO_FAIL;
    61a4:	45 31 c0             	xor    %r8d,%r8d
		((plen > 0) && (payload == (uint8_t *) 0)) ||
    61a7:	4d 85 db             	test   %r11,%r11
    61aa:	0f 84 23 01 00 00    	je     62d3 <tc_ccm_generation_encryption+0x18f>
		(alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
    61b0:	41 81 fa ff fe 00 00 	cmp    $0xfeff,%r10d
    61b7:	0f 87 13 01 00 00    	ja     62d0 <tc_ccm_generation_encryption+0x18c>
    61bd:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    61c3:	0f 87 07 01 00 00    	ja     62d0 <tc_ccm_generation_encryption+0x18c>
		(olen < (plen + c->mlen))) {  /* invalid output buffer size */
    61c9:	8b 45 10             	mov    0x10(%rbp),%eax
		return TC_CRYPTO_FAIL;
    61cc:	45 31 c0             	xor    %r8d,%r8d
		(olen < (plen + c->mlen))) {  /* invalid output buffer size */
    61cf:	8d 14 18             	lea    (%rax,%rbx,1),%edx
		(plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
    61d2:	39 f2                	cmp    %esi,%edx
    61d4:	0f 87 f9 00 00 00    	ja     62d3 <tc_ccm_generation_encryption+0x18f>
	unsigned int i;

	/* GENERATING THE AUTHENTICATION TAG: */

	/* formatting the sequence b for authentication: */
	b[0] = ((alen > 0) ? 0x40:0) | (((c->mlen - 2) / 2 << 3)) | (1);
    61da:	45 85 d2             	test   %r10d,%r10d
	for (i = 1; i <= 13; ++i) {
		b[i] = c->nonce[i - 1];
    61dd:	48 8b 75 08          	mov    0x8(%rbp),%rsi
    61e1:	4c 8d 6c 24 18       	lea    0x18(%rsp),%r13
	b[0] = ((alen > 0) ? 0x40:0) | (((c->mlen - 2) / 2 << 3)) | (1);
    61e6:	0f 95 c2             	setne  %dl
    61e9:	83 e8 02             	sub    $0x2,%eax
    61ec:	d1 e8                	shr    %eax
    61ee:	c1 e2 06             	shl    $0x6,%edx
    61f1:	c1 e0 03             	shl    $0x3,%eax
    61f4:	09 d0                	or     %edx,%eax
		b[i] = c->nonce[i - 1];
    61f6:	48 8d 54 24 19       	lea    0x19(%rsp),%rdx
	b[0] = ((alen > 0) ? 0x40:0) | (((c->mlen - 2) / 2 << 3)) | (1);
    61fb:	83 c8 01             	or     $0x1,%eax
    61fe:	88 44 24 18          	mov    %al,0x18(%rsp)
		b[i] = c->nonce[i - 1];
    6202:	31 c0                	xor    %eax,%eax
    6204:	8a 0c 06             	mov    (%rsi,%rax,1),%cl
    6207:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
	for (i = 1; i <= 13; ++i) {
    620a:	48 ff c0             	inc    %rax
    620d:	48 83 f8 0d          	cmp    $0xd,%rax
    6211:	75 f1                	jne    6204 <tc_ccm_generation_encryption+0xc0>
	}
	b[14] = (uint8_t)(plen >> 8);
    6213:	89 d8                	mov    %ebx,%eax
	b[15] = (uint8_t)(plen);

	/* computing the authentication tag using cbc-mac: */
	(void) tc_aes_encrypt(tag, b, c->sched);
    6215:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    6219:	4c 8d 7c 24 28       	lea    0x28(%rsp),%r15
    621e:	4c 89 ee             	mov    %r13,%rsi
	b[14] = (uint8_t)(plen >> 8);
    6221:	86 e0                	xchg   %ah,%al
	(void) tc_aes_encrypt(tag, b, c->sched);
    6223:	4c 89 ff             	mov    %r15,%rdi
    6226:	44 89 54 24 0c       	mov    %r10d,0xc(%rsp)
    622b:	4c 89 1c 24          	mov    %r11,(%rsp)
	b[14] = (uint8_t)(plen >> 8);
    622f:	66 89 44 24 26       	mov    %ax,0x26(%rsp)
	(void) tc_aes_encrypt(tag, b, c->sched);
    6234:	e8 92 f8 ff ff       	callq  5acb <tc_aes_encrypt>
	if (alen > 0) {
    6239:	44 8b 54 24 0c       	mov    0xc(%rsp),%r10d
    623e:	4c 8b 1c 24          	mov    (%rsp),%r11
    6242:	45 85 d2             	test   %r10d,%r10d
    6245:	74 17                	je     625e <tc_ccm_generation_encryption+0x11a>
		ccm_cbc_mac(tag, associated_data, alen, 1, c->sched);
    6247:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    624b:	b9 01 00 00 00       	mov    $0x1,%ecx
    6250:	44 89 d2             	mov    %r10d,%edx
    6253:	4c 89 de             	mov    %r11,%rsi
    6256:	4c 89 ff             	mov    %r15,%rdi
    6259:	e8 09 fd ff ff       	callq  5f67 <ccm_cbc_mac>
	}
	if (plen > 0) {
    625e:	85 db                	test   %ebx,%ebx
    6260:	74 13                	je     6275 <tc_ccm_generation_encryption+0x131>
		ccm_cbc_mac(tag, payload, plen, 0, c->sched);
    6262:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    6266:	31 c9                	xor    %ecx,%ecx
    6268:	89 da                	mov    %ebx,%edx
    626a:	4c 89 f6             	mov    %r14,%rsi
    626d:	4c 89 ff             	mov    %r15,%rdi
    6270:	e8 f2 fc ff ff       	callq  5f67 <ccm_cbc_mac>
	/* formatting the sequence b for encryption: */
	b[0] = 1; /* q - 1 = 2 - 1 = 1 */
	b[14] = b[15] = TC_ZERO_BYTE;

	/* encrypting payload using ctr mode: */
	ccm_ctr_mode(out, plen, payload, plen, b, c->sched);
    6275:	4c 8b 4d 00          	mov    0x0(%rbp),%r9
    6279:	89 d9                	mov    %ebx,%ecx
    627b:	89 de                	mov    %ebx,%esi
    627d:	4d 89 e8             	mov    %r13,%r8
    6280:	4c 89 f2             	mov    %r14,%rdx
    6283:	4c 89 e7             	mov    %r12,%rdi
	b[0] = 1; /* q - 1 = 2 - 1 = 1 */
    6286:	c6 44 24 18 01       	movb   $0x1,0x18(%rsp)

	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter for ctr_mode (0):*/

	/* encrypting b and adding the tag to the output: */
	(void) tc_aes_encrypt(b, b, c->sched);
	out += plen;
    628b:	4c 01 e3             	add    %r12,%rbx
	b[14] = b[15] = TC_ZERO_BYTE;
    628e:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	ccm_ctr_mode(out, plen, payload, plen, b, c->sched);
    6295:	e8 37 fd ff ff       	callq  5fd1 <ccm_ctr_mode.constprop.0>
	(void) tc_aes_encrypt(b, b, c->sched);
    629a:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    629e:	4c 89 ee             	mov    %r13,%rsi
    62a1:	4c 89 ef             	mov    %r13,%rdi
	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter for ctr_mode (0):*/
    62a4:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	(void) tc_aes_encrypt(b, b, c->sched);
    62ab:	e8 1b f8 ff ff       	callq  5acb <tc_aes_encrypt>
	for (i = 0; i < c->mlen; ++i) {
    62b0:	31 c0                	xor    %eax,%eax
    62b2:	39 45 10             	cmp    %eax,0x10(%rbp)
    62b5:	76 11                	jbe    62c8 <tc_ccm_generation_encryption+0x184>
		*out++ = tag[i] ^ b[i];
    62b7:	41 8a 14 07          	mov    (%r15,%rax,1),%dl
    62bb:	41 32 54 05 00       	xor    0x0(%r13,%rax,1),%dl
    62c0:	88 14 03             	mov    %dl,(%rbx,%rax,1)
	for (i = 0; i < c->mlen; ++i) {
    62c3:	48 ff c0             	inc    %rax
    62c6:	eb ea                	jmp    62b2 <tc_ccm_generation_encryption+0x16e>
	}

	return TC_CRYPTO_SUCCESS;
    62c8:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    62ce:	eb 03                	jmp    62d3 <tc_ccm_generation_encryption+0x18f>
		return TC_CRYPTO_FAIL;
    62d0:	45 31 c0             	xor    %r8d,%r8d
}
    62d3:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    62d8:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    62df:	00 00 
    62e1:	74 05                	je     62e8 <tc_ccm_generation_encryption+0x1a4>
    62e3:	e8 c8 d1 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    62e8:	48 83 c4 48          	add    $0x48,%rsp
    62ec:	44 89 c0             	mov    %r8d,%eax
    62ef:	5b                   	pop    %rbx
    62f0:	5d                   	pop    %rbp
    62f1:	41 5c                	pop    %r12
    62f3:	41 5d                	pop    %r13
    62f5:	41 5e                	pop    %r14
    62f7:	41 5f                	pop    %r15
    62f9:	c3                   	retq   

00000000000062fa <tc_ccm_decryption_verification>:

int tc_ccm_decryption_verification(uint8_t *out, unsigned int olen,
				   const uint8_t *associated_data,
				   unsigned int alen, const uint8_t *payload,
				   unsigned int plen, TCCcmMode_t c)
{
    62fa:	f3 0f 1e fa          	endbr64 
    62fe:	41 57                	push   %r15
    6300:	41 56                	push   %r14
    6302:	41 55                	push   %r13
    6304:	49 89 fd             	mov    %rdi,%r13
    6307:	41 54                	push   %r12
    6309:	55                   	push   %rbp
    630a:	53                   	push   %rbx
    630b:	48 83 ec 48          	sub    $0x48,%rsp
    630f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6316:	00 00 
    6318:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    631d:	31 c0                	xor    %eax,%eax
    631f:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
    6326:	00 

	/* input sanity check: */
	if ((out == (uint8_t *) 0) ||
    6327:	48 85 ff             	test   %rdi,%rdi
    632a:	0f 84 a2 01 00 00    	je     64d2 <tc_ccm_decryption_verification+0x1d8>
    6330:	48 85 ed             	test   %rbp,%rbp
    6333:	0f 84 99 01 00 00    	je     64d2 <tc_ccm_decryption_verification+0x1d8>
    6339:	89 f7                	mov    %esi,%edi
    633b:	49 89 d6             	mov    %rdx,%r14
    633e:	41 89 cf             	mov    %ecx,%r15d
    6341:	4d 89 c3             	mov    %r8,%r11
    6344:	44 89 cb             	mov    %r9d,%ebx
	    (c == (TCCcmMode_t) 0) ||
    6347:	45 85 c9             	test   %r9d,%r9d
    634a:	74 09                	je     6355 <tc_ccm_decryption_verification+0x5b>
    634c:	4d 85 c0             	test   %r8,%r8
    634f:	0f 84 7f 01 00 00    	je     64d4 <tc_ccm_decryption_verification+0x1da>
	    ((plen > 0) && (payload == (uint8_t *) 0)) ||
    6355:	45 85 ff             	test   %r15d,%r15d
    6358:	74 0b                	je     6365 <tc_ccm_decryption_verification+0x6b>
	    ((alen > 0) && (associated_data == (uint8_t *) 0)) ||
	    (alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
	    (plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
	    (olen < plen - c->mlen)) { /* invalid output buffer size */
		return TC_CRYPTO_FAIL;
    635a:	31 c0                	xor    %eax,%eax
	    ((plen > 0) && (payload == (uint8_t *) 0)) ||
    635c:	4d 85 f6             	test   %r14,%r14
    635f:	0f 84 6f 01 00 00    	je     64d4 <tc_ccm_decryption_verification+0x1da>
	    (alen >= TC_CCM_AAD_MAX_BYTES) || /* associated data size unsupported */
    6365:	41 81 ff ff fe 00 00 	cmp    $0xfeff,%r15d
    636c:	0f 87 60 01 00 00    	ja     64d2 <tc_ccm_decryption_verification+0x1d8>
    6372:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    6378:	0f 87 54 01 00 00    	ja     64d2 <tc_ccm_decryption_verification+0x1d8>
	    (olen < plen - c->mlen)) { /* invalid output buffer size */
    637e:	89 de                	mov    %ebx,%esi
    6380:	2b 75 10             	sub    0x10(%rbp),%esi
		return TC_CRYPTO_FAIL;
    6383:	31 c0                	xor    %eax,%eax
	    (plen >= TC_CCM_PAYLOAD_MAX_BYTES) || /* payload size unsupported */
    6385:	39 fe                	cmp    %edi,%esi
    6387:	0f 87 47 01 00 00    	ja     64d4 <tc_ccm_decryption_verification+0x1da>
	unsigned int i;

	/* DECRYPTION: */

	/* formatting the sequence b for decryption: */
	b[0] = 1; /* q - 1 = 2 - 1 = 1 */
    638d:	c6 44 24 18 01       	movb   $0x1,0x18(%rsp)
	for (i = 1; i < 14; ++i) {
		b[i] = c->nonce[i - 1];
    6392:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
    6396:	31 c0                	xor    %eax,%eax
    6398:	4c 8d 64 24 18       	lea    0x18(%rsp),%r12
    639d:	4c 8d 54 24 19       	lea    0x19(%rsp),%r10
    63a2:	8a 14 01             	mov    (%rcx,%rax,1),%dl
    63a5:	41 88 14 02          	mov    %dl,(%r10,%rax,1)
	for (i = 1; i < 14; ++i) {
    63a9:	48 ff c0             	inc    %rax
    63ac:	48 83 f8 0d          	cmp    $0xd,%rax
    63b0:	75 f0                	jne    63a2 <tc_ccm_decryption_verification+0xa8>
	}
	b[14] = b[15] = TC_ZERO_BYTE; /* initial counter value is 0 */

	/* decrypting payload using ctr mode: */
	ccm_ctr_mode(out, plen - c->mlen, payload, plen - c->mlen, b, c->sched);
    63b2:	4c 8b 4d 00          	mov    0x0(%rbp),%r9
    63b6:	89 f1                	mov    %esi,%ecx
    63b8:	4c 89 da             	mov    %r11,%rdx
    63bb:	4d 89 e0             	mov    %r12,%r8
    63be:	4c 89 ef             	mov    %r13,%rdi
    63c1:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
    63c6:	4c 89 1c 24          	mov    %r11,(%rsp)
	b[14] = b[15] = TC_ZERO_BYTE; /* initial counter value is 0 */
    63ca:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	ccm_ctr_mode(out, plen - c->mlen, payload, plen - c->mlen, b, c->sched);
    63d1:	e8 fb fb ff ff       	callq  5fd1 <ccm_ctr_mode.constprop.0>

	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter value (0) */

	/* encrypting b and restoring the tag from input: */
	(void) tc_aes_encrypt(b, b, c->sched);
    63d6:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    63da:	4c 89 e6             	mov    %r12,%rsi
    63dd:	4c 89 e7             	mov    %r12,%rdi
	b[14] = b[15] = TC_ZERO_BYTE; /* restoring initial counter value (0) */
    63e0:	66 c7 44 24 26 00 00 	movw   $0x0,0x26(%rsp)
	(void) tc_aes_encrypt(b, b, c->sched);
    63e7:	e8 df f6 ff ff       	callq  5acb <tc_aes_encrypt>
	for (i = 0; i < c->mlen; ++i) {
    63ec:	8b 45 10             	mov    0x10(%rbp),%eax
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    63ef:	4c 8b 1c 24          	mov    (%rsp),%r11
    63f3:	41 89 d8             	mov    %ebx,%r8d
	for (i = 0; i < c->mlen; ++i) {
    63f6:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    63fb:	49 29 c0             	sub    %rax,%r8
	for (i = 0; i < c->mlen; ++i) {
    63fe:	48 89 c1             	mov    %rax,%rcx
    6401:	31 c0                	xor    %eax,%eax
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    6403:	4d 01 c3             	add    %r8,%r11
	for (i = 0; i < c->mlen; ++i) {
    6406:	39 c1                	cmp    %eax,%ecx
    6408:	76 11                	jbe    641b <tc_ccm_decryption_verification+0x121>
		tag[i] = *(payload + plen - c->mlen + i) ^ b[i];
    640a:	41 8a 14 03          	mov    (%r11,%rax,1),%dl
    640e:	41 32 14 04          	xor    (%r12,%rax,1),%dl
    6412:	88 54 04 28          	mov    %dl,0x28(%rsp,%rax,1)
	for (i = 0; i < c->mlen; ++i) {
    6416:	48 ff c0             	inc    %rax
    6419:	eb eb                	jmp    6406 <tc_ccm_decryption_verification+0x10c>
	}

	/* VERIFYING THE AUTHENTICATION TAG: */

	/* formatting the sequence b for authentication: */
	b[0] = ((alen > 0) ? 0x40:0)|(((c->mlen - 2) / 2 << 3)) | (1);
    641b:	45 85 ff             	test   %r15d,%r15d
    641e:	0f 95 c0             	setne  %al
    6421:	c1 e0 06             	shl    $0x6,%eax
    6424:	89 c6                	mov    %eax,%esi
    6426:	8d 41 fe             	lea    -0x2(%rcx),%eax
    6429:	d1 e8                	shr    %eax
    642b:	8d 04 c5 00 00 00 00 	lea    0x0(,%rax,8),%eax
    6432:	09 f0                	or     %esi,%eax
	for (i = 1; i < 14; ++i) {
		b[i] = c->nonce[i - 1];
    6434:	48 8b 75 08          	mov    0x8(%rbp),%rsi
	b[0] = ((alen > 0) ? 0x40:0)|(((c->mlen - 2) / 2 << 3)) | (1);
    6438:	83 c8 01             	or     $0x1,%eax
    643b:	88 44 24 18          	mov    %al,0x18(%rsp)
		b[i] = c->nonce[i - 1];
    643f:	31 c0                	xor    %eax,%eax
    6441:	8a 14 06             	mov    (%rsi,%rax,1),%dl
    6444:	41 88 14 02          	mov    %dl,(%r10,%rax,1)
	for (i = 1; i < 14; ++i) {
    6448:	48 ff c0             	inc    %rax
    644b:	48 83 f8 0d          	cmp    $0xd,%rax
    644f:	75 f0                	jne    6441 <tc_ccm_decryption_verification+0x147>
	}
	b[14] = (uint8_t)((plen - c->mlen) >> 8);
    6451:	89 d8                	mov    %ebx,%eax
	b[15] = (uint8_t)(plen - c->mlen);

	/* computing the authentication tag using cbc-mac: */
	(void) tc_aes_encrypt(b, b, c->sched);
    6453:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    6457:	4c 89 e6             	mov    %r12,%rsi
    645a:	4c 89 e7             	mov    %r12,%rdi
	b[14] = (uint8_t)((plen - c->mlen) >> 8);
    645d:	29 c8                	sub    %ecx,%eax
    645f:	88 64 24 26          	mov    %ah,0x26(%rsp)
	b[15] = (uint8_t)(plen - c->mlen);
    6463:	89 d8                	mov    %ebx,%eax
    6465:	29 c8                	sub    %ecx,%eax
    6467:	88 44 24 27          	mov    %al,0x27(%rsp)
	(void) tc_aes_encrypt(b, b, c->sched);
    646b:	e8 5b f6 ff ff       	callq  5acb <tc_aes_encrypt>
	if (alen > 0) {
    6470:	45 85 ff             	test   %r15d,%r15d
    6473:	74 17                	je     648c <tc_ccm_decryption_verification+0x192>
		ccm_cbc_mac(b, associated_data, alen, 1, c->sched);
    6475:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    6479:	b9 01 00 00 00       	mov    $0x1,%ecx
    647e:	44 89 fa             	mov    %r15d,%edx
    6481:	4c 89 f6             	mov    %r14,%rsi
    6484:	4c 89 e7             	mov    %r12,%rdi
    6487:	e8 db fa ff ff       	callq  5f67 <ccm_cbc_mac>
	}
	if (plen > 0) {
    648c:	85 db                	test   %ebx,%ebx
    648e:	74 16                	je     64a6 <tc_ccm_decryption_verification+0x1ac>
		ccm_cbc_mac(b, out, plen - c->mlen, 0, c->sched);
    6490:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    6494:	89 da                	mov    %ebx,%edx
    6496:	31 c9                	xor    %ecx,%ecx
    6498:	2b 55 10             	sub    0x10(%rbp),%edx
    649b:	4c 89 ee             	mov    %r13,%rsi
    649e:	4c 89 e7             	mov    %r12,%rdi
    64a1:	e8 c1 fa ff ff       	callq  5f67 <ccm_cbc_mac>
	}

	/* comparing the received tag and the computed one: */
	if (_compare(b, tag, c->mlen) == 0) {
    64a6:	8b 55 10             	mov    0x10(%rbp),%edx
    64a9:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
    64ae:	4c 89 e7             	mov    %r12,%rdi
    64b1:	e8 d0 ec ff ff       	callq  5186 <_compare>
    64b6:	41 89 c0             	mov    %eax,%r8d
		return TC_CRYPTO_SUCCESS;
    64b9:	b8 01 00 00 00       	mov    $0x1,%eax
	if (_compare(b, tag, c->mlen) == 0) {
    64be:	45 85 c0             	test   %r8d,%r8d
    64c1:	74 11                	je     64d4 <tc_ccm_decryption_verification+0x1da>
  	} else {
		/* erase the decrypted buffer in case of mac validation failure: */
		_set(out, 0, plen - c->mlen);
    64c3:	2b 5d 10             	sub    0x10(%rbp),%ebx
    64c6:	31 f6                	xor    %esi,%esi
    64c8:	4c 89 ef             	mov    %r13,%rdi
    64cb:	89 da                	mov    %ebx,%edx
    64cd:	e8 96 ec ff ff       	callq  5168 <_set>
		return TC_CRYPTO_FAIL;
    64d2:	31 c0                	xor    %eax,%eax
		return TC_CRYPTO_FAIL;
	}
}
    64d4:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    64d9:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    64e0:	00 00 
    64e2:	74 05                	je     64e9 <tc_ccm_decryption_verification+0x1ef>
    64e4:	e8 c7 cf ff ff       	callq  34b0 <__stack_chk_fail@plt>
    64e9:	48 83 c4 48          	add    $0x48,%rsp
    64ed:	5b                   	pop    %rbx
    64ee:	5d                   	pop    %rbp
    64ef:	41 5c                	pop    %r12
    64f1:	41 5d                	pop    %r13
    64f3:	41 5e                	pop    %r14
    64f5:	41 5f                	pop    %r15
    64f7:	c3                   	retq   

00000000000064f8 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
    64f8:	f3 0f 1e fa          	endbr64 
    64fc:	50                   	push   %rax
	sys_trace_idle();
	posix_irq_full_unlock();
    64fd:	e8 74 10 00 00       	callq  7576 <posix_irq_full_unlock>
	posix_halt_cpu();
}
    6502:	5a                   	pop    %rdx
	posix_halt_cpu();
    6503:	e9 42 06 00 00       	jmpq   6b4a <posix_halt_cpu>

0000000000006508 <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
    6508:	f3 0f 1e fa          	endbr64 
	posix_irq_enable(irq);
    650c:	e9 70 10 00 00       	jmpq   7581 <posix_irq_enable>

0000000000006511 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    6511:	85 ff                	test   %edi,%edi
    6513:	74 0e                	je     6523 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    6515:	48 8d 3d 67 43 00 00 	lea    0x4367(%rip),%rdi        # a883 <default_cmd+0x623>
    651c:	31 c0                	xor    %eax,%eax
    651e:	e9 d3 13 00 00       	jmpq   78f6 <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    6523:	c3                   	retq   

0000000000006524 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
    6524:	50                   	push   %rax
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    6525:	48 8d 3d d4 98 00 00 	lea    0x98d4(%rip),%rdi        # fe00 <mtx_threads>
    652c:	e8 6f d0 ff ff       	callq  35a0 <pthread_mutex_unlock@plt>
    6531:	48 8d 35 65 43 00 00 	lea    0x4365(%rip),%rsi        # a89d <default_cmd+0x63d>
    6538:	89 c7                	mov    %eax,%edi
    653a:	e8 d2 ff ff ff       	callq  6511 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    653f:	e8 ac d0 ff ff       	callq  35f0 <pthread_self@plt>
}
    6544:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    6545:	48 89 c7             	mov    %rax,%rdi
    6548:	e9 93 ce ff ff       	jmpq   33e0 <pthread_detach@plt>

000000000000654d <abort_tail>:
{
    654d:	50                   	push   %rax
    654e:	58                   	pop    %rax
	threads_table[this_th_nbr].running = false;
    654f:	48 63 ff             	movslq %edi,%rdi
{
    6552:	50                   	push   %rax
	threads_table[this_th_nbr].running = false;
    6553:	48 c1 e7 05          	shl    $0x5,%rdi
    6557:	48 03 3d 22 a0 00 00 	add    0xa022(%rip),%rdi        # 10580 <threads_table>
    655e:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
	threads_table[this_th_nbr].state = ABORTED;
    6562:	c7 07 03 00 00 00    	movl   $0x3,(%rdi)
	posix_preexit_cleanup();
    6568:	e8 b7 ff ff ff       	callq  6524 <posix_preexit_cleanup>
	pthread_exit(NULL);
    656d:	31 ff                	xor    %edi,%edi
    656f:	e8 3c d0 ff ff       	callq  35b0 <pthread_exit@plt>

0000000000006574 <posix_wait_until_allowed>:
{
    6574:	41 54                	push   %r12
	threads_table[this_th_nbr].running = false;
    6576:	48 8b 05 03 a0 00 00 	mov    0xa003(%rip),%rax        # 10580 <threads_table>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    657d:	4c 8d 25 7c 98 00 00 	lea    0x987c(%rip),%r12        # fe00 <mtx_threads>
{
    6584:	55                   	push   %rbp
    6585:	53                   	push   %rbx
    6586:	48 63 df             	movslq %edi,%rbx
    6589:	48 89 dd             	mov    %rbx,%rbp
	threads_table[this_th_nbr].running = false;
    658c:	48 c1 e3 05          	shl    $0x5,%rbx
    6590:	c6 44 18 04 00       	movb   $0x0,0x4(%rax,%rbx,1)
	while (this_th_nbr != currently_allowed_thread) {
    6595:	39 2d b5 a0 00 00    	cmp    %ebp,0xa0b5(%rip)        # 10650 <currently_allowed_thread>
    659b:	74 28                	je     65c5 <posix_wait_until_allowed+0x51>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    659d:	4c 89 e6             	mov    %r12,%rsi
    65a0:	48 8d 3d 99 98 00 00 	lea    0x9899(%rip),%rdi        # fe40 <cond_threads>
    65a7:	e8 f4 ce ff ff       	callq  34a0 <pthread_cond_wait@plt>
		if (threads_table &&
    65ac:	48 8b 05 cd 9f 00 00 	mov    0x9fcd(%rip),%rax        # 10580 <threads_table>
    65b3:	48 85 c0             	test   %rax,%rax
    65b6:	74 dd                	je     6595 <posix_wait_until_allowed+0x21>
    65b8:	83 3c 18 02          	cmpl   $0x2,(%rax,%rbx,1)
    65bc:	75 d7                	jne    6595 <posix_wait_until_allowed+0x21>
			abort_tail(this_th_nbr);
    65be:	89 ef                	mov    %ebp,%edi
    65c0:	e8 88 ff ff ff       	callq  654d <abort_tail>
	threads_table[this_th_nbr].running = true;
    65c5:	48 8b 05 b4 9f 00 00 	mov    0x9fb4(%rip),%rax        # 10580 <threads_table>
    65cc:	c6 44 18 04 01       	movb   $0x1,0x4(%rax,%rbx,1)
}
    65d1:	5b                   	pop    %rbx
    65d2:	5d                   	pop    %rbp
    65d3:	41 5c                	pop    %r12
    65d5:	c3                   	retq   

00000000000065d6 <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
    65d6:	f3 0f 1e fa          	endbr64 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    65da:	80 3d ae a0 00 00 00 	cmpb   $0x0,0xa0ae(%rip)        # 1068f <terminate>
    65e1:	74 29                	je     660c <posix_cleanup_handler+0x36>
{
    65e3:	50                   	push   %rax
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    65e4:	48 8d 3d 15 98 00 00 	lea    0x9815(%rip),%rdi        # fe00 <mtx_threads>
    65eb:	e8 b0 cf ff ff       	callq  35a0 <pthread_mutex_unlock@plt>
    65f0:	48 8d 35 a6 42 00 00 	lea    0x42a6(%rip),%rsi        # a89d <default_cmd+0x63d>
    65f7:	89 c7                	mov    %eax,%edi
    65f9:	e8 13 ff ff ff       	callq  6511 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    65fe:	e8 ed cf ff ff       	callq  35f0 <pthread_self@plt>
}
    6603:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    6604:	48 89 c7             	mov    %rax,%rdi
    6607:	e9 d4 cd ff ff       	jmpq   33e0 <pthread_detach@plt>
    660c:	c3                   	retq   

000000000000660d <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    660d:	f3 0f 1e fa          	endbr64 
    6611:	50                   	push   %rax
    6612:	58                   	pop    %rax
    6613:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    661a:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    661f:	48 8d 3d da 97 00 00 	lea    0x97da(%rip),%rdi        # fe00 <mtx_threads>
{
    6626:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    662d:	00 00 
    662f:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    6634:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    6636:	e8 75 d0 ff ff       	callq  36b0 <pthread_mutex_lock@plt>
    663b:	48 8d 35 7e 42 00 00 	lea    0x427e(%rip),%rsi        # a8c0 <default_cmd+0x660>
    6642:	89 c7                	mov    %eax,%edi
    6644:	e8 c8 fe ff ff       	callq  6511 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    6649:	48 83 3d 2f 9f 00 00 	cmpq   $0x0,0x9f2f(%rip)        # 10580 <threads_table>
    6650:	00 
    6651:	75 11                	jne    6664 <posix_thread_starter+0x57>
		posix_cleanup_handler(arg);
    6653:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    6658:	e8 79 ff ff ff       	callq  65d6 <posix_cleanup_handler>
		pthread_exit(NULL);
    665d:	31 ff                	xor    %edi,%edi
    665f:	e8 4c cf ff ff       	callq  35b0 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    6664:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    6669:	31 f6                	xor    %esi,%esi
    666b:	e8 10 d0 ff ff       	callq  3680 <__sigsetjmp@plt>
    6670:	f3 0f 1e fa          	endbr64 
    6674:	85 c0                	test   %eax,%eax
    6676:	74 14                	je     668c <posix_thread_starter+0x7f>
    6678:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    667d:	e8 54 ff ff ff       	callq  65d6 <posix_cleanup_handler>
    6682:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    6687:	e8 c4 cf ff ff       	callq  3650 <__pthread_unwind_next@plt>
    668c:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    6691:	e8 ba cd ff ff       	callq  3450 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    6696:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    669a:	e8 d5 fe ff ff       	callq  6574 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    669f:	e8 92 03 00 00       	callq  6a36 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    66a4:	48 63 44 24 08       	movslq 0x8(%rsp),%rax
    66a9:	48 c1 e0 05          	shl    $0x5,%rax
    66ad:	48 03 05 cc 9e 00 00 	add    0x9ecc(%rip),%rax        # 10580 <threads_table>
    66b4:	48 8b 40 18          	mov    0x18(%rax),%rax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    66b8:	48 8b 48 18          	mov    0x18(%rax),%rcx
    66bc:	48 8b 50 10          	mov    0x10(%rax),%rdx
    66c0:	48 8b 70 08          	mov    0x8(%rax),%rsi
    66c4:	48 8b 38             	mov    (%rax),%rdi
    66c7:	e8 1d dc ff ff       	callq  42e9 <z_thread_entry>

00000000000066cc <posix_swap>:
{
    66cc:	f3 0f 1e fa          	endbr64 
    66d0:	55                   	push   %rbp
    66d1:	89 f5                	mov    %esi,%ebp
	currently_allowed_thread = next_allowed_th;
    66d3:	89 3d 77 9f 00 00    	mov    %edi,0x9f77(%rip)        # 10650 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    66d9:	48 8d 3d 60 97 00 00 	lea    0x9760(%rip),%rdi        # fe40 <cond_threads>
    66e0:	e8 2b cd ff ff       	callq  3410 <pthread_cond_broadcast@plt>
    66e5:	48 8d 35 f5 41 00 00 	lea    0x41f5(%rip),%rsi        # a8e1 <default_cmd+0x681>
    66ec:	89 c7                	mov    %eax,%edi
    66ee:	e8 1e fe ff ff       	callq  6511 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    66f3:	48 63 c5             	movslq %ebp,%rax
		abort_tail(this_th_nbr);
    66f6:	89 ef                	mov    %ebp,%edi
	if (threads_table[this_th_nbr].state == ABORTING) {
    66f8:	48 c1 e0 05          	shl    $0x5,%rax
    66fc:	48 03 05 7d 9e 00 00 	add    0x9e7d(%rip),%rax        # 10580 <threads_table>
    6703:	83 38 02             	cmpl   $0x2,(%rax)
    6706:	75 05                	jne    670d <posix_swap+0x41>
		abort_tail(this_th_nbr);
    6708:	e8 40 fe ff ff       	callq  654d <abort_tail>
}
    670d:	5d                   	pop    %rbp
		posix_wait_until_allowed(this_th_nbr);
    670e:	e9 61 fe ff ff       	jmpq   6574 <posix_wait_until_allowed>

0000000000006713 <posix_main_thread_start>:
{
    6713:	f3 0f 1e fa          	endbr64 
    6717:	50                   	push   %rax
	currently_allowed_thread = next_allowed_th;
    6718:	89 3d 32 9f 00 00    	mov    %edi,0x9f32(%rip)        # 10650 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    671e:	48 8d 3d 1b 97 00 00 	lea    0x971b(%rip),%rdi        # fe40 <cond_threads>
    6725:	e8 e6 cc ff ff       	callq  3410 <pthread_cond_broadcast@plt>
    672a:	48 8d 35 b0 41 00 00 	lea    0x41b0(%rip),%rsi        # a8e1 <default_cmd+0x681>
    6731:	89 c7                	mov    %eax,%edi
    6733:	e8 d9 fd ff ff       	callq  6511 <pc_safe_call>
	posix_preexit_cleanup();
    6738:	e8 e7 fd ff ff       	callq  6524 <posix_preexit_cleanup>
	pthread_exit(NULL);
    673d:	31 ff                	xor    %edi,%edi
    673f:	e8 6c ce ff ff       	callq  35b0 <pthread_exit@plt>

0000000000006744 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    6744:	f3 0f 1e fa          	endbr64 
    6748:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    6749:	8b 35 09 9f 00 00    	mov    0x9f09(%rip),%esi        # 10658 <threads_table_size>
{
    674f:	48 89 fb             	mov    %rdi,%rbx
	for (int i = 0; i < threads_table_size; i++) {
    6752:	31 c0                	xor    %eax,%eax
		if ((threads_table[i].state == NOTUSED)
    6754:	48 8b 3d 25 9e 00 00 	mov    0x9e25(%rip),%rdi        # 10580 <threads_table>
    675b:	41 89 c0             	mov    %eax,%r8d
	for (int i = 0; i < threads_table_size; i++) {
    675e:	39 c6                	cmp    %eax,%esi
    6760:	7e 13                	jle    6775 <posix_new_thread+0x31>
		if ((threads_table[i].state == NOTUSED)
    6762:	48 ff c0             	inc    %rax
    6765:	48 89 c2             	mov    %rax,%rdx
    6768:	48 c1 e2 05          	shl    $0x5,%rdx
    676c:	83 7c 17 e0 00       	cmpl   $0x0,-0x20(%rdi,%rdx,1)
    6771:	75 e8                	jne    675b <posix_new_thread+0x17>
    6773:	eb 52                	jmp    67c7 <posix_new_thread+0x83>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
    6775:	83 c6 40             	add    $0x40,%esi
    6778:	48 63 f6             	movslq %esi,%rsi
	threads_table = realloc(threads_table,
    677b:	48 c1 e6 05          	shl    $0x5,%rsi
    677f:	e8 4c ce ff ff       	callq  35d0 <realloc@plt>
    6784:	48 89 05 f5 9d 00 00 	mov    %rax,0x9df5(%rip)        # 10580 <threads_table>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    678b:	48 85 c0             	test   %rax,%rax
    678e:	75 0c                	jne    679c <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    6790:	48 8d 3d 70 41 00 00 	lea    0x4170(%rip),%rdi        # a907 <default_cmd+0x6a7>
    6797:	e8 5a 11 00 00       	callq  78f6 <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
    679c:	48 63 15 b5 9e 00 00 	movslq 0x9eb5(%rip),%rdx        # 10658 <threads_table_size>
    67a3:	31 c0                	xor    %eax,%eax
    67a5:	b9 00 02 00 00       	mov    $0x200,%ecx
    67aa:	49 89 d0             	mov    %rdx,%r8
    67ad:	48 c1 e2 05          	shl    $0x5,%rdx
    67b1:	48 03 15 c8 9d 00 00 	add    0x9dc8(%rip),%rdx        # 10580 <threads_table>
    67b8:	48 89 d7             	mov    %rdx,%rdi
    67bb:	f3 ab                	rep stos %eax,%es:(%rdi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    67bd:	41 8d 40 40          	lea    0x40(%r8),%eax
    67c1:	89 05 91 9e 00 00    	mov    %eax,0x9e91(%rip)        # 10658 <threads_table_size>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
    67c7:	49 63 c8             	movslq %r8d,%rcx
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    67ca:	8b 05 84 9e 00 00    	mov    0x9e84(%rip),%eax        # 10654 <thread_create_count>
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    67d0:	31 f6                	xor    %esi,%esi
	threads_table[t_slot].state = USED;
    67d2:	48 89 cf             	mov    %rcx,%rdi
    67d5:	48 c1 e7 05          	shl    $0x5,%rdi
    67d9:	48 03 3d a0 9d 00 00 	add    0x9da0(%rip),%rdi        # 10580 <threads_table>
	threads_table[t_slot].thead_cnt = thread_create_count++;
    67e0:	8d 50 01             	lea    0x1(%rax),%edx
	threads_table[t_slot].t_status = ptr;
    67e3:	48 89 5f 18          	mov    %rbx,0x18(%rdi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    67e7:	48 83 c7 08          	add    $0x8,%rdi
	threads_table[t_slot].state = USED;
    67eb:	c7 47 f8 01 00 00 00 	movl   $0x1,-0x8(%rdi)
	threads_table[t_slot].running = false;
    67f2:	c6 47 fc 00          	movb   $0x0,-0x4(%rdi)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    67f6:	89 47 08             	mov    %eax,0x8(%rdi)
	ptr->thread_idx = t_slot;
    67f9:	44 89 43 20          	mov    %r8d,0x20(%rbx)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    67fd:	89 15 51 9e 00 00    	mov    %edx,0x9e51(%rip)        # 10654 <thread_create_count>
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    6803:	48 8d 15 03 fe ff ff 	lea    -0x1fd(%rip),%rdx        # 660d <posix_thread_starter>
    680a:	e8 b1 cb ff ff       	callq  33c0 <pthread_create@plt>
    680f:	48 8d 35 19 41 00 00 	lea    0x4119(%rip),%rsi        # a92f <default_cmd+0x6cf>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    6816:	5b                   	pop    %rbx
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    6817:	89 c7                	mov    %eax,%edi
    6819:	e9 f3 fc ff ff       	jmpq   6511 <pc_safe_call>

000000000000681e <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    681e:	f3 0f 1e fa          	endbr64 
    6822:	52                   	push   %rdx
	thread_create_count = 0;

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    6823:	be 20 00 00 00       	mov    $0x20,%esi
    6828:	bf 40 00 00 00       	mov    $0x40,%edi
	thread_create_count = 0;
    682d:	c7 05 1d 9e 00 00 00 	movl   $0x0,0x9e1d(%rip)        # 10654 <thread_create_count>
    6834:	00 00 00 
	currently_allowed_thread = -1;
    6837:	c7 05 0f 9e 00 00 ff 	movl   $0xffffffff,0x9e0f(%rip)        # 10650 <currently_allowed_thread>
    683e:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    6841:	e8 ea cc ff ff       	callq  3530 <calloc@plt>
    6846:	48 89 05 33 9d 00 00 	mov    %rax,0x9d33(%rip)        # 10580 <threads_table>
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    684d:	48 85 c0             	test   %rax,%rax
    6850:	75 0c                	jne    685e <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    6852:	48 8d 3d ae 40 00 00 	lea    0x40ae(%rip),%rdi        # a907 <default_cmd+0x6a7>
    6859:	e8 98 10 00 00       	callq  78f6 <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    685e:	48 8d 3d 9b 95 00 00 	lea    0x959b(%rip),%rdi        # fe00 <mtx_threads>
	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    6865:	c7 05 e9 9d 00 00 40 	movl   $0x40,0x9de9(%rip)        # 10658 <threads_table_size>
    686c:	00 00 00 
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    686f:	e8 3c ce ff ff       	callq  36b0 <pthread_mutex_lock@plt>
    6874:	48 8d 35 45 40 00 00 	lea    0x4045(%rip),%rsi        # a8c0 <default_cmd+0x660>
    687b:	89 c7                	mov    %eax,%edi
}
    687d:	58                   	pop    %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    687e:	e9 8e fc ff ff       	jmpq   6511 <pc_safe_call>

0000000000006883 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
    6883:	f3 0f 1e fa          	endbr64 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    6887:	48 83 3d f1 9c 00 00 	cmpq   $0x0,0x9cf1(%rip)        # 10580 <threads_table>
    688e:	00 
    688f:	74 62                	je     68f3 <posix_core_clean_up+0x70>
{
    6891:	55                   	push   %rbp
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
    6892:	48 8d 2d fa 40 00 00 	lea    0x40fa(%rip),%rbp        # a993 <default_cmd+0x733>
{
    6899:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    689a:	31 db                	xor    %ebx,%ebx
{
    689c:	52                   	push   %rdx
	terminate = true;
    689d:	c6 05 eb 9d 00 00 01 	movb   $0x1,0x9deb(%rip)        # 1068f <terminate>
	for (int i = 0; i < threads_table_size; i++) {
    68a4:	39 1d ae 9d 00 00    	cmp    %ebx,0x9dae(%rip)        # 10658 <threads_table_size>
    68aa:	48 8b 3d cf 9c 00 00 	mov    0x9ccf(%rip),%rdi        # 10580 <threads_table>
    68b1:	7e 2c                	jle    68df <posix_core_clean_up+0x5c>
		if (threads_table[i].state != USED) {
    68b3:	48 63 c3             	movslq %ebx,%rax
    68b6:	48 c1 e0 05          	shl    $0x5,%rax
    68ba:	48 01 c7             	add    %rax,%rdi
    68bd:	83 3f 01             	cmpl   $0x1,(%rdi)
    68c0:	75 19                	jne    68db <posix_core_clean_up+0x58>
		if (pthread_cancel(threads_table[i].thread)) {
    68c2:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
    68c6:	e8 55 cb ff ff       	callq  3420 <pthread_cancel@plt>
    68cb:	85 c0                	test   %eax,%eax
    68cd:	74 0c                	je     68db <posix_core_clean_up+0x58>
			posix_print_warning(
    68cf:	89 de                	mov    %ebx,%esi
    68d1:	48 89 ef             	mov    %rbp,%rdi
    68d4:	31 c0                	xor    %eax,%eax
    68d6:	e8 f4 10 00 00       	callq  79cf <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
    68db:	ff c3                	inc    %ebx
    68dd:	eb c5                	jmp    68a4 <posix_core_clean_up+0x21>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    68df:	e8 cc ca ff ff       	callq  33b0 <free@plt>
	threads_table = NULL;
    68e4:	48 c7 05 91 9c 00 00 	movq   $0x0,0x9c91(%rip)        # 10580 <threads_table>
    68eb:	00 00 00 00 
}
    68ef:	58                   	pop    %rax
    68f0:	5b                   	pop    %rbx
    68f1:	5d                   	pop    %rbp
    68f2:	c3                   	retq   
    68f3:	c3                   	retq   

00000000000068f4 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
    68f4:	f3 0f 1e fa          	endbr64 
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    68f8:	48 63 ff             	movslq %edi,%rdi
    68fb:	48 c1 e7 05          	shl    $0x5,%rdi
    68ff:	48 03 3d 7a 9c 00 00 	add    0x9c7a(%rip),%rdi        # 10580 <threads_table>
    6906:	83 3f 01             	cmpl   $0x1,(%rdi)
    6909:	75 06                	jne    6911 <posix_abort_thread+0x1d>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    690b:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    6911:	c3                   	retq   

0000000000006912 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
    6912:	f3 0f 1e fa          	endbr64 
    6916:	41 55                	push   %r13
    6918:	41 54                	push   %r12
    691a:	55                   	push   %rbp
    691b:	48 89 fd             	mov    %rdi,%rbp
    691e:	53                   	push   %rbx
    691f:	52                   	push   %rdx
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    6920:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    6924:	44 8b 6b 20          	mov    0x20(%rbx),%r13d
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    6928:	e8 32 0c 00 00       	callq  755f <posix_irq_lock>
    692d:	41 89 c4             	mov    %eax,%r12d

	key = irq_lock();

	if (_current == thread) {
    6930:	48 8d 05 c9 9b 00 00 	lea    0x9bc9(%rip),%rax        # 10500 <_kernel>
    6937:	48 39 68 10          	cmp    %rbp,0x10(%rax)
    693b:	75 34                	jne    6971 <z_impl_k_thread_abort+0x5f>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    693d:	83 7b 24 00          	cmpl   $0x0,0x24(%rbx)
    6941:	75 09                	jne    694c <z_impl_k_thread_abort+0x3a>
			tstatus->aborted = 1;
    6943:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
    694a:	eb 11                	jmp    695d <z_impl_k_thread_abort+0x4b>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    694c:	44 89 ee             	mov    %r13d,%esi
    694f:	48 8d 3d 71 40 00 00 	lea    0x4071(%rip),%rdi        # a9c7 <default_cmd+0x767>
    6956:	31 c0                	xor    %eax,%eax
    6958:	e8 72 10 00 00       	callq  79cf <posix_print_warning>
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    695d:	49 63 c5             	movslq %r13d,%rax
    6960:	48 c1 e0 05          	shl    $0x5,%rax
    6964:	48 03 05 15 9c 00 00 	add    0x9c15(%rip),%rax        # 10580 <threads_table>
    696b:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
    6971:	48 89 ef             	mov    %rbp,%rdi
    6974:	e8 99 2f 00 00       	callq  9912 <z_thread_abort>

	if (tstatus->aborted == 0) {
    6979:	83 7b 24 00          	cmpl   $0x0,0x24(%rbx)
    697d:	75 0f                	jne    698e <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
    697f:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
		posix_abort_thread(thread_idx);
    6986:	44 89 ef             	mov    %r13d,%edi
    6989:	e8 66 ff ff ff       	callq  68f4 <posix_abort_thread>
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
}
    698e:	58                   	pop    %rax
	z_reschedule_irqlock(key);
    698f:	44 89 e7             	mov    %r12d,%edi
}
    6992:	5b                   	pop    %rbx
    6993:	5d                   	pop    %rbp
    6994:	41 5c                	pop    %r12
    6996:	41 5d                	pop    %r13
	z_reschedule_irqlock(key);
    6998:	e9 2f 28 00 00       	jmpq   91cc <z_reschedule_irqlock>

000000000000699d <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <power/power.h>

int arch_swap(unsigned int key)
{
    699d:	f3 0f 1e fa          	endbr64 
    69a1:	53                   	push   %rbx
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
    69a2:	48 8d 1d 57 9b 00 00 	lea    0x9b57(%rip),%rbx        # 10500 <_kernel>
    69a9:	48 8b 43 10          	mov    0x10(%rbx),%rax
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    69ad:	48 8b 53 38          	mov    0x38(%rbx),%rdx
	_current->callee_saved.key = key;
    69b1:	89 78 48             	mov    %edi,0x48(%rax)
	posix_thread_status_t *ready_thread_ptr =
    69b4:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
	_current->callee_saved.retval = -EAGAIN;
    69b8:	c7 40 4c f5 ff ff ff 	movl   $0xfffffff5,0x4c(%rax)

	posix_thread_status_t *this_thread_ptr  =
    69bf:	48 8b 40 50          	mov    0x50(%rax),%rax
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
    69c3:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    69c7:	8b 79 20             	mov    0x20(%rcx),%edi
    69ca:	8b 70 20             	mov    0x20(%rax),%esi
    69cd:	e8 fa fc ff ff       	callq  66cc <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
    69d2:	48 8b 43 10          	mov    0x10(%rbx),%rax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    69d6:	8b 78 48             	mov    0x48(%rax),%edi
    69d9:	e8 8f 0b 00 00       	callq  756d <posix_irq_unlock>

	return _current->callee_saved.retval;
    69de:	48 8b 43 10          	mov    0x10(%rbx),%rax
}
    69e2:	5b                   	pop    %rbx
	return _current->callee_saved.retval;
    69e3:	8b 40 4c             	mov    0x4c(%rax),%eax
}
    69e6:	c3                   	retq   

00000000000069e7 <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    69e7:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    69eb:	48 8d 05 0e 9b 00 00 	lea    0x9b0e(%rip),%rax        # 10500 <_kernel>
    69f2:	48 8b 50 38          	mov    0x38(%rax),%rdx
	posix_thread_status_t *ready_thread_ptr =
    69f6:	48 8b 4a 50          	mov    0x50(%rdx),%rcx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
    69fa:	48 89 50 10          	mov    %rdx,0x10(%rax)

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    69fe:	8b 79 20             	mov    0x20(%rcx),%edi
    6a01:	e9 0d fd ff ff       	jmpq   6713 <posix_main_thread_start>

0000000000006a06 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    6a06:	f3 0f 1e fa          	endbr64 

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
    6a0a:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
{
    6a0f:	49 89 fa             	mov    %rdi,%r10
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
    6a12:	48 8d 7a d8          	lea    -0x28(%rdx),%rdi
	thread_status->entry_point = entry;
    6a16:	48 89 4a d8          	mov    %rcx,-0x28(%rdx)
	thread_status->arg1 = p1;
    6a1a:	4c 89 42 e0          	mov    %r8,-0x20(%rdx)
	thread_status->arg2 = p2;
    6a1e:	4c 89 4a e8          	mov    %r9,-0x18(%rdx)
	thread_status->arg3 = p3;
    6a22:	48 89 42 f0          	mov    %rax,-0x10(%rdx)
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
    6a26:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%rdx)
#endif

	thread->callee_saved.thread_status = thread_status;
    6a2d:	49 89 7a 50          	mov    %rdi,0x50(%r10)

	posix_new_thread(thread_status);
    6a31:	e9 0e fd ff ff       	jmpq   6744 <posix_new_thread>

0000000000006a36 <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
    6a36:	f3 0f 1e fa          	endbr64 
	posix_irq_full_unlock();
    6a3a:	e9 37 0b 00 00       	jmpq   7576 <posix_irq_full_unlock>

0000000000006a3f <pc_safe_call>:
	if (unlikely(test)) {
    6a3f:	85 ff                	test   %edi,%edi
    6a41:	74 0e                	je     6a51 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    6a43:	48 8d 3d 39 3e 00 00 	lea    0x3e39(%rip),%rdi        # a883 <default_cmd+0x623>
    6a4a:	31 c0                	xor    %eax,%eax
    6a4c:	e9 a5 0e 00 00       	jmpq   78f6 <posix_print_error_and_exit>
}
    6a51:	c3                   	retq   

0000000000006a52 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
    6a52:	f3 0f 1e fa          	endbr64 
    6a56:	50                   	push   %rax
    6a57:	58                   	pop    %rax
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6a58:	48 8d 3d 21 94 00 00 	lea    0x9421(%rip),%rdi        # fe80 <mtx_cpu>
{
    6a5f:	50                   	push   %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6a60:	e8 4b cc ff ff       	callq  36b0 <pthread_mutex_lock@plt>
    6a65:	48 8d 35 d7 3f 00 00 	lea    0x3fd7(%rip),%rsi        # aa43 <default_cmd+0x7e3>
    6a6c:	89 c7                	mov    %eax,%edi
    6a6e:	e8 cc ff ff ff       	callq  6a3f <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6a73:	48 8d 3d 06 94 00 00 	lea    0x9406(%rip),%rdi        # fe80 <mtx_cpu>
    6a7a:	e8 21 cb ff ff       	callq  35a0 <pthread_mutex_unlock@plt>
    6a7f:	48 8d 35 da 3f 00 00 	lea    0x3fda(%rip),%rsi        # aa60 <default_cmd+0x800>
    6a86:	89 c7                	mov    %eax,%edi
    6a88:	e8 b2 ff ff ff       	callq  6a3f <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    6a8d:	e8 8c fd ff ff       	callq  681e <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    6a92:	e8 13 23 00 00       	callq  8daa <z_cstart>

0000000000006a97 <posix_is_cpu_running>:
{
    6a97:	f3 0f 1e fa          	endbr64 
	return !cpu_halted;
    6a9b:	8a 05 db 69 00 00    	mov    0x69db(%rip),%al        # d47c <cpu_halted>
    6aa1:	83 f0 01             	xor    $0x1,%eax
    6aa4:	0f b6 c0             	movzbl %al,%eax
}
    6aa7:	c3                   	retq   

0000000000006aa8 <posix_change_cpu_state_and_wait>:
{
    6aa8:	f3 0f 1e fa          	endbr64 
    6aac:	55                   	push   %rbp
    6aad:	89 fd                	mov    %edi,%ebp
    6aaf:	53                   	push   %rbx
    6ab0:	89 fb                	mov    %edi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6ab2:	48 8d 3d c7 93 00 00 	lea    0x93c7(%rip),%rdi        # fe80 <mtx_cpu>
{
    6ab9:	52                   	push   %rdx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6aba:	e8 f1 cb ff ff       	callq  36b0 <pthread_mutex_lock@plt>
    6abf:	48 8d 35 7d 3f 00 00 	lea    0x3f7d(%rip),%rsi        # aa43 <default_cmd+0x7e3>
    6ac6:	89 c7                	mov    %eax,%edi
    6ac8:	e8 72 ff ff ff       	callq  6a3f <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    6acd:	48 8d 3d ec 93 00 00 	lea    0x93ec(%rip),%rdi        # fec0 <cond_cpu>
	cpu_halted = halted;
    6ad4:	88 1d a2 69 00 00    	mov    %bl,0x69a2(%rip)        # d47c <cpu_halted>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    6ada:	48 8d 1d 9f 93 00 00 	lea    0x939f(%rip),%rbx        # fe80 <mtx_cpu>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    6ae1:	e8 2a c9 ff ff       	callq  3410 <pthread_cond_broadcast@plt>
    6ae6:	48 8d 35 92 3f 00 00 	lea    0x3f92(%rip),%rsi        # aa7f <default_cmd+0x81f>
    6aed:	89 c7                	mov    %eax,%edi
    6aef:	e8 4b ff ff ff       	callq  6a3f <pc_safe_call>
	while (cpu_halted == halted) {
    6af4:	40 38 2d 81 69 00 00 	cmp    %bpl,0x6981(%rip)        # d47c <cpu_halted>
    6afb:	75 11                	jne    6b0e <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    6afd:	48 89 de             	mov    %rbx,%rsi
    6b00:	48 8d 3d b9 93 00 00 	lea    0x93b9(%rip),%rdi        # fec0 <cond_cpu>
    6b07:	e8 94 c9 ff ff       	callq  34a0 <pthread_cond_wait@plt>
    6b0c:	eb e6                	jmp    6af4 <posix_change_cpu_state_and_wait+0x4c>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6b0e:	48 8d 3d 6b 93 00 00 	lea    0x936b(%rip),%rdi        # fe80 <mtx_cpu>
    6b15:	e8 86 ca ff ff       	callq  35a0 <pthread_mutex_unlock@plt>
    6b1a:	48 8d 35 3f 3f 00 00 	lea    0x3f3f(%rip),%rsi        # aa60 <default_cmd+0x800>
    6b21:	89 c7                	mov    %eax,%edi
}
    6b23:	58                   	pop    %rax
    6b24:	5b                   	pop    %rbx
    6b25:	5d                   	pop    %rbp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6b26:	e9 14 ff ff ff       	jmpq   6a3f <pc_safe_call>

0000000000006b2b <posix_interrupt_raised>:
{
    6b2b:	f3 0f 1e fa          	endbr64 
    6b2f:	51                   	push   %rcx
	posix_change_cpu_state_and_wait(false);
    6b30:	31 ff                	xor    %edi,%edi
    6b32:	e8 71 ff ff ff       	callq  6aa8 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
    6b37:	80 3d 52 9b 00 00 00 	cmpb   $0x0,0x9b52(%rip)        # 10690 <soc_terminate>
    6b3e:	74 08                	je     6b48 <posix_interrupt_raised+0x1d>
		posix_exit(0);
    6b40:	31 ff                	xor    %edi,%edi
}
    6b42:	5a                   	pop    %rdx
		posix_exit(0);
    6b43:	e9 b2 0c 00 00       	jmpq   77fa <posix_exit>
}
    6b48:	58                   	pop    %rax
    6b49:	c3                   	retq   

0000000000006b4a <posix_halt_cpu>:
{
    6b4a:	f3 0f 1e fa          	endbr64 
    6b4e:	50                   	push   %rax
	posix_change_cpu_state_and_wait(true);
    6b4f:	bf 01 00 00 00       	mov    $0x1,%edi
    6b54:	e8 4f ff ff ff       	callq  6aa8 <posix_change_cpu_state_and_wait>
}
    6b59:	5a                   	pop    %rdx
	posix_irq_handler();
    6b5a:	e9 c6 08 00 00       	jmpq   7425 <posix_irq_handler>

0000000000006b5f <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    6b5f:	f3 0f 1e fa          	endbr64 
    6b63:	53                   	push   %rbx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6b64:	48 8d 3d 15 93 00 00 	lea    0x9315(%rip),%rdi        # fe80 <mtx_cpu>
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    6b6b:	48 8d 1d 0e 93 00 00 	lea    0x930e(%rip),%rbx        # fe80 <mtx_cpu>
{
    6b72:	48 83 ec 10          	sub    $0x10,%rsp
    6b76:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6b7d:	00 00 
    6b7f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    6b84:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6b86:	e8 25 cb ff ff       	callq  36b0 <pthread_mutex_lock@plt>
    6b8b:	48 8d 35 b1 3e 00 00 	lea    0x3eb1(%rip),%rsi        # aa43 <default_cmd+0x7e3>
    6b92:	89 c7                	mov    %eax,%edi
    6b94:	e8 a6 fe ff ff       	callq  6a3f <pc_safe_call>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    6b99:	48 89 e7             	mov    %rsp,%rdi
    6b9c:	31 c9                	xor    %ecx,%ecx
    6b9e:	31 f6                	xor    %esi,%esi
    6ba0:	48 8d 15 ab fe ff ff 	lea    -0x155(%rip),%rdx        # 6a52 <zephyr_wrapper>
	cpu_halted = false;
    6ba7:	c6 05 ce 68 00 00 00 	movb   $0x0,0x68ce(%rip)        # d47c <cpu_halted>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    6bae:	e8 0d c8 ff ff       	callq  33c0 <pthread_create@plt>
    6bb3:	48 8d 35 e7 3e 00 00 	lea    0x3ee7(%rip),%rsi        # aaa1 <default_cmd+0x841>
    6bba:	89 c7                	mov    %eax,%edi
    6bbc:	e8 7e fe ff ff       	callq  6a3f <pc_safe_call>
	while (cpu_halted == false) {
    6bc1:	80 3d b4 68 00 00 00 	cmpb   $0x0,0x68b4(%rip)        # d47c <cpu_halted>
    6bc8:	75 11                	jne    6bdb <posix_boot_cpu+0x7c>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    6bca:	48 89 de             	mov    %rbx,%rsi
    6bcd:	48 8d 3d ec 92 00 00 	lea    0x92ec(%rip),%rdi        # fec0 <cond_cpu>
    6bd4:	e8 c7 c8 ff ff       	callq  34a0 <pthread_cond_wait@plt>
    6bd9:	eb e6                	jmp    6bc1 <posix_boot_cpu+0x62>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6bdb:	48 8d 3d 9e 92 00 00 	lea    0x929e(%rip),%rdi        # fe80 <mtx_cpu>
    6be2:	e8 b9 c9 ff ff       	callq  35a0 <pthread_mutex_unlock@plt>
    6be7:	48 8d 35 72 3e 00 00 	lea    0x3e72(%rip),%rsi        # aa60 <default_cmd+0x800>
    6bee:	89 c7                	mov    %eax,%edi
    6bf0:	e8 4a fe ff ff       	callq  6a3f <pc_safe_call>

	if (soc_terminate) {
    6bf5:	80 3d 94 9a 00 00 00 	cmpb   $0x0,0x9a94(%rip)        # 10690 <soc_terminate>
    6bfc:	74 07                	je     6c05 <posix_boot_cpu+0xa6>
		posix_exit(0);
    6bfe:	31 ff                	xor    %edi,%edi
    6c00:	e8 f5 0b 00 00       	callq  77fa <posix_exit>
	}
}
    6c05:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    6c0a:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    6c11:	00 00 
    6c13:	74 05                	je     6c1a <posix_boot_cpu+0xbb>
    6c15:	e8 96 c8 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    6c1a:	48 83 c4 10          	add    $0x10,%rsp
    6c1e:	5b                   	pop    %rbx
    6c1f:	c3                   	retq   

0000000000006c20 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
    6c20:	f3 0f 1e fa          	endbr64 
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    6c24:	48 8d 05 35 5f 00 00 	lea    0x5f35(%rip),%rax        # cb60 <native_pre_tasks.6323>
    6c2b:	48 63 d7             	movslq %edi,%rdx
{
    6c2e:	41 54                	push   %r12
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    6c30:	ff c7                	inc    %edi
{
    6c32:	55                   	push   %rbp
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    6c33:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    6c37:	49 89 c4             	mov    %rax,%r12
{
    6c3a:	53                   	push   %rbx
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    6c3b:	48 63 df             	movslq %edi,%rbx
    6c3e:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    6c42:	76 11                	jbe    6c55 <run_native_tasks+0x35>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    6c44:	48 8b 45 00          	mov    0x0(%rbp),%rax
    6c48:	48 85 c0             	test   %rax,%rax
    6c4b:	74 02                	je     6c4f <run_native_tasks+0x2f>
			(*fptr)();
    6c4d:	ff d0                	callq  *%rax
		fptr++) {
    6c4f:	48 83 c5 08          	add    $0x8,%rbp
    6c53:	eb e9                	jmp    6c3e <run_native_tasks+0x1e>
		}
	}
}
    6c55:	5b                   	pop    %rbx
    6c56:	5d                   	pop    %rbp
    6c57:	41 5c                	pop    %r12
    6c59:	c3                   	retq   

0000000000006c5a <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    6c5a:	f3 0f 1e fa          	endbr64 
    6c5e:	51                   	push   %rcx
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    6c5f:	80 3d 16 68 00 00 00 	cmpb   $0x0,0x6816(%rip)        # d47c <cpu_halted>
    6c66:	74 10                	je     6c78 <posix_soc_clean_up+0x1e>

		posix_core_clean_up();
    6c68:	e8 16 fc ff ff       	callq  6883 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    6c6d:	bf 04 00 00 00       	mov    $0x4,%edi
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    6c72:	5a                   	pop    %rdx
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    6c73:	e9 a8 ff ff ff       	jmpq   6c20 <run_native_tasks>
	} else if (soc_terminate == false) {
    6c78:	80 3d 11 9a 00 00 00 	cmpb   $0x0,0x9a11(%rip)        # 10690 <soc_terminate>
    6c7f:	75 68                	jne    6ce9 <posix_soc_clean_up+0x8f>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6c81:	48 8d 3d f8 91 00 00 	lea    0x91f8(%rip),%rdi        # fe80 <mtx_cpu>
		soc_terminate = true;
    6c88:	c6 05 01 9a 00 00 01 	movb   $0x1,0x9a01(%rip)        # 10690 <soc_terminate>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    6c8f:	e8 1c ca ff ff       	callq  36b0 <pthread_mutex_lock@plt>
    6c94:	48 8d 35 a8 3d 00 00 	lea    0x3da8(%rip),%rsi        # aa43 <default_cmd+0x7e3>
    6c9b:	89 c7                	mov    %eax,%edi
    6c9d:	e8 9d fd ff ff       	callq  6a3f <pc_safe_call>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    6ca2:	48 8d 3d 17 92 00 00 	lea    0x9217(%rip),%rdi        # fec0 <cond_cpu>
		cpu_halted = true;
    6ca9:	c6 05 cc 67 00 00 01 	movb   $0x1,0x67cc(%rip)        # d47c <cpu_halted>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    6cb0:	e8 5b c7 ff ff       	callq  3410 <pthread_cond_broadcast@plt>
    6cb5:	48 8d 35 c3 3d 00 00 	lea    0x3dc3(%rip),%rsi        # aa7f <default_cmd+0x81f>
    6cbc:	89 c7                	mov    %eax,%edi
    6cbe:	e8 7c fd ff ff       	callq  6a3f <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6cc3:	48 8d 3d b6 91 00 00 	lea    0x91b6(%rip),%rdi        # fe80 <mtx_cpu>
    6cca:	e8 d1 c8 ff ff       	callq  35a0 <pthread_mutex_unlock@plt>
    6ccf:	48 8d 35 8a 3d 00 00 	lea    0x3d8a(%rip),%rsi        # aa60 <default_cmd+0x800>
    6cd6:	89 c7                	mov    %eax,%edi
    6cd8:	e8 62 fd ff ff       	callq  6a3f <pc_safe_call>
			sleep(1);
    6cdd:	bf 01 00 00 00       	mov    $0x1,%edi
    6ce2:	e8 b9 c9 ff ff       	callq  36a0 <sleep@plt>
		while (1) {
    6ce7:	eb f4                	jmp    6cdd <posix_soc_clean_up+0x83>
}
    6ce9:	58                   	pop    %rax
    6cea:	c3                   	retq   

0000000000006ceb <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
    6ceb:	f3 0f 1e fa          	endbr64 
	signaled_end = 1;
    6cef:	c7 05 63 99 00 00 01 	movl   $0x1,0x9963(%rip)        # 1065c <signaled_end>
    6cf6:	00 00 00 
}
    6cf9:	c3                   	retq   

0000000000006cfa <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    6cfa:	f3 0f 1e fa          	endbr64 
    6cfe:	55                   	push   %rbp
    6cff:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    6d06:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6d0d:	00 00 
    6d0f:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    6d16:	00 
    6d17:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
    6d19:	48 8d 05 cb ff ff ff 	lea    -0x35(%rip),%rax        # 6ceb <hwm_signal_end_handler>
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    6d20:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
	act.sa_handler = hwm_signal_end_handler;
    6d25:	48 89 04 24          	mov    %rax,(%rsp)
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    6d29:	e8 52 c8 ff ff       	callq  3580 <sigemptyset@plt>
	if (unlikely(test)) {
    6d2e:	85 c0                	test   %eax,%eax
    6d30:	74 15                	je     6d47 <hwm_set_sig_handler+0x4d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    6d32:	48 8d 35 a3 3d 00 00 	lea    0x3da3(%rip),%rsi        # aadc <default_cmd+0x87c>
    6d39:	48 8d 3d 43 3b 00 00 	lea    0x3b43(%rip),%rdi        # a883 <default_cmd+0x623>
    6d40:	31 c0                	xor    %eax,%eax
    6d42:	e8 af 0b 00 00       	callq  78f6 <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    6d47:	48 89 e5             	mov    %rsp,%rbp
    6d4a:	31 d2                	xor    %edx,%edx
    6d4c:	bf 0f 00 00 00       	mov    $0xf,%edi
	act.sa_flags = SA_RESETHAND;
    6d51:	c7 84 24 88 00 00 00 	movl   $0x80000000,0x88(%rsp)
    6d58:	00 00 00 80 
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    6d5c:	48 89 ee             	mov    %rbp,%rsi
    6d5f:	e8 dc c6 ff ff       	callq  3440 <sigaction@plt>
	if (unlikely(test)) {
    6d64:	85 c0                	test   %eax,%eax
    6d66:	74 15                	je     6d7d <hwm_set_sig_handler+0x83>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    6d68:	48 8d 35 87 3d 00 00 	lea    0x3d87(%rip),%rsi        # aaf6 <default_cmd+0x896>
    6d6f:	48 8d 3d 0d 3b 00 00 	lea    0x3b0d(%rip),%rdi        # a883 <default_cmd+0x623>
    6d76:	31 c0                	xor    %eax,%eax
    6d78:	e8 79 0b 00 00       	callq  78f6 <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    6d7d:	31 d2                	xor    %edx,%edx
    6d7f:	48 89 ee             	mov    %rbp,%rsi
    6d82:	bf 02 00 00 00       	mov    $0x2,%edi
    6d87:	e8 b4 c6 ff ff       	callq  3440 <sigaction@plt>
	if (unlikely(test)) {
    6d8c:	85 c0                	test   %eax,%eax
    6d8e:	74 15                	je     6da5 <hwm_set_sig_handler+0xab>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    6d90:	48 8d 35 7e 3d 00 00 	lea    0x3d7e(%rip),%rsi        # ab15 <default_cmd+0x8b5>
    6d97:	48 8d 3d e5 3a 00 00 	lea    0x3ae5(%rip),%rdi        # a883 <default_cmd+0x623>
    6d9e:	31 c0                	xor    %eax,%eax
    6da0:	e8 51 0b 00 00       	callq  78f6 <posix_print_error_and_exit>
}
    6da5:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
    6dac:	00 
    6dad:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    6db4:	00 00 
    6db6:	74 05                	je     6dbd <hwm_set_sig_handler+0xc3>
    6db8:	e8 f3 c6 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    6dbd:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    6dc4:	5d                   	pop    %rbp
    6dc5:	c3                   	retq   

0000000000006dc6 <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
    6dc6:	f3 0f 1e fa          	endbr64 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
    6dca:	48 8d 05 ff 97 00 00 	lea    0x97ff(%rip),%rax        # 105d0 <hw_timer_timer>
	next_timer_index = 0;
    6dd1:	c7 05 95 66 00 00 00 	movl   $0x0,0x6695(%rip)        # d470 <next_timer_index>
    6dd8:	00 00 00 
	next_timer_time  = *Timer_list[0];
    6ddb:	48 8b 10             	mov    (%rax),%rdx

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    6dde:	48 8d 05 7b 66 00 00 	lea    0x667b(%rip),%rax        # d460 <irq_ctrl_timer>
    6de5:	48 8b 00             	mov    (%rax),%rax
	next_timer_time  = *Timer_list[0];
    6de8:	48 89 15 99 97 00 00 	mov    %rdx,0x9799(%rip)        # 10588 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    6def:	48 39 c2             	cmp    %rax,%rdx
    6df2:	76 11                	jbe    6e05 <hwm_find_next_timer+0x3f>
			next_timer_index = i;
    6df4:	c7 05 72 66 00 00 01 	movl   $0x1,0x6672(%rip)        # d470 <next_timer_index>
    6dfb:	00 00 00 
			next_timer_time = *Timer_list[i];
    6dfe:	48 89 05 83 97 00 00 	mov    %rax,0x9783(%rip)        # 10588 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    6e05:	48 8d 05 14 98 00 00 	lea    0x9814(%rip),%rax        # 10620 <hw_counter_timer>
    6e0c:	48 8b 00             	mov    (%rax),%rax
    6e0f:	48 3b 05 72 97 00 00 	cmp    0x9772(%rip),%rax        # 10588 <next_timer_time>
    6e16:	73 11                	jae    6e29 <hwm_find_next_timer+0x63>
			next_timer_index = i;
    6e18:	c7 05 4e 66 00 00 02 	movl   $0x2,0x664e(%rip)        # d470 <next_timer_index>
    6e1f:	00 00 00 
			next_timer_time = *Timer_list[i];
    6e22:	48 89 05 5f 97 00 00 	mov    %rax,0x975f(%rip)        # 10588 <next_timer_time>
		}
	}
}
    6e29:	c3                   	retq   

0000000000006e2a <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    6e2a:	f3 0f 1e fa          	endbr64 
    6e2e:	48 83 ec 18          	sub    $0x18,%rsp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    6e32:	48 8b 35 4f 97 00 00 	mov    0x974f(%rip),%rsi        # 10588 <next_timer_time>
    6e39:	48 8b 15 50 97 00 00 	mov    0x9750(%rip),%rdx        # 10590 <simu_time>
    6e40:	48 39 d6             	cmp    %rdx,%rsi
    6e43:	72 09                	jb     6e4e <hwm_main_loop+0x24>
		simu_time = next_timer_time;
    6e45:	48 89 35 44 97 00 00 	mov    %rsi,0x9744(%rip)        # 10590 <simu_time>
    6e4c:	eb 14                	jmp    6e62 <hwm_main_loop+0x38>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    6e4e:	8b 0d 1c 66 00 00    	mov    0x661c(%rip),%ecx        # d470 <next_timer_index>
    6e54:	48 8d 3d d8 3c 00 00 	lea    0x3cd8(%rip),%rdi        # ab33 <default_cmd+0x8d3>
    6e5b:	31 c0                	xor    %eax,%eax
    6e5d:	e8 6d 0b 00 00       	callq  79cf <posix_print_warning>
	if (signaled_end || (simu_time > end_of_time)) {
    6e62:	8b 15 f4 97 00 00    	mov    0x97f4(%rip),%edx        # 1065c <signaled_end>
    6e68:	48 8b 05 21 97 00 00 	mov    0x9721(%rip),%rax        # 10590 <simu_time>
    6e6f:	85 d2                	test   %edx,%edx
    6e71:	75 09                	jne    6e7c <hwm_main_loop+0x52>
    6e73:	48 39 05 d6 65 00 00 	cmp    %rax,0x65d6(%rip)        # d450 <end_of_time>
    6e7a:	73 36                	jae    6eb2 <hwm_main_loop+0x88>
				((long double)simu_time)/1.0e6);
    6e7c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    6e81:	df 6c 24 08          	fildll 0x8(%rsp)
    6e85:	48 85 c0             	test   %rax,%rax
    6e88:	79 06                	jns    6e90 <hwm_main_loop+0x66>
    6e8a:	d8 05 30 35 00 00    	fadds  0x3530(%rip)        # a3c0 <default_cmd+0x160>
		posix_print_trace("\nStopped at %.3Lfs\n",
    6e90:	d8 35 2e 35 00 00    	fdivs  0x352e(%rip)        # a3c4 <default_cmd+0x164>
    6e96:	50                   	push   %rax
    6e97:	48 8d 3d ca 3c 00 00 	lea    0x3cca(%rip),%rdi        # ab68 <default_cmd+0x908>
    6e9e:	50                   	push   %rax
    6e9f:	31 c0                	xor    %eax,%eax
    6ea1:	db 3c 24             	fstpt  (%rsp)
    6ea4:	e8 f5 0b 00 00       	callq  7a9e <posix_print_trace>
    6ea9:	5a                   	pop    %rdx
		posix_exit(0);
    6eaa:	31 ff                	xor    %edi,%edi
		posix_print_trace("\nStopped at %.3Lfs\n",
    6eac:	59                   	pop    %rcx
		posix_exit(0);
    6ead:	e8 48 09 00 00       	callq  77fa <posix_exit>
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    6eb2:	8b 05 b8 65 00 00    	mov    0x65b8(%rip),%eax        # d470 <next_timer_index>
    6eb8:	83 f8 01             	cmp    $0x1,%eax
    6ebb:	74 10                	je     6ecd <hwm_main_loop+0xa3>
    6ebd:	83 f8 02             	cmp    $0x2,%eax
    6ec0:	74 12                	je     6ed4 <hwm_main_loop+0xaa>
    6ec2:	85 c0                	test   %eax,%eax
    6ec4:	75 15                	jne    6edb <hwm_main_loop+0xb1>
		case HWTIMER:
			hwtimer_timer_reached();
    6ec6:	e8 02 03 00 00       	callq  71cd <hwtimer_timer_reached>
			break;
    6ecb:	eb 1c                	jmp    6ee9 <hwm_main_loop+0xbf>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
    6ecd:	e8 11 09 00 00       	callq  77e3 <hw_irq_ctrl_timer_triggered>
			break;
    6ed2:	eb 15                	jmp    6ee9 <hwm_main_loop+0xbf>
		case HW_COUNTER:
			hw_counter_triggered();
    6ed4:	e8 29 16 00 00       	callq  8502 <hw_counter_triggered>
			break;
    6ed9:	eb 0e                	jmp    6ee9 <hwm_main_loop+0xbf>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    6edb:	48 8d 3d 9a 3c 00 00 	lea    0x3c9a(%rip),%rdi        # ab7c <default_cmd+0x91c>
    6ee2:	31 c0                	xor    %eax,%eax
    6ee4:	e8 0d 0a 00 00       	callq  78f6 <posix_print_error_and_exit>
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    6ee9:	e8 d8 fe ff ff       	callq  6dc6 <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    6eee:	e9 3f ff ff ff       	jmpq   6e32 <hwm_main_loop+0x8>

0000000000006ef3 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
    6ef3:	f3 0f 1e fa          	endbr64 
	end_of_time = new_end_of_time;
    6ef7:	48 89 3d 52 65 00 00 	mov    %rdi,0x6552(%rip)        # d450 <end_of_time>
}
    6efe:	c3                   	retq   

0000000000006eff <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
    6eff:	f3 0f 1e fa          	endbr64 
	return simu_time;
}
    6f03:	48 8b 05 86 96 00 00 	mov    0x9686(%rip),%rax        # 10590 <simu_time>
    6f0a:	c3                   	retq   

0000000000006f0b <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    6f0b:	f3 0f 1e fa          	endbr64 
    6f0f:	50                   	push   %rax
	hwm_set_sig_handler();
    6f10:	e8 e5 fd ff ff       	callq  6cfa <hwm_set_sig_handler>
	hwtimer_init();
    6f15:	e8 7e 01 00 00       	callq  7098 <hwtimer_init>
	hw_counter_init();
    6f1a:	e8 a8 15 00 00       	callq  84c7 <hw_counter_init>
	hw_irq_ctrl_init();
    6f1f:	e8 f3 06 00 00       	callq  7617 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    6f24:	5a                   	pop    %rdx
	hwm_find_next_timer();
    6f25:	e9 9c fe ff ff       	jmpq   6dc6 <hwm_find_next_timer>

0000000000006f2a <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    6f2a:	f3 0f 1e fa          	endbr64 
    6f2e:	50                   	push   %rax
	hwtimer_cleanup();
    6f2f:	e8 67 02 00 00       	callq  719b <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    6f34:	5a                   	pop    %rdx
	hw_irq_ctrl_cleanup();
    6f35:	e9 1c 07 00 00       	jmpq   7656 <hw_irq_ctrl_cleanup>

0000000000006f3a <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    6f3a:	48 8d 15 7f 96 00 00 	lea    0x967f(%rip),%rdx        # 105c0 <hw_timer_awake_timer>
    6f41:	48 8d 05 80 96 00 00 	lea    0x9680(%rip),%rax        # 105c8 <hw_timer_tick_timer>
    6f48:	48 8b 00             	mov    (%rax),%rax
    6f4b:	48 39 02             	cmp    %rax,(%rdx)
    6f4e:	48 0f 46 02          	cmovbe (%rdx),%rax
    6f52:	48 8d 15 77 96 00 00 	lea    0x9677(%rip),%rdx        # 105d0 <hw_timer_timer>
    6f59:	48 89 02             	mov    %rax,(%rdx)
}
    6f5c:	c3                   	retq   

0000000000006f5d <native_add_time_options>:
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}

static void native_add_time_options(void)
{
    6f5d:	f3 0f 1e fa          	endbr64 
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    6f61:	48 8d 3d 98 60 00 00 	lea    0x6098(%rip),%rdi        # d000 <timer_options.3187>
    6f68:	e9 e8 13 00 00       	jmpq   8355 <native_add_command_line_opts>

0000000000006f6d <cmd_stop_at_found>:
{
    6f6d:	f3 0f 1e fa          	endbr64 
	if (args.stop_at < 0) {
    6f71:	0f 57 c0             	xorps  %xmm0,%xmm0
{
    6f74:	52                   	push   %rdx
	if (args.stop_at < 0) {
    6f75:	66 0f 2f 05 83 8f 00 	comisd 0x8f83(%rip),%xmm0        # ff00 <args>
    6f7c:	00 
    6f7d:	76 11                	jbe    6f90 <cmd_stop_at_found+0x23>
    6f7f:	48 89 fe             	mov    %rdi,%rsi
		posix_print_error_and_exit("Error: stop-at must be positive "
    6f82:	31 c0                	xor    %eax,%eax
    6f84:	48 8d 3d 0d 3c 00 00 	lea    0x3c0d(%rip),%rdi        # ab98 <default_cmd+0x938>
    6f8b:	e8 66 09 00 00       	callq  78f6 <posix_print_error_and_exit>
	hwm_set_end_of_time(args.stop_at*1e6);
    6f90:	f2 0f 10 05 e0 32 00 	movsd  0x32e0(%rip),%xmm0        # a278 <default_cmd+0x18>
    6f97:	00 
    6f98:	f2 0f 59 05 60 8f 00 	mulsd  0x8f60(%rip),%xmm0        # ff00 <args>
    6f9f:	00 
    6fa0:	f2 0f 10 0d d8 32 00 	movsd  0x32d8(%rip),%xmm1        # a280 <default_cmd+0x20>
    6fa7:	00 
    6fa8:	66 0f 2f c1          	comisd %xmm1,%xmm0
    6fac:	73 07                	jae    6fb5 <cmd_stop_at_found+0x48>
    6fae:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    6fb3:	eb 0e                	jmp    6fc3 <cmd_stop_at_found+0x56>
    6fb5:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    6fb9:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    6fbe:	48 0f ba ff 3f       	btc    $0x3f,%rdi
}
    6fc3:	58                   	pop    %rax
	hwm_set_end_of_time(args.stop_at*1e6);
    6fc4:	e9 2a ff ff ff       	jmpq   6ef3 <hwm_set_end_of_time>

0000000000006fc9 <hwtimer_set_real_time_mode>:
{
    6fc9:	f3 0f 1e fa          	endbr64 
	real_time_mode = new_rt;
    6fcd:	40 88 3d a9 64 00 00 	mov    %dil,0x64a9(%rip)        # d47d <real_time_mode>
}
    6fd4:	c3                   	retq   

0000000000006fd5 <cmd_no_realtime_found>:
{
    6fd5:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(false);
    6fd9:	31 ff                	xor    %edi,%edi
    6fdb:	e9 e9 ff ff ff       	jmpq   6fc9 <hwtimer_set_real_time_mode>

0000000000006fe0 <cmd_realtime_found>:
{
    6fe0:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(true);
    6fe4:	bf 01 00 00 00       	mov    $0x1,%edi
    6fe9:	e9 db ff ff ff       	jmpq   6fc9 <hwtimer_set_real_time_mode>

0000000000006fee <get_host_us_time>:
{
    6fee:	f3 0f 1e fa          	endbr64 
    6ff2:	48 83 ec 28          	sub    $0x28,%rsp
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    6ff6:	bf 04 00 00 00       	mov    $0x4,%edi
{
    6ffb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7002:	00 00 
    7004:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    7009:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    700b:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    7010:	e8 6b c4 ff ff       	callq  3480 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    7015:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    701a:	48 85 d2             	test   %rdx,%rdx
    701d:	78 07                	js     7026 <get_host_us_time+0x38>
    701f:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    7024:	eb 15                	jmp    703b <get_host_us_time+0x4d>
    7026:	48 89 d0             	mov    %rdx,%rax
    7029:	83 e2 01             	and    $0x1,%edx
    702c:	48 d1 e8             	shr    %rax
    702f:	48 09 d0             	or     %rdx,%rax
    7032:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    7037:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    703b:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    7040:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    7045:	f2 0f 59 05 2b 32 00 	mulsd  0x322b(%rip),%xmm0        # a278 <default_cmd+0x18>
    704c:	00 
    704d:	48 99                	cqto   
    704f:	48 f7 f9             	idiv   %rcx
    7052:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    7057:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    705b:	f2 0f 10 0d 1d 32 00 	movsd  0x321d(%rip),%xmm1        # a280 <default_cmd+0x20>
    7062:	00 
    7063:	66 0f 2f c1          	comisd %xmm1,%xmm0
    7067:	73 07                	jae    7070 <get_host_us_time+0x82>
    7069:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    706e:	eb 0e                	jmp    707e <get_host_us_time+0x90>
    7070:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    7074:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    7079:	48 0f ba f8 3f       	btc    $0x3f,%rax
}
    707e:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    7083:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    708a:	00 00 
    708c:	74 05                	je     7093 <get_host_us_time+0xa5>
    708e:	e8 1d c4 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    7093:	48 83 c4 28          	add    $0x28,%rsp
    7097:	c3                   	retq   

0000000000007098 <hwtimer_init>:
{
    7098:	f3 0f 1e fa          	endbr64 
    709c:	48 83 ec 28          	sub    $0x28,%rsp
    70a0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    70a7:	00 00 
    70a9:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    70ae:	31 c0                	xor    %eax,%eax
	hw_timer_tick_timer = NEVER;
    70b0:	48 8d 05 11 95 00 00 	lea    0x9511(%rip),%rax        # 105c8 <hw_timer_tick_timer>
	silent_ticks = 0;
    70b7:	48 c7 05 ee 94 00 00 	movq   $0x0,0x94ee(%rip)        # 105b0 <silent_ticks>
    70be:	00 00 00 00 
	hw_timer_tick_timer = NEVER;
    70c2:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hw_timer_awake_timer = NEVER;
    70c9:	48 8d 05 f0 94 00 00 	lea    0x94f0(%rip),%rax        # 105c0 <hw_timer_awake_timer>
    70d0:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    70d7:	e8 5e fe ff ff       	callq  6f3a <hwtimer_update_timer>
	if (real_time_mode) {
    70dc:	80 3d 9a 63 00 00 00 	cmpb   $0x0,0x639a(%rip)        # d47d <real_time_mode>
    70e3:	74 17                	je     70fc <hwtimer_init+0x64>
		boot_time = get_host_us_time();
    70e5:	e8 04 ff ff ff       	callq  6fee <get_host_us_time>
		last_radj_stime = 0U;
    70ea:	48 c7 05 a3 94 00 00 	movq   $0x0,0x94a3(%rip)        # 10598 <last_radj_stime>
    70f1:	00 00 00 00 
		last_radj_rtime = boot_time;
    70f5:	48 89 05 a4 94 00 00 	mov    %rax,0x94a4(%rip)        # 105a0 <last_radj_rtime>
	if (!reset_rtc) {
    70fc:	80 3d 8e 95 00 00 00 	cmpb   $0x0,0x958e(%rip)        # 10691 <reset_rtc>
    7103:	75 7c                	jne    7181 <hwtimer_init+0xe9>
		clock_gettime(CLOCK_REALTIME, &tv);
    7105:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    710a:	31 ff                	xor    %edi,%edi
    710c:	e8 6f c3 ff ff       	callq  3480 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    7111:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    7116:	48 85 d2             	test   %rdx,%rdx
    7119:	78 07                	js     7122 <hwtimer_init+0x8a>
    711b:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    7120:	eb 15                	jmp    7137 <hwtimer_init+0x9f>
    7122:	48 89 d0             	mov    %rdx,%rax
    7125:	83 e2 01             	and    $0x1,%edx
    7128:	48 d1 e8             	shr    %rax
    712b:	48 09 d0             	or     %rdx,%rax
    712e:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    7133:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    7137:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    713c:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    7141:	f2 0f 59 05 2f 31 00 	mulsd  0x312f(%rip),%xmm0        # a278 <default_cmd+0x18>
    7148:	00 
    7149:	48 99                	cqto   
    714b:	48 f7 f9             	idiv   %rcx
    714e:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    7153:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    7157:	f2 0f 10 0d 21 31 00 	movsd  0x3121(%rip),%xmm1        # a280 <default_cmd+0x20>
    715e:	00 
    715f:	66 0f 2f c1          	comisd %xmm1,%xmm0
    7163:	73 07                	jae    716c <hwtimer_init+0xd4>
    7165:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    716a:	eb 0e                	jmp    717a <hwtimer_init+0xe2>
    716c:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    7170:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    7175:	48 0f ba f8 3f       	btc    $0x3f,%rax
		rtc_offset += realhosttime;
    717a:	48 01 05 27 94 00 00 	add    %rax,0x9427(%rip)        # 105a8 <rtc_offset>
}
    7181:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    7186:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    718d:	00 00 
    718f:	74 05                	je     7196 <hwtimer_init+0xfe>
    7191:	e8 1a c3 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    7196:	48 83 c4 28          	add    $0x28,%rsp
    719a:	c3                   	retq   

000000000000719b <hwtimer_cleanup>:
{
    719b:	f3 0f 1e fa          	endbr64 
}
    719f:	c3                   	retq   

00000000000071a0 <hwtimer_enable>:
{
    71a0:	f3 0f 1e fa          	endbr64 
    71a4:	50                   	push   %rax
	tick_p = period;
    71a5:	48 89 3d 0c 94 00 00 	mov    %rdi,0x940c(%rip)        # 105b8 <tick_p>
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    71ac:	e8 4e fd ff ff       	callq  6eff <hwm_get_time>
    71b1:	48 8d 15 10 94 00 00 	lea    0x9410(%rip),%rdx        # 105c8 <hw_timer_tick_timer>
    71b8:	48 03 05 f9 93 00 00 	add    0x93f9(%rip),%rax        # 105b8 <tick_p>
    71bf:	48 89 02             	mov    %rax,(%rdx)
	hwtimer_update_timer();
    71c2:	e8 73 fd ff ff       	callq  6f3a <hwtimer_update_timer>
}
    71c7:	5a                   	pop    %rdx
	hwm_find_next_timer();
    71c8:	e9 f9 fb ff ff       	jmpq   6dc6 <hwm_find_next_timer>

00000000000071cd <hwtimer_timer_reached>:
{
    71cd:	f3 0f 1e fa          	endbr64 
    71d1:	55                   	push   %rbp
    71d2:	53                   	push   %rbx
    71d3:	48 83 ec 38          	sub    $0x38,%rsp
    71d7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    71de:	00 00 
    71e0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    71e5:	31 c0                	xor    %eax,%eax
	uint64_t Now = hw_timer_timer;
    71e7:	48 8d 05 e2 93 00 00 	lea    0x93e2(%rip),%rax        # 105d0 <hw_timer_timer>
    71ee:	48 8b 18             	mov    (%rax),%rbx
	if (hw_timer_awake_timer == Now) {
    71f1:	48 8d 05 c8 93 00 00 	lea    0x93c8(%rip),%rax        # 105c0 <hw_timer_awake_timer>
    71f8:	48 39 18             	cmp    %rbx,(%rax)
    71fb:	75 16                	jne    7213 <hwtimer_timer_reached+0x46>
	hw_timer_awake_timer = NEVER;
    71fd:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    7204:	e8 31 fd ff ff       	callq  6f3a <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    7209:	bf ff ff 00 00       	mov    $0xffff,%edi
    720e:	e8 5a 05 00 00       	callq  776d <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
    7213:	48 8d 2d ae 93 00 00 	lea    0x93ae(%rip),%rbp        # 105c8 <hw_timer_tick_timer>
    721a:	48 39 5d 00          	cmp    %rbx,0x0(%rbp)
    721e:	0f 85 12 01 00 00    	jne    7336 <hwtimer_timer_reached+0x169>
	if (real_time_mode) {
    7224:	80 3d 52 62 00 00 00 	cmpb   $0x0,0x6252(%rip)        # d47d <real_time_mode>
    722b:	0f 84 d6 00 00 00    	je     7307 <hwtimer_timer_reached+0x13a>
				    / clock_ratio
    7231:	48 2b 1d 60 93 00 00 	sub    0x9360(%rip),%rbx        # 10598 <last_radj_stime>
    7238:	78 07                	js     7241 <hwtimer_timer_reached+0x74>
    723a:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    723f:	eb 15                	jmp    7256 <hwtimer_timer_reached+0x89>
    7241:	48 89 d8             	mov    %rbx,%rax
    7244:	83 e3 01             	and    $0x1,%ebx
    7247:	48 d1 e8             	shr    %rax
    724a:	48 09 d8             	or     %rbx,%rax
    724d:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    7252:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
				    + last_radj_rtime;
    7256:	48 8b 15 43 93 00 00 	mov    0x9343(%rip),%rdx        # 105a0 <last_radj_rtime>
				    / clock_ratio
    725d:	f2 0f 5e 05 f3 61 00 	divsd  0x61f3(%rip),%xmm0        # d458 <clock_ratio>
    7264:	00 
				    + last_radj_rtime;
    7265:	48 85 d2             	test   %rdx,%rdx
    7268:	78 07                	js     7271 <hwtimer_timer_reached+0xa4>
    726a:	f2 48 0f 2a ca       	cvtsi2sd %rdx,%xmm1
    726f:	eb 15                	jmp    7286 <hwtimer_timer_reached+0xb9>
    7271:	48 89 d0             	mov    %rdx,%rax
    7274:	83 e2 01             	and    $0x1,%edx
    7277:	48 d1 e8             	shr    %rax
    727a:	48 09 d0             	or     %rdx,%rax
    727d:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    7282:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
    7286:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    728a:	f2 0f 10 0d ee 2f 00 	movsd  0x2fee(%rip),%xmm1        # a280 <default_cmd+0x20>
    7291:	00 
    7292:	66 0f 2f c1          	comisd %xmm1,%xmm0
    7296:	73 07                	jae    729f <hwtimer_timer_reached+0xd2>
    7298:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    729d:	eb 0e                	jmp    72ad <hwtimer_timer_reached+0xe0>
    729f:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    72a3:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    72a8:	48 0f ba fb 3f       	btc    $0x3f,%rbx
		uint64_t real_time = get_host_us_time();
    72ad:	e8 3c fd ff ff       	callq  6fee <get_host_us_time>
		int64_t diff = expected_rt - real_time;
    72b2:	48 29 c3             	sub    %rax,%rbx
		if (diff > 0) { /* we need to slow down */
    72b5:	48 85 db             	test   %rbx,%rbx
    72b8:	7e 4d                	jle    7307 <hwtimer_timer_reached+0x13a>
			requested_time.tv_sec  = diff / 1e6;
    72ba:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    72bf:	f2 0f 10 1d b1 2f 00 	movsd  0x2fb1(%rip),%xmm3        # a278 <default_cmd+0x18>
    72c6:	00 
			(void) nanosleep(&requested_time, &remaining);
    72c7:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    72cc:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
			requested_time.tv_sec  = diff / 1e6;
    72d1:	66 0f 28 d0          	movapd %xmm0,%xmm2
    72d5:	f2 0f 5e d3          	divsd  %xmm3,%xmm2
    72d9:	f2 48 0f 2c c2       	cvttsd2si %xmm2,%rax
						 requested_time.tv_sec*1e6)*1e3;
    72de:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
			requested_time.tv_sec  = diff / 1e6;
    72e3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
						 requested_time.tv_sec*1e6)*1e3;
    72e8:	f2 0f 59 cb          	mulsd  %xmm3,%xmm1
			requested_time.tv_nsec = (diff -
    72ec:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
						 requested_time.tv_sec*1e6)*1e3;
    72f0:	f2 0f 59 05 90 2f 00 	mulsd  0x2f90(%rip),%xmm0        # a288 <default_cmd+0x28>
    72f7:	00 
			requested_time.tv_nsec = (diff -
    72f8:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    72fd:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			(void) nanosleep(&requested_time, &remaining);
    7302:	e8 d9 c1 ff ff       	callq  34e0 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
    7307:	48 8b 05 aa 92 00 00 	mov    0x92aa(%rip),%rax        # 105b8 <tick_p>
    730e:	48 01 45 00          	add    %rax,0x0(%rbp)
	hwtimer_update_timer();
    7312:	e8 23 fc ff ff       	callq  6f3a <hwtimer_update_timer>
	if (silent_ticks > 0) {
    7317:	48 8b 05 92 92 00 00 	mov    0x9292(%rip),%rax        # 105b0 <silent_ticks>
    731e:	48 85 c0             	test   %rax,%rax
    7321:	7e 0c                	jle    732f <hwtimer_timer_reached+0x162>
		silent_ticks -= 1;
    7323:	48 ff c8             	dec    %rax
    7326:	48 89 05 83 92 00 00 	mov    %rax,0x9283(%rip)        # 105b0 <silent_ticks>
    732d:	eb 07                	jmp    7336 <hwtimer_timer_reached+0x169>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    732f:	31 ff                	xor    %edi,%edi
    7331:	e8 37 04 00 00       	callq  776d <hw_irq_ctrl_set_irq>
}
    7336:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    733b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7342:	00 00 
    7344:	74 05                	je     734b <hwtimer_timer_reached+0x17e>
    7346:	e8 65 c1 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    734b:	48 83 c4 38          	add    $0x38,%rsp
    734f:	5b                   	pop    %rbx
    7350:	5d                   	pop    %rbp
    7351:	c3                   	retq   

0000000000007352 <hwtimer_set_silent_ticks>:
{
    7352:	f3 0f 1e fa          	endbr64 
	silent_ticks = sys_ticks;
    7356:	48 89 3d 53 92 00 00 	mov    %rdi,0x9253(%rip)        # 105b0 <silent_ticks>
}
    735d:	c3                   	retq   

000000000000735e <hwtimer_reset_rtc>:
{
    735e:	f3 0f 1e fa          	endbr64 
	reset_rtc = true;
    7362:	c6 05 28 93 00 00 01 	movb   $0x1,0x9328(%rip)        # 10691 <reset_rtc>
}
    7369:	c3                   	retq   

000000000000736a <cmd_rtcreset_found>:
{
    736a:	f3 0f 1e fa          	endbr64 
	hwtimer_reset_rtc();
    736e:	e9 eb ff ff ff       	jmpq   735e <hwtimer_reset_rtc>

0000000000007373 <hwtimer_set_rtc_offset>:
{
    7373:	f3 0f 1e fa          	endbr64 
	rtc_offset = offset;
    7377:	48 89 3d 2a 92 00 00 	mov    %rdi,0x922a(%rip)        # 105a8 <rtc_offset>
}
    737e:	c3                   	retq   

000000000000737f <cmd_rtcoffset_found>:
{
    737f:	f3 0f 1e fa          	endbr64 
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    7383:	f2 0f 10 05 ed 2e 00 	movsd  0x2eed(%rip),%xmm0        # a278 <default_cmd+0x18>
    738a:	00 
    738b:	f2 0f 59 05 75 8b 00 	mulsd  0x8b75(%rip),%xmm0        # ff08 <args+0x8>
    7392:	00 
    7393:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    7398:	e9 d6 ff ff ff       	jmpq   7373 <hwtimer_set_rtc_offset>

000000000000739d <hwtimer_set_rt_ratio>:
{
    739d:	f3 0f 1e fa          	endbr64 
	clock_ratio = ratio;
    73a1:	f2 0f 11 05 af 60 00 	movsd  %xmm0,0x60af(%rip)        # d458 <clock_ratio>
    73a8:	00 
}
    73a9:	c3                   	retq   

00000000000073aa <cmd_rt_ratio_found>:
{
    73aa:	f3 0f 1e fa          	endbr64 
	if ((args.rt_ratio <= 0)) {
    73ae:	0f 57 c0             	xorps  %xmm0,%xmm0
    73b1:	66 0f 2f 05 5f 8b 00 	comisd 0x8b5f(%rip),%xmm0        # ff18 <args+0x18>
    73b8:	00 
    73b9:	72 1a                	jb     73d5 <cmd_rt_ratio_found+0x2b>
{
    73bb:	50                   	push   %rax
		posix_print_error_and_exit("The ratio needs to be > 0. "
    73bc:	48 8d 3d fb 37 00 00 	lea    0x37fb(%rip),%rdi        # abbe <default_cmd+0x95e>
    73c3:	31 c0                	xor    %eax,%eax
    73c5:	e8 2c 05 00 00       	callq  78f6 <posix_print_error_and_exit>
	hwtimer_set_rt_ratio(args.rt_ratio);
    73ca:	f2 0f 10 05 46 8b 00 	movsd  0x8b46(%rip),%xmm0        # ff18 <args+0x18>
    73d1:	00 
}
    73d2:	5a                   	pop    %rdx
    73d3:	eb 08                	jmp    73dd <cmd_rt_ratio_found+0x33>
	hwtimer_set_rt_ratio(args.rt_ratio);
    73d5:	f2 0f 10 05 3b 8b 00 	movsd  0x8b3b(%rip),%xmm0        # ff18 <args+0x18>
    73dc:	00 
    73dd:	e9 bb ff ff ff       	jmpq   739d <hwtimer_set_rt_ratio>

00000000000073e2 <cmd_rt_drift_found>:
{
    73e2:	f3 0f 1e fa          	endbr64 
    73e6:	52                   	push   %rdx
	if (!(args.rt_drift > -1)) {
    73e7:	f2 0f 10 05 21 8b 00 	movsd  0x8b21(%rip),%xmm0        # ff10 <args+0x10>
    73ee:	00 
    73ef:	66 0f 2f 05 99 2e 00 	comisd 0x2e99(%rip),%xmm0        # a290 <default_cmd+0x30>
    73f6:	00 
    73f7:	77 0e                	ja     7407 <cmd_rt_drift_found+0x25>
		posix_print_error_and_exit("The drift needs to be > -1. "
    73f9:	48 8d 3d fa 37 00 00 	lea    0x37fa(%rip),%rdi        # abfa <default_cmd+0x99a>
    7400:	31 c0                	xor    %eax,%eax
    7402:	e8 ef 04 00 00       	callq  78f6 <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
    7407:	f2 0f 10 05 89 2e 00 	movsd  0x2e89(%rip),%xmm0        # a298 <default_cmd+0x38>
    740e:	00 
    740f:	f2 0f 58 05 f9 8a 00 	addsd  0x8af9(%rip),%xmm0        # ff10 <args+0x10>
    7416:	00 
    7417:	f2 0f 11 05 f9 8a 00 	movsd  %xmm0,0x8af9(%rip)        # ff18 <args+0x18>
    741e:	00 
}
    741f:	58                   	pop    %rax
	hwtimer_set_rt_ratio(args.rt_ratio);
    7420:	e9 78 ff ff ff       	jmpq   739d <hwtimer_set_rt_ratio>

0000000000007425 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    7425:	f3 0f 1e fa          	endbr64 
    7429:	41 56                	push   %r14
    742b:	41 55                	push   %r13
    742d:	41 54                	push   %r12
    742f:	55                   	push   %rbp
    7430:	53                   	push   %rbx
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    7431:	e8 5e 02 00 00       	callq  7694 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    7436:	85 c0                	test   %eax,%eax
    7438:	0f 85 e6 00 00 00    	jne    7524 <posix_irq_handler+0xff>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
    743e:	48 8d 1d bb 90 00 00 	lea    0x90bb(%rip),%rbx        # 10500 <_kernel>
    7445:	8b 03                	mov    (%rbx),%eax
    7447:	85 c0                	test   %eax,%eax
    7449:	75 0a                	jne    7455 <posix_irq_handler+0x30>
		may_swap = 0;
    744b:	c7 05 0b 92 00 00 00 	movl   $0x0,0x920b(%rip)        # 10660 <may_swap.5208>
    7452:	00 00 00 
	}

	_kernel.cpus[0].nested++;
    7455:	ff c0                	inc    %eax
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    7457:	4c 8d 2d c2 8a 00 00 	lea    0x8ac2(%rip),%r13        # ff20 <irq_vector_table>
	_kernel.cpus[0].nested++;
    745e:	89 03                	mov    %eax,(%rbx)

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    7460:	e8 7a 02 00 00       	callq  76df <hw_irq_ctrl_get_highest_prio_irq>
    7465:	89 c5                	mov    %eax,%ebp
    7467:	83 f8 ff             	cmp    $0xffffffff,%eax
    746a:	0f 84 84 00 00 00    	je     74f4 <posix_irq_handler+0xcf>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    7470:	e8 f1 01 00 00       	callq  7666 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    7475:	89 ef                	mov    %ebp,%edi
		int last_running_irq = currently_running_irq;
    7477:	44 8b 35 f6 5f 00 00 	mov    0x5ff6(%rip),%r14d        # d474 <currently_running_irq>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    747e:	41 89 c4             	mov    %eax,%r12d
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    7481:	e8 fd 01 00 00       	callq  7683 <hw_irq_ctrl_get_prio>
    7486:	0f b6 f8             	movzbl %al,%edi
    7489:	e8 cd 01 00 00       	callq  765b <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    748e:	89 ef                	mov    %ebp,%edi
    7490:	e8 b9 02 00 00       	callq  774e <hw_irq_ctrl_clear_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    7495:	48 63 c5             	movslq %ebp,%rax

		currently_running_irq = irq_nbr;
    7498:	89 2d d6 5f 00 00    	mov    %ebp,0x5fd6(%rip)        # d474 <currently_running_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    749e:	48 6b c0 18          	imul   $0x18,%rax,%rax
    74a2:	4c 01 e8             	add    %r13,%rax
    74a5:	48 8b 50 08          	mov    0x8(%rax),%rdx
    74a9:	48 85 d2             	test   %rdx,%rdx
    74ac:	75 12                	jne    74c0 <posix_irq_handler+0x9b>
		posix_print_error_and_exit("Received irq %i without a "
    74ae:	89 ee                	mov    %ebp,%esi
    74b0:	48 8d 3d 59 3b 00 00 	lea    0x3b59(%rip),%rdi        # b010 <default_cmd+0xdb0>
    74b7:	31 c0                	xor    %eax,%eax
    74b9:	e8 38 04 00 00       	callq  78f6 <posix_print_error_and_exit>
    74be:	eb 20                	jmp    74e0 <posix_irq_handler+0xbb>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    74c0:	f6 40 04 01          	testb  $0x1,0x4(%rax)
    74c4:	74 0a                	je     74d0 <posix_irq_handler+0xab>
			*may_swap |= ((direct_irq_f_ptr)
    74c6:	ff d2                	callq  *%rdx
    74c8:	09 05 92 91 00 00    	or     %eax,0x9192(%rip)        # 10660 <may_swap.5208>
    74ce:	eb 10                	jmp    74e0 <posix_irq_handler+0xbb>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    74d0:	48 8b 78 10          	mov    0x10(%rax),%rdi
    74d4:	ff d2                	callq  *%rdx
			*may_swap = 1;
    74d6:	c7 05 80 91 00 00 01 	movl   $0x1,0x9180(%rip)        # 10660 <may_swap.5208>
    74dd:	00 00 00 
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    74e0:	44 89 e7             	mov    %r12d,%edi
		currently_running_irq = last_running_irq;
    74e3:	44 89 35 8a 5f 00 00 	mov    %r14d,0x5f8a(%rip)        # d474 <currently_running_irq>
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    74ea:	e8 6c 01 00 00       	callq  765b <hw_irq_ctrl_set_cur_prio>
    74ef:	e9 6c ff ff ff       	jmpq   7460 <posix_irq_handler+0x3b>
	}

	_kernel.cpus[0].nested--;
    74f4:	ff 0b                	decl   (%rbx)
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    74f6:	83 3d 63 91 00 00 00 	cmpl   $0x0,0x9163(%rip)        # 10660 <may_swap.5208>
    74fd:	74 25                	je     7524 <posix_irq_handler+0xff>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    74ff:	e8 62 01 00 00       	callq  7666 <hw_irq_ctrl_get_cur_prio>
    7504:	3d 00 01 00 00       	cmp    $0x100,%eax
    7509:	75 19                	jne    7524 <posix_irq_handler+0xff>
		&& (_kernel.ready_q.cache != _current)) {
    750b:	48 8b 43 10          	mov    0x10(%rbx),%rax
    750f:	48 39 43 38          	cmp    %rax,0x38(%rbx)
    7513:	74 0f                	je     7524 <posix_irq_handler+0xff>

		(void)z_swap_irqlock(irq_lock);
	}
}
    7515:	5b                   	pop    %rbx

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
    7516:	31 ff                	xor    %edi,%edi
    7518:	5d                   	pop    %rbp
    7519:	41 5c                	pop    %r12
    751b:	41 5d                	pop    %r13
    751d:	41 5e                	pop    %r14
    751f:	e9 79 f4 ff ff       	jmpq   699d <arch_swap>
    7524:	5b                   	pop    %rbx
    7525:	5d                   	pop    %rbp
    7526:	41 5c                	pop    %r12
    7528:	41 5d                	pop    %r13
    752a:	41 5e                	pop    %r14
    752c:	c3                   	retq   

000000000000752d <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    752d:	f3 0f 1e fa          	endbr64 
    7531:	51                   	push   %rcx
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    7532:	e8 a8 01 00 00       	callq  76df <hw_irq_ctrl_get_highest_prio_irq>
    7537:	ff c0                	inc    %eax
    7539:	74 22                	je     755d <posix_irq_handler_im_from_sw+0x30>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    753b:	e8 57 f5 ff ff       	callq  6a97 <posix_is_cpu_running>
    7540:	85 c0                	test   %eax,%eax
    7542:	75 13                	jne    7557 <posix_irq_handler_im_from_sw+0x2a>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    7544:	48 8d 35 f5 2c 00 00 	lea    0x2cf5(%rip),%rsi        # a240 <__func__.5217>
    754b:	48 8d 3d ec 3a 00 00 	lea    0x3aec(%rip),%rdi        # b03e <default_cmd+0xdde>
    7552:	e8 9f 03 00 00       	callq  78f6 <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    7557:	5a                   	pop    %rdx
		posix_irq_handler();
    7558:	e9 c8 fe ff ff       	jmpq   7425 <posix_irq_handler>
}
    755d:	58                   	pop    %rax
    755e:	c3                   	retq   

000000000000755f <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
    755f:	f3 0f 1e fa          	endbr64 
	return hw_irq_ctrl_change_lock(true);
    7563:	bf 01 00 00 00       	mov    $0x1,%edi
    7568:	e9 33 01 00 00       	jmpq   76a0 <hw_irq_ctrl_change_lock>

000000000000756d <posix_irq_unlock>:
 *
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
    756d:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(key);
    7571:	e9 2a 01 00 00       	jmpq   76a0 <hw_irq_ctrl_change_lock>

0000000000007576 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
    7576:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(false);
    757a:	31 ff                	xor    %edi,%edi
    757c:	e9 1f 01 00 00       	jmpq   76a0 <hw_irq_ctrl_change_lock>

0000000000007581 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
    7581:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_enable_irq(irq);
    7585:	e9 31 02 00 00       	jmpq   77bb <hw_irq_ctrl_enable_irq>

000000000000758a <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
    758a:	f3 0f 1e fa          	endbr64 
	irq_vector_table[irq_p].irq   = irq_p;
    758e:	89 f8                	mov    %edi,%eax
{
    7590:	49 89 d0             	mov    %rdx,%r8
	irq_vector_table[irq_p].irq   = irq_p;
    7593:	48 6b d0 18          	imul   $0x18,%rax,%rdx
    7597:	48 8d 05 82 89 00 00 	lea    0x8982(%rip),%rax        # ff20 <irq_vector_table>
    759e:	48 01 d0             	add    %rdx,%rax
    75a1:	89 38                	mov    %edi,(%rax)
	irq_vector_table[irq_p].func  = isr_p;
    75a3:	4c 89 40 08          	mov    %r8,0x8(%rax)
	irq_vector_table[irq_p].param = isr_param_p;
    75a7:	48 89 48 10          	mov    %rcx,0x10(%rax)
	irq_vector_table[irq_p].flags = flags;
    75ab:	89 70 04             	mov    %esi,0x4(%rax)
}
    75ae:	c3                   	retq   

00000000000075af <posix_irq_priority_set>:
 * Lower values take priority over higher values.
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    75af:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_prio_set(irq, prio);
    75b3:	e9 b9 00 00 00       	jmpq   7671 <hw_irq_ctrl_prio_set>

00000000000075b8 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    75b8:	80 3d d4 90 00 00 00 	cmpb   $0x0,0x90d4(%rip)        # 10693 <irqs_locked>
    75bf:	74 09                	je     75ca <irq_raising_from_hw_now+0x12>
    75c1:	80 3d ca 90 00 00 00 	cmpb   $0x0,0x90ca(%rip)        # 10692 <lock_ignore>
    75c8:	74 0c                	je     75d6 <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
    75ca:	c6 05 c1 90 00 00 00 	movb   $0x0,0x90c1(%rip)        # 10692 <lock_ignore>
		posix_interrupt_raised();
    75d1:	e9 55 f5 ff ff       	jmpq   6b2b <posix_interrupt_raised>
	}
}
    75d6:	c3                   	retq   

00000000000075d7 <hw_irq_ctrl_irq_raise_prefix>:
{
    75d7:	89 f9                	mov    %edi,%ecx
	if (irq < N_IRQS) {
    75d9:	83 ff 1f             	cmp    $0x1f,%edi
    75dc:	77 29                	ja     7607 <hw_irq_ctrl_irq_raise_prefix+0x30>
		if (irq_mask & (1 << irq)) {
    75de:	b8 01 00 00 00       	mov    $0x1,%eax
		irq_premask |= ((uint64_t)1<<irq);
    75e3:	ba 01 00 00 00       	mov    $0x1,%edx
		if (irq_mask & (1 << irq)) {
    75e8:	d3 e0                	shl    %cl,%eax
		irq_premask |= ((uint64_t)1<<irq);
    75ea:	48 d3 e2             	shl    %cl,%rdx
    75ed:	48 09 15 ec 8f 00 00 	or     %rdx,0x8fec(%rip)        # 105e0 <irq_premask>
		if (irq_mask & (1 << irq)) {
    75f4:	48 98                	cltq   
    75f6:	48 85 05 db 8f 00 00 	test   %rax,0x8fdb(%rip)        # 105d8 <irq_mask>
    75fd:	74 17                	je     7616 <hw_irq_ctrl_irq_raise_prefix+0x3f>
			irq_status |= ((uint64_t)1<<irq);
    75ff:	48 09 15 e2 8f 00 00 	or     %rdx,0x8fe2(%rip)        # 105e8 <irq_status>
    7606:	c3                   	retq   
	} else if (irq == PHONY_HARD_IRQ) {
    7607:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
    760d:	75 07                	jne    7616 <hw_irq_ctrl_irq_raise_prefix+0x3f>
		lock_ignore = true;
    760f:	c6 05 7c 90 00 00 01 	movb   $0x1,0x907c(%rip)        # 10692 <lock_ignore>
}
    7616:	c3                   	retq   

0000000000007617 <hw_irq_ctrl_init>:
{
    7617:	f3 0f 1e fa          	endbr64 
	irqs_locked = false;
    761b:	c6 05 71 90 00 00 00 	movb   $0x0,0x9071(%rip)        # 10693 <irqs_locked>
    7622:	48 8d 05 f7 8b 00 00 	lea    0x8bf7(%rip),%rax        # 10220 <irq_prio>
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    7629:	48 c7 05 a4 8f 00 00 	movq   $0x0,0x8fa4(%rip)        # 105d8 <irq_mask>
    7630:	00 00 00 00 
	irq_premask = 0U;
    7634:	48 8d 50 20          	lea    0x20(%rax),%rdx
    7638:	48 c7 05 9d 8f 00 00 	movq   $0x0,0x8f9d(%rip)        # 105e0 <irq_premask>
    763f:	00 00 00 00 
	lock_ignore = false;
    7643:	c6 05 48 90 00 00 00 	movb   $0x0,0x9048(%rip)        # 10692 <lock_ignore>
		irq_prio[i] = 255U;
    764a:	c6 00 ff             	movb   $0xff,(%rax)
	for (int i = 0 ; i < N_IRQS; i++) {
    764d:	48 ff c0             	inc    %rax
    7650:	48 39 d0             	cmp    %rdx,%rax
    7653:	75 f5                	jne    764a <hw_irq_ctrl_init+0x33>
}
    7655:	c3                   	retq   

0000000000007656 <hw_irq_ctrl_cleanup>:
{
    7656:	f3 0f 1e fa          	endbr64 
}
    765a:	c3                   	retq   

000000000000765b <hw_irq_ctrl_set_cur_prio>:
{
    765b:	f3 0f 1e fa          	endbr64 
	currently_running_prio = new;
    765f:	89 3d 13 5e 00 00    	mov    %edi,0x5e13(%rip)        # d478 <currently_running_prio>
}
    7665:	c3                   	retq   

0000000000007666 <hw_irq_ctrl_get_cur_prio>:
{
    7666:	f3 0f 1e fa          	endbr64 
}
    766a:	8b 05 08 5e 00 00    	mov    0x5e08(%rip),%eax        # d478 <currently_running_prio>
    7670:	c3                   	retq   

0000000000007671 <hw_irq_ctrl_prio_set>:
{
    7671:	f3 0f 1e fa          	endbr64 
	irq_prio[irq] = prio;
    7675:	89 ff                	mov    %edi,%edi
    7677:	48 8d 05 a2 8b 00 00 	lea    0x8ba2(%rip),%rax        # 10220 <irq_prio>
    767e:	40 88 34 38          	mov    %sil,(%rax,%rdi,1)
}
    7682:	c3                   	retq   

0000000000007683 <hw_irq_ctrl_get_prio>:
{
    7683:	f3 0f 1e fa          	endbr64 
	return irq_prio[irq];
    7687:	89 ff                	mov    %edi,%edi
    7689:	48 8d 05 90 8b 00 00 	lea    0x8b90(%rip),%rax        # 10220 <irq_prio>
    7690:	8a 04 38             	mov    (%rax,%rdi,1),%al
}
    7693:	c3                   	retq   

0000000000007694 <hw_irq_ctrl_get_current_lock>:
{
    7694:	f3 0f 1e fa          	endbr64 
	return irqs_locked;
    7698:	0f b6 05 f4 8f 00 00 	movzbl 0x8ff4(%rip),%eax        # 10693 <irqs_locked>
}
    769f:	c3                   	retq   

00000000000076a0 <hw_irq_ctrl_change_lock>:
{
    76a0:	f3 0f 1e fa          	endbr64 
	irqs_locked = new_lock;
    76a4:	85 ff                	test   %edi,%edi
{
    76a6:	41 54                	push   %r12
	uint32_t previous_lock = irqs_locked;
    76a8:	44 0f b6 25 e3 8f 00 	movzbl 0x8fe3(%rip),%r12d        # 10693 <irqs_locked>
    76af:	00 
	irqs_locked = new_lock;
    76b0:	0f 95 05 dc 8f 00 00 	setne  0x8fdc(%rip)        # 10693 <irqs_locked>
	if ((previous_lock == true) && (new_lock == false)) {
    76b7:	75 14                	jne    76cd <hw_irq_ctrl_change_lock+0x2d>
    76b9:	45 84 e4             	test   %r12b,%r12b
    76bc:	74 0f                	je     76cd <hw_irq_ctrl_change_lock+0x2d>
		if (irq_status != 0U) {
    76be:	48 83 3d 22 8f 00 00 	cmpq   $0x0,0x8f22(%rip)        # 105e8 <irq_status>
    76c5:	00 
    76c6:	74 05                	je     76cd <hw_irq_ctrl_change_lock+0x2d>
			posix_irq_handler_im_from_sw();
    76c8:	e8 60 fe ff ff       	callq  752d <posix_irq_handler_im_from_sw>
}
    76cd:	44 89 e0             	mov    %r12d,%eax
    76d0:	41 5c                	pop    %r12
    76d2:	c3                   	retq   

00000000000076d3 <hw_irq_ctrl_get_irq_status>:
{
    76d3:	f3 0f 1e fa          	endbr64 
}
    76d7:	48 8b 05 0a 8f 00 00 	mov    0x8f0a(%rip),%rax        # 105e8 <irq_status>
    76de:	c3                   	retq   

00000000000076df <hw_irq_ctrl_get_highest_prio_irq>:
{
    76df:	f3 0f 1e fa          	endbr64 
	if (irqs_locked) {
    76e3:	80 3d a9 8f 00 00 00 	cmpb   $0x0,0x8fa9(%rip)        # 10693 <irqs_locked>
    76ea:	75 55                	jne    7741 <hw_irq_ctrl_get_highest_prio_irq+0x62>
{
    76ec:	51                   	push   %rcx
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
    76ed:	e8 e1 ff ff ff       	callq  76d3 <hw_irq_ctrl_get_irq_status>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    76f2:	8b 3d 80 5d 00 00    	mov    0x5d80(%rip),%edi        # d478 <currently_running_prio>
	int winner_prio = 256;
    76f8:	be 00 01 00 00       	mov    $0x100,%esi
	int winner = -1;
    76fd:	41 83 c8 ff          	or     $0xffffffff,%r8d
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	return __builtin_ffs(op);
    7701:	41 83 c9 ff          	or     $0xffffffff,%r9d
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    7705:	41 ba 01 00 00 00    	mov    $0x1,%r10d
		if ((winner_prio > (int)irq_prio[irq_nbr])
    770b:	4c 8d 1d 0e 8b 00 00 	lea    0x8b0e(%rip),%r11        # 10220 <irq_prio>
	while (irq_status != 0U) {
    7712:	48 85 c0             	test   %rax,%rax
    7715:	74 32                	je     7749 <hw_irq_ctrl_get_highest_prio_irq+0x6a>
    7717:	0f bc c8             	bsf    %eax,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    771a:	4c 89 d2             	mov    %r10,%rdx
		int irq_nbr = find_lsb_set(irq_status) - 1;
    771d:	41 0f 44 c9          	cmove  %r9d,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    7721:	48 d3 e2             	shl    %cl,%rdx
    7724:	48 f7 d2             	not    %rdx
    7727:	48 21 d0             	and    %rdx,%rax
		if ((winner_prio > (int)irq_prio[irq_nbr])
    772a:	48 63 d1             	movslq %ecx,%rdx
    772d:	41 0f b6 14 13       	movzbl (%r11,%rdx,1),%edx
    7732:	39 f2                	cmp    %esi,%edx
    7734:	7d dc                	jge    7712 <hw_irq_ctrl_get_highest_prio_irq+0x33>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    7736:	39 fa                	cmp    %edi,%edx
    7738:	0f 4c f2             	cmovl  %edx,%esi
    773b:	44 0f 4c c1          	cmovl  %ecx,%r8d
    773f:	eb d1                	jmp    7712 <hw_irq_ctrl_get_highest_prio_irq+0x33>
    7741:	41 83 c8 ff          	or     $0xffffffff,%r8d
}
    7745:	44 89 c0             	mov    %r8d,%eax
    7748:	c3                   	retq   
    7749:	44 89 c0             	mov    %r8d,%eax
    774c:	5a                   	pop    %rdx
    774d:	c3                   	retq   

000000000000774e <hw_irq_ctrl_clear_irq>:
{
    774e:	f3 0f 1e fa          	endbr64 
	irq_status  &= ~((uint64_t)1<<irq);
    7752:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    7759:	89 f9                	mov    %edi,%ecx
    775b:	48 d3 c0             	rol    %cl,%rax
    775e:	48 21 05 83 8e 00 00 	and    %rax,0x8e83(%rip)        # 105e8 <irq_status>
	irq_premask &= ~((uint64_t)1<<irq);
    7765:	48 21 05 74 8e 00 00 	and    %rax,0x8e74(%rip)        # 105e0 <irq_premask>
}
    776c:	c3                   	retq   

000000000000776d <hw_irq_ctrl_set_irq>:
{
    776d:	f3 0f 1e fa          	endbr64 
    7771:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    7772:	e8 60 fe ff ff       	callq  75d7 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    7777:	80 3d 15 8f 00 00 00 	cmpb   $0x0,0x8f15(%rip)        # 10693 <irqs_locked>
    777e:	74 09                	je     7789 <hw_irq_ctrl_set_irq+0x1c>
    7780:	80 3d 0b 8f 00 00 00 	cmpb   $0x0,0x8f0b(%rip)        # 10692 <lock_ignore>
    7787:	74 15                	je     779e <hw_irq_ctrl_set_irq+0x31>
		irq_ctrl_timer = hwm_get_time();
    7789:	e8 71 f7 ff ff       	callq  6eff <hwm_get_time>
    778e:	48 8d 15 cb 5c 00 00 	lea    0x5ccb(%rip),%rdx        # d460 <irq_ctrl_timer>
    7795:	48 89 02             	mov    %rax,(%rdx)
}
    7798:	5a                   	pop    %rdx
		hwm_find_next_timer();
    7799:	e9 28 f6 ff ff       	jmpq   6dc6 <hwm_find_next_timer>
}
    779e:	58                   	pop    %rax
    779f:	c3                   	retq   

00000000000077a0 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    77a0:	f3 0f 1e fa          	endbr64 
    77a4:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    77a5:	e8 2d fe ff ff       	callq  75d7 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    77aa:	80 3d e2 8e 00 00 00 	cmpb   $0x0,0x8ee2(%rip)        # 10693 <irqs_locked>
    77b1:	75 06                	jne    77b9 <hw_irq_ctrl_raise_im_from_sw+0x19>
		posix_irq_handler_im_from_sw();
	}
}
    77b3:	5a                   	pop    %rdx
		posix_irq_handler_im_from_sw();
    77b4:	e9 74 fd ff ff       	jmpq   752d <posix_irq_handler_im_from_sw>
}
    77b9:	58                   	pop    %rax
    77ba:	c3                   	retq   

00000000000077bb <hw_irq_ctrl_enable_irq>:
{
    77bb:	f3 0f 1e fa          	endbr64 
	irq_mask |= ((uint64_t)1<<irq);
    77bf:	b8 01 00 00 00       	mov    $0x1,%eax
    77c4:	89 f9                	mov    %edi,%ecx
    77c6:	48 d3 e0             	shl    %cl,%rax
    77c9:	48 09 05 08 8e 00 00 	or     %rax,0x8e08(%rip)        # 105d8 <irq_mask>
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    77d0:	48 8b 05 09 8e 00 00 	mov    0x8e09(%rip),%rax        # 105e0 <irq_premask>
    77d7:	48 0f a3 f8          	bt     %rdi,%rax
    77db:	73 05                	jae    77e2 <hw_irq_ctrl_enable_irq+0x27>
		hw_irq_ctrl_raise_im_from_sw(irq);
    77dd:	e9 be ff ff ff       	jmpq   77a0 <hw_irq_ctrl_raise_im_from_sw>
}
    77e2:	c3                   	retq   

00000000000077e3 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
    77e3:	f3 0f 1e fa          	endbr64 
	irq_ctrl_timer = NEVER;
    77e7:	48 8d 05 72 5c 00 00 	lea    0x5c72(%rip),%rax        # d460 <irq_ctrl_timer>
    77ee:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	irq_raising_from_hw_now();
    77f5:	e9 be fd ff ff       	jmpq   75b8 <irq_raising_from_hw_now>

00000000000077fa <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    77fa:	f3 0f 1e fa          	endbr64 
    77fe:	50                   	push   %rax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    77ff:	39 3d 5f 8e 00 00    	cmp    %edi,0x8e5f(%rip)        # 10664 <max_exit_code.2396>
    7805:	0f 4d 3d 58 8e 00 00 	cmovge 0x8e58(%rip),%edi        # 10664 <max_exit_code.2396>
    780c:	89 3d 52 8e 00 00    	mov    %edi,0x8e52(%rip)        # 10664 <max_exit_code.2396>
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    7812:	e8 43 f4 ff ff       	callq  6c5a <posix_soc_clean_up>
	hwm_cleanup();
    7817:	e8 0e f7 ff ff       	callq  6f2a <hwm_cleanup>
	native_cleanup_cmd_line();
    781c:	e8 10 0b 00 00       	callq  8331 <native_cleanup_cmd_line>
	exit(max_exit_code);
    7821:	8b 3d 3d 8e 00 00    	mov    0x8e3d(%rip),%edi        # 10664 <max_exit_code.2396>
    7827:	e8 34 be ff ff       	callq  3660 <exit@plt>

000000000000782c <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    782c:	f3 0f 1e fa          	endbr64 
    7830:	55                   	push   %rbp
    7831:	89 fd                	mov    %edi,%ebp
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    7833:	31 ff                	xor    %edi,%edi
{
    7835:	48 83 ec 10          	sub    $0x10,%rsp
    7839:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    783e:	e8 dd f3 ff ff       	callq  6c20 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
    7843:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    7848:	89 ef                	mov    %ebp,%edi
    784a:	e8 bd 0b 00 00       	callq  840c <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    784f:	bf 01 00 00 00       	mov    $0x1,%edi
    7854:	e8 c7 f3 ff ff       	callq  6c20 <run_native_tasks>

	hwm_init();
    7859:	e8 ad f6 ff ff       	callq  6f0b <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    785e:	bf 02 00 00 00       	mov    $0x2,%edi
    7863:	e8 b8 f3 ff ff       	callq  6c20 <run_native_tasks>

	posix_boot_cpu();
    7868:	e8 f2 f2 ff ff       	callq  6b5f <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    786d:	bf 03 00 00 00       	mov    $0x3,%edi
    7872:	e8 a9 f3 ff ff       	callq  6c20 <run_native_tasks>

	hwm_main_loop();
    7877:	e8 ae f5 ff ff       	callq  6e2a <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    787c:	48 83 c4 10          	add    $0x10,%rsp
    7880:	b8 01 00 00 00       	mov    $0x1,%eax
    7885:	5d                   	pop    %rbp
    7886:	c3                   	retq   

0000000000007887 <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
    7887:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 0;
    788b:	48 c7 05 d2 5b 00 00 	movq   $0x0,0x5bd2(%rip)        # d468 <is_a_tty>
    7892:	00 00 00 00 
	is_a_tty[1] = 0;
}
    7896:	c3                   	retq   

0000000000007897 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
    7897:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = -1;
    789b:	48 c7 05 c2 5b 00 00 	movq   $0xffffffffffffffff,0x5bc2(%rip)        # d468 <is_a_tty>
    78a2:	ff ff ff ff 
	is_a_tty[1] = -1;

}
    78a6:	c3                   	retq   

00000000000078a7 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
    78a7:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 1;
    78ab:	48 b8 01 00 00 00 01 	movabs $0x100000001,%rax
    78b2:	00 00 00 
    78b5:	48 89 05 ac 5b 00 00 	mov    %rax,0x5bac(%rip)        # d468 <is_a_tty>
	is_a_tty[1] = 1;
}
    78bc:	c3                   	retq   

00000000000078bd <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    78bd:	f3 0f 1e fa          	endbr64 
    78c1:	52                   	push   %rdx
	if (is_a_tty[0] == -1) {
    78c2:	83 3d 9f 5b 00 00 ff 	cmpl   $0xffffffff,0x5b9f(%rip)        # d468 <is_a_tty>
    78c9:	75 10                	jne    78db <decide_about_color+0x1e>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    78cb:	bf 01 00 00 00       	mov    $0x1,%edi
    78d0:	e8 5b bb ff ff       	callq  3430 <isatty@plt>
    78d5:	89 05 8d 5b 00 00    	mov    %eax,0x5b8d(%rip)        # d468 <is_a_tty>
	}
	if (is_a_tty[1] == -1) {
    78db:	83 3d 8a 5b 00 00 ff 	cmpl   $0xffffffff,0x5b8a(%rip)        # d46c <is_a_tty+0x4>
    78e2:	75 10                	jne    78f4 <decide_about_color+0x37>
		is_a_tty[1] = isatty(STDERR_FILENO);
    78e4:	bf 02 00 00 00       	mov    $0x2,%edi
    78e9:	e8 42 bb ff ff       	callq  3430 <isatty@plt>
    78ee:	89 05 78 5b 00 00    	mov    %eax,0x5b78(%rip)        # d46c <is_a_tty+0x4>
	}
}
    78f4:	58                   	pop    %rax
    78f5:	c3                   	retq   

00000000000078f6 <posix_print_error_and_exit>:
{
    78f6:	f3 0f 1e fa          	endbr64 
    78fa:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    7901:	49 89 fa             	mov    %rdi,%r10
    7904:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    7909:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    790e:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    7913:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    7918:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    791d:	84 c0                	test   %al,%al
    791f:	74 37                	je     7958 <posix_print_error_and_exit+0x62>
    7921:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    7926:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    792b:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    7930:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    7937:	00 
    7938:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    793f:	00 
    7940:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    7947:	00 
    7948:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    794f:	00 
    7950:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    7957:	00 
    7958:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    795f:	00 00 
    7961:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    7966:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    7968:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    796f:	00 

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    7970:	48 89 e1             	mov    %rsp,%rcx
    7973:	4c 89 d2             	mov    %r10,%rdx
    7976:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    797b:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    7980:	be 01 00 00 00       	mov    $0x1,%esi
    7985:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    798a:	48 8b 05 5f 56 00 00 	mov    0x565f(%rip),%rax        # cff0 <stderr@GLIBC_2.2.5>
    7991:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    7998:	48 8b 38             	mov    (%rax),%rdi
    799b:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    79a2:	00 
    79a3:	e8 48 ba ff ff       	callq  33f0 <__vfprintf_chk@plt>
	posix_exit(1);
    79a8:	bf 01 00 00 00       	mov    $0x1,%edi
    79ad:	e8 48 fe ff ff       	callq  77fa <posix_exit>
}
    79b2:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    79b7:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    79be:	00 00 
    79c0:	74 05                	je     79c7 <posix_print_error_and_exit+0xd1>
    79c2:	e8 e9 ba ff ff       	callq  34b0 <__stack_chk_fail@plt>
    79c7:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    79ce:	c3                   	retq   

00000000000079cf <posix_print_warning>:
{
    79cf:	f3 0f 1e fa          	endbr64 
    79d3:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    79da:	49 89 fa             	mov    %rdi,%r10
    79dd:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    79e2:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    79e7:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    79ec:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    79f1:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    79f6:	84 c0                	test   %al,%al
    79f8:	74 37                	je     7a31 <posix_print_warning+0x62>
    79fa:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    79ff:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    7a04:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    7a09:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    7a10:	00 
    7a11:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    7a18:	00 
    7a19:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    7a20:	00 
    7a21:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    7a28:	00 
    7a29:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    7a30:	00 
    7a31:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7a38:	00 00 
    7a3a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    7a3f:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    7a41:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    7a48:	00 
    7a49:	48 89 e1             	mov    %rsp,%rcx
    7a4c:	4c 89 d2             	mov    %r10,%rdx
    7a4f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    7a54:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    7a59:	be 01 00 00 00       	mov    $0x1,%esi
    7a5e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    7a63:	48 8b 05 86 55 00 00 	mov    0x5586(%rip),%rax        # cff0 <stderr@GLIBC_2.2.5>
    7a6a:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    7a71:	48 8b 38             	mov    (%rax),%rdi
    7a74:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    7a7b:	00 
    7a7c:	e8 6f b9 ff ff       	callq  33f0 <__vfprintf_chk@plt>
}
    7a81:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    7a86:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7a8d:	00 00 
    7a8f:	74 05                	je     7a96 <posix_print_warning+0xc7>
    7a91:	e8 1a ba ff ff       	callq  34b0 <__stack_chk_fail@plt>
    7a96:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    7a9d:	c3                   	retq   

0000000000007a9e <posix_print_trace>:
{
    7a9e:	f3 0f 1e fa          	endbr64 
    7aa2:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    7aa9:	49 89 fa             	mov    %rdi,%r10
    7aac:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    7ab1:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    7ab6:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    7abb:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    7ac0:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    7ac5:	84 c0                	test   %al,%al
    7ac7:	74 37                	je     7b00 <posix_print_trace+0x62>
    7ac9:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    7ace:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    7ad3:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    7ad8:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    7adf:	00 
    7ae0:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    7ae7:	00 
    7ae8:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    7aef:	00 
    7af0:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    7af7:	00 
    7af8:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    7aff:	00 
    7b00:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7b07:	00 00 
    7b09:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    7b0e:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    7b10:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    7b17:	00 
    7b18:	48 89 e1             	mov    %rsp,%rcx
    7b1b:	4c 89 d2             	mov    %r10,%rdx
    7b1e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    7b23:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    7b28:	be 01 00 00 00       	mov    $0x1,%esi
    7b2d:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    7b32:	48 8b 05 6f 54 00 00 	mov    0x546f(%rip),%rax        # cfa8 <stdout@GLIBC_2.2.5>
    7b39:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    7b40:	48 8b 38             	mov    (%rax),%rdi
    7b43:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    7b4a:	00 
    7b4b:	e8 a0 b8 ff ff       	callq  33f0 <__vfprintf_chk@plt>
}
    7b50:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    7b55:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7b5c:	00 00 
    7b5e:	74 05                	je     7b65 <posix_print_trace+0xc7>
    7b60:	e8 4b b9 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    7b65:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    7b6c:	c3                   	retq   

0000000000007b6d <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
    7b6d:	f3 0f 1e fa          	endbr64 
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    7b71:	48 8d 3d 48 56 00 00 	lea    0x5648(%rip),%rdi        # d1c0 <trace_options.3560>
    7b78:	e9 d8 07 00 00       	jmpq   8355 <native_add_command_line_opts>

0000000000007b7d <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    7b7d:	41 55                	push   %r13
    7b7f:	41 bd 46 00 00 00    	mov    $0x46,%r13d
    7b85:	41 54                	push   %r12
    7b87:	49 89 f4             	mov    %rsi,%r12
    7b8a:	55                   	push   %rbp
    7b8b:	48 89 fd             	mov    %rdi,%rbp
    7b8e:	53                   	push   %rbx
    7b8f:	41 53                	push   %r11

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    7b91:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
    7b95:	75 0c                	jne    7ba3 <cmd_gen_switch_syntax.constprop.0+0x26>
		*buf++ = '[';
    7b97:	c6 07 5b             	movb   $0x5b,(%rdi)
    7b9a:	48 ff c5             	inc    %rbp
		size--;
    7b9d:	41 bd 45 00 00 00    	mov    $0x45,%r13d
	}

	if (args_s_el->is_switch == true) {
    7ba3:	41 80 7c 24 02 00    	cmpb   $0x0,0x2(%r12)
    7ba9:	4d 8b 4c 24 08       	mov    0x8(%r12),%r9
    7bae:	49 63 f5             	movslq %r13d,%rsi
    7bb1:	74 1c                	je     7bcf <cmd_gen_switch_syntax.constprop.0+0x52>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    7bb3:	4c 8d 05 71 35 00 00 	lea    0x3571(%rip),%r8        # b12b <default_cmd+0xecb>
    7bba:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    7bbe:	48 89 ef             	mov    %rbp,%rdi
    7bc1:	31 c0                	xor    %eax,%eax
    7bc3:	ba 01 00 00 00       	mov    $0x1,%edx
    7bc8:	e8 d3 b7 ff ff       	callq  33a0 <__snprintf_chk@plt>
    7bcd:	eb 38                	jmp    7c07 <cmd_gen_switch_syntax.constprop.0+0x8a>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
    7bcf:	41 80 7c 24 18 6c    	cmpb   $0x6c,0x18(%r12)
    7bd5:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    7bda:	74 0c                	je     7be8 <cmd_gen_switch_syntax.constprop.0+0x6b>
    7bdc:	4c 8d 05 4c 35 00 00 	lea    0x354c(%rip),%r8        # b12f <default_cmd+0xecf>
    7be3:	41 52                	push   %r10
    7be5:	50                   	push   %rax
    7be6:	eb 0a                	jmp    7bf2 <cmd_gen_switch_syntax.constprop.0+0x75>
    7be8:	41 50                	push   %r8
    7bea:	4c 8d 05 47 35 00 00 	lea    0x3547(%rip),%r8        # b138 <default_cmd+0xed8>
    7bf1:	50                   	push   %rax
    7bf2:	48 89 ef             	mov    %rbp,%rdi
    7bf5:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    7bf9:	ba 01 00 00 00       	mov    $0x1,%edx
    7bfe:	31 c0                	xor    %eax,%eax
    7c00:	e8 9b b7 ff ff       	callq  33a0 <__snprintf_chk@plt>
    7c05:	5e                   	pop    %rsi
    7c06:	5f                   	pop    %rdi
    7c07:	48 63 d8             	movslq %eax,%rbx
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    7c0a:	85 db                	test   %ebx,%ebx
    7c0c:	79 1a                	jns    7c28 <cmd_gen_switch_syntax.constprop.0+0xab>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    7c0e:	ba 07 01 00 00       	mov    $0x107,%edx
    7c13:	48 8d 35 2a 35 00 00 	lea    0x352a(%rip),%rsi        # b144 <default_cmd+0xee4>
    7c1a:	48 8d 3d 61 35 00 00 	lea    0x3561(%rip),%rdi        # b182 <default_cmd+0xf22>
    7c21:	31 c0                	xor    %eax,%eax
    7c23:	e8 ce fc ff ff       	callq  78f6 <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    7c28:	41 29 dd             	sub    %ebx,%r13d
    7c2b:	78 2c                	js     7c59 <cmd_gen_switch_syntax.constprop.0+0xdc>
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    7c2d:	41 80 7c 24 01 00    	cmpb   $0x0,0x1(%r12)
	buf += ret;
    7c33:	48 8d 7c 1d 00       	lea    0x0(%rbp,%rbx,1),%rdi
	if (args_s_el->is_mandatory == false) {
    7c38:	49 63 f5             	movslq %r13d,%rsi
    7c3b:	48 8d 15 5b 35 00 00 	lea    0x355b(%rip),%rdx        # b19d <default_cmd+0xf3d>
    7c42:	74 07                	je     7c4b <cmd_gen_switch_syntax.constprop.0+0xce>
    7c44:	48 8d 15 53 35 00 00 	lea    0x3553(%rip),%rdx        # b19e <default_cmd+0xf3e>
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    7c4b:	59                   	pop    %rcx
    7c4c:	31 c0                	xor    %eax,%eax
    7c4e:	5b                   	pop    %rbx
    7c4f:	5d                   	pop    %rbp
    7c50:	41 5c                	pop    %r12
    7c52:	41 5d                	pop    %r13
    7c54:	e9 77 b8 ff ff       	jmpq   34d0 <snprintf@plt>
    7c59:	58                   	pop    %rax
    7c5a:	5b                   	pop    %rbx
    7c5b:	5d                   	pop    %rbp
    7c5c:	41 5c                	pop    %r12
    7c5e:	41 5d                	pop    %r13
    7c60:	c3                   	retq   

0000000000007c61 <cmd_is_option>:
{
    7c61:	f3 0f 1e fa          	endbr64 
    7c65:	41 54                	push   %r12
    7c67:	49 89 f8             	mov    %rdi,%r8
    7c6a:	41 89 d4             	mov    %edx,%r12d
    7c6d:	55                   	push   %rbp
    7c6e:	48 89 f5             	mov    %rsi,%rbp
    7c71:	53                   	push   %rbx
	int of = 0;
    7c72:	31 db                	xor    %ebx,%ebx
    7c74:	80 3f 2d             	cmpb   $0x2d,(%rdi)
	if (arg[of] == '-') {
    7c77:	0f 94 c0             	sete   %al
	int of = 0;
    7c7a:	0f 94 c3             	sete   %bl
	if (arg[of] == '-') {
    7c7d:	0f b6 c0             	movzbl %al,%eax
    7c80:	80 3c 07 2d          	cmpb   $0x2d,(%rdi,%rax,1)
    7c84:	75 02                	jne    7c88 <cmd_is_option+0x27>
		of++;
    7c86:	ff c3                	inc    %ebx
	if (!with_value) {
    7c88:	45 85 e4             	test   %r12d,%r12d
    7c8b:	75 28                	jne    7cb5 <cmd_is_option+0x54>
		if (strcmp(&arg[of], option) != 0) {
    7c8d:	48 63 fb             	movslq %ebx,%rdi
    7c90:	48 89 ee             	mov    %rbp,%rsi
    7c93:	4c 01 c7             	add    %r8,%rdi
    7c96:	e8 a5 b8 ff ff       	callq  3540 <strcmp@plt>
    7c9b:	85 c0                	test   %eax,%eax
    7c9d:	75 68                	jne    7d07 <cmd_is_option+0xa6>
	size_t to_match_len = strlen(option);
    7c9f:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    7ca3:	48 89 ef             	mov    %rbp,%rdi
    7ca6:	f2 ae                	repnz scas %es:(%rdi),%al
    7ca8:	48 89 c8             	mov    %rcx,%rax
    7cab:	48 f7 d0             	not    %rax
			return of + to_match_len;
    7cae:	44 8d 64 03 ff       	lea    -0x1(%rbx,%rax,1),%r12d
    7cb3:	eb 52                	jmp    7d07 <cmd_is_option+0xa6>
    7cb5:	31 d2                	xor    %edx,%edx
    7cb7:	44 8d 24 13          	lea    (%rbx,%rdx,1),%r12d
	while (!(arg[of] == 0 && *option == 0)) {
    7cbb:	8a 4c 15 00          	mov    0x0(%rbp,%rdx,1),%cl
    7cbf:	49 63 c4             	movslq %r12d,%rax
    7cc2:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    7cc6:	89 c6                	mov    %eax,%esi
    7cc8:	40 08 ce             	or     %cl,%sil
    7ccb:	74 24                	je     7cf1 <cmd_is_option+0x90>
		if (*option == 0) {
    7ccd:	84 c9                	test   %cl,%cl
    7ccf:	75 17                	jne    7ce8 <cmd_is_option+0x87>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    7cd1:	3c 3a                	cmp    $0x3a,%al
    7cd3:	74 04                	je     7cd9 <cmd_is_option+0x78>
    7cd5:	3c 3d                	cmp    $0x3d,%al
    7cd7:	75 2b                	jne    7d04 <cmd_is_option+0xa3>
				of++;
    7cd9:	41 ff c4             	inc    %r12d
	if (arg[of] == 0) { /* we need a value to follow */
    7cdc:	49 63 c4             	movslq %r12d,%rax
    7cdf:	41 80 3c 00 00       	cmpb   $0x0,(%r8,%rax,1)
    7ce4:	75 21                	jne    7d07 <cmd_is_option+0xa6>
    7ce6:	eb 09                	jmp    7cf1 <cmd_is_option+0x90>
		if (arg[of] != *option) {
    7ce8:	48 ff c2             	inc    %rdx
    7ceb:	38 c8                	cmp    %cl,%al
    7ced:	74 c8                	je     7cb7 <cmd_is_option+0x56>
    7cef:	eb 13                	jmp    7d04 <cmd_is_option+0xa3>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    7cf1:	4c 89 c6             	mov    %r8,%rsi
    7cf4:	48 8d 3d a5 34 00 00 	lea    0x34a5(%rip),%rdi        # b1a0 <default_cmd+0xf40>
    7cfb:	31 c0                	xor    %eax,%eax
    7cfd:	e8 f4 fb ff ff       	callq  78f6 <posix_print_error_and_exit>
    7d02:	eb 03                	jmp    7d07 <cmd_is_option+0xa6>
			return 0;
    7d04:	45 31 e4             	xor    %r12d,%r12d
}
    7d07:	44 89 e0             	mov    %r12d,%eax
    7d0a:	5b                   	pop    %rbx
    7d0b:	5d                   	pop    %rbp
    7d0c:	41 5c                	pop    %r12
    7d0e:	c3                   	retq   

0000000000007d0f <cmd_is_help_option>:
{
    7d0f:	f3 0f 1e fa          	endbr64 
    7d13:	55                   	push   %rbp
	if (arg[0] == '-') {
    7d14:	80 3f 2d             	cmpb   $0x2d,(%rdi)
{
    7d17:	48 89 fd             	mov    %rdi,%rbp
	if (arg[0] == '-') {
    7d1a:	75 0f                	jne    7d2b <cmd_is_help_option+0x1c>
	if (arg[0] == '-') {
    7d1c:	80 7f 01 2d          	cmpb   $0x2d,0x1(%rdi)
    7d20:	74 05                	je     7d27 <cmd_is_help_option+0x18>
		arg++;
    7d22:	48 ff c5             	inc    %rbp
    7d25:	eb 04                	jmp    7d2b <cmd_is_help_option+0x1c>
		arg++;
    7d27:	48 83 c5 02          	add    $0x2,%rbp
	if ((strcasecmp(arg, "?") == 0) ||
    7d2b:	48 8d 35 c8 34 00 00 	lea    0x34c8(%rip),%rsi        # b1fa <default_cmd+0xf9a>
    7d32:	48 89 ef             	mov    %rbp,%rdi
    7d35:	e8 96 b6 ff ff       	callq  33d0 <strcasecmp@plt>
    7d3a:	41 89 c0             	mov    %eax,%r8d
		return 1;
    7d3d:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    7d42:	45 85 c0             	test   %r8d,%r8d
    7d45:	74 33                	je     7d7a <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
    7d47:	48 8d 35 ae 34 00 00 	lea    0x34ae(%rip),%rsi        # b1fc <default_cmd+0xf9c>
    7d4e:	48 89 ef             	mov    %rbp,%rdi
    7d51:	e8 7a b6 ff ff       	callq  33d0 <strcasecmp@plt>
    7d56:	41 89 c0             	mov    %eax,%r8d
		return 1;
    7d59:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    7d5e:	45 85 c0             	test   %r8d,%r8d
    7d61:	74 17                	je     7d7a <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
    7d63:	48 8d 35 32 35 00 00 	lea    0x3532(%rip),%rsi        # b29c <default_cmd+0x103c>
    7d6a:	48 89 ef             	mov    %rbp,%rdi
    7d6d:	e8 5e b6 ff ff       	callq  33d0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
    7d72:	85 c0                	test   %eax,%eax
    7d74:	0f 94 c0             	sete   %al
    7d77:	0f b6 c0             	movzbl %al,%eax
}
    7d7a:	5d                   	pop    %rbp
    7d7b:	c3                   	retq   

0000000000007d7c <cmd_read_option_value>:
{
    7d7c:	f3 0f 1e fa          	endbr64 
    7d80:	41 54                	push   %r12
    7d82:	49 89 fc             	mov    %rdi,%r12
    7d85:	55                   	push   %rbp
    7d86:	48 89 cd             	mov    %rcx,%rbp
    7d89:	53                   	push   %rbx
    7d8a:	48 89 f3             	mov    %rsi,%rbx
    7d8d:	48 83 ec 10          	sub    $0x10,%rsp
    7d91:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    7d98:	00 00 
    7d9a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    7d9f:	31 c0                	xor    %eax,%eax
	char *endptr = NULL;
    7da1:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    7da8:	00 
	switch (type) {
    7da9:	80 fa 64             	cmp    $0x64,%dl
    7dac:	0f 84 11 01 00 00    	je     7ec3 <cmd_read_option_value+0x147>
    7db2:	7f 26                	jg     7dda <cmd_read_option_value+0x5e>
    7db4:	80 fa 55             	cmp    $0x55,%dl
    7db7:	0f 84 f1 00 00 00    	je     7eae <cmd_read_option_value+0x132>
    7dbd:	80 fa 62             	cmp    $0x62,%dl
    7dc0:	74 42                	je     7e04 <cmd_read_option_value+0x88>
    7dc2:	80 fa 49             	cmp    $0x49,%dl
    7dc5:	0f 85 06 01 00 00    	jne    7ed1 <cmd_read_option_value+0x155>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    7dcb:	48 89 e6             	mov    %rsp,%rsi
    7dce:	31 d2                	xor    %edx,%edx
    7dd0:	e8 7b b7 ff ff       	callq  3550 <strtoll@plt>
    7dd5:	e9 e4 00 00 00       	jmpq   7ebe <cmd_read_option_value+0x142>
	switch (type) {
    7dda:	80 fa 73             	cmp    $0x73,%dl
    7ddd:	0f 84 aa 00 00 00    	je     7e8d <cmd_read_option_value+0x111>
    7de3:	80 fa 75             	cmp    $0x75,%dl
    7de6:	0f 84 b6 00 00 00    	je     7ea2 <cmd_read_option_value+0x126>
    7dec:	80 fa 69             	cmp    $0x69,%dl
    7def:	0f 85 dc 00 00 00    	jne    7ed1 <cmd_read_option_value+0x155>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    7df5:	48 89 e6             	mov    %rsp,%rsi
    7df8:	31 d2                	xor    %edx,%edx
    7dfa:	e8 91 b7 ff ff       	callq  3590 <strtol@plt>
    7dff:	e9 b6 00 00 00       	jmpq   7eba <cmd_read_option_value+0x13e>
		if (strcasecmp(str, "false") == 0) {
    7e04:	48 8d 35 f3 33 00 00 	lea    0x33f3(%rip),%rsi        # b1fe <default_cmd+0xf9e>
    7e0b:	e8 c0 b5 ff ff       	callq  33d0 <strcasecmp@plt>
    7e10:	85 c0                	test   %eax,%eax
    7e12:	75 0a                	jne    7e1e <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
    7e14:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 5;
    7e17:	49 8d 44 24 05       	lea    0x5(%r12),%rax
    7e1c:	eb 1b                	jmp    7e39 <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "0") == 0) {
    7e1e:	48 8d 35 c7 38 00 00 	lea    0x38c7(%rip),%rsi        # b6ec <default_cmd+0x148c>
    7e25:	4c 89 e7             	mov    %r12,%rdi
    7e28:	e8 13 b7 ff ff       	callq  3540 <strcmp@plt>
    7e2d:	85 c0                	test   %eax,%eax
    7e2f:	75 11                	jne    7e42 <cmd_read_option_value+0xc6>
			*(bool *)dest = false;
    7e31:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 1;
    7e34:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    7e39:	48 89 04 24          	mov    %rax,(%rsp)
	if (!error && endptr && *endptr != 0) {
    7e3d:	e9 a0 00 00 00       	jmpq   7ee2 <cmd_read_option_value+0x166>
		} else if (strcasecmp(str, "true") == 0) {
    7e42:	48 8d 35 bb 33 00 00 	lea    0x33bb(%rip),%rsi        # b204 <default_cmd+0xfa4>
    7e49:	4c 89 e7             	mov    %r12,%rdi
    7e4c:	e8 7f b5 ff ff       	callq  33d0 <strcasecmp@plt>
    7e51:	85 c0                	test   %eax,%eax
    7e53:	75 0a                	jne    7e5f <cmd_read_option_value+0xe3>
			*(bool *)dest = true;
    7e55:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 4;
    7e58:	49 8d 44 24 04       	lea    0x4(%r12),%rax
    7e5d:	eb da                	jmp    7e39 <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "1") == 0) {
    7e5f:	48 8d 35 a3 33 00 00 	lea    0x33a3(%rip),%rsi        # b209 <default_cmd+0xfa9>
    7e66:	4c 89 e7             	mov    %r12,%rdi
    7e69:	e8 d2 b6 ff ff       	callq  3540 <strcmp@plt>
    7e6e:	85 c0                	test   %eax,%eax
    7e70:	74 16                	je     7e88 <cmd_read_option_value+0x10c>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    7e72:	4c 89 e2             	mov    %r12,%rdx
    7e75:	48 89 ee             	mov    %rbp,%rsi
    7e78:	48 8d 3d 8c 33 00 00 	lea    0x338c(%rip),%rdi        # b20b <default_cmd+0xfab>
    7e7f:	31 c0                	xor    %eax,%eax
    7e81:	e8 70 fa ff ff       	callq  78f6 <posix_print_error_and_exit>
    7e86:	eb 68                	jmp    7ef0 <cmd_read_option_value+0x174>
			*(bool *)dest = true;
    7e88:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 1;
    7e8b:	eb a7                	jmp    7e34 <cmd_read_option_value+0xb8>
		*(char **)dest = (char *)str;
    7e8d:	48 89 3b             	mov    %rdi,(%rbx)
		endptr = (char *)str + strlen(str);
    7e90:	31 c0                	xor    %eax,%eax
    7e92:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    7e96:	f2 ae                	repnz scas %es:(%rdi),%al
    7e98:	48 f7 d1             	not    %rcx
    7e9b:	49 8d 44 0c ff       	lea    -0x1(%r12,%rcx,1),%rax
    7ea0:	eb 97                	jmp    7e39 <cmd_read_option_value+0xbd>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
    7ea2:	48 89 e6             	mov    %rsp,%rsi
    7ea5:	31 d2                	xor    %edx,%edx
    7ea7:	e8 74 b7 ff ff       	callq  3620 <strtoul@plt>
    7eac:	eb 0c                	jmp    7eba <cmd_read_option_value+0x13e>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
    7eae:	48 89 e6             	mov    %rsp,%rsi
    7eb1:	31 d2                	xor    %edx,%edx
    7eb3:	e8 68 b6 ff ff       	callq  3520 <strtoull@plt>
    7eb8:	eb 04                	jmp    7ebe <cmd_read_option_value+0x142>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    7eba:	89 03                	mov    %eax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    7ebc:	eb 24                	jmp    7ee2 <cmd_read_option_value+0x166>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    7ebe:	48 89 03             	mov    %rax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    7ec1:	eb 1f                	jmp    7ee2 <cmd_read_option_value+0x166>
		*(double *)dest = strtod(str, &endptr);
    7ec3:	48 89 e6             	mov    %rsp,%rsi
    7ec6:	e8 95 b5 ff ff       	callq  3460 <strtod@plt>
    7ecb:	f2 0f 11 03          	movsd  %xmm0,(%rbx)
	if (!error && endptr && *endptr != 0) {
    7ecf:	eb 11                	jmp    7ee2 <cmd_read_option_value+0x166>
	switch (type) {
    7ed1:	0f be f2             	movsbl %dl,%esi
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    7ed4:	48 8d 3d 72 33 00 00 	lea    0x3372(%rip),%rdi        # b24d <default_cmd+0xfed>
    7edb:	31 c0                	xor    %eax,%eax
    7edd:	e8 14 fa ff ff       	callq  78f6 <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
    7ee2:	48 8b 04 24          	mov    (%rsp),%rax
    7ee6:	48 85 c0             	test   %rax,%rax
    7ee9:	74 05                	je     7ef0 <cmd_read_option_value+0x174>
    7eeb:	80 38 00             	cmpb   $0x0,(%rax)
    7eee:	75 82                	jne    7e72 <cmd_read_option_value+0xf6>
}
    7ef0:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    7ef5:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    7efc:	00 00 
    7efe:	74 05                	je     7f05 <cmd_read_option_value+0x189>
    7f00:	e8 ab b5 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    7f05:	48 83 c4 10          	add    $0x10,%rsp
    7f09:	5b                   	pop    %rbx
    7f0a:	5d                   	pop    %rbp
    7f0b:	41 5c                	pop    %r12
    7f0d:	c3                   	retq   

0000000000007f0e <cmd_args_set_defaults>:
{
    7f0e:	f3 0f 1e fa          	endbr64 
    7f12:	55                   	push   %rbp
	int count = 0;
    7f13:	31 ed                	xor    %ebp,%ebp
{
    7f15:	53                   	push   %rbx
    7f16:	48 89 fb             	mov    %rdi,%rbx
    7f19:	52                   	push   %rdx
	while (args_struct[count].option != NULL) {
    7f1a:	48 63 d5             	movslq %ebp,%rdx
    7f1d:	48 6b d2 38          	imul   $0x38,%rdx,%rdx
    7f21:	48 01 da             	add    %rbx,%rdx
    7f24:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
    7f29:	0f 84 a0 00 00 00    	je     7fcf <cmd_args_set_defaults+0xc1>
		if (args_struct[count].dest == NULL) {
    7f2f:	48 8b 42 20          	mov    0x20(%rdx),%rax
    7f33:	ff c5                	inc    %ebp
    7f35:	48 85 c0             	test   %rax,%rax
    7f38:	74 e0                	je     7f1a <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    7f3a:	0f be 72 18          	movsbl 0x18(%rdx),%esi
    7f3e:	40 80 fe 64          	cmp    $0x64,%sil
    7f42:	74 69                	je     7fad <cmd_args_set_defaults+0x9f>
    7f44:	7f 2d                	jg     7f73 <cmd_args_set_defaults+0x65>
    7f46:	40 80 fe 55          	cmp    $0x55,%sil
    7f4a:	74 55                	je     7fa1 <cmd_args_set_defaults+0x93>
    7f4c:	7f 1a                	jg     7f68 <cmd_args_set_defaults+0x5a>
    7f4e:	40 84 f6             	test   %sil,%sil
    7f51:	74 c7                	je     7f1a <cmd_args_set_defaults+0xc>
    7f53:	40 80 fe 49          	cmp    $0x49,%sil
    7f57:	75 63                	jne    7fbc <cmd_args_set_defaults+0xae>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
    7f59:	48 b9 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rcx
    7f60:	ff ff 7f 
    7f63:	48 89 08             	mov    %rcx,(%rax)
			break;
    7f66:	eb b2                	jmp    7f1a <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    7f68:	40 80 fe 62          	cmp    $0x62,%sil
    7f6c:	75 4e                	jne    7fbc <cmd_args_set_defaults+0xae>
			*(bool *)args_struct[count].dest = false;
    7f6e:	c6 00 00             	movb   $0x0,(%rax)
			break;
    7f71:	eb a7                	jmp    7f1a <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    7f73:	40 80 fe 73          	cmp    $0x73,%sil
    7f77:	74 14                	je     7f8d <cmd_args_set_defaults+0x7f>
    7f79:	40 80 fe 75          	cmp    $0x75,%sil
    7f7d:	74 17                	je     7f96 <cmd_args_set_defaults+0x88>
    7f7f:	40 80 fe 69          	cmp    $0x69,%sil
    7f83:	75 37                	jne    7fbc <cmd_args_set_defaults+0xae>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
    7f85:	c7 00 ff ff ff 7f    	movl   $0x7fffffff,(%rax)
			break;
    7f8b:	eb 8d                	jmp    7f1a <cmd_args_set_defaults+0xc>
			*(char **)args_struct[count].dest = NULL;
    7f8d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			break;
    7f94:	eb 84                	jmp    7f1a <cmd_args_set_defaults+0xc>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
    7f96:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
			break;
    7f9c:	e9 79 ff ff ff       	jmpq   7f1a <cmd_args_set_defaults+0xc>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
    7fa1:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
			break;
    7fa8:	e9 6d ff ff ff       	jmpq   7f1a <cmd_args_set_defaults+0xc>
			*(double *)args_struct[count].dest = NAN;
    7fad:	48 8b 0d ec 22 00 00 	mov    0x22ec(%rip),%rcx        # a2a0 <default_cmd+0x40>
    7fb4:	48 89 08             	mov    %rcx,(%rax)
			break;
    7fb7:	e9 5e ff ff ff       	jmpq   7f1a <cmd_args_set_defaults+0xc>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    7fbc:	48 8d 3d 8a 32 00 00 	lea    0x328a(%rip),%rdi        # b24d <default_cmd+0xfed>
    7fc3:	31 c0                	xor    %eax,%eax
    7fc5:	e8 2c f9 ff ff       	callq  78f6 <posix_print_error_and_exit>
			break;
    7fca:	e9 4b ff ff ff       	jmpq   7f1a <cmd_args_set_defaults+0xc>
}
    7fcf:	58                   	pop    %rax
    7fd0:	5b                   	pop    %rbx
    7fd1:	5d                   	pop    %rbp
    7fd2:	c3                   	retq   

0000000000007fd3 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    7fd3:	f3 0f 1e fa          	endbr64 
    7fd7:	41 56                	push   %r14
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    7fd9:	be 01 00 00 00       	mov    $0x1,%esi
    7fde:	48 8d 0d 8d 32 00 00 	lea    0x328d(%rip),%rcx        # b272 <default_cmd+0x1012>
    7fe5:	48 8d 15 9f 32 00 00 	lea    0x329f(%rip),%rdx        # b28b <default_cmd+0x102b>
    7fec:	41 55                	push   %r13
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    7fee:	41 be 19 00 00 00    	mov    $0x19,%r14d
	int count = 0;
    7ff4:	45 31 ed             	xor    %r13d,%r13d
{
    7ff7:	41 54                	push   %r12
    7ff9:	49 89 fc             	mov    %rdi,%r12
    7ffc:	55                   	push   %rbp
    7ffd:	53                   	push   %rbx
    7ffe:	48 83 ec 50          	sub    $0x50,%rsp

	fprintf(stdout, "%s ", _HELP_SWITCH);
    8002:	48 8b 1d 9f 4f 00 00 	mov    0x4f9f(%rip),%rbx        # cfa8 <stdout@GLIBC_2.2.5>
{
    8009:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8010:	00 00 
    8012:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    8017:	31 c0                	xor    %eax,%eax

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    8019:	48 8d 6c 24 02       	lea    0x2(%rsp),%rbp
    801e:	48 8b 3b             	mov    (%rbx),%rdi
    8021:	e8 4a b6 ff ff       	callq  3670 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
    8026:	49 63 f5             	movslq %r13d,%rsi
    8029:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    802d:	4c 01 e6             	add    %r12,%rsi
    8030:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
    8035:	74 6e                	je     80a5 <cmd_print_switches_help+0xd2>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    8037:	48 89 ef             	mov    %rbp,%rdi
    803a:	e8 3e fb ff ff       	callq  7b7d <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    803f:	31 c0                	xor    %eax,%eax
    8041:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    8045:	48 89 ef             	mov    %rbp,%rdi
    8048:	f2 ae                	repnz scas %es:(%rdi),%al
    804a:	49 63 c6             	movslq %r14d,%rax
    804d:	48 f7 d1             	not    %rcx
    8050:	48 8d 44 01 ff       	lea    -0x1(%rcx,%rax,1),%rax
    8055:	48 83 f8 64          	cmp    $0x64,%rax
    8059:	76 19                	jbe    8074 <cmd_print_switches_help+0xa1>
    805b:	48 8b 3b             	mov    (%rbx),%rdi
    805e:	48 8d 15 a4 24 00 00 	lea    0x24a4(%rip),%rdx        # a509 <default_cmd+0x2a9>
    8065:	31 c0                	xor    %eax,%eax
			fprintf(stdout, "\n");
			printed_in_line = 0;
    8067:	45 31 f6             	xor    %r14d,%r14d
    806a:	be 01 00 00 00       	mov    $0x1,%esi
    806f:	e8 fc b5 ff ff       	callq  3670 <__fprintf_chk@plt>
    8074:	48 8b 3b             	mov    (%rbx),%rdi
    8077:	48 89 e9             	mov    %rbp,%rcx
    807a:	48 8d 15 ab 30 00 00 	lea    0x30ab(%rip),%rdx        # b12c <default_cmd+0xecc>
    8081:	31 c0                	xor    %eax,%eax
    8083:	be 01 00 00 00       	mov    $0x1,%esi
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
		count++;
    8088:	41 ff c5             	inc    %r13d
    808b:	e8 e0 b5 ff ff       	callq  3670 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
    8090:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    8094:	31 c0                	xor    %eax,%eax
    8096:	48 89 ef             	mov    %rbp,%rdi
    8099:	f2 ae                	repnz scas %es:(%rdi),%al
    809b:	48 f7 d1             	not    %rcx
    809e:	45 8d 74 0e ff       	lea    -0x1(%r14,%rcx,1),%r14d
		count++;
    80a3:	eb 81                	jmp    8026 <cmd_print_switches_help+0x53>
    80a5:	48 8b 3b             	mov    (%rbx),%rdi
    80a8:	31 c0                	xor    %eax,%eax
    80aa:	be 01 00 00 00       	mov    $0x1,%esi
    80af:	48 8d 15 53 24 00 00 	lea    0x2453(%rip),%rdx        # a509 <default_cmd+0x2a9>
    80b6:	e8 b5 b5 ff ff       	callq  3670 <__fprintf_chk@plt>
	}

	fprintf(stdout, "\n");
}
    80bb:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    80c0:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    80c7:	00 00 
    80c9:	74 05                	je     80d0 <cmd_print_switches_help+0xfd>
    80cb:	e8 e0 b3 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    80d0:	48 83 c4 50          	add    $0x50,%rsp
    80d4:	5b                   	pop    %rbx
    80d5:	5d                   	pop    %rbp
    80d6:	41 5c                	pop    %r12
    80d8:	41 5d                	pop    %r13
    80da:	41 5e                	pop    %r14
    80dc:	c3                   	retq   

00000000000080dd <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    80dd:	f3 0f 1e fa          	endbr64 
    80e1:	41 57                	push   %r15
    80e3:	4c 8d 3d 20 24 00 00 	lea    0x2420(%rip),%r15        # a50a <default_cmd+0x2aa>
    80ea:	41 56                	push   %r14
    80ec:	41 55                	push   %r13
	int ret;
	int count = 0;
    80ee:	45 31 ed             	xor    %r13d,%r13d
{
    80f1:	41 54                	push   %r12
    80f3:	49 89 fc             	mov    %rdi,%r12
    80f6:	55                   	push   %rbp
    80f7:	53                   	push   %rbx
    80f8:	48 83 ec 68          	sub    $0x68,%rsp
    80fc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8103:	00 00 
    8105:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    810a:	31 c0                	xor    %eax,%eax
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    810c:	e8 c2 fe ff ff       	callq  7fd3 <cmd_print_switches_help>

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
    8111:	48 8b 1d 90 4e 00 00 	mov    0x4e90(%rip),%rbx        # cfa8 <stdout@GLIBC_2.2.5>
    8118:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    811d:	31 c0                	xor    %eax,%eax
    811f:	4c 8d 0d 69 31 00 00 	lea    0x3169(%rip),%r9        # b28f <default_cmd+0x102f>
    8126:	4c 8d 05 45 31 00 00 	lea    0x3145(%rip),%r8        # b272 <default_cmd+0x1012>
    812d:	be 01 00 00 00       	mov    $0x1,%esi
    8132:	48 8b 3b             	mov    (%rbx),%rdi
    8135:	48 8d 15 65 31 00 00 	lea    0x3165(%rip),%rdx        # b2a1 <default_cmd+0x1041>
    813c:	e8 2f b5 ff ff       	callq  3670 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    8141:	49 63 ed             	movslq %r13d,%rbp
    8144:	48 6b ed 38          	imul   $0x38,%rbp,%rbp
    8148:	4c 01 e5             	add    %r12,%rbp
    814b:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
    8150:	0f 84 c8 00 00 00    	je     821e <cmd_print_long_help+0x141>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    8156:	4c 8d 44 24 12       	lea    0x12(%rsp),%r8
    815b:	48 89 ee             	mov    %rbp,%rsi
    815e:	4c 89 c7             	mov    %r8,%rdi
    8161:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    8166:	e8 12 fa ff ff       	callq  7b7d <cmd_gen_switch_syntax.constprop.0>
    816b:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    8170:	48 8b 3b             	mov    (%rbx),%rdi
    8173:	31 c0                	xor    %eax,%eax
    8175:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    817a:	48 8d 15 2b 31 00 00 	lea    0x312b(%rip),%rdx        # b2ac <default_cmd+0x104c>
    8181:	be 01 00 00 00       	mov    $0x1,%esi
    8186:	e8 e5 b4 ff ff       	callq  3670 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    818b:	4c 8b 75 30          	mov    0x30(%rbp),%r14
		total_to_print = strlen(toprint);
    818f:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    8193:	48 8d 15 19 31 00 00 	lea    0x3119(%rip),%rdx        # b2b3 <default_cmd+0x1053>
    819a:	41 89 c0             	mov    %eax,%r8d
    819d:	31 c0                	xor    %eax,%eax
    819f:	be 01 00 00 00       	mov    $0x1,%esi
    81a4:	4c 89 f7             	mov    %r14,%rdi
    81a7:	f2 ae                	repnz scas %es:(%rdi),%al
    81a9:	48 8b 3b             	mov    (%rbx),%rdi
    81ac:	48 f7 d1             	not    %rcx
    81af:	8d 41 ff             	lea    -0x1(%rcx),%eax
		ret = fprintf(stdout, "%.*s\n",
    81b2:	b9 64 00 00 00       	mov    $0x64,%ecx
		total_to_print = strlen(toprint);
    81b7:	89 44 24 08          	mov    %eax,0x8(%rsp)
		ret = fprintf(stdout, "%.*s\n",
    81bb:	44 29 c1             	sub    %r8d,%ecx
    81be:	31 c0                	xor    %eax,%eax
    81c0:	4d 89 f0             	mov    %r14,%r8
    81c3:	e8 a8 b4 ff ff       	callq  3670 <__fprintf_chk@plt>
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    81c8:	8d 68 ff             	lea    -0x1(%rax),%ebp

		while (printed_right < total_to_print) {
    81cb:	3b 6c 24 08          	cmp    0x8(%rsp),%ebp
    81cf:	7d 45                	jge    8216 <cmd_print_long_help+0x139>
    81d1:	48 8b 3b             	mov    (%rbx),%rdi
    81d4:	4d 89 f8             	mov    %r15,%r8
    81d7:	b9 1e 00 00 00       	mov    $0x1e,%ecx
    81dc:	be 01 00 00 00       	mov    $0x1,%esi
    81e1:	48 8d 15 d1 30 00 00 	lea    0x30d1(%rip),%rdx        # b2b9 <default_cmd+0x1059>
    81e8:	31 c0                	xor    %eax,%eax
    81ea:	e8 81 b4 ff ff       	callq  3670 <__fprintf_chk@plt>
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    81ef:	4c 63 c5             	movslq %ebp,%r8
    81f2:	48 8b 3b             	mov    (%rbx),%rdi
    81f5:	b9 46 00 00 00       	mov    $0x46,%ecx
    81fa:	4d 01 f0             	add    %r14,%r8
    81fd:	48 8d 15 af 30 00 00 	lea    0x30af(%rip),%rdx        # b2b3 <default_cmd+0x1053>
    8204:	be 01 00 00 00       	mov    $0x1,%esi
    8209:	31 c0                	xor    %eax,%eax
    820b:	e8 60 b4 ff ff       	callq  3670 <__fprintf_chk@plt>
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    8210:	8d 6c 05 ff          	lea    -0x1(%rbp,%rax,1),%ebp
    8214:	eb b5                	jmp    81cb <cmd_print_long_help+0xee>
		}
		count++;
    8216:	41 ff c5             	inc    %r13d
    8219:	e9 23 ff ff ff       	jmpq   8141 <cmd_print_long_help+0x64>
    821e:	48 8b 3b             	mov    (%rbx),%rdi
    8221:	48 8d 15 e1 22 00 00 	lea    0x22e1(%rip),%rdx        # a509 <default_cmd+0x2a9>
    8228:	be 01 00 00 00       	mov    $0x1,%esi
    822d:	31 c0                	xor    %eax,%eax
    822f:	e8 3c b4 ff ff       	callq  3670 <__fprintf_chk@plt>
    8234:	48 8b 3b             	mov    (%rbx),%rdi
    8237:	31 c0                	xor    %eax,%eax
    8239:	be 01 00 00 00       	mov    $0x1,%esi
    823e:	48 8d 15 78 30 00 00 	lea    0x3078(%rip),%rdx        # b2bd <default_cmd+0x105d>
    8245:	e8 26 b4 ff ff       	callq  3670 <__fprintf_chk@plt>
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    824a:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    824f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    8256:	00 00 
    8258:	74 05                	je     825f <cmd_print_long_help+0x182>
    825a:	e8 51 b2 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    825f:	48 83 c4 68          	add    $0x68,%rsp
    8263:	5b                   	pop    %rbx
    8264:	5d                   	pop    %rbp
    8265:	41 5c                	pop    %r12
    8267:	41 5d                	pop    %r13
    8269:	41 5e                	pop    %r14
    826b:	41 5f                	pop    %r15
    826d:	c3                   	retq   

000000000000826e <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    826e:	f3 0f 1e fa          	endbr64 
    8272:	41 56                	push   %r14
    8274:	41 55                	push   %r13
    8276:	49 89 f5             	mov    %rsi,%r13
    8279:	41 54                	push   %r12
    827b:	55                   	push   %rbp
    827c:	48 89 fd             	mov    %rdi,%rbp
    827f:	53                   	push   %rbx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    8280:	e8 8a fa ff ff       	callq  7d0f <cmd_is_help_option>
    8285:	85 c0                	test   %eax,%eax
    8287:	74 0f                	je     8298 <cmd_parse_one_arg+0x2a>
		cmd_print_long_help(args_struct);
    8289:	4c 89 ef             	mov    %r13,%rdi
    828c:	e8 4c fe ff ff       	callq  80dd <cmd_print_long_help>
		posix_exit(0);
    8291:	31 ff                	xor    %edi,%edi
    8293:	e8 62 f5 ff ff       	callq  77fa <posix_exit>
{
    8298:	45 31 f6             	xor    %r14d,%r14d
	}

	while (args_struct[count].option != NULL) {
    829b:	49 63 de             	movslq %r14d,%rbx
    829e:	48 6b db 38          	imul   $0x38,%rbx,%rbx
    82a2:	4c 01 eb             	add    %r13,%rbx
    82a5:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    82a9:	48 85 f6             	test   %rsi,%rsi
    82ac:	74 78                	je     8326 <cmd_parse_one_arg+0xb8>
		if (args_struct[count].manual) {
    82ae:	80 3b 00             	cmpb   $0x0,(%rbx)
    82b1:	75 6b                	jne    831e <cmd_parse_one_arg+0xb0>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
				    !args_struct[count].is_switch);
    82b3:	8a 53 02             	mov    0x2(%rbx),%dl
		ret = cmd_is_option(argv, args_struct[count].option,
    82b6:	48 89 ef             	mov    %rbp,%rdi
				    !args_struct[count].is_switch);
    82b9:	83 f2 01             	xor    $0x1,%edx
		ret = cmd_is_option(argv, args_struct[count].option,
    82bc:	0f b6 d2             	movzbl %dl,%edx
    82bf:	e8 9d f9 ff ff       	callq  7c61 <cmd_is_option>
    82c4:	41 89 c4             	mov    %eax,%r12d
		if (ret) {
    82c7:	85 c0                	test   %eax,%eax
    82c9:	74 53                	je     831e <cmd_parse_one_arg+0xb0>
	if (arg_element->dest != NULL) {
    82cb:	48 8b 73 20          	mov    0x20(%rbx),%rsi
    82cf:	48 85 f6             	test   %rsi,%rsi
    82d2:	74 33                	je     8307 <cmd_parse_one_arg+0x99>
		if (arg_element->is_switch) {
    82d4:	80 7b 02 00          	cmpb   $0x0,0x2(%rbx)
    82d8:	0f be 53 18          	movsbl 0x18(%rbx),%edx
    82dc:	74 1a                	je     82f8 <cmd_parse_one_arg+0x8a>
			if (arg_element->type == 'b') {
    82de:	80 fa 62             	cmp    $0x62,%dl
    82e1:	75 05                	jne    82e8 <cmd_parse_one_arg+0x7a>
				*(bool *)arg_element->dest = true;
    82e3:	c6 06 01             	movb   $0x1,(%rsi)
    82e6:	eb 1f                	jmp    8307 <cmd_parse_one_arg+0x99>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    82e8:	48 8d 3d 1e 30 00 00 	lea    0x301e(%rip),%rdi        # b30d <default_cmd+0x10ad>
    82ef:	31 c0                	xor    %eax,%eax
    82f1:	e8 00 f6 ff ff       	callq  78f6 <posix_print_error_and_exit>
    82f6:	eb 0f                	jmp    8307 <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
    82f8:	48 63 f8             	movslq %eax,%rdi
    82fb:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    82ff:	48 01 ef             	add    %rbp,%rdi
    8302:	e8 75 fa ff ff       	callq  7d7c <cmd_read_option_value>
	if (arg_element->call_when_found) {
    8307:	48 8b 53 28          	mov    0x28(%rbx),%rdx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    830b:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
    830d:	48 85 d2             	test   %rdx,%rdx
    8310:	74 16                	je     8328 <cmd_parse_one_arg+0xba>
		arg_element->call_when_found(argv, offset);
    8312:	44 89 e6             	mov    %r12d,%esi
    8315:	48 89 ef             	mov    %rbp,%rdi
    8318:	ff d2                	callq  *%rdx
			return true;
    831a:	b0 01                	mov    $0x1,%al
    831c:	eb 0a                	jmp    8328 <cmd_parse_one_arg+0xba>
    831e:	41 ff c6             	inc    %r14d
    8321:	e9 75 ff ff ff       	jmpq   829b <cmd_parse_one_arg+0x2d>
		}
		count++;
	}
	return false;
    8326:	31 c0                	xor    %eax,%eax
}
    8328:	5b                   	pop    %rbx
    8329:	5d                   	pop    %rbp
    832a:	41 5c                	pop    %r12
    832c:	41 5d                	pop    %r13
    832e:	41 5e                	pop    %r14
    8330:	c3                   	retq   

0000000000008331 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
    8331:	f3 0f 1e fa          	endbr64 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    8335:	48 8b 3d b4 82 00 00 	mov    0x82b4(%rip),%rdi        # 105f0 <args_struct>
    833c:	48 85 ff             	test   %rdi,%rdi
    833f:	74 13                	je     8354 <native_cleanup_cmd_line+0x23>
{
    8341:	50                   	push   %rax
		free(args_struct);
    8342:	e8 69 b0 ff ff       	callq  33b0 <free@plt>
		args_struct = NULL;
    8347:	48 c7 05 9e 82 00 00 	movq   $0x0,0x829e(%rip)        # 105f0 <args_struct>
    834e:	00 00 00 00 
	}
}
    8352:	5a                   	pop    %rdx
    8353:	c3                   	retq   
    8354:	c3                   	retq   

0000000000008355 <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    8355:	f3 0f 1e fa          	endbr64 
    8359:	41 54                	push   %r12
    835b:	55                   	push   %rbp
    835c:	48 89 fd             	mov    %rdi,%rbp
    835f:	53                   	push   %rbx
	int count = 0;
    8360:	31 db                	xor    %ebx,%ebx

	while (args[count].option != NULL) {
    8362:	48 63 c3             	movslq %ebx,%rax
    8365:	ff c3                	inc    %ebx
    8367:	48 6b c0 38          	imul   $0x38,%rax,%rax
    836b:	48 83 7c 05 08 00    	cmpq   $0x0,0x8(%rbp,%rax,1)
    8371:	75 ef                	jne    8362 <native_add_command_line_opts+0xd>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    8373:	8b 15 f3 82 00 00    	mov    0x82f3(%rip),%edx        # 1066c <used_args>
    8379:	8b 05 e9 82 00 00    	mov    0x82e9(%rip),%eax        # 10668 <args_aval>
    837f:	01 da                	add    %ebx,%edx
    8381:	39 c2                	cmp    %eax,%edx
    8383:	7c 44                	jl     83c9 <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    8385:	83 fb 14             	cmp    $0x14,%ebx
    8388:	41 bc 14 00 00 00    	mov    $0x14,%r12d
		struct args_struct_t *new_args_struct = realloc(args_struct,
    838e:	48 8b 3d 5b 82 00 00 	mov    0x825b(%rip),%rdi        # 105f0 <args_struct>
				      (args_aval + growby)*
    8395:	44 0f 4d e3          	cmovge %ebx,%r12d
    8399:	41 01 c4             	add    %eax,%r12d
    839c:	49 63 f4             	movslq %r12d,%rsi
		struct args_struct_t *new_args_struct = realloc(args_struct,
    839f:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    83a3:	e8 28 b2 ff ff       	callq  35d0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
    83a8:	44 89 25 b9 82 00 00 	mov    %r12d,0x82b9(%rip)        # 10668 <args_aval>
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    83af:	48 85 c0             	test   %rax,%rax
    83b2:	75 0e                	jne    83c2 <native_add_command_line_opts+0x6d>
			posix_print_error_and_exit("Could not allocate memory");
    83b4:	48 8d 3d 9d 2f 00 00 	lea    0x2f9d(%rip),%rdi        # b358 <default_cmd+0x10f8>
    83bb:	e8 36 f5 ff ff       	callq  78f6 <posix_print_error_and_exit>
    83c0:	eb 07                	jmp    83c9 <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
    83c2:	48 89 05 27 82 00 00 	mov    %rax,0x8227(%rip)        # 105f0 <args_struct>
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    83c9:	48 63 05 9c 82 00 00 	movslq 0x829c(%rip),%rax        # 1066c <used_args>
    83d0:	48 63 cb             	movslq %ebx,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    83d3:	48 89 ee             	mov    %rbp,%rsi
    83d6:	48 6b c9 38          	imul   $0x38,%rcx,%rcx
    83da:	48 89 c2             	mov    %rax,%rdx
    83dd:	48 6b c0 38          	imul   $0x38,%rax,%rax
    83e1:	48 03 05 08 82 00 00 	add    0x8208(%rip),%rax        # 105f0 <args_struct>
    83e8:	48 89 c7             	mov    %rax,%rdi
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    83eb:	8d 44 1a ff          	lea    -0x1(%rdx,%rbx,1),%eax
    83ef:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    83f1:	89 05 75 82 00 00    	mov    %eax,0x8275(%rip)        # 1066c <used_args>
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    83f7:	5b                   	pop    %rbx
    83f8:	5d                   	pop    %rbp
    83f9:	41 5c                	pop    %r12
    83fb:	c3                   	retq   

00000000000083fc <native_add_testargs_option>:

void native_add_testargs_option(void)
{
    83fc:	f3 0f 1e fa          	endbr64 
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    8400:	48 8d 3d 99 4e 00 00 	lea    0x4e99(%rip),%rdi        # d2a0 <testargs_options.2552>
    8407:	e9 49 ff ff ff       	jmpq   8355 <native_add_command_line_opts>

000000000000840c <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    840c:	f3 0f 1e fa          	endbr64 
    8410:	41 57                	push   %r15

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    8412:	4c 8d 3d 59 2f 00 00 	lea    0x2f59(%rip),%r15        # b372 <default_cmd+0x1112>
{
    8419:	41 56                	push   %r14
    841b:	41 55                	push   %r13
    841d:	41 54                	push   %r12
    841f:	49 89 f4             	mov    %rsi,%r12
    8422:	55                   	push   %rbp
	for (i = 1; i < argc; i++) {
    8423:	bd 01 00 00 00       	mov    $0x1,%ebp
{
    8428:	53                   	push   %rbx
    8429:	89 fb                	mov    %edi,%ebx
    842b:	52                   	push   %rdx
	native_add_tracing_options();
    842c:	e8 3c f7 ff ff       	callq  7b6d <native_add_tracing_options>
	native_add_testargs_option();
    8431:	e8 c6 ff ff ff       	callq  83fc <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
    8436:	48 8b 3d b3 81 00 00 	mov    0x81b3(%rip),%rdi        # 105f0 <args_struct>
	s_argv = argv;
    843d:	4c 89 25 bc 81 00 00 	mov    %r12,0x81bc(%rip)        # 10600 <s_argv>
	s_argc = argc;
    8444:	89 1d 2a 82 00 00    	mov    %ebx,0x822a(%rip)        # 10674 <s_argc>
	cmd_args_set_defaults(args_struct);
    844a:	e8 bf fa ff ff       	callq  7f0e <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
    844f:	41 89 ee             	mov    %ebp,%r14d
    8452:	39 eb                	cmp    %ebp,%ebx
    8454:	7e 65                	jle    84bb <native_handle_cmd_line+0xaf>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
    8456:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    845a:	31 d2                	xor    %edx,%edx
    845c:	4c 89 fe             	mov    %r15,%rsi
    845f:	4c 8d 6d 01          	lea    0x1(%rbp),%r13
    8463:	e8 f9 f7 ff ff       	callq  7c61 <cmd_is_option>
    8468:	85 c0                	test   %eax,%eax
    846a:	74 18                	je     8484 <native_handle_cmd_line+0x78>
			test_argc = argc - i - 1;
    846c:	ff cb                	dec    %ebx
			test_argv = &argv[i+1];
    846e:	4b 8d 04 ec          	lea    (%r12,%r13,8),%rax
			test_argc = argc - i - 1;
    8472:	44 29 f3             	sub    %r14d,%ebx
			test_argv = &argv[i+1];
    8475:	48 89 05 7c 81 00 00 	mov    %rax,0x817c(%rip)        # 105f8 <test_argv>
			test_argc = argc - i - 1;
    847c:	89 1d ee 81 00 00    	mov    %ebx,0x81ee(%rip)        # 10670 <test_argc>
			break;
    8482:	eb 37                	jmp    84bb <native_handle_cmd_line+0xaf>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    8484:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    8488:	48 8b 35 61 81 00 00 	mov    0x8161(%rip),%rsi        # 105f0 <args_struct>
    848f:	e8 da fd ff ff       	callq  826e <cmd_parse_one_arg>
    8494:	84 c0                	test   %al,%al
    8496:	75 1e                	jne    84b6 <native_handle_cmd_line+0xaa>
			cmd_print_switches_help(args_struct);
    8498:	48 8b 3d 51 81 00 00 	mov    0x8151(%rip),%rdi        # 105f0 <args_struct>
    849f:	e8 2f fb ff ff       	callq  7fd3 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    84a4:	49 8b 34 ec          	mov    (%r12,%rbp,8),%rsi
    84a8:	48 8d 3d cc 2e 00 00 	lea    0x2ecc(%rip),%rdi        # b37b <default_cmd+0x111b>
    84af:	31 c0                	xor    %eax,%eax
    84b1:	e8 40 f4 ff ff       	callq  78f6 <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
    84b6:	4c 89 ed             	mov    %r13,%rbp
    84b9:	eb 94                	jmp    844f <native_handle_cmd_line+0x43>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    84bb:	58                   	pop    %rax
    84bc:	5b                   	pop    %rbx
    84bd:	5d                   	pop    %rbp
    84be:	41 5c                	pop    %r12
    84c0:	41 5d                	pop    %r13
    84c2:	41 5e                	pop    %r14
    84c4:	41 5f                	pop    %r15
    84c6:	c3                   	retq   

00000000000084c7 <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
    84c7:	f3 0f 1e fa          	endbr64 
	hw_counter_timer = NEVER;
    84cb:	48 8d 05 4e 81 00 00 	lea    0x814e(%rip),%rax        # 10620 <hw_counter_timer>
	counter_target = NEVER;
	counter_value = 0;
	counter_running = false;
    84d2:	c6 05 bb 81 00 00 00 	movb   $0x0,0x81bb(%rip)        # 10694 <counter_running>
	counter_target = NEVER;
    84d9:	48 c7 05 2c 81 00 00 	movq   $0xffffffffffffffff,0x812c(%rip)        # 10610 <counter_target>
    84e0:	ff ff ff ff 
	hw_counter_timer = NEVER;
    84e4:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	counter_value = 0;
    84eb:	48 c7 05 22 81 00 00 	movq   $0x0,0x8122(%rip)        # 10618 <counter_value>
    84f2:	00 00 00 00 
	counter_period = NEVER;
    84f6:	48 c7 05 07 81 00 00 	movq   $0xffffffffffffffff,0x8107(%rip)        # 10608 <counter_period>
    84fd:	ff ff ff ff 
}
    8501:	c3                   	retq   

0000000000008502 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
    8502:	f3 0f 1e fa          	endbr64 
	if (!counter_running) {
    8506:	80 3d 87 81 00 00 00 	cmpb   $0x0,0x8187(%rip)        # 10694 <counter_running>
{
    850d:	53                   	push   %rbx
    850e:	48 8d 1d 0b 81 00 00 	lea    0x810b(%rip),%rbx        # 10620 <hw_counter_timer>
	if (!counter_running) {
    8515:	75 09                	jne    8520 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
    8517:	48 c7 03 ff ff ff ff 	movq   $0xffffffffffffffff,(%rbx)
		return;
    851e:	eb 34                	jmp    8554 <hw_counter_triggered+0x52>
	}

	hw_counter_timer = hwm_get_time() + counter_period;
    8520:	e8 da e9 ff ff       	callq  6eff <hwm_get_time>
    8525:	48 03 05 dc 80 00 00 	add    0x80dc(%rip),%rax        # 10608 <counter_period>
    852c:	48 89 03             	mov    %rax,(%rbx)
	counter_value = counter_value + 1;
    852f:	48 8b 05 e2 80 00 00 	mov    0x80e2(%rip),%rax        # 10618 <counter_value>
    8536:	48 ff c0             	inc    %rax

	if (counter_value == counter_target) {
    8539:	48 3b 05 d0 80 00 00 	cmp    0x80d0(%rip),%rax        # 10610 <counter_target>
	counter_value = counter_value + 1;
    8540:	48 89 05 d1 80 00 00 	mov    %rax,0x80d1(%rip)        # 10618 <counter_value>
	if (counter_value == counter_target) {
    8547:	75 0b                	jne    8554 <hw_counter_triggered+0x52>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    8549:	bf 02 00 00 00       	mov    $0x2,%edi
	}
}
    854e:	5b                   	pop    %rbx
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    854f:	e9 19 f2 ff ff       	jmpq   776d <hw_irq_ctrl_set_irq>
}
    8554:	5b                   	pop    %rbx
    8555:	c3                   	retq   

0000000000008556 <tc_query_caps>:

	return 0;
}

static int tc_query_caps(const struct device *dev)
{
    8556:	f3 0f 1e fa          	endbr64 
	return (CAP_RAW_KEY | CAP_SEPARATE_IO_BUFS | CAP_SYNC_OPS);
}
    855a:	b8 32 00 00 00       	mov    $0x32,%eax
    855f:	c3                   	retq   

0000000000008560 <tc_shim_init>:

	return 0;
}

static int tc_shim_init(const struct device *dev)
{
    8560:	f3 0f 1e fa          	endbr64 
	int i;

	ARG_UNUSED(dev);
	for (i = 0; i < CRYPTO_MAX_SESSION; i++) {
		tc_driver_state[i].in_use = 0;
    8564:	c7 05 d2 7c 00 00 00 	movl   $0x0,0x7cd2(%rip)        # 10240 <tc_driver_state>
    856b:	00 00 00 
	}

	return 0;
}
    856e:	31 c0                	xor    %eax,%eax
		tc_driver_state[i].in_use = 0;
    8570:	c7 05 7a 7d 00 00 00 	movl   $0x0,0x7d7a(%rip)        # 102f4 <tc_driver_state+0xb4>
    8577:	00 00 00 
}
    857a:	c3                   	retq   

000000000000857b <tc_session_free>:
{
    857b:	f3 0f 1e fa          	endbr64 
	struct tc_shim_drv_state *data =  sessn->drv_sessn_state;
    857f:	48 8b 56 20          	mov    0x20(%rsi),%rdx
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    8583:	31 c0                	xor    %eax,%eax
    8585:	b9 2d 00 00 00       	mov    $0x2d,%ecx
    858a:	48 89 d7             	mov    %rdx,%rdi
    858d:	f3 ab                	rep stos %eax,%es:(%rdi)
}
    858f:	c3                   	retq   

0000000000008590 <tc_session_setup>:
{
    8590:	f3 0f 1e fa          	endbr64 
	if (algo != CRYPTO_CIPHER_ALGO_AES) {
    8594:	ff ca                	dec    %edx
		return -EINVAL;
    8596:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (algo != CRYPTO_CIPHER_ALGO_AES) {
    859b:	0f 85 fb 00 00 00    	jne    869c <tc_session_setup+0x10c>
{
    85a1:	55                   	push   %rbp
    85a2:	53                   	push   %rbx
    85a3:	48 89 f3             	mov    %rsi,%rbx
    85a6:	57                   	push   %rdi
	if (!(ctx->flags & CAP_SYNC_OPS)) {
    85a7:	f6 46 36 20          	testb  $0x20,0x36(%rsi)
    85ab:	0f 84 e7 00 00 00    	je     8698 <tc_session_setup+0x108>
	if (ctx->keylen != TC_AES_KEY_SIZE) {
    85b1:	66 83 7e 34 10       	cmpw   $0x10,0x34(%rsi)
    85b6:	0f 85 dc 00 00 00    	jne    8698 <tc_session_setup+0x108>
	if (op_type == CRYPTO_CIPHER_OP_ENCRYPT) {
    85bc:	41 ff c8             	dec    %r8d
    85bf:	75 1c                	jne    85dd <tc_session_setup+0x4d>
		switch (mode) {
    85c1:	83 f9 03             	cmp    $0x3,%ecx
    85c4:	74 1c                	je     85e2 <tc_session_setup+0x52>
    85c6:	83 f9 04             	cmp    $0x4,%ecx
    85c9:	74 2f                	je     85fa <tc_session_setup+0x6a>
    85cb:	83 f9 02             	cmp    $0x2,%ecx
    85ce:	0f 85 c4 00 00 00    	jne    8698 <tc_session_setup+0x108>
			ctx->ops.cbc_crypt_hndlr = do_cbc_encrypt;
    85d4:	48 8d 05 0e 03 00 00 	lea    0x30e(%rip),%rax        # 88e9 <do_cbc_encrypt>
    85db:	eb 49                	jmp    8626 <tc_session_setup+0x96>
		switch (mode) {
    85dd:	83 f9 03             	cmp    $0x3,%ecx
    85e0:	75 21                	jne    8603 <tc_session_setup+0x73>
			if (ctx->mode_params.ctr_info.ctr_len != 32U) {
    85e2:	83 7b 30 20          	cmpl   $0x20,0x30(%rbx)
		return -EINVAL;
    85e6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			if (ctx->mode_params.ctr_info.ctr_len != 32U) {
    85eb:	0f 85 a7 00 00 00    	jne    8698 <tc_session_setup+0x108>
			ctx->ops.ctr_crypt_hndlr = do_ctr_op;
    85f1:	48 8d 05 5a 02 00 00 	lea    0x25a(%rip),%rax        # 8852 <do_ctr_op>
    85f8:	eb 2c                	jmp    8626 <tc_session_setup+0x96>
			ctx->ops.ccm_crypt_hndlr = do_ccm_encrypt_mac;
    85fa:	48 8d 05 a1 01 00 00 	lea    0x1a1(%rip),%rax        # 87a2 <do_ccm_encrypt_mac>
    8601:	eb 23                	jmp    8626 <tc_session_setup+0x96>
		switch (mode) {
    8603:	83 f9 04             	cmp    $0x4,%ecx
    8606:	74 17                	je     861f <tc_session_setup+0x8f>
    8608:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    860d:	83 f9 02             	cmp    $0x2,%ecx
    8610:	0f 85 82 00 00 00    	jne    8698 <tc_session_setup+0x108>
			ctx->ops.cbc_crypt_hndlr = do_cbc_decrypt;
    8616:	48 8d 05 3c 01 00 00 	lea    0x13c(%rip),%rax        # 8759 <do_cbc_decrypt>
    861d:	eb 07                	jmp    8626 <tc_session_setup+0x96>
			ctx->ops.ccm_crypt_hndlr = do_ccm_decrypt_auth;
    861f:	48 8d 05 77 00 00 00 	lea    0x77(%rip),%rax        # 869d <do_ccm_decrypt_auth>
    8626:	48 89 43 08          	mov    %rax,0x8(%rbx)
		if (tc_driver_state[i].in_use == 0) {
    862a:	48 63 05 0f 7c 00 00 	movslq 0x7c0f(%rip),%rax        # 10240 <tc_driver_state>
	ctx->ops.cipher_mode = mode;
    8631:	89 0b                	mov    %ecx,(%rbx)
		if (tc_driver_state[i].in_use == 0) {
    8633:	85 c0                	test   %eax,%eax
    8635:	74 1f                	je     8656 <tc_session_setup+0xc6>
    8637:	83 3d b6 7c 00 00 00 	cmpl   $0x0,0x7cb6(%rip)        # 102f4 <tc_driver_state+0xb4>
		return -ENOSPC;
    863e:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
		if (tc_driver_state[i].in_use == 0) {
    8643:	75 53                	jne    8698 <tc_session_setup+0x108>
			tc_driver_state[i].in_use = 1;
    8645:	c7 05 a5 7c 00 00 01 	movl   $0x1,0x7ca5(%rip)        # 102f4 <tc_driver_state+0xb4>
    864c:	00 00 00 
	for (i = 0; i < CRYPTO_MAX_SESSION; i++) {
    864f:	b8 01 00 00 00       	mov    $0x1,%eax
    8654:	eb 0a                	jmp    8660 <tc_session_setup+0xd0>
			tc_driver_state[i].in_use = 1;
    8656:	c7 05 e0 7b 00 00 01 	movl   $0x1,0x7be0(%rip)        # 10240 <tc_driver_state>
    865d:	00 00 00 
	data = &tc_driver_state[idx];
    8660:	48 69 c0 b4 00 00 00 	imul   $0xb4,%rax,%rax
    8667:	48 8d 15 d2 7b 00 00 	lea    0x7bd2(%rip),%rdx        # 10240 <tc_driver_state>
	if (tc_aes128_set_encrypt_key(&data->session_key, ctx->key.bit_stream)
    866e:	48 8b 73 10          	mov    0x10(%rbx),%rsi
    8672:	48 8d 7c 02 04       	lea    0x4(%rdx,%rax,1),%rdi
	data = &tc_driver_state[idx];
    8677:	48 8d 2c 10          	lea    (%rax,%rdx,1),%rbp
	if (tc_aes128_set_encrypt_key(&data->session_key, ctx->key.bit_stream)
    867b:	e8 48 d3 ff ff       	callq  59c8 <tc_aes128_set_encrypt_key>
    8680:	85 c0                	test   %eax,%eax
    8682:	75 0e                	jne    8692 <tc_session_setup+0x102>
		tc_driver_state[idx].in_use = 0;
    8684:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%rbp)
		return -EIO;
    868b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    8690:	eb 06                	jmp    8698 <tc_session_setup+0x108>
	ctx->drv_sessn_state = data;
    8692:	48 89 6b 20          	mov    %rbp,0x20(%rbx)
	return 0;
    8696:	31 c0                	xor    %eax,%eax
}
    8698:	5a                   	pop    %rdx
    8699:	5b                   	pop    %rbx
    869a:	5d                   	pop    %rbp
    869b:	c3                   	retq   
    869c:	c3                   	retq   

000000000000869d <do_ccm_decrypt_auth>:
{
    869d:	f3 0f 1e fa          	endbr64 
    86a1:	41 55                	push   %r13
    86a3:	41 54                	push   %r12
    86a5:	49 89 f4             	mov    %rsi,%r12
    86a8:	55                   	push   %rbp
    86a9:	53                   	push   %rbx
    86aa:	48 89 fb             	mov    %rdi,%rbx
    86ad:	48 83 ec 28          	sub    $0x28,%rsp
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    86b1:	0f b7 4f 32          	movzwl 0x32(%rdi),%ecx
    86b5:	44 0f b7 47 30       	movzwl 0x30(%rdi),%r8d
{
    86ba:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    86c1:	00 00 
    86c3:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    86c8:	31 c0                	xor    %eax,%eax
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    86ca:	48 8b 47 20          	mov    0x20(%rdi),%rax
    86ce:	49 89 e5             	mov    %rsp,%r13
	struct cipher_pkt *op = aead_op->pkt;
    86d1:	48 8b 2e             	mov    (%rsi),%rbp
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    86d4:	4c 89 ef             	mov    %r13,%rdi
    86d7:	48 8d 70 04          	lea    0x4(%rax),%rsi
    86db:	e8 1a da ff ff       	callq  60fa <tc_ccm_config>
    86e0:	85 c0                	test   %eax,%eax
    86e2:	75 07                	jne    86eb <do_ccm_decrypt_auth+0x4e>
		return -EIO;
    86e4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    86e9:	eb 4e                	jmp    8739 <do_ccm_decrypt_auth+0x9c>
	if (aead_op->tag != op->in_buf + op->in_len) {
    86eb:	48 63 45 08          	movslq 0x8(%rbp),%rax
    86ef:	4c 8b 45 00          	mov    0x0(%rbp),%r8
    86f3:	48 89 c2             	mov    %rax,%rdx
    86f6:	4c 01 c0             	add    %r8,%rax
    86f9:	49 39 44 24 18       	cmp    %rax,0x18(%r12)
    86fe:	75 e4                	jne    86e4 <do_ccm_decrypt_auth+0x47>
	if (tc_ccm_decryption_verification(op->out_buf, op->out_buf_max,
    8700:	4d 8b 54 24 08       	mov    0x8(%r12),%r10
    8705:	8b 75 18             	mov    0x18(%rbp),%esi
    8708:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
					   op->in_len + ccm_param->tag_len,
    870c:	0f b7 43 30          	movzwl 0x30(%rbx),%eax
	if (tc_ccm_decryption_verification(op->out_buf, op->out_buf_max,
    8710:	41 51                	push   %r9
    8712:	41 55                	push   %r13
    8714:	41 8b 4c 24 10       	mov    0x10(%r12),%ecx
    8719:	44 8d 0c 10          	lea    (%rax,%rdx,1),%r9d
    871d:	4c 89 d2             	mov    %r10,%rdx
    8720:	e8 d5 db ff ff       	callq  62fa <tc_ccm_decryption_verification>
    8725:	41 5a                	pop    %r10
    8727:	41 5b                	pop    %r11
    8729:	85 c0                	test   %eax,%eax
    872b:	74 b7                	je     86e4 <do_ccm_decrypt_auth+0x47>
	op->out_len = op->in_len + ccm_param->tag_len;
    872d:	0f b7 43 30          	movzwl 0x30(%rbx),%eax
    8731:	03 45 08             	add    0x8(%rbp),%eax
    8734:	89 45 1c             	mov    %eax,0x1c(%rbp)
	return 0;
    8737:	31 c0                	xor    %eax,%eax
}
    8739:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    873e:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    8745:	00 00 
    8747:	74 05                	je     874e <do_ccm_decrypt_auth+0xb1>
    8749:	e8 62 ad ff ff       	callq  34b0 <__stack_chk_fail@plt>
    874e:	48 83 c4 28          	add    $0x28,%rsp
    8752:	5b                   	pop    %rbx
    8753:	5d                   	pop    %rbp
    8754:	41 5c                	pop    %r12
    8756:	41 5d                	pop    %r13
    8758:	c3                   	retq   

0000000000008759 <do_cbc_decrypt>:
{
    8759:	f3 0f 1e fa          	endbr64 
	if (iv != op->in_buf) {
    875d:	4c 8b 06             	mov    (%rsi),%r8
	struct tc_shim_drv_state *data =  ctx->drv_sessn_state;
    8760:	48 8b 47 20          	mov    0x20(%rdi),%rax
	if (iv != op->in_buf) {
    8764:	49 39 d0             	cmp    %rdx,%r8
    8767:	75 33                	jne    879c <do_cbc_decrypt+0x43>
{
    8769:	53                   	push   %rbx
    876a:	48 89 f3             	mov    %rsi,%rbx
			op->in_len - TC_AES_BLOCK_SIZE,
    876d:	8b 4e 08             	mov    0x8(%rsi),%ecx
			op->in_buf + TC_AES_BLOCK_SIZE,
    8770:	49 8d 50 10          	lea    0x10(%r8),%rdx
	if (tc_cbc_mode_decrypt(op->out_buf,
    8774:	8b 76 18             	mov    0x18(%rsi),%esi
    8777:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    877b:	4c 8d 48 04          	lea    0x4(%rax),%r9
			op->in_len - TC_AES_BLOCK_SIZE,
    877f:	83 e9 10             	sub    $0x10,%ecx
	if (tc_cbc_mode_decrypt(op->out_buf,
    8782:	e8 f1 d5 ff ff       	callq  5d78 <tc_cbc_mode_decrypt>
    8787:	85 c0                	test   %eax,%eax
    8789:	75 07                	jne    8792 <do_cbc_decrypt+0x39>
		return -EIO;
    878b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    8790:	eb 08                	jmp    879a <do_cbc_decrypt+0x41>
	op->out_len = op->in_len;
    8792:	8b 43 08             	mov    0x8(%rbx),%eax
    8795:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    8798:	31 c0                	xor    %eax,%eax
}
    879a:	5b                   	pop    %rbx
    879b:	c3                   	retq   
		return -EIO;
    879c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    87a1:	c3                   	retq   

00000000000087a2 <do_ccm_encrypt_mac>:
{
    87a2:	f3 0f 1e fa          	endbr64 
    87a6:	41 54                	push   %r12
    87a8:	55                   	push   %rbp
    87a9:	48 89 f5             	mov    %rsi,%rbp
    87ac:	53                   	push   %rbx
    87ad:	48 83 ec 20          	sub    $0x20,%rsp
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    87b1:	0f b7 4f 32          	movzwl 0x32(%rdi),%ecx
    87b5:	44 0f b7 47 30       	movzwl 0x30(%rdi),%r8d
{
    87ba:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    87c1:	00 00 
    87c3:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    87c8:	31 c0                	xor    %eax,%eax
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    87ca:	48 8b 47 20          	mov    0x20(%rdi),%rax
    87ce:	49 89 e4             	mov    %rsp,%r12
	struct cipher_pkt *op = aead_op->pkt;
    87d1:	48 8b 1e             	mov    (%rsi),%rbx
	if (tc_ccm_config(&ccm, &data->session_key, nonce,
    87d4:	4c 89 e7             	mov    %r12,%rdi
    87d7:	48 8d 70 04          	lea    0x4(%rax),%rsi
    87db:	e8 1a d9 ff ff       	callq  60fa <tc_ccm_config>
    87e0:	85 c0                	test   %eax,%eax
    87e2:	75 07                	jne    87eb <do_ccm_encrypt_mac+0x49>
		return -EIO;
    87e4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    87e9:	eb 49                	jmp    8834 <do_ccm_encrypt_mac+0x92>
	if (tc_ccm_generation_encryption(op->out_buf, op->out_buf_max,
    87eb:	44 8b 4b 08          	mov    0x8(%rbx),%r9d
    87ef:	8b 73 18             	mov    0x18(%rbx),%esi
    87f2:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    87f6:	8b 4d 10             	mov    0x10(%rbp),%ecx
    87f9:	50                   	push   %rax
    87fa:	48 8b 55 08          	mov    0x8(%rbp),%rdx
    87fe:	4c 8b 03             	mov    (%rbx),%r8
    8801:	41 54                	push   %r12
    8803:	e8 3c d9 ff ff       	callq  6144 <tc_ccm_generation_encryption>
    8808:	5a                   	pop    %rdx
    8809:	59                   	pop    %rcx
    880a:	85 c0                	test   %eax,%eax
    880c:	74 d6                	je     87e4 <do_ccm_encrypt_mac+0x42>
	if (aead_op->tag) {
    880e:	48 8b 45 18          	mov    0x18(%rbp),%rax
    8812:	48 85 c0             	test   %rax,%rax
    8815:	74 11                	je     8828 <do_ccm_encrypt_mac+0x86>
		memcpy(aead_op->tag, op->out_buf + op->in_len, ccm.mlen);
    8817:	48 63 73 08          	movslq 0x8(%rbx),%rsi
    881b:	8b 4c 24 10          	mov    0x10(%rsp),%ecx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    881f:	48 89 c7             	mov    %rax,%rdi
    8822:	48 03 73 10          	add    0x10(%rbx),%rsi
    8826:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	op->out_len = op->in_len + ccm.mlen;
    8828:	8b 44 24 10          	mov    0x10(%rsp),%eax
    882c:	03 43 08             	add    0x8(%rbx),%eax
    882f:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    8832:	31 c0                	xor    %eax,%eax
}
    8834:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    8839:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    8840:	00 00 
    8842:	74 05                	je     8849 <do_ccm_encrypt_mac+0xa7>
    8844:	e8 67 ac ff ff       	callq  34b0 <__stack_chk_fail@plt>
    8849:	48 83 c4 20          	add    $0x20,%rsp
    884d:	5b                   	pop    %rbx
    884e:	5d                   	pop    %rbp
    884f:	41 5c                	pop    %r12
    8851:	c3                   	retq   

0000000000008852 <do_ctr_op>:
{
    8852:	f3 0f 1e fa          	endbr64 
    8856:	55                   	push   %rbp
	uint8_t ctr[16] = {0};	/* CTR mode Counter =  iv:ctr */
    8857:	0f 57 c0             	xorps  %xmm0,%xmm0
    885a:	b9 10 00 00 00       	mov    $0x10,%ecx
{
    885f:	53                   	push   %rbx
    8860:	48 89 f3             	mov    %rsi,%rbx
    8863:	48 89 d6             	mov    %rdx,%rsi
    8866:	48 83 ec 28          	sub    $0x28,%rsp
	int ivlen = ctx->keylen - (ctx->mode_params.ctr_info.ctr_len >> 3);
    886a:	0f b7 57 34          	movzwl 0x34(%rdi),%edx
	struct tc_shim_drv_state *data =  ctx->drv_sessn_state;
    886e:	48 8b 6f 20          	mov    0x20(%rdi),%rbp
{
    8872:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8879:	00 00 
    887b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    8880:	31 c0                	xor    %eax,%eax
	int ivlen = ctx->keylen - (ctx->mode_params.ctr_info.ctr_len >> 3);
    8882:	8b 47 30             	mov    0x30(%rdi),%eax
    8885:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
	uint8_t ctr[16] = {0};	/* CTR mode Counter =  iv:ctr */
    888a:	0f 11 44 24 08       	movups %xmm0,0x8(%rsp)
    888f:	4c 89 c7             	mov    %r8,%rdi
	int ivlen = ctx->keylen - (ctx->mode_params.ctr_info.ctr_len >> 3);
    8892:	c1 e8 03             	shr    $0x3,%eax
    8895:	29 c2                	sub    %eax,%edx
	memcpy(ctr, iv, ivlen);
    8897:	48 63 d2             	movslq %edx,%rdx
    889a:	e8 d1 ac ff ff       	callq  3570 <__memcpy_chk@plt>
	if (tc_ctr_mode(op->out_buf, op->out_buf_max, op->in_buf,
    889f:	8b 4b 08             	mov    0x8(%rbx),%ecx
    88a2:	8b 73 18             	mov    0x18(%rbx),%esi
    88a5:	4c 8d 4d 04          	lea    0x4(%rbp),%r9
    88a9:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    88ad:	48 8b 13             	mov    (%rbx),%rdx
    88b0:	49 89 c0             	mov    %rax,%r8
    88b3:	e8 8a d5 ff ff       	callq  5e42 <tc_ctr_mode>
    88b8:	41 89 c0             	mov    %eax,%r8d
    88bb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    88c0:	45 85 c0             	test   %r8d,%r8d
    88c3:	74 08                	je     88cd <do_ctr_op+0x7b>
	op->out_len = op->in_len;
    88c5:	8b 43 08             	mov    0x8(%rbx),%eax
    88c8:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    88cb:	31 c0                	xor    %eax,%eax
}
    88cd:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    88d2:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    88d9:	00 00 
    88db:	74 05                	je     88e2 <do_ctr_op+0x90>
    88dd:	e8 ce ab ff ff       	callq  34b0 <__stack_chk_fail@plt>
    88e2:	48 83 c4 28          	add    $0x28,%rsp
    88e6:	5b                   	pop    %rbx
    88e7:	5d                   	pop    %rbp
    88e8:	c3                   	retq   

00000000000088e9 <do_cbc_encrypt>:
{
    88e9:	f3 0f 1e fa          	endbr64 
    88ed:	53                   	push   %rbx
    88ee:	48 89 f3             	mov    %rsi,%rbx
	if (tc_cbc_mode_encrypt(op->out_buf,
    88f1:	48 8b 47 20          	mov    0x20(%rdi),%rax
{
    88f5:	49 89 d0             	mov    %rdx,%r8
	if (tc_cbc_mode_encrypt(op->out_buf,
    88f8:	8b 4e 08             	mov    0x8(%rsi),%ecx
    88fb:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    88ff:	8b 76 18             	mov    0x18(%rsi),%esi
    8902:	48 8b 13             	mov    (%rbx),%rdx
    8905:	4c 8d 48 04          	lea    0x4(%rax),%r9
    8909:	e8 41 d3 ff ff       	callq  5c4f <tc_cbc_mode_encrypt>
    890e:	41 89 c0             	mov    %eax,%r8d
    8911:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    8916:	45 85 c0             	test   %r8d,%r8d
    8919:	74 08                	je     8923 <do_cbc_encrypt+0x3a>
	op->out_len = op->in_len;
    891b:	8b 43 08             	mov    0x8(%rbx),%eax
    891e:	89 43 1c             	mov    %eax,0x1c(%rbx)
	return 0;
    8921:	31 c0                	xor    %eax,%eax
}
    8923:	5b                   	pop    %rbx
    8924:	c3                   	retq   

0000000000008925 <np_uart_tty_poll_in>:
 * @retval 0 If a character arrived and was stored in p_char
 * @retval -1 If no character was available to read
 */
static int np_uart_tty_poll_in(const struct device *dev,
			       unsigned char *p_char)
{
    8925:	f3 0f 1e fa          	endbr64 
    8929:	50                   	push   %rax
	int n = -1;
	int in_f = ((struct native_uart_status *)dev->data)->in_fd;
    892a:	48 8b 47 20          	mov    0x20(%rdi),%rax
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
    892e:	ba 01 00 00 00       	mov    $0x1,%edx
    8933:	8b 78 04             	mov    0x4(%rax),%edi
    8936:	e8 d5 ab ff ff       	callq  3510 <read@plt>
	n = read(in_f, p_char, 1);
	if (n == -1) {
		return -1;
	}
	return 0;
}
    893b:	5a                   	pop    %rdx
	if (n == -1) {
    893c:	ff c0                	inc    %eax
    893e:	0f 94 c0             	sete   %al
    8941:	0f b6 c0             	movzbl %al,%eax
    8944:	f7 d8                	neg    %eax
}
    8946:	c3                   	retq   

0000000000008947 <np_cleanup_uart>:

	native_add_command_line_opts(uart_options);
}

static void np_cleanup_uart(void)
{
    8947:	f3 0f 1e fa          	endbr64 
	if (IS_ENABLED(CONFIG_NATIVE_UART_0_ON_OWN_PTY)) {
		if (native_uart_status_0.in_fd != 0) {
    894b:	8b 3d db 7c 00 00    	mov    0x7cdb(%rip),%edi        # 1062c <native_uart_status_0+0x4>
    8951:	85 ff                	test   %edi,%edi
    8953:	74 05                	je     895a <np_cleanup_uart+0x13>
			close(native_uart_status_0.in_fd);
    8955:	e9 a6 ab ff ff       	jmpq   3500 <close@plt>
#if defined(CONFIG_UART_NATIVE_POSIX_PORT_1_ENABLE)
	if (native_uart_status_1.in_fd != 0) {
		close(native_uart_status_1.in_fd);
	}
#endif
}
    895a:	c3                   	retq   

000000000000895b <np_add_uart_options>:
{
    895b:	f3 0f 1e fa          	endbr64 
	native_add_command_line_opts(uart_options);
    895f:	48 8d 3d da 49 00 00 	lea    0x49da(%rip),%rdi        # d340 <uart_options.7281>
    8966:	e9 ea f9 ff ff       	jmpq   8355 <native_add_command_line_opts>

000000000000896b <np_uart_0_init>:
{
    896b:	f3 0f 1e fa          	endbr64 
    896f:	55                   	push   %rbp
    8970:	48 89 e5             	mov    %rsp,%rbp
    8973:	41 57                	push   %r15
    8975:	41 56                	push   %r14
    8977:	41 55                	push   %r13
    8979:	41 54                	push   %r12
    897b:	53                   	push   %rbx
    897c:	48 83 ec 68          	sub    $0x68,%rsp
	d = (struct native_uart_status *)dev->data;
    8980:	4c 8b 6f 20          	mov    0x20(%rdi),%r13
	master_pty = posix_openpt(O_RDWR | O_NOCTTY);
    8984:	bf 02 01 00 00       	mov    $0x102,%edi
		int tty_fn = open_tty(d, DT_INST_LABEL(0),
    8989:	44 8a 3d 05 7d 00 00 	mov    0x7d05(%rip),%r15b        # 10695 <auto_attach>
{
    8990:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8997:	00 00 
    8999:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    899d:	31 c0                	xor    %eax,%eax
	master_pty = posix_openpt(O_RDWR | O_NOCTTY);
    899f:	e8 ec ac ff ff       	callq  3690 <posix_openpt@plt>
    89a4:	89 c3                	mov    %eax,%ebx
	if (master_pty == -1) {
    89a6:	ff c0                	inc    %eax
    89a8:	75 0e                	jne    89b8 <np_uart_0_init+0x4d>
		ERROR("Could not open a new TTY for the UART\n");
    89aa:	48 8d 3d 86 2a 00 00 	lea    0x2a86(%rip),%rdi        # b437 <default_cmd+0x11d7>
    89b1:	31 c0                	xor    %eax,%eax
    89b3:	e8 3e ef ff ff       	callq  78f6 <posix_print_error_and_exit>
	ret = grantpt(master_pty);
    89b8:	89 df                	mov    %ebx,%edi
    89ba:	e8 71 ac ff ff       	callq  3630 <grantpt@plt>
	if (ret == -1) {
    89bf:	ff c0                	inc    %eax
    89c1:	75 21                	jne    89e4 <np_uart_0_init+0x79>
		err_nbr = errno;
    89c3:	e8 38 aa ff ff       	callq  3400 <__errno_location@plt>
		close(master_pty);
    89c8:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    89ca:	49 89 c4             	mov    %rax,%r12
		close(master_pty);
    89cd:	e8 2e ab ff ff       	callq  3500 <close@plt>
		ERROR("Could not grant access to the slave PTY side (%i)\n",
    89d2:	41 8b 34 24          	mov    (%r12),%esi
    89d6:	48 8d 3d 81 2a 00 00 	lea    0x2a81(%rip),%rdi        # b45e <default_cmd+0x11fe>
    89dd:	31 c0                	xor    %eax,%eax
    89df:	e8 12 ef ff ff       	callq  78f6 <posix_print_error_and_exit>
	ret = unlockpt(master_pty);
    89e4:	89 df                	mov    %ebx,%edi
    89e6:	e8 75 ab ff ff       	callq  3560 <unlockpt@plt>
	if (ret == -1) {
    89eb:	ff c0                	inc    %eax
    89ed:	75 21                	jne    8a10 <np_uart_0_init+0xa5>
		err_nbr = errno;
    89ef:	e8 0c aa ff ff       	callq  3400 <__errno_location@plt>
		close(master_pty);
    89f4:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    89f6:	49 89 c4             	mov    %rax,%r12
		close(master_pty);
    89f9:	e8 02 ab ff ff       	callq  3500 <close@plt>
		ERROR("Could not unlock the slave PTY side (%i)\n", errno);
    89fe:	41 8b 34 24          	mov    (%r12),%esi
    8a02:	48 8d 3d 88 2a 00 00 	lea    0x2a88(%rip),%rdi        # b491 <default_cmd+0x1231>
    8a09:	31 c0                	xor    %eax,%eax
    8a0b:	e8 e6 ee ff ff       	callq  78f6 <posix_print_error_and_exit>
	slave_pty_name = ptsname(master_pty);
    8a10:	89 df                	mov    %ebx,%edi
    8a12:	e8 79 a9 ff ff       	callq  3390 <ptsname@plt>
    8a17:	49 89 c4             	mov    %rax,%r12
	if (slave_pty_name == NULL) {
    8a1a:	48 85 c0             	test   %rax,%rax
    8a1d:	75 20                	jne    8a3f <np_uart_0_init+0xd4>
		err_nbr = errno;
    8a1f:	e8 dc a9 ff ff       	callq  3400 <__errno_location@plt>
		close(master_pty);
    8a24:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    8a26:	49 89 c6             	mov    %rax,%r14
		close(master_pty);
    8a29:	e8 d2 aa ff ff       	callq  3500 <close@plt>
		ERROR("Error getting slave PTY device name (%i)\n", errno);
    8a2e:	41 8b 36             	mov    (%r14),%esi
    8a31:	48 8d 3d 83 2a 00 00 	lea    0x2a83(%rip),%rdi        # b4bb <default_cmd+0x125b>
    8a38:	31 c0                	xor    %eax,%eax
    8a3a:	e8 b7 ee ff ff       	callq  78f6 <posix_print_error_and_exit>
	flags = fcntl(master_pty, F_GETFL);
    8a3f:	be 03 00 00 00       	mov    $0x3,%esi
    8a44:	89 df                	mov    %ebx,%edi
    8a46:	31 c0                	xor    %eax,%eax
    8a48:	e8 23 aa ff ff       	callq  3470 <fcntl@plt>
    8a4d:	41 89 c6             	mov    %eax,%r14d
	if (flags == -1) {
    8a50:	83 f8 ff             	cmp    $0xffffffff,%eax
    8a53:	75 2a                	jne    8a7f <np_uart_0_init+0x114>
		err_nbr = errno;
    8a55:	e8 a6 a9 ff ff       	callq  3400 <__errno_location@plt>
		close(master_pty);
    8a5a:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    8a5c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		close(master_pty);
    8a63:	e8 98 aa ff ff       	callq  3500 <close@plt>
		ERROR("Could not read the master PTY file status flags (%i)\n",
    8a68:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
    8a6f:	48 8d 3d 6f 2a 00 00 	lea    0x2a6f(%rip),%rdi        # b4e5 <default_cmd+0x1285>
    8a76:	31 c0                	xor    %eax,%eax
    8a78:	8b 32                	mov    (%rdx),%esi
    8a7a:	e8 77 ee ff ff       	callq  78f6 <posix_print_error_and_exit>
	ret = fcntl(master_pty, F_SETFL, flags | O_NONBLOCK);
    8a7f:	44 89 f2             	mov    %r14d,%edx
    8a82:	31 c0                	xor    %eax,%eax
    8a84:	be 04 00 00 00       	mov    $0x4,%esi
    8a89:	89 df                	mov    %ebx,%edi
    8a8b:	80 ce 08             	or     $0x8,%dh
    8a8e:	e8 dd a9 ff ff       	callq  3470 <fcntl@plt>
	if (ret == -1) {
    8a93:	ff c0                	inc    %eax
    8a95:	75 20                	jne    8ab7 <np_uart_0_init+0x14c>
		err_nbr = errno;
    8a97:	e8 64 a9 ff ff       	callq  3400 <__errno_location@plt>
		close(master_pty);
    8a9c:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    8a9e:	49 89 c6             	mov    %rax,%r14
		close(master_pty);
    8aa1:	e8 5a aa ff ff       	callq  3500 <close@plt>
		ERROR("Could not set the master PTY as non-blocking (%i)\n",
    8aa6:	41 8b 36             	mov    (%r14),%esi
    8aa9:	48 8d 3d 6b 2a 00 00 	lea    0x2a6b(%rip),%rdi        # b51b <default_cmd+0x12bb>
    8ab0:	31 c0                	xor    %eax,%eax
    8ab2:	e8 3f ee ff ff       	callq  78f6 <posix_print_error_and_exit>
	ret = tcgetattr(master_pty, &ter);
    8ab7:	4c 8d 75 8c          	lea    -0x74(%rbp),%r14
    8abb:	89 df                	mov    %ebx,%edi
    8abd:	4c 89 f6             	mov    %r14,%rsi
    8ac0:	e8 3b ab ff ff       	callq  3600 <tcgetattr@plt>
	if (ret == -1) {
    8ac5:	ff c0                	inc    %eax
    8ac7:	75 0e                	jne    8ad7 <np_uart_0_init+0x16c>
		ERROR("Could not read terminal driver settings\n");
    8ac9:	48 8d 3d 7e 2a 00 00 	lea    0x2a7e(%rip),%rdi        # b54e <default_cmd+0x12ee>
    8ad0:	31 c0                	xor    %eax,%eax
    8ad2:	e8 1f ee ff ff       	callq  78f6 <posix_print_error_and_exit>
	ret = tcsetattr(master_pty, TCSANOW, &ter);
    8ad7:	31 f6                	xor    %esi,%esi
    8ad9:	4c 89 f2             	mov    %r14,%rdx
    8adc:	89 df                	mov    %ebx,%edi
	ter.c_lflag &= ~(ICANON | ISIG | IEXTEN | ECHO);
    8ade:	81 65 98 f4 7f ff ff 	andl   $0xffff7ff4,-0x68(%rbp)
	ter.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR | INPCK
    8ae5:	48 b8 04 fa ff ff fe 	movabs $0xfffffffefffffa04,%rax
    8aec:	ff ff ff 
	ter.c_cc[VTIME] = 0;
    8aef:	66 c7 45 a2 00 00    	movw   $0x0,-0x5e(%rbp)
	ter.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR | INPCK
    8af5:	48 21 45 8c          	and    %rax,-0x74(%rbp)
	ret = tcsetattr(master_pty, TCSANOW, &ter);
    8af9:	e8 12 ab ff ff       	callq  3610 <tcsetattr@plt>
	if (ret == -1) {
    8afe:	ff c0                	inc    %eax
    8b00:	75 0e                	jne    8b10 <np_uart_0_init+0x1a5>
		ERROR("Could not change terminal driver settings\n");
    8b02:	48 8d 3d 6e 2a 00 00 	lea    0x2a6e(%rip),%rdi        # b577 <default_cmd+0x1317>
    8b09:	31 c0                	xor    %eax,%eax
    8b0b:	e8 e6 ed ff ff       	callq  78f6 <posix_print_error_and_exit>
	posix_print_trace("%s connected to pseudotty: %s\n",
    8b10:	31 c0                	xor    %eax,%eax
    8b12:	4c 89 e2             	mov    %r12,%rdx
    8b15:	48 8d 35 0e 1b 00 00 	lea    0x1b0e(%rip),%rsi        # a62a <default_cmd+0x3ca>
    8b1c:	48 8d 3d 7f 2a 00 00 	lea    0x2a7f(%rip),%rdi        # b5a2 <default_cmd+0x1342>
    8b23:	e8 76 ef ff ff       	callq  7a9e <posix_print_trace>
	if (do_auto_attach) {
    8b28:	45 84 ff             	test   %r15b,%r15b
    8b2b:	0f 84 da 00 00 00    	je     8c0b <np_uart_0_init+0x2a0>
	if (auto_attach_cmd == NULL) {
    8b31:	48 83 3d f7 7a 00 00 	cmpq   $0x0,0x7af7(%rip)        # 10630 <auto_attach_cmd>
    8b38:	00 
{
    8b39:	49 89 e6             	mov    %rsp,%r14
	if (auto_attach_cmd == NULL) {
    8b3c:	75 0e                	jne    8b4c <np_uart_0_init+0x1e1>
		auto_attach_cmd = (char *)default_cmd;
    8b3e:	48 8d 05 1b 17 00 00 	lea    0x171b(%rip),%rax        # a260 <default_cmd>
    8b45:	48 89 05 e4 7a 00 00 	mov    %rax,0x7ae4(%rip)        # 10630 <auto_attach_cmd>
	char command[strlen(auto_attach_cmd) + strlen(slave_tty) + 1];
    8b4c:	4c 8b 0d dd 7a 00 00 	mov    0x7add(%rip),%r9        # 10630 <auto_attach_cmd>
    8b53:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    8b57:	31 c0                	xor    %eax,%eax
    8b59:	48 89 f1             	mov    %rsi,%rcx
    8b5c:	4c 89 cf             	mov    %r9,%rdi
    8b5f:	f2 ae                	repnz scas %es:(%rdi),%al
    8b61:	4c 89 e7             	mov    %r12,%rdi
    8b64:	48 f7 d1             	not    %rcx
    8b67:	48 89 ca             	mov    %rcx,%rdx
    8b6a:	48 89 f1             	mov    %rsi,%rcx
    8b6d:	f2 ae                	repnz scas %es:(%rdi),%al
    8b6f:	48 89 c8             	mov    %rcx,%rax
    8b72:	48 89 e1             	mov    %rsp,%rcx
    8b75:	48 f7 d0             	not    %rax
    8b78:	48 8d 54 02 0e       	lea    0xe(%rdx,%rax,1),%rdx
    8b7d:	48 89 d0             	mov    %rdx,%rax
    8b80:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    8b87:	48 29 d1             	sub    %rdx,%rcx
    8b8a:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    8b8e:	48 89 ca             	mov    %rcx,%rdx
    8b91:	48 39 d4             	cmp    %rdx,%rsp
    8b94:	74 12                	je     8ba8 <np_uart_0_init+0x23d>
    8b96:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
    8b9d:	48 83 8c 24 f8 0f 00 	orq    $0x0,0xff8(%rsp)
    8ba4:	00 00 
    8ba6:	eb e9                	jmp    8b91 <np_uart_0_init+0x226>
    8ba8:	25 ff 0f 00 00       	and    $0xfff,%eax
    8bad:	48 29 c4             	sub    %rax,%rsp
    8bb0:	48 85 c0             	test   %rax,%rax
    8bb3:	74 06                	je     8bbb <np_uart_0_init+0x250>
    8bb5:	48 83 4c 04 f8 00    	orq    $0x0,-0x8(%rsp,%rax,1)
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
    8bbb:	4d 89 e0             	mov    %r12,%r8
    8bbe:	4c 89 c9             	mov    %r9,%rcx
    8bc1:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    8bc5:	be 01 00 00 00       	mov    $0x1,%esi
    8bca:	48 89 e7             	mov    %rsp,%rdi
    8bcd:	31 c0                	xor    %eax,%eax
    8bcf:	e8 fc aa ff ff       	callq  36d0 <__sprintf_chk@plt>
	int ret = system(command);
    8bd4:	48 89 e7             	mov    %rsp,%rdi
    8bd7:	e8 e4 a8 ff ff       	callq  34c0 <system@plt>
    8bdc:	41 89 c4             	mov    %eax,%r12d
	if (ret != 0) {
    8bdf:	85 c0                	test   %eax,%eax
    8be1:	74 25                	je     8c08 <np_uart_0_init+0x29d>
		WARN("Could not attach to the UART with \"%s\"\n", command);
    8be3:	48 89 e6             	mov    %rsp,%rsi
    8be6:	48 8d 3d d4 29 00 00 	lea    0x29d4(%rip),%rdi        # b5c1 <default_cmd+0x1361>
    8bed:	31 c0                	xor    %eax,%eax
    8bef:	e8 db ed ff ff       	callq  79cf <posix_print_warning>
		WARN("The command returned %i\n", WEXITSTATUS(ret));
    8bf4:	44 89 e0             	mov    %r12d,%eax
    8bf7:	48 8d 3d eb 29 00 00 	lea    0x29eb(%rip),%rdi        # b5e9 <default_cmd+0x1389>
    8bfe:	0f b6 f4             	movzbl %ah,%esi
    8c01:	31 c0                	xor    %eax,%eax
    8c03:	e8 c7 ed ff ff       	callq  79cf <posix_print_warning>
    8c08:	4c 89 f4             	mov    %r14,%rsp
		np_uart_driver_api_0.poll_in = np_uart_tty_poll_in;
    8c0b:	48 8d 05 13 fd ff ff 	lea    -0x2ed(%rip),%rax        # 8925 <np_uart_tty_poll_in>
		d->in_fd = tty_fn;
    8c12:	41 89 5d 04          	mov    %ebx,0x4(%r13)
		d->out_fd = tty_fn;
    8c16:	41 89 5d 00          	mov    %ebx,0x0(%r13)
		np_uart_driver_api_0.poll_in = np_uart_tty_poll_in;
    8c1a:	48 89 05 df 47 00 00 	mov    %rax,0x47df(%rip)        # d400 <np_uart_driver_api_0>
}
    8c21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    8c25:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    8c2c:	00 00 
    8c2e:	74 05                	je     8c35 <np_uart_0_init+0x2ca>
    8c30:	e8 7b a8 ff ff       	callq  34b0 <__stack_chk_fail@plt>
    8c35:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    8c39:	31 c0                	xor    %eax,%eax
    8c3b:	5b                   	pop    %rbx
    8c3c:	41 5c                	pop    %r12
    8c3e:	41 5d                	pop    %r13
    8c40:	41 5e                	pop    %r14
    8c42:	41 5f                	pop    %r15
    8c44:	5d                   	pop    %rbp
    8c45:	c3                   	retq   

0000000000008c46 <np_uart_poll_out>:
{
    8c46:	f3 0f 1e fa          	endbr64 
    8c4a:	48 83 ec 18          	sub    $0x18,%rsp
	ret = write(d->out_fd, &out_char, 1);
    8c4e:	48 8b 47 20          	mov    0x20(%rdi),%rax
    8c52:	ba 01 00 00 00       	mov    $0x1,%edx
{
    8c57:	40 88 74 24 0c       	mov    %sil,0xc(%rsp)
	ret = write(d->out_fd, &out_char, 1);
    8c5c:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
    8c61:	8b 38                	mov    (%rax),%edi
    8c63:	e8 28 a8 ff ff       	callq  3490 <write@plt>
}
    8c68:	48 83 c4 18          	add    $0x18,%rsp
    8c6c:	c3                   	retq   

0000000000008c6d <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
    8c6d:	f3 0f 1e fa          	endbr64 
	while (dev < __device_end) {
		device_pm_state_init(dev);
		z_object_init(dev);
		++dev;
	}
}
    8c71:	c3                   	retq   

0000000000008c72 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    8c72:	f3 0f 1e fa          	endbr64 
    8c76:	41 55                	push   %r13
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    8c78:	48 8d 05 21 3f 00 00 	lea    0x3f21(%rip),%rax        # cba0 <levels.4940>
{
    8c7f:	41 54                	push   %r12
    8c81:	49 89 c4             	mov    %rax,%r12
    8c84:	55                   	push   %rbp
    8c85:	53                   	push   %rbx
    8c86:	52                   	push   %rdx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    8c87:	48 63 d7             	movslq %edi,%rdx
    8c8a:	ff c7                	inc    %edi
    8c8c:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    8c90:	48 63 df             	movslq %edi,%rbx
    8c93:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    8c97:	76 39                	jbe    8cd2 <z_sys_init_run_level+0x60>
		const struct device *dev = entry->dev;
    8c99:	4c 8b 6d 08          	mov    0x8(%rbp),%r13
		int rc = entry->init(dev);
    8c9d:	4c 89 ef             	mov    %r13,%rdi
    8ca0:	ff 55 00             	callq  *0x0(%rbp)

		if (dev != NULL) {
    8ca3:	4d 85 ed             	test   %r13,%r13
    8ca6:	74 24                	je     8ccc <z_sys_init_run_level+0x5a>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
    8ca8:	49 8b 55 18          	mov    0x18(%r13),%rdx
    8cac:	85 c0                	test   %eax,%eax
    8cae:	74 18                	je     8cc8 <z_sys_init_run_level+0x56>
				if (rc < 0) {
    8cb0:	89 c1                	mov    %eax,%ecx
    8cb2:	c1 f9 1f             	sar    $0x1f,%ecx
    8cb5:	31 c8                	xor    %ecx,%eax
    8cb7:	29 c8                	sub    %ecx,%eax
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    8cb9:	b9 ff 00 00 00       	mov    $0xff,%ecx
    8cbe:	3d ff 00 00 00       	cmp    $0xff,%eax
    8cc3:	0f 4f c1             	cmovg  %ecx,%eax
    8cc6:	88 02                	mov    %al,(%rdx)
			}
			dev->state->initialized = true;
    8cc8:	80 4a 01 01          	orb    $0x1,0x1(%rdx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    8ccc:	48 83 c5 10          	add    $0x10,%rbp
    8cd0:	eb c1                	jmp    8c93 <z_sys_init_run_level+0x21>
		}
	}
}
    8cd2:	58                   	pop    %rax
    8cd3:	5b                   	pop    %rbx
    8cd4:	5d                   	pop    %rbp
    8cd5:	41 5c                	pop    %r12
    8cd7:	41 5d                	pop    %r13
    8cd9:	c3                   	retq   

0000000000008cda <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
    8cda:	f3 0f 1e fa          	endbr64 
	return dev->state->initialized && (dev->state->init_res == 0U);
    8cde:	48 8b 47 18          	mov    0x18(%rdi),%rax
    8ce2:	8b 00                	mov    (%rax),%eax
    8ce4:	66 25 ff 01          	and    $0x1ff,%ax
    8ce8:	66 3d 00 01          	cmp    $0x100,%ax
    8cec:	0f 94 c0             	sete   %al
}
    8cef:	c3                   	retq   

0000000000008cf0 <z_impl_device_get_binding>:
{
    8cf0:	f3 0f 1e fa          	endbr64 
    8cf4:	41 54                	push   %r12
    8cf6:	55                   	push   %rbp
    8cf7:	53                   	push   %rbx
	if ((name == NULL) || (name[0] == '\0')) {
    8cf8:	48 85 ff             	test   %rdi,%rdi
    8cfb:	75 05                	jne    8d02 <z_impl_device_get_binding+0x12>
		return NULL;
    8cfd:	45 31 e4             	xor    %r12d,%r12d
    8d00:	eb 61                	jmp    8d63 <z_impl_device_get_binding+0x73>
	if ((name == NULL) || (name[0] == '\0')) {
    8d02:	80 3f 00             	cmpb   $0x0,(%rdi)
    8d05:	48 89 fb             	mov    %rdi,%rbx
    8d08:	74 f3                	je     8cfd <z_impl_device_get_binding+0xd>
	for (dev = __device_start; dev != __device_end; dev++) {
    8d0a:	4c 8d 25 7f 6c 00 00 	lea    0x6c7f(%rip),%r12        # f990 <__device_dts_ord_10>
    8d11:	4c 89 e5             	mov    %r12,%rbp
    8d14:	4c 3b 25 bd 42 00 00 	cmp    0x42bd(%rip),%r12        # cfd8 <_GLOBAL_OFFSET_TABLE_+0x200>
    8d1b:	74 18                	je     8d35 <z_impl_device_get_binding+0x45>
		if (z_device_ready(dev) && (dev->name == name)) {
    8d1d:	4c 89 e7             	mov    %r12,%rdi
    8d20:	e8 b5 ff ff ff       	callq  8cda <z_device_ready>
    8d25:	84 c0                	test   %al,%al
    8d27:	74 06                	je     8d2f <z_impl_device_get_binding+0x3f>
    8d29:	49 39 1c 24          	cmp    %rbx,(%r12)
    8d2d:	74 34                	je     8d63 <z_impl_device_get_binding+0x73>
	for (dev = __device_start; dev != __device_end; dev++) {
    8d2f:	49 83 c4 30          	add    $0x30,%r12
    8d33:	eb df                	jmp    8d14 <z_impl_device_get_binding+0x24>
	for (dev = __device_start; dev != __device_end; dev++) {
    8d35:	49 89 ec             	mov    %rbp,%r12
    8d38:	4c 3b 25 99 42 00 00 	cmp    0x4299(%rip),%r12        # cfd8 <_GLOBAL_OFFSET_TABLE_+0x200>
    8d3f:	74 bc                	je     8cfd <z_impl_device_get_binding+0xd>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    8d41:	4c 89 e7             	mov    %r12,%rdi
    8d44:	e8 91 ff ff ff       	callq  8cda <z_device_ready>
    8d49:	84 c0                	test   %al,%al
    8d4b:	74 10                	je     8d5d <z_impl_device_get_binding+0x6d>
    8d4d:	49 8b 34 24          	mov    (%r12),%rsi
    8d51:	48 89 df             	mov    %rbx,%rdi
    8d54:	e8 e7 a7 ff ff       	callq  3540 <strcmp@plt>
    8d59:	85 c0                	test   %eax,%eax
    8d5b:	74 06                	je     8d63 <z_impl_device_get_binding+0x73>
	for (dev = __device_start; dev != __device_end; dev++) {
    8d5d:	49 83 c4 30          	add    $0x30,%r12
    8d61:	eb d5                	jmp    8d38 <z_impl_device_get_binding+0x48>
}
    8d63:	4c 89 e0             	mov    %r12,%rax
    8d66:	5b                   	pop    %rbx
    8d67:	5d                   	pop    %rbp
    8d68:	41 5c                	pop    %r12
    8d6a:	c3                   	retq   

0000000000008d6b <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    8d6b:	f3 0f 1e fa          	endbr64 
    8d6f:	50                   	push   %rax
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    8d70:	48 8d 05 1f 79 00 00 	lea    0x791f(%rip),%rax        # 10696 <z_sys_post_kernel>

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    8d77:	bf 02 00 00 00       	mov    $0x2,%edi
	z_sys_post_kernel = true;
    8d7c:	c6 00 01             	movb   $0x1,(%rax)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    8d7f:	e8 ee fe ff ff       	callq  8c72 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    8d84:	e8 d9 0d 00 00       	callq  9b62 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    8d89:	bf 03 00 00 00       	mov    $0x3,%edi
    8d8e:	e8 df fe ff ff       	callq  8c72 <z_sys_init_run_level>

	z_init_static_threads();
    8d93:	e8 15 0d 00 00       	callq  9aad <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    8d98:	e8 64 af ff ff       	callq  3d01 <zephyr_app_main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    8d9d:	48 8d 05 bc 76 00 00 	lea    0x76bc(%rip),%rax        # 10460 <z_main_thread>
    8da4:	80 60 18 fe          	andb   $0xfe,0x18(%rax)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    8da8:	5a                   	pop    %rdx
    8da9:	c3                   	retq   

0000000000008daa <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    8daa:	f3 0f 1e fa          	endbr64 
    8dae:	41 55                	push   %r13
    8db0:	41 54                	push   %r12
    8db2:	55                   	push   %rbp
    8db3:	53                   	push   %rbx
    8db4:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    8dbb:	48 8d 1d 3e 77 00 00 	lea    0x773e(%rip),%rbx        # 10500 <_kernel>
    8dc2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    8dc9:	00 00 
    8dcb:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
    8dd2:	00 
    8dd3:	31 c0                	xor    %eax,%eax
    8dd5:	48 89 e0             	mov    %rsp,%rax
	dummy_thread->base.user_options = K_ESSENTIAL;
    8dd8:	66 c7 44 24 18 01 01 	movw   $0x101,0x18(%rsp)
	_current_cpu->current = dummy_thread;
    8ddf:	48 89 43 10          	mov    %rax,0x10(%rbx)
#endif
#if defined(CONFIG_MMU) && defined(CONFIG_USERSPACE)
	z_kernel_map_fixup();
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    8de3:	e8 85 fe ff ff       	callq  8c6d <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    8de8:	31 ff                	xor    %edi,%edi
    8dea:	e8 83 fe ff ff       	callq  8c72 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    8def:	bf 01 00 00 00       	mov    $0x1,%edi
    8df4:	e8 79 fe ff ff       	callq  8c72 <z_sys_init_run_level>
	z_sched_init();
    8df9:	e8 af 09 00 00       	callq  97ad <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    8dfe:	45 31 c9             	xor    %r9d,%r9d
    8e01:	45 31 c0             	xor    %r8d,%r8d
    8e04:	ba 00 04 00 00       	mov    $0x400,%edx
	_kernel.ready_q.cache = &z_main_thread;
    8e09:	48 8d 2d 50 76 00 00 	lea    0x7650(%rip),%rbp        # 10460 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    8e10:	48 8d 05 90 28 00 00 	lea    0x2890(%rip),%rax        # b6a7 <default_cmd+0x1447>
    8e17:	48 8d 35 fa 5e 00 00 	lea    0x5efa(%rip),%rsi        # ed18 <z_main_stack>
    8e1e:	48 8d 0d 46 ff ff ff 	lea    -0xba(%rip),%rcx        # 8d6b <bg_thread_main>
	_kernel.ready_q.cache = &z_main_thread;
    8e25:	48 89 6b 38          	mov    %rbp,0x38(%rbx)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    8e29:	48 89 ef             	mov    %rbp,%rdi
    8e2c:	50                   	push   %rax
    8e2d:	6a 01                	pushq  $0x1
    8e2f:	6a 00                	pushq  $0x0
    8e31:	6a 00                	pushq  $0x0
    8e33:	e8 d9 0b 00 00       	callq  9a11 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    8e38:	80 65 19 fb          	andb   $0xfb,0x19(%rbp)
    8e3c:	48 83 c4 20          	add    $0x20,%rsp
	z_ready_thread(&z_main_thread);
    8e40:	48 89 ef             	mov    %rbp,%rdi
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    8e43:	49 89 c5             	mov    %rax,%r13
	z_ready_thread(&z_main_thread);
    8e46:	e8 57 08 00 00       	callq  96a2 <z_ready_thread>
	z_setup_new_thread(thread, stack,
    8e4b:	6a 00                	pushq  $0x0
    8e4d:	45 31 c9             	xor    %r9d,%r9d
    8e50:	49 89 d8             	mov    %rbx,%r8
    8e53:	6a 01                	pushq  $0x1
    8e55:	4c 8d 25 64 75 00 00 	lea    0x7564(%rip),%r12        # 103c0 <z_idle_threads>
    8e5c:	ba 00 01 00 00       	mov    $0x100,%edx
    8e61:	48 8d 35 b0 5d 00 00 	lea    0x5db0(%rip),%rsi        # ec18 <z_idle_stacks>
    8e68:	6a 0f                	pushq  $0xf
    8e6a:	48 8d 0d 51 10 00 00 	lea    0x1051(%rip),%rcx        # 9ec2 <idle>
    8e71:	6a 00                	pushq  $0x0
    8e73:	4c 89 e7             	mov    %r12,%rdi
    8e76:	e8 96 0b 00 00       	callq  9a11 <z_setup_new_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    8e7b:	4c 89 63 18          	mov    %r12,0x18(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    8e7f:	4c 89 ee             	mov    %r13,%rsi
    8e82:	48 89 ef             	mov    %rbp,%rdi
		_kernel.cpus[i].irq_stack =
    8e85:	48 8d 05 8c 62 00 00 	lea    0x628c(%rip),%rax        # f118 <z_interrupt_stacks>
		_kernel.cpus[i].id = i;
    8e8c:	c6 43 24 00          	movb   $0x0,0x24(%rbx)
	z_setup_new_thread(thread, stack,
    8e90:	48 83 c4 20          	add    $0x20,%rsp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    8e94:	48 8d 15 d0 fe ff ff 	lea    -0x130(%rip),%rdx        # 8d6b <bg_thread_main>
    8e9b:	41 80 64 24 19 fb    	andb   $0xfb,0x19(%r12)
		_kernel.cpus[i].irq_stack =
    8ea1:	48 05 00 08 00 00    	add    $0x800,%rax
    8ea7:	48 89 43 08          	mov    %rax,0x8(%rbx)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    8eab:	48 8d 43 28          	lea    0x28(%rbx),%rax
    8eaf:	48 89 43 28          	mov    %rax,0x28(%rbx)
	list->tail = (sys_dnode_t *)list;
    8eb3:	48 89 43 30          	mov    %rax,0x30(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    8eb7:	e8 2b db ff ff       	callq  69e7 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    8ebc:	ba 27 01 00 00       	mov    $0x127,%edx
    8ec1:	48 8d 35 e4 27 00 00 	lea    0x27e4(%rip),%rsi        # b6ac <default_cmd+0x144c>
    8ec8:	31 c0                	xor    %eax,%eax
    8eca:	48 8d 3d 7d 19 00 00 	lea    0x197d(%rip),%rdi        # a84e <default_cmd+0x5ee>
    8ed1:	e8 20 ea ff ff       	callq  78f6 <posix_print_error_and_exit>

0000000000008ed6 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
    8ed6:	f3 0f 1e fa          	endbr64 
    8eda:	41 57                	push   %r15
    8edc:	41 56                	push   %r14
    8ede:	49 89 d6             	mov    %rdx,%r14
    8ee1:	41 55                	push   %r13
    8ee3:	41 54                	push   %r12
    8ee5:	49 89 fc             	mov    %rdi,%r12
    8ee8:	55                   	push   %rbp

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    8ee9:	48 8d 6f 10          	lea    0x10(%rdi),%rbp
{
    8eed:	48 83 ec 10          	sub    $0x10,%rsp
    8ef1:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
    8ef6:	e8 64 e6 ff ff       	callq  755f <posix_irq_lock>

	if (msgq->used_msgs < msgq->max_msgs) {
    8efb:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    8f00:	41 89 c5             	mov    %eax,%r13d
    8f03:	41 8b 44 24 18       	mov    0x18(%r12),%eax
    8f08:	41 39 44 24 40       	cmp    %eax,0x40(%r12)
    8f0d:	73 6d                	jae    8f7c <z_impl_k_msgq_put+0xa6>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    8f0f:	4c 89 e7             	mov    %r12,%rdi
    8f12:	e8 49 08 00 00       	callq  9760 <z_unpend_first_thread>
		if (pending_thread != NULL) {
    8f17:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    8f1c:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    8f21:	48 85 c0             	test   %rax,%rax
    8f24:	74 25                	je     8f4b <z_impl_k_msgq_put+0x75>
    8f26:	48 8b 78 20          	mov    0x20(%rax),%rdi
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
    8f2a:	45 31 ff             	xor    %r15d,%r15d
    8f2d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
    8f2f:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
			z_ready_thread(pending_thread);
    8f36:	48 89 c7             	mov    %rax,%rdi
    8f39:	e8 64 07 00 00       	callq  96a2 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    8f3e:	44 89 ee             	mov    %r13d,%esi
    8f41:	48 89 ef             	mov    %rbp,%rdi
    8f44:	e8 5a 02 00 00       	callq  91a3 <z_reschedule>
			return 0;
    8f49:	eb 71                	jmp    8fbc <z_impl_k_msgq_put+0xe6>
    8f4b:	49 8b 7c 24 38       	mov    0x38(%r12),%rdi
    8f50:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    8f52:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    8f57:	49 03 44 24 38       	add    0x38(%r12),%rax
    8f5c:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
    8f61:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    8f66:	75 0a                	jne    8f72 <z_impl_k_msgq_put+0x9c>
				msgq->write_ptr = msgq->buffer_start;
    8f68:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    8f6d:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			}
			msgq->used_msgs++;
    8f72:	41 ff 44 24 40       	incl   0x40(%r12)
		}
		result = 0;
    8f77:	45 31 ff             	xor    %r15d,%r15d
    8f7a:	eb 38                	jmp    8fb4 <z_impl_k_msgq_put+0xde>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for message space to become available */
		result = -ENOMSG;
    8f7c:	41 bf d6 ff ff ff    	mov    $0xffffffd6,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    8f82:	4d 85 f6             	test   %r14,%r14
    8f85:	74 2d                	je     8fb4 <z_impl_k_msgq_put+0xde>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
    8f87:	48 8d 05 72 75 00 00 	lea    0x7572(%rip),%rax        # 10500 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    8f8e:	4c 89 f1             	mov    %r14,%rcx
    8f91:	4c 89 e2             	mov    %r12,%rdx
    8f94:	48 89 ef             	mov    %rbp,%rdi
		_current->base.swap_data = (void *) data;
    8f97:	48 8b 40 10          	mov    0x10(%rax),%rax
    8f9b:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    8f9f:	48 83 c4 10          	add    $0x10,%rsp
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    8fa3:	44 89 ee             	mov    %r13d,%esi
}
    8fa6:	5d                   	pop    %rbp
    8fa7:	41 5c                	pop    %r12
    8fa9:	41 5d                	pop    %r13
    8fab:	41 5e                	pop    %r14
    8fad:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    8faf:	e9 0c 04 00 00       	jmpq   93c0 <z_pend_curr>
	posix_irq_unlock(key);
    8fb4:	44 89 ef             	mov    %r13d,%edi
    8fb7:	e8 b1 e5 ff ff       	callq  756d <posix_irq_unlock>
}
    8fbc:	48 83 c4 10          	add    $0x10,%rsp
    8fc0:	44 89 f8             	mov    %r15d,%eax
    8fc3:	5d                   	pop    %rbp
    8fc4:	41 5c                	pop    %r12
    8fc6:	41 5d                	pop    %r13
    8fc8:	41 5e                	pop    %r14
    8fca:	41 5f                	pop    %r15
    8fcc:	c3                   	retq   

0000000000008fcd <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    8fcd:	f3 0f 1e fa          	endbr64 
    8fd1:	41 57                	push   %r15
    8fd3:	41 56                	push   %r14
    8fd5:	49 89 d6             	mov    %rdx,%r14
    8fd8:	41 55                	push   %r13

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    8fda:	4c 8d 6f 10          	lea    0x10(%rdi),%r13
{
    8fde:	41 54                	push   %r12
    8fe0:	49 89 fc             	mov    %rdi,%r12
    8fe3:	55                   	push   %rbp
    8fe4:	53                   	push   %rbx
    8fe5:	48 89 f3             	mov    %rsi,%rbx
    8fe8:	41 51                	push   %r9
	return posix_irq_lock();
    8fea:	e8 70 e5 ff ff       	callq  755f <posix_irq_lock>

	if (msgq->used_msgs > 0U) {
    8fef:	41 83 7c 24 40 00    	cmpl   $0x0,0x40(%r12)
    8ff5:	89 c5                	mov    %eax,%ebp
    8ff7:	0f 84 9f 00 00 00    	je     909c <z_impl_k_msgq_get+0xcf>
    8ffd:	49 8b 74 24 30       	mov    0x30(%r12),%rsi
    9002:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    9007:	48 89 df             	mov    %rbx,%rdi
    900a:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
    900c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    9011:	49 03 44 24 30       	add    0x30(%r12),%rax
    9016:	49 89 44 24 30       	mov    %rax,0x30(%r12)
		if (msgq->read_ptr == msgq->buffer_end) {
    901b:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    9020:	75 0a                	jne    902c <z_impl_k_msgq_get+0x5f>
			msgq->read_ptr = msgq->buffer_start;
    9022:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    9027:	49 89 44 24 30       	mov    %rax,0x30(%r12)
		}
		msgq->used_msgs--;
    902c:	41 ff 4c 24 40       	decl   0x40(%r12)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    9031:	4c 89 e7             	mov    %r12,%rdi
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
		}
		result = 0;
    9034:	45 31 ff             	xor    %r15d,%r15d
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    9037:	e8 24 07 00 00       	callq  9760 <z_unpend_first_thread>
    903c:	49 89 c0             	mov    %rax,%r8
		if (pending_thread != NULL) {
    903f:	48 85 c0             	test   %rax,%rax
    9042:	0f 84 8a 00 00 00    	je     90d2 <z_impl_k_msgq_get+0x105>
    9048:	48 8b 70 20          	mov    0x20(%rax),%rsi
    904c:	49 8b 7c 24 38       	mov    0x38(%r12),%rdi
    9051:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    9056:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
			msgq->write_ptr += msgq->msg_size;
    9058:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    905d:	49 03 44 24 38       	add    0x38(%r12),%rax
    9062:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
    9067:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    906c:	75 0a                	jne    9078 <z_impl_k_msgq_get+0xab>
				msgq->write_ptr = msgq->buffer_start;
    906e:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    9073:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			msgq->used_msgs++;
    9078:	41 ff 44 24 40       	incl   0x40(%r12)
			z_ready_thread(pending_thread);
    907d:	4c 89 c7             	mov    %r8,%rdi
			return 0;
    9080:	45 31 ff             	xor    %r15d,%r15d
    9083:	41 c7 40 4c 00 00 00 	movl   $0x0,0x4c(%r8)
    908a:	00 
			z_ready_thread(pending_thread);
    908b:	e8 12 06 00 00       	callq  96a2 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    9090:	89 ee                	mov    %ebp,%esi
    9092:	4c 89 ef             	mov    %r13,%rdi
    9095:	e8 09 01 00 00       	callq  91a3 <z_reschedule>
			return 0;
    909a:	eb 3d                	jmp    90d9 <z_impl_k_msgq_get+0x10c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for a message to become available */
		result = -ENOMSG;
    909c:	41 bf d6 ff ff ff    	mov    $0xffffffd6,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    90a2:	4d 85 f6             	test   %r14,%r14
    90a5:	74 2b                	je     90d2 <z_impl_k_msgq_get+0x105>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
    90a7:	48 8d 05 52 74 00 00 	lea    0x7452(%rip),%rax        # 10500 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    90ae:	4c 89 f1             	mov    %r14,%rcx
    90b1:	4c 89 e2             	mov    %r12,%rdx
    90b4:	89 ee                	mov    %ebp,%esi
    90b6:	4c 89 ef             	mov    %r13,%rdi
		_current->base.swap_data = data;
    90b9:	48 8b 40 10          	mov    0x10(%rax),%rax
    90bd:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    90c1:	41 58                	pop    %r8
    90c3:	5b                   	pop    %rbx
    90c4:	5d                   	pop    %rbp
    90c5:	41 5c                	pop    %r12
    90c7:	41 5d                	pop    %r13
    90c9:	41 5e                	pop    %r14
    90cb:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    90cd:	e9 ee 02 00 00       	jmpq   93c0 <z_pend_curr>
	posix_irq_unlock(key);
    90d2:	89 ef                	mov    %ebp,%edi
    90d4:	e8 94 e4 ff ff       	callq  756d <posix_irq_unlock>
}
    90d9:	5a                   	pop    %rdx
    90da:	44 89 f8             	mov    %r15d,%eax
    90dd:	5b                   	pop    %rbx
    90de:	5d                   	pop    %rbp
    90df:	41 5c                	pop    %r12
    90e1:	41 5d                	pop    %r13
    90e3:	41 5e                	pop    %r14
    90e5:	41 5f                	pop    %r15
    90e7:	c3                   	retq   

00000000000090e8 <z_sched_prio_cmp>:
 * Do not rely on the actual value returned aside from the above.
 * (Again, like memcmp.)
 */
int32_t z_sched_prio_cmp(struct k_thread *thread_1,
	struct k_thread *thread_2)
{
    90e8:	f3 0f 1e fa          	endbr64 
	/* `prio` is <32b, so the below cannot overflow. */
	int32_t b1 = thread_1->base.prio;
    90ec:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
	int32_t b2 = thread_2->base.prio;
    90f0:	0f be 4e 1a          	movsbl 0x1a(%rsi),%ecx
		 * from UB on overflow to impdef.
		 */
		return (int32_t) (d2 - d1);
	}
#endif
	return 0;
    90f4:	31 c0                	xor    %eax,%eax
	if (b1 != b2) {
    90f6:	39 ca                	cmp    %ecx,%edx
    90f8:	74 04                	je     90fe <z_sched_prio_cmp+0x16>
		return b2 - b1;
    90fa:	89 c8                	mov    %ecx,%eax
    90fc:	29 d0                	sub    %edx,%eax
}
    90fe:	c3                   	retq   

00000000000090ff <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    90ff:	f3 0f 1e fa          	endbr64 
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    9103:	83 3d 7a 75 00 00 00 	cmpl   $0x0,0x757a(%rip)        # 10684 <slice_time>
    910a:	74 20                	je     912c <z_reset_time_slice+0x2d>
{
    910c:	50                   	push   %rax
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    910d:	e8 21 c0 ff ff       	callq  5133 <sys_clock_elapsed>
    9112:	8b 3d 6c 75 00 00    	mov    0x756c(%rip),%edi        # 10684 <slice_time>
    9118:	48 8d 15 e1 73 00 00 	lea    0x73e1(%rip),%rdx        # 10500 <_kernel>
		z_set_timeout_expiry(slice_time, false);
    911f:	31 f6                	xor    %esi,%esi
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    9121:	01 f8                	add    %edi,%eax
    9123:	89 42 20             	mov    %eax,0x20(%rdx)
	}
}
    9126:	5a                   	pop    %rdx
		z_set_timeout_expiry(slice_time, false);
    9127:	e9 5b 0c 00 00       	jmpq   9d87 <z_set_timeout_expiry>
    912c:	c3                   	retq   

000000000000912d <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    912d:	f3 0f 1e fa          	endbr64 
    9131:	41 54                	push   %r12
    9133:	41 89 f4             	mov    %esi,%r12d
    9136:	55                   	push   %rbp
    9137:	53                   	push   %rbx
    9138:	89 fb                	mov    %edi,%ebx
	return posix_irq_lock();
    913a:	e8 20 e4 ff ff       	callq  755f <posix_irq_lock>
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
    913f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    9144:	89 c5                	mov    %eax,%ebp
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    9146:	48 8d 05 b3 73 00 00 	lea    0x73b3(%rip),%rax        # 10500 <_kernel>
    914d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    9154:	89 d8                	mov    %ebx,%eax
		t += off;
    9156:	48 83 c0 09          	add    $0x9,%rax
		if (result32 && (t < BIT64(32))) {
    915a:	48 39 d0             	cmp    %rdx,%rax
    915d:	77 0e                	ja     916d <k_sched_time_slice_set+0x40>
			return ((uint32_t)t) / (from_hz / to_hz);
    915f:	8d 43 09             	lea    0x9(%rbx),%eax
    9162:	b9 0a 00 00 00       	mov    $0xa,%ecx
    9167:	31 d2                	xor    %edx,%edx
    9169:	f7 f1                	div    %ecx
    916b:	eb 0a                	jmp    9177 <k_sched_time_slice_set+0x4a>
			return t / (from_hz / to_hz);
    916d:	b9 0a 00 00 00       	mov    $0xa,%ecx
    9172:	31 d2                	xor    %edx,%edx
    9174:	48 f7 f1             	div    %rcx
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    9177:	85 db                	test   %ebx,%ebx
    9179:	7e 0b                	jle    9186 <k_sched_time_slice_set+0x59>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    917b:	83 f8 02             	cmp    $0x2,%eax
    917e:	ba 02 00 00 00       	mov    $0x2,%edx
    9183:	0f 4c c2             	cmovl  %edx,%eax
		}
		slice_max_prio = prio;
    9186:	44 89 25 f3 74 00 00 	mov    %r12d,0x74f3(%rip)        # 10680 <slice_max_prio>
			slice_time = MAX(2, slice_time);
    918d:	89 05 f1 74 00 00    	mov    %eax,0x74f1(%rip)        # 10684 <slice_time>
		z_reset_time_slice();
    9193:	e8 67 ff ff ff       	callq  90ff <z_reset_time_slice>
	}
}
    9198:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    9199:	89 ef                	mov    %ebp,%edi
    919b:	5d                   	pop    %rbp
    919c:	41 5c                	pop    %r12
    919e:	e9 ca e3 ff ff       	jmpq   756d <posix_irq_unlock>

00000000000091a3 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    91a3:	f3 0f 1e fa          	endbr64 
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    91a7:	48 8d 05 52 73 00 00 	lea    0x7352(%rip),%rax        # 10500 <_kernel>
	if (resched(key.key) && need_swap()) {
    91ae:	89 f2                	mov    %esi,%edx
{
    91b0:	89 f7                	mov    %esi,%edi
	if (resched(key.key) && need_swap()) {
    91b2:	0b 10                	or     (%rax),%edx
    91b4:	75 11                	jne    91c7 <z_reschedule+0x24>
    91b6:	48 8b 48 10          	mov    0x10(%rax),%rcx
    91ba:	48 39 48 38          	cmp    %rcx,0x38(%rax)
    91be:	74 07                	je     91c7 <z_reschedule+0x24>
	ret = arch_swap(key);
    91c0:	31 ff                	xor    %edi,%edi
    91c2:	e9 d6 d7 ff ff       	jmpq   699d <arch_swap>
    91c7:	e9 a1 e3 ff ff       	jmpq   756d <posix_irq_unlock>

00000000000091cc <z_reschedule_irqlock>:
		k_spin_unlock(lock, key);
	}
}

void z_reschedule_irqlock(uint32_t key)
{
    91cc:	f3 0f 1e fa          	endbr64 
	if (resched(key)) {
    91d0:	48 8d 05 29 73 00 00 	lea    0x7329(%rip),%rax        # 10500 <_kernel>
    91d7:	89 fa                	mov    %edi,%edx
    91d9:	0b 10                	or     (%rax),%edx
    91db:	75 07                	jne    91e4 <z_reschedule_irqlock+0x18>
    91dd:	31 ff                	xor    %edi,%edi
    91df:	e9 b9 d7 ff ff       	jmpq   699d <arch_swap>
    91e4:	e9 84 e3 ff ff       	jmpq   756d <posix_irq_unlock>

00000000000091e9 <z_reschedule_unlocked>:
{
    91e9:	50                   	push   %rax
	return posix_irq_lock();
    91ea:	e8 70 e3 ff ff       	callq  755f <posix_irq_lock>
}
    91ef:	5a                   	pop    %rdx
    91f0:	89 c7                	mov    %eax,%edi
	(void) z_reschedule_irqlock(arch_irq_lock());
    91f2:	e9 d5 ff ff ff       	jmpq   91cc <z_reschedule_irqlock>

00000000000091f7 <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
    91f7:	f3 0f 1e fa          	endbr64 
    91fb:	50                   	push   %rax
    91fc:	e8 5e e3 ff ff       	callq  755f <posix_irq_lock>
    9201:	89 c7                	mov    %eax,%edi
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    9203:	48 8d 05 f6 72 00 00 	lea    0x72f6(%rip),%rax        # 10500 <_kernel>
    920a:	48 8b 40 10          	mov    0x10(%rax),%rax
    920e:	fe 48 1b             	decb   0x1b(%rax)
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    9211:	5a                   	pop    %rdx
	posix_irq_unlock(key);
    9212:	e9 56 e3 ff ff       	jmpq   756d <posix_irq_unlock>

0000000000009217 <z_priq_dumb_remove>:

	sys_dlist_append(pq, &thread->base.qnode_dlist);
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    9217:	f3 0f 1e fa          	endbr64 
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    921b:	48 8b 56 08          	mov    0x8(%rsi),%rdx
	sys_dnode_t *const next = node->next;
    921f:	48 8b 06             	mov    (%rsi),%rax

	prev->next = next;
    9222:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
    9225:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    9229:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	node->prev = NULL;
    9230:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
    9237:	00 
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    9238:	c3                   	retq   

0000000000009239 <unpend_thread_no_timeout>:
{
    9239:	53                   	push   %rbx
    923a:	48 89 fb             	mov    %rdi,%rbx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
    923d:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    9241:	48 89 de             	mov    %rbx,%rsi
    9244:	e8 ce ff ff ff       	callq  9217 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    9249:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
	thread->base.pended_on = NULL;
    924d:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    9254:	00 
}
    9255:	5b                   	pop    %rbx
    9256:	c3                   	retq   

0000000000009257 <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    9257:	f3 0f 1e fa          	endbr64 
	return list->head == list;
    925b:	48 8b 07             	mov    (%rdi),%rax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
    925e:	48 85 c0             	test   %rax,%rax
    9261:	74 05                	je     9268 <z_priq_dumb_best+0x11>
    9263:	48 39 c7             	cmp    %rax,%rdi
    9266:	75 02                	jne    926a <z_priq_dumb_best+0x13>
	struct k_thread *thread = NULL;
    9268:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    926a:	c3                   	retq   

000000000000926b <update_cache>:
{
    926b:	41 54                	push   %r12
    926d:	41 89 fc             	mov    %edi,%r12d
    9270:	55                   	push   %rbp
	thread = _priq_run_best(&_kernel.ready_q.runq);
    9271:	48 8d 2d 88 72 00 00 	lea    0x7288(%rip),%rbp        # 10500 <_kernel>
{
    9278:	53                   	push   %rbx
	thread = _priq_run_best(&_kernel.ready_q.runq);
    9279:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    927d:	e8 d5 ff ff ff       	callq  9257 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    9282:	48 89 c3             	mov    %rax,%rbx
    9285:	48 85 c0             	test   %rax,%rax
    9288:	75 04                	jne    928e <update_cache+0x23>
    928a:	48 8b 5d 18          	mov    0x18(%rbp),%rbx
	if (preempt_ok != 0) {
    928e:	48 8b 45 10          	mov    0x10(%rbp),%rax
    9292:	45 85 e4             	test   %r12d,%r12d
    9295:	75 13                	jne    92aa <update_cache+0x3f>
	if (z_is_thread_prevented_from_running(_current)) {
    9297:	f6 40 19 1f          	testb  $0x1f,0x19(%rax)
    929b:	75 0d                	jne    92aa <update_cache+0x3f>
	if (is_preempt(_current) || is_metairq(thread)) {
    929d:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
    92a2:	76 06                	jbe    92aa <update_cache+0x3f>
		_kernel.ready_q.cache = _current;
    92a4:	48 89 45 38          	mov    %rax,0x38(%rbp)
    92a8:	eb 0e                	jmp    92b8 <update_cache+0x4d>
		if (thread != _current) {
    92aa:	48 39 c3             	cmp    %rax,%rbx
    92ad:	74 05                	je     92b4 <update_cache+0x49>
			z_reset_time_slice();
    92af:	e8 4b fe ff ff       	callq  90ff <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    92b4:	48 89 5d 38          	mov    %rbx,0x38(%rbp)
}
    92b8:	5b                   	pop    %rbx
    92b9:	5d                   	pop    %rbp
    92ba:	41 5c                	pop    %r12
    92bc:	c3                   	retq   

00000000000092bd <unready_thread>:
{
    92bd:	55                   	push   %rbp
    92be:	53                   	push   %rbx
    92bf:	48 89 fb             	mov    %rdi,%rbx
    92c2:	52                   	push   %rdx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    92c3:	8a 47 19             	mov    0x19(%rdi),%al
	return (thread->base.thread_state & state) != 0U;
    92c6:	48 8d 2d 33 72 00 00 	lea    0x7233(%rip),%rbp        # 10500 <_kernel>
	if (z_is_thread_queued(thread)) {
    92cd:	84 c0                	test   %al,%al
    92cf:	79 12                	jns    92e3 <unready_thread+0x26>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    92d1:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    92d4:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    92d7:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    92da:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    92de:	e8 34 ff ff ff       	callq  9217 <z_priq_dumb_remove>
	update_cache(thread == _current);
    92e3:	31 ff                	xor    %edi,%edi
    92e5:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
}
    92e9:	58                   	pop    %rax
	update_cache(thread == _current);
    92ea:	40 0f 94 c7          	sete   %dil
}
    92ee:	5b                   	pop    %rbx
    92ef:	5d                   	pop    %rbp
	update_cache(thread == _current);
    92f0:	e9 76 ff ff ff       	jmpq   926b <update_cache>

00000000000092f5 <add_to_waitq_locked>:
{
    92f5:	41 54                	push   %r12
    92f7:	55                   	push   %rbp
    92f8:	48 89 f5             	mov    %rsi,%rbp
    92fb:	53                   	push   %rbx
    92fc:	48 89 fb             	mov    %rdi,%rbx
	unready_thread(thread);
    92ff:	e8 b9 ff ff ff       	callq  92bd <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    9304:	80 4b 19 02          	orb    $0x2,0x19(%rbx)
	if (wait_q != NULL) {
    9308:	48 85 ed             	test   %rbp,%rbp
    930b:	74 5a                	je     9367 <add_to_waitq_locked+0x72>
    930d:	4c 8b 65 00          	mov    0x0(%rbp),%r12
		thread->base.pended_on = wait_q;
    9311:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    9315:	4d 85 e4             	test   %r12,%r12
    9318:	74 05                	je     931f <add_to_waitq_locked+0x2a>
    931a:	4c 39 e5             	cmp    %r12,%rbp
    931d:	75 14                	jne    9333 <add_to_waitq_locked+0x3e>
	sys_dnode_t *const tail = list->tail;
    931f:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = list;
    9323:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = tail;
    9326:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    932a:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    932d:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    9331:	eb 34                	jmp    9367 <add_to_waitq_locked+0x72>
		if (z_sched_prio_cmp(thread, t) > 0) {
    9333:	4c 89 e6             	mov    %r12,%rsi
    9336:	48 89 df             	mov    %rbx,%rdi
    9339:	e8 aa fd ff ff       	callq  90e8 <z_sched_prio_cmp>
    933e:	85 c0                	test   %eax,%eax
    9340:	7e 16                	jle    9358 <add_to_waitq_locked+0x63>
	sys_dnode_t *const prev = successor->prev;
    9342:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
    9347:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = prev;
    934a:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    934e:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    9351:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
    9356:	eb 0f                	jmp    9367 <add_to_waitq_locked+0x72>
	return (node == list->tail) ? NULL : node->next;
    9358:	4c 3b 65 08          	cmp    0x8(%rbp),%r12
    935c:	74 c1                	je     931f <add_to_waitq_locked+0x2a>
    935e:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    9362:	4d 85 e4             	test   %r12,%r12
    9365:	eb b6                	jmp    931d <add_to_waitq_locked+0x28>
}
    9367:	5b                   	pop    %rbx
    9368:	5d                   	pop    %rbp
    9369:	41 5c                	pop    %r12
    936b:	c3                   	retq   

000000000000936c <pend>:
{
    936c:	55                   	push   %rbp
    936d:	53                   	push   %rbx
    936e:	48 89 fb             	mov    %rdi,%rbx
    9371:	48 83 ec 18          	sub    $0x18,%rsp
    9375:	48 89 14 24          	mov    %rdx,(%rsp)
    9379:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
    937e:	e8 dc e1 ff ff       	callq  755f <posix_irq_lock>
		add_to_waitq_locked(thread, wait_q);
    9383:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    9388:	48 89 df             	mov    %rbx,%rdi
    938b:	89 c5                	mov    %eax,%ebp
    938d:	e8 63 ff ff ff       	callq  92f5 <add_to_waitq_locked>
	posix_irq_unlock(key);
    9392:	89 ef                	mov    %ebp,%edi
    9394:	e8 d4 e1 ff ff       	callq  756d <posix_irq_unlock>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    9399:	48 8b 14 24          	mov    (%rsp),%rdx
    939d:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    93a1:	74 16                	je     93b9 <pend+0x4d>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    93a3:	48 8d 35 74 03 00 00 	lea    0x374(%rip),%rsi        # 971e <z_thread_timeout>
}
    93aa:	48 83 c4 18          	add    $0x18,%rsp
    93ae:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
    93b2:	5b                   	pop    %rbx
    93b3:	5d                   	pop    %rbp
    93b4:	e9 70 08 00 00       	jmpq   9c29 <z_add_timeout>
    93b9:	48 83 c4 18          	add    $0x18,%rsp
    93bd:	5b                   	pop    %rbx
    93be:	5d                   	pop    %rbp
    93bf:	c3                   	retq   

00000000000093c0 <z_pend_curr>:
{
    93c0:	f3 0f 1e fa          	endbr64 
	pend(_current, wait_q, timeout);
    93c4:	48 8d 05 35 71 00 00 	lea    0x7135(%rip),%rax        # 10500 <_kernel>
{
    93cb:	55                   	push   %rbp
    93cc:	89 f5                	mov    %esi,%ebp
    93ce:	48 89 d6             	mov    %rdx,%rsi
    93d1:	48 89 ca             	mov    %rcx,%rdx
	pend(_current, wait_q, timeout);
    93d4:	48 8b 78 10          	mov    0x10(%rax),%rdi
    93d8:	e8 8f ff ff ff       	callq  936c <pend>
    93dd:	89 ef                	mov    %ebp,%edi
}
    93df:	5d                   	pop    %rbp
    93e0:	e9 b8 d5 ff ff       	jmpq   699d <arch_swap>

00000000000093e5 <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
    93e5:	41 55                	push   %r13
    93e7:	41 54                	push   %r12
    93e9:	55                   	push   %rbp
    93ea:	53                   	push   %rbx
    93eb:	48 89 fb             	mov    %rdi,%rbx
    93ee:	50                   	push   %rax
		return 0;
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);

	expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    93ef:	e8 c2 0a 00 00       	callq  9eb6 <sys_clock_tick_get_32>
    93f4:	89 c5                	mov    %eax,%ebp
	return posix_irq_lock();
    93f6:	e8 64 e1 ff ff       	callq  755f <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
    93fb:	4c 8d 2d fe 70 00 00 	lea    0x70fe(%rip),%r13        # 10500 <_kernel>
    9402:	41 89 c4             	mov    %eax,%r12d
    9405:	49 8b 7d 10          	mov    0x10(%r13),%rdi
    9409:	e8 af fe ff ff       	callq  92bd <unready_thread>
    940e:	49 8b 45 10          	mov    0x10(%r13),%rax
    9412:	48 8d 35 05 03 00 00 	lea    0x305(%rip),%rsi        # 971e <z_thread_timeout>
    9419:	48 89 da             	mov    %rbx,%rdx

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    941c:	01 eb                	add    %ebp,%ebx
    941e:	48 8d 78 28          	lea    0x28(%rax),%rdi
    9422:	e8 02 08 00 00       	callq  9c29 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    9427:	49 8b 45 10          	mov    0x10(%r13),%rax
    942b:	44 89 e7             	mov    %r12d,%edi
	thread->base.thread_state |= _THREAD_SUSPENDED;
    942e:	80 48 19 10          	orb    $0x10,0x19(%rax)
    9432:	e8 66 d5 ff ff       	callq  699d <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    9437:	e8 7a 0a 00 00       	callq  9eb6 <sys_clock_tick_get_32>
	if (ticks > 0) {
    943c:	ba 00 00 00 00       	mov    $0x0,%edx
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    9441:	89 c0                	mov    %eax,%eax
    9443:	48 29 c3             	sub    %rax,%rbx
    9446:	48 89 d8             	mov    %rbx,%rax
    9449:	48 0f 48 c2          	cmovs  %rdx,%rax
		return ticks;
	}
#endif

	return 0;
}
    944d:	5a                   	pop    %rdx
    944e:	5b                   	pop    %rbx
    944f:	5d                   	pop    %rbp
    9450:	41 5c                	pop    %r12
    9452:	41 5d                	pop    %r13
    9454:	c3                   	retq   

0000000000009455 <z_impl_k_thread_suspend>:
{
    9455:	f3 0f 1e fa          	endbr64 
    9459:	41 54                	push   %r12
    945b:	55                   	push   %rbp
    945c:	53                   	push   %rbx
    945d:	48 89 fb             	mov    %rdi,%rbx
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    9460:	48 83 c7 28          	add    $0x28,%rdi
    9464:	e8 dc 08 00 00       	callq  9d45 <z_abort_timeout>
    9469:	e8 f1 e0 ff ff       	callq  755f <posix_irq_lock>
    946e:	48 8d 2d 8b 70 00 00 	lea    0x708b(%rip),%rbp        # 10500 <_kernel>
    9475:	41 89 c4             	mov    %eax,%r12d
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    9478:	8a 43 19             	mov    0x19(%rbx),%al
		if (z_is_thread_queued(thread)) {
    947b:	84 c0                	test   %al,%al
    947d:	79 12                	jns    9491 <z_impl_k_thread_suspend+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    947f:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    9482:	48 89 de             	mov    %rbx,%rsi
    9485:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    9489:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    948c:	e8 86 fd ff ff       	callq  9217 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    9491:	80 4b 19 10          	orb    $0x10,0x19(%rbx)
		update_cache(thread == _current);
    9495:	31 ff                	xor    %edi,%edi
    9497:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    949b:	40 0f 94 c7          	sete   %dil
    949f:	e8 c7 fd ff ff       	callq  926b <update_cache>
	posix_irq_unlock(key);
    94a4:	44 89 e7             	mov    %r12d,%edi
    94a7:	e8 c1 e0 ff ff       	callq  756d <posix_irq_unlock>
	if (thread == _current) {
    94ac:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    94b0:	75 09                	jne    94bb <z_impl_k_thread_suspend+0x66>
}
    94b2:	5b                   	pop    %rbx
    94b3:	5d                   	pop    %rbp
    94b4:	41 5c                	pop    %r12
		z_reschedule_unlocked();
    94b6:	e9 2e fd ff ff       	jmpq   91e9 <z_reschedule_unlocked>
}
    94bb:	5b                   	pop    %rbx
    94bc:	5d                   	pop    %rbp
    94bd:	41 5c                	pop    %r12
    94bf:	c3                   	retq   

00000000000094c0 <k_sched_unlock>:
{
    94c0:	f3 0f 1e fa          	endbr64 
    94c4:	55                   	push   %rbp
	return posix_irq_lock();
    94c5:	e8 95 e0 ff ff       	callq  755f <posix_irq_lock>
		update_cache(0);
    94ca:	31 ff                	xor    %edi,%edi
    94cc:	89 c5                	mov    %eax,%ebp
		++_current->base.sched_locked;
    94ce:	48 8d 05 2b 70 00 00 	lea    0x702b(%rip),%rax        # 10500 <_kernel>
    94d5:	48 8b 40 10          	mov    0x10(%rax),%rax
    94d9:	fe 40 1b             	incb   0x1b(%rax)
		update_cache(0);
    94dc:	e8 8a fd ff ff       	callq  926b <update_cache>
	posix_irq_unlock(key);
    94e1:	89 ef                	mov    %ebp,%edi
    94e3:	e8 85 e0 ff ff       	callq  756d <posix_irq_unlock>
}
    94e8:	5d                   	pop    %rbp
	z_reschedule_unlocked();
    94e9:	e9 fb fc ff ff       	jmpq   91e9 <z_reschedule_unlocked>

00000000000094ee <move_thread_to_end_of_prio_q>:
{
    94ee:	41 54                	push   %r12
    94f0:	4c 8d 25 09 70 00 00 	lea    0x7009(%rip),%r12        # 10500 <_kernel>
    94f7:	55                   	push   %rbp
    94f8:	53                   	push   %rbx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    94f9:	8a 47 19             	mov    0x19(%rdi),%al
    94fc:	48 89 fb             	mov    %rdi,%rbx
	if (z_is_thread_queued(thread)) {
    94ff:	84 c0                	test   %al,%al
    9501:	79 13                	jns    9516 <move_thread_to_end_of_prio_q+0x28>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    9503:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    9506:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    9509:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    950c:	49 8d 7c 24 40       	lea    0x40(%r12),%rdi
    9511:	e8 01 fd ff ff       	callq  9217 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    9516:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	return list->head == list;
    951a:	49 8b 6c 24 40       	mov    0x40(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    951f:	48 85 ed             	test   %rbp,%rbp
    9522:	74 0a                	je     952e <move_thread_to_end_of_prio_q+0x40>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    9524:	49 8d 44 24 40       	lea    0x40(%r12),%rax
    9529:	48 39 c5             	cmp    %rax,%rbp
    952c:	75 1b                	jne    9549 <move_thread_to_end_of_prio_q+0x5b>
	sys_dnode_t *const tail = list->tail;
    952e:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	node->next = list;
    9533:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
    9538:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    953b:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    953f:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    9542:	49 89 5c 24 48       	mov    %rbx,0x48(%r12)
}
    9547:	eb 33                	jmp    957c <move_thread_to_end_of_prio_q+0x8e>
		if (z_sched_prio_cmp(thread, t) > 0) {
    9549:	48 89 ee             	mov    %rbp,%rsi
    954c:	48 89 df             	mov    %rbx,%rdi
    954f:	e8 94 fb ff ff       	callq  90e8 <z_sched_prio_cmp>
    9554:	85 c0                	test   %eax,%eax
    9556:	7e 14                	jle    956c <move_thread_to_end_of_prio_q+0x7e>
	sys_dnode_t *const prev = successor->prev;
    9558:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    955c:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = prev;
    955f:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    9563:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    9566:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    956a:	eb 10                	jmp    957c <move_thread_to_end_of_prio_q+0x8e>
	return (node == list->tail) ? NULL : node->next;
    956c:	49 39 6c 24 48       	cmp    %rbp,0x48(%r12)
    9571:	74 bb                	je     952e <move_thread_to_end_of_prio_q+0x40>
    9573:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    9577:	48 85 ed             	test   %rbp,%rbp
    957a:	eb b0                	jmp    952c <move_thread_to_end_of_prio_q+0x3e>
	update_cache(thread == _current);
    957c:	31 ff                	xor    %edi,%edi
    957e:	49 39 5c 24 10       	cmp    %rbx,0x10(%r12)
}
    9583:	5b                   	pop    %rbx
	update_cache(thread == _current);
    9584:	40 0f 94 c7          	sete   %dil
}
    9588:	5d                   	pop    %rbp
    9589:	41 5c                	pop    %r12
	update_cache(thread == _current);
    958b:	e9 db fc ff ff       	jmpq   926b <update_cache>

0000000000009590 <z_time_slice>:
{
    9590:	f3 0f 1e fa          	endbr64 
    9594:	55                   	push   %rbp
    9595:	53                   	push   %rbx
    9596:	89 fb                	mov    %edi,%ebx
    9598:	52                   	push   %rdx
	return posix_irq_lock();
    9599:	e8 c1 df ff ff       	callq  755f <posix_irq_lock>
	if (slice_time && sliceable(_current)) {
    959e:	83 3d df 70 00 00 00 	cmpl   $0x0,0x70df(%rip)        # 10684 <slice_time>
    95a5:	89 c5                	mov    %eax,%ebp
    95a7:	48 8d 05 52 6f 00 00 	lea    0x6f52(%rip),%rax        # 10500 <_kernel>
    95ae:	74 40                	je     95f0 <z_time_slice+0x60>
    95b0:	48 8b 78 10          	mov    0x10(%rax),%rdi
		&& !z_is_idle_thread_object(thread);
    95b4:	66 83 7f 1a 7f       	cmpw   $0x7f,0x1a(%rdi)
    95b9:	77 35                	ja     95f0 <z_time_slice+0x60>
		&& !z_is_thread_prevented_from_running(thread)
    95bb:	f6 47 19 1f          	testb  $0x1f,0x19(%rdi)
    95bf:	75 2f                	jne    95f0 <z_time_slice+0x60>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    95c1:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
		&& !z_is_idle_thread_object(thread);
    95c5:	39 15 b5 70 00 00    	cmp    %edx,0x70b5(%rip)        # 10680 <slice_max_prio>
    95cb:	7f 23                	jg     95f0 <z_time_slice+0x60>
    95cd:	48 3b 3d dc 39 00 00 	cmp    0x39dc(%rip),%rdi        # cfb0 <_GLOBAL_OFFSET_TABLE_+0x1d8>
    95d4:	74 1a                	je     95f0 <z_time_slice+0x60>
		if (ticks >= _current_cpu->slice_ticks) {
    95d6:	8b 50 20             	mov    0x20(%rax),%edx
    95d9:	39 da                	cmp    %ebx,%edx
    95db:	7f 0c                	jg     95e9 <z_time_slice+0x59>
			move_thread_to_end_of_prio_q(_current);
    95dd:	e8 0c ff ff ff       	callq  94ee <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    95e2:	e8 18 fb ff ff       	callq  90ff <z_reset_time_slice>
    95e7:	eb 0e                	jmp    95f7 <z_time_slice+0x67>
			_current_cpu->slice_ticks -= ticks;
    95e9:	29 da                	sub    %ebx,%edx
    95eb:	89 50 20             	mov    %edx,0x20(%rax)
    95ee:	eb 07                	jmp    95f7 <z_time_slice+0x67>
		_current_cpu->slice_ticks = 0;
    95f0:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
}
    95f7:	58                   	pop    %rax
	posix_irq_unlock(key);
    95f8:	89 ef                	mov    %ebp,%edi
    95fa:	5b                   	pop    %rbx
    95fb:	5d                   	pop    %rbp
    95fc:	e9 6c df ff ff       	jmpq   756d <posix_irq_unlock>

0000000000009601 <ready_thread>:
    9601:	8a 47 19             	mov    0x19(%rdi),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    9604:	84 c0                	test   %al,%al
    9606:	0f 88 95 00 00 00    	js     96a1 <ready_thread+0xa0>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    960c:	a8 1f                	test   $0x1f,%al
    960e:	0f 85 8d 00 00 00    	jne    96a1 <ready_thread+0xa0>
{
    9614:	41 54                	push   %r12
    9616:	55                   	push   %rbp
    9617:	53                   	push   %rbx
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    9618:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
    961d:	48 89 fb             	mov    %rdi,%rbx
    9620:	75 7a                	jne    969c <ready_thread+0x9b>
	return list->head == list;
    9622:	4c 8d 25 d7 6e 00 00 	lea    0x6ed7(%rip),%r12        # 10500 <_kernel>
	thread->base.thread_state |= _THREAD_QUEUED;
    9629:	83 c8 80             	or     $0xffffff80,%eax
    962c:	88 47 19             	mov    %al,0x19(%rdi)
    962f:	49 8b 6c 24 40       	mov    0x40(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    9634:	48 85 ed             	test   %rbp,%rbp
    9637:	74 0a                	je     9643 <ready_thread+0x42>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    9639:	49 8d 44 24 40       	lea    0x40(%r12),%rax
    963e:	48 39 c5             	cmp    %rax,%rbp
    9641:	75 1b                	jne    965e <ready_thread+0x5d>
	sys_dnode_t *const tail = list->tail;
    9643:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	node->next = list;
    9648:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
    964d:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    9650:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    9654:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    9657:	49 89 5c 24 48       	mov    %rbx,0x48(%r12)
}
    965c:	eb 33                	jmp    9691 <ready_thread+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
    965e:	48 89 ee             	mov    %rbp,%rsi
    9661:	48 89 df             	mov    %rbx,%rdi
    9664:	e8 7f fa ff ff       	callq  90e8 <z_sched_prio_cmp>
    9669:	85 c0                	test   %eax,%eax
    966b:	7e 14                	jle    9681 <ready_thread+0x80>
	sys_dnode_t *const prev = successor->prev;
    966d:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    9671:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = prev;
    9674:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    9678:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    967b:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    967f:	eb 10                	jmp    9691 <ready_thread+0x90>
	return (node == list->tail) ? NULL : node->next;
    9681:	49 39 6c 24 48       	cmp    %rbp,0x48(%r12)
    9686:	74 bb                	je     9643 <ready_thread+0x42>
    9688:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    968c:	48 85 ed             	test   %rbp,%rbp
    968f:	eb b0                	jmp    9641 <ready_thread+0x40>
}
    9691:	5b                   	pop    %rbx
		update_cache(0);
    9692:	31 ff                	xor    %edi,%edi
}
    9694:	5d                   	pop    %rbp
    9695:	41 5c                	pop    %r12
		update_cache(0);
    9697:	e9 cf fb ff ff       	jmpq   926b <update_cache>
}
    969c:	5b                   	pop    %rbx
    969d:	5d                   	pop    %rbp
    969e:	41 5c                	pop    %r12
    96a0:	c3                   	retq   
    96a1:	c3                   	retq   

00000000000096a2 <z_ready_thread>:
{
    96a2:	f3 0f 1e fa          	endbr64 
    96a6:	55                   	push   %rbp
    96a7:	48 83 ec 10          	sub    $0x10,%rsp
    96ab:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    96b0:	e8 aa de ff ff       	callq  755f <posix_irq_lock>
			ready_thread(thread);
    96b5:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    96ba:	89 c5                	mov    %eax,%ebp
    96bc:	e8 40 ff ff ff       	callq  9601 <ready_thread>
}
    96c1:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    96c5:	89 ef                	mov    %ebp,%edi
    96c7:	5d                   	pop    %rbp
    96c8:	e9 a0 de ff ff       	jmpq   756d <posix_irq_unlock>

00000000000096cd <z_sched_start>:
{
    96cd:	f3 0f 1e fa          	endbr64 
    96d1:	41 54                	push   %r12
    96d3:	48 83 ec 10          	sub    $0x10,%rsp
    96d7:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    96dc:	e8 7e de ff ff       	callq  755f <posix_irq_lock>
	if (z_has_thread_started(thread)) {
    96e1:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    96e6:	41 89 c4             	mov    %eax,%r12d
    96e9:	8a 47 19             	mov    0x19(%rdi),%al
    96ec:	a8 04                	test   $0x4,%al
    96ee:	75 0e                	jne    96fe <z_sched_start+0x31>
}
    96f0:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    96f4:	44 89 e7             	mov    %r12d,%edi
    96f7:	41 5c                	pop    %r12
    96f9:	e9 6f de ff ff       	jmpq   756d <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    96fe:	83 e0 fb             	and    $0xfffffffb,%eax
    9701:	88 47 19             	mov    %al,0x19(%rdi)
	ready_thread(thread);
    9704:	e8 f8 fe ff ff       	callq  9601 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    9709:	48 8d 3d 87 6f 00 00 	lea    0x6f87(%rip),%rdi        # 10697 <sched_spinlock>
}
    9710:	48 83 c4 10          	add    $0x10,%rsp
	z_reschedule(&sched_spinlock, key);
    9714:	44 89 e6             	mov    %r12d,%esi
}
    9717:	41 5c                	pop    %r12
	z_reschedule(&sched_spinlock, key);
    9719:	e9 85 fa ff ff       	jmpq   91a3 <z_reschedule>

000000000000971e <z_thread_timeout>:
{
    971e:	f3 0f 1e fa          	endbr64 
    9722:	41 54                	push   %r12
    9724:	55                   	push   %rbp
    9725:	53                   	push   %rbx
    9726:	48 89 fb             	mov    %rdi,%rbx
	return posix_irq_lock();
    9729:	e8 31 de ff ff       	callq  755f <posix_irq_lock>
    972e:	89 c5                	mov    %eax,%ebp
		if (!killed) {
    9730:	f6 43 f1 28          	testb  $0x28,-0xf(%rbx)
    9734:	75 1f                	jne    9755 <z_thread_timeout+0x37>
			if (thread->base.pended_on != NULL) {
    9736:	48 83 7b e8 00       	cmpq   $0x0,-0x18(%rbx)
	struct k_thread *thread = CONTAINER_OF(timeout,
    973b:	4c 8d 63 d8          	lea    -0x28(%rbx),%r12
			if (thread->base.pended_on != NULL) {
    973f:	74 08                	je     9749 <z_thread_timeout+0x2b>
				unpend_thread_no_timeout(thread);
    9741:	4c 89 e7             	mov    %r12,%rdi
    9744:	e8 f0 fa ff ff       	callq  9239 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    9749:	80 63 f1 eb          	andb   $0xeb,-0xf(%rbx)
			ready_thread(thread);
    974d:	4c 89 e7             	mov    %r12,%rdi
    9750:	e8 ac fe ff ff       	callq  9601 <ready_thread>
}
    9755:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    9756:	89 ef                	mov    %ebp,%edi
    9758:	5d                   	pop    %rbp
    9759:	41 5c                	pop    %r12
    975b:	e9 0d de ff ff       	jmpq   756d <posix_irq_unlock>

0000000000009760 <z_unpend_first_thread>:
{
    9760:	f3 0f 1e fa          	endbr64 
    9764:	41 54                	push   %r12
    9766:	55                   	push   %rbp
    9767:	48 83 ec 18          	sub    $0x18,%rsp
    976b:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    9770:	e8 ea dd ff ff       	callq  755f <posix_irq_lock>
		thread = _priq_wait_best(&wait_q->waitq);
    9775:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    977a:	89 c5                	mov    %eax,%ebp
    977c:	e8 d6 fa ff ff       	callq  9257 <z_priq_dumb_best>
    9781:	49 89 c4             	mov    %rax,%r12
		if (thread != NULL) {
    9784:	48 85 c0             	test   %rax,%rax
    9787:	74 12                	je     979b <z_unpend_first_thread+0x3b>
			unpend_thread_no_timeout(thread);
    9789:	48 89 c7             	mov    %rax,%rdi
    978c:	e8 a8 fa ff ff       	callq  9239 <unpend_thread_no_timeout>
    9791:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
    9796:	e8 aa 05 00 00       	callq  9d45 <z_abort_timeout>
	posix_irq_unlock(key);
    979b:	89 ef                	mov    %ebp,%edi
    979d:	e8 cb dd ff ff       	callq  756d <posix_irq_unlock>
}
    97a2:	48 83 c4 18          	add    $0x18,%rsp
    97a6:	4c 89 e0             	mov    %r12,%rax
    97a9:	5d                   	pop    %rbp
    97aa:	41 5c                	pop    %r12
    97ac:	c3                   	retq   

00000000000097ad <z_sched_init>:
{
    97ad:	f3 0f 1e fa          	endbr64 
	list->head = (sys_dnode_t *)list;
    97b1:	48 8d 05 48 6d 00 00 	lea    0x6d48(%rip),%rax        # 10500 <_kernel>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    97b8:	31 f6                	xor    %esi,%esi
    97ba:	31 ff                	xor    %edi,%edi
    97bc:	48 8d 50 40          	lea    0x40(%rax),%rdx
    97c0:	48 89 50 40          	mov    %rdx,0x40(%rax)
	list->tail = (sys_dnode_t *)list;
    97c4:	48 89 50 48          	mov    %rdx,0x48(%rax)
    97c8:	e9 60 f9 ff ff       	jmpq   912d <k_sched_time_slice_set>

00000000000097cd <z_impl_k_yield>:
{
    97cd:	f3 0f 1e fa          	endbr64 
    97d1:	41 55                	push   %r13
    97d3:	41 54                	push   %r12
    97d5:	55                   	push   %rbp
    97d6:	53                   	push   %rbx
    97d7:	52                   	push   %rdx
	if (!z_is_idle_thread_object(_current)) {
    97d8:	48 8d 2d 21 6d 00 00 	lea    0x6d21(%rip),%rbp        # 10500 <_kernel>
    97df:	48 8d 05 da 6b 00 00 	lea    0x6bda(%rip),%rax        # 103c0 <z_idle_threads>
    97e6:	48 39 45 10          	cmp    %rax,0x10(%rbp)
    97ea:	0f 84 8e 00 00 00    	je     987e <z_impl_k_yield+0xb1>
	return posix_irq_lock();
    97f0:	e8 6a dd ff ff       	callq  755f <posix_irq_lock>
			dequeue_thread(&_kernel.ready_q.runq,
    97f5:	48 8b 75 10          	mov    0x10(%rbp),%rsi
		_priq_run_remove(pq, thread);
    97f9:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    97fd:	41 89 c5             	mov    %eax,%r13d
	thread->base.thread_state &= ~_THREAD_QUEUED;
    9800:	80 66 19 7f          	andb   $0x7f,0x19(%rsi)
		_priq_run_remove(pq, thread);
    9804:	e8 0e fa ff ff       	callq  9217 <z_priq_dumb_remove>
		queue_thread(&_kernel.ready_q.runq, _current);
    9809:	48 8b 5d 10          	mov    0x10(%rbp),%rbx
	thread->base.thread_state |= _THREAD_QUEUED;
    980d:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	return list->head == list;
    9811:	4c 8b 65 40          	mov    0x40(%rbp),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    9815:	4d 85 e4             	test   %r12,%r12
    9818:	74 09                	je     9823 <z_impl_k_yield+0x56>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    981a:	48 8d 45 40          	lea    0x40(%rbp),%rax
    981e:	49 39 c4             	cmp    %rax,%r12
    9821:	75 18                	jne    983b <z_impl_k_yield+0x6e>
	sys_dnode_t *const tail = list->tail;
    9823:	48 8b 45 48          	mov    0x48(%rbp),%rax
	node->next = list;
    9827:	48 8d 55 40          	lea    0x40(%rbp),%rdx
    982b:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    982e:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    9832:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    9835:	48 89 5d 48          	mov    %rbx,0x48(%rbp)
}
    9839:	eb 34                	jmp    986f <z_impl_k_yield+0xa2>
		if (z_sched_prio_cmp(thread, t) > 0) {
    983b:	4c 89 e6             	mov    %r12,%rsi
    983e:	48 89 df             	mov    %rbx,%rdi
    9841:	e8 a2 f8 ff ff       	callq  90e8 <z_sched_prio_cmp>
    9846:	85 c0                	test   %eax,%eax
    9848:	7e 16                	jle    9860 <z_impl_k_yield+0x93>
	sys_dnode_t *const prev = successor->prev;
    984a:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
    984f:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = prev;
    9852:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    9856:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    9859:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
    985e:	eb 0f                	jmp    986f <z_impl_k_yield+0xa2>
	return (node == list->tail) ? NULL : node->next;
    9860:	4c 39 65 48          	cmp    %r12,0x48(%rbp)
    9864:	74 bd                	je     9823 <z_impl_k_yield+0x56>
    9866:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    986a:	4d 85 e4             	test   %r12,%r12
    986d:	eb b2                	jmp    9821 <z_impl_k_yield+0x54>
		update_cache(1);
    986f:	bf 01 00 00 00       	mov    $0x1,%edi
    9874:	e8 f2 f9 ff ff       	callq  926b <update_cache>
    9879:	44 89 ef             	mov    %r13d,%edi
    987c:	eb 07                	jmp    9885 <z_impl_k_yield+0xb8>
    987e:	e8 dc dc ff ff       	callq  755f <posix_irq_lock>
    9883:	89 c7                	mov    %eax,%edi
}
    9885:	58                   	pop    %rax
    9886:	5b                   	pop    %rbx
    9887:	5d                   	pop    %rbp
    9888:	41 5c                	pop    %r12
    988a:	41 5d                	pop    %r13
    988c:	e9 0c d1 ff ff       	jmpq   699d <arch_swap>

0000000000009891 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    9891:	f3 0f 1e fa          	endbr64 
    9895:	51                   	push   %rcx

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    9896:	48 83 ff ff          	cmp    $0xffffffffffffffff,%rdi
    989a:	75 15                	jne    98b1 <z_impl_k_sleep+0x20>
		k_thread_suspend(_current);
    989c:	48 8d 05 5d 6c 00 00 	lea    0x6c5d(%rip),%rax        # 10500 <_kernel>
    98a3:	48 8b 78 10          	mov    0x10(%rax),%rdi
	z_impl_k_thread_suspend(thread);
    98a7:	e8 a9 fb ff ff       	callq  9455 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    98ac:	83 c8 ff             	or     $0xffffffff,%eax
}
    98af:	eb 16                	jmp    98c7 <z_impl_k_sleep+0x36>
	if (ticks == 0) {
    98b1:	48 85 ff             	test   %rdi,%rdi
    98b4:	75 09                	jne    98bf <z_impl_k_sleep+0x2e>
	z_impl_k_yield();
    98b6:	e8 12 ff ff ff       	callq  97cd <z_impl_k_yield>
		return 0;
    98bb:	31 c0                	xor    %eax,%eax
}
    98bd:	eb 05                	jmp    98c4 <z_impl_k_sleep+0x33>
    98bf:	e8 21 fb ff ff       	callq  93e5 <z_tick_sleep.part.0>

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
    98c4:	6b c0 0a             	imul   $0xa,%eax,%eax
}
    98c7:	5a                   	pop    %rdx
    98c8:	c3                   	retq   

00000000000098c9 <z_impl_k_usleep>:
}
#include <syscalls/k_sleep_mrsh.c>
#endif

int32_t z_impl_k_usleep(int us)
{
    98c9:	f3 0f 1e fa          	endbr64 
	int32_t ticks;

	ticks = k_us_to_ticks_ceil64(us);
    98cd:	48 63 c7             	movslq %edi,%rax
    98d0:	31 d2                	xor    %edx,%edx
{
    98d2:	51                   	push   %rcx
    98d3:	b9 10 27 00 00       	mov    $0x2710,%ecx
		t += off;
    98d8:	48 05 0f 27 00 00    	add    $0x270f,%rax
			return t / (from_hz / to_hz);
    98de:	48 f7 f1             	div    %rcx
	ticks = z_tick_sleep(ticks);
    98e1:	48 63 f8             	movslq %eax,%rdi
	if (ticks == 0) {
    98e4:	48 85 ff             	test   %rdi,%rdi
    98e7:	75 09                	jne    98f2 <z_impl_k_usleep+0x29>
	z_impl_k_yield();
    98e9:	e8 df fe ff ff       	callq  97cd <z_impl_k_yield>
		return 0;
    98ee:	31 c0                	xor    %eax,%eax
}
    98f0:	eb 05                	jmp    98f7 <z_impl_k_usleep+0x2e>
    98f2:	e8 ee fa ff ff       	callq  93e5 <z_tick_sleep.part.0>
	return k_ticks_to_us_floor64(ticks);
    98f7:	48 98                	cltq   
}
    98f9:	5a                   	pop    %rdx
			return t * (to_hz / from_hz);
    98fa:	48 69 c0 10 27 00 00 	imul   $0x2710,%rax,%rax
    9901:	c3                   	retq   

0000000000009902 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
    9902:	f3 0f 1e fa          	endbr64 
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    9906:	48 8d 05 f3 6b 00 00 	lea    0x6bf3(%rip),%rax        # 10500 <_kernel>

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    990d:	48 8b 40 10          	mov    0x10(%rax),%rax
}
    9911:	c3                   	retq   

0000000000009912 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    9912:	f3 0f 1e fa          	endbr64 
    9916:	41 55                	push   %r13
    9918:	41 54                	push   %r12
    991a:	55                   	push   %rbp
    991b:	53                   	push   %rbx
    991c:	48 89 fb             	mov    %rdi,%rbx
    991f:	52                   	push   %rdx
    9920:	e8 3a dc ff ff       	callq  755f <posix_irq_lock>
    9925:	41 89 c4             	mov    %eax,%r12d
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    9928:	8a 43 19             	mov    0x19(%rbx),%al
    992b:	a8 08                	test   $0x8,%al
    992d:	0f 85 9b 00 00 00    	jne    99ce <z_thread_abort+0xbc>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    9933:	89 c2                	mov    %eax,%edx
    9935:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
    9938:	80 ca 08             	or     $0x8,%dl
    993b:	78 05                	js     9942 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    993d:	88 53 19             	mov    %dl,0x19(%rbx)
    9940:	eb 1c                	jmp    995e <z_thread_abort+0x4c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    9942:	83 e0 5f             	and    $0x5f,%eax
		_priq_run_remove(pq, thread);
    9945:	48 89 de             	mov    %rbx,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    9948:	83 c8 08             	or     $0x8,%eax
    994b:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    994e:	48 8d 05 ab 6b 00 00 	lea    0x6bab(%rip),%rax        # 10500 <_kernel>
    9955:	48 8d 78 40          	lea    0x40(%rax),%rdi
    9959:	e8 b9 f8 ff ff       	callq  9217 <z_priq_dumb_remove>
		if (thread->base.pended_on != NULL) {
    995e:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
    9963:	74 08                	je     996d <z_thread_abort+0x5b>
			unpend_thread_no_timeout(thread);
    9965:	48 89 df             	mov    %rbx,%rdi
    9968:	e8 cc f8 ff ff       	callq  9239 <unpend_thread_no_timeout>
    996d:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    9971:	4c 8d 6b 60          	lea    0x60(%rbx),%r13
    9975:	e8 cb 03 00 00       	callq  9d45 <z_abort_timeout>
	return list->head == list;
    997a:	48 8b 6b 60          	mov    0x60(%rbx),%rbp
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    997e:	48 85 ed             	test   %rbp,%rbp
    9981:	74 27                	je     99aa <z_thread_abort+0x98>
    9983:	4c 39 ed             	cmp    %r13,%rbp
    9986:	74 22                	je     99aa <z_thread_abort+0x98>
		unpend_thread_no_timeout(thread);
    9988:	48 89 ef             	mov    %rbp,%rdi
    998b:	e8 a9 f8 ff ff       	callq  9239 <unpend_thread_no_timeout>
    9990:	48 8d 7d 28          	lea    0x28(%rbp),%rdi
    9994:	e8 ac 03 00 00       	callq  9d45 <z_abort_timeout>
	thread->callee_saved.retval = value;
    9999:	c7 45 4c 00 00 00 00 	movl   $0x0,0x4c(%rbp)
		ready_thread(thread);
    99a0:	48 89 ef             	mov    %rbp,%rdi
    99a3:	e8 59 fc ff ff       	callq  9601 <ready_thread>
    99a8:	eb d0                	jmp    997a <z_thread_abort+0x68>
		update_cache(1);
    99aa:	bf 01 00 00 00       	mov    $0x1,%edi
    99af:	e8 b7 f8 ff ff       	callq  926b <update_cache>
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
    99b4:	48 8d 05 45 6b 00 00 	lea    0x6b45(%rip),%rax        # 10500 <_kernel>
    99bb:	48 39 58 10          	cmp    %rbx,0x10(%rax)
    99bf:	75 0d                	jne    99ce <z_thread_abort+0xbc>
    99c1:	83 38 00             	cmpl   $0x0,(%rax)
    99c4:	75 08                	jne    99ce <z_thread_abort+0xbc>
    99c6:	44 89 e7             	mov    %r12d,%edi
    99c9:	e8 cf cf ff ff       	callq  699d <arch_swap>
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    99ce:	58                   	pop    %rax
	posix_irq_unlock(key);
    99cf:	44 89 e7             	mov    %r12d,%edi
    99d2:	5b                   	pop    %rbx
    99d3:	5d                   	pop    %rbp
    99d4:	41 5c                	pop    %r12
    99d6:	41 5d                	pop    %r13
    99d8:	e9 90 db ff ff       	jmpq   756d <posix_irq_unlock>

00000000000099dd <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    99dd:	f3 0f 1e fa          	endbr64 
	z_sched_start(thread);
    99e1:	e9 e7 fc ff ff       	jmpq   96cd <z_sched_start>

00000000000099e6 <z_init_thread_base>:
}
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    99e6:	f3 0f 1e fa          	endbr64 
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    99ea:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    99f1:	00 
	thread_base->user_options = (uint8_t)options;
    99f2:	88 4f 18             	mov    %cl,0x18(%rdi)
	thread_base->thread_state = (uint8_t)initial_state;
    99f5:	88 57 19             	mov    %dl,0x19(%rdi)

	thread_base->prio = priority;
    99f8:	40 88 77 1a          	mov    %sil,0x1a(%rdi)

	thread_base->sched_locked = 0U;
    99fc:	c6 47 1b 00          	movb   $0x0,0x1b(%rdi)
	node->next = NULL;
    9a00:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
    9a07:	00 
	node->prev = NULL;
    9a08:	48 c7 47 30 00 00 00 	movq   $0x0,0x30(%rdi)
    9a0f:	00 
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    9a10:	c3                   	retq   

0000000000009a11 <z_setup_new_thread>:
{
    9a11:	f3 0f 1e fa          	endbr64 
    9a15:	41 55                	push   %r13
	sys_dlist_init(&w->waitq);
    9a17:	48 8d 47 60          	lea    0x60(%rdi),%rax
    9a1b:	49 89 cd             	mov    %rcx,%r13
    9a1e:	41 54                	push   %r12
    9a20:	49 89 d4             	mov    %rdx,%r12
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    9a23:	ba 04 00 00 00       	mov    $0x4,%edx
{
    9a28:	55                   	push   %rbp
    9a29:	48 89 f5             	mov    %rsi,%rbp
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    9a2c:	49 83 c4 07          	add    $0x7,%r12
{
    9a30:	53                   	push   %rbx
    9a31:	48 89 fb             	mov    %rdi,%rbx
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    9a34:	49 83 e4 f8          	and    $0xfffffffffffffff8,%r12
	stack_ptr = (char *)stack + stack_obj_size;
    9a38:	49 01 ec             	add    %rbp,%r12
{
    9a3b:	48 83 ec 18          	sub    $0x18,%rsp
	list->head = (sys_dnode_t *)list;
    9a3f:	48 89 47 60          	mov    %rax,0x60(%rdi)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    9a43:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
    9a47:	8b 74 24 48          	mov    0x48(%rsp),%esi
	list->tail = (sys_dnode_t *)list;
    9a4b:	48 89 47 68          	mov    %rax,0x68(%rdi)
{
    9a4f:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    9a54:	4c 89 0c 24          	mov    %r9,(%rsp)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    9a58:	e8 89 ff ff ff       	callq  99e6 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    9a5d:	4c 89 e9             	mov    %r13,%rcx
    9a60:	4c 89 e2             	mov    %r12,%rdx
    9a63:	48 89 ee             	mov    %rbp,%rsi
    9a66:	50                   	push   %rax
    9a67:	48 89 df             	mov    %rbx,%rdi
    9a6a:	ff 74 24 48          	pushq  0x48(%rsp)
    9a6e:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
    9a73:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    9a78:	e8 89 cf ff ff       	callq  6a06 <arch_new_thread>
	if (!_current) {
    9a7d:	48 8d 05 7c 6a 00 00 	lea    0x6a7c(%rip),%rax        # 10500 <_kernel>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    9a84:	5a                   	pop    %rdx
	new_thread->init_data = NULL;
    9a85:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    9a8c:	00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    9a8d:	59                   	pop    %rcx
	if (!_current) {
    9a8e:	48 8b 40 10          	mov    0x10(%rax),%rax
    9a92:	48 85 c0             	test   %rax,%rax
    9a95:	74 04                	je     9a9b <z_setup_new_thread+0x8a>
	new_thread->resource_pool = _current->resource_pool;
    9a97:	48 8b 40 78          	mov    0x78(%rax),%rax
	return stack_ptr;
    9a9b:	48 89 43 78          	mov    %rax,0x78(%rbx)
}
    9a9f:	48 83 c4 18          	add    $0x18,%rsp
    9aa3:	4c 89 e0             	mov    %r12,%rax
    9aa6:	5b                   	pop    %rbx
    9aa7:	5d                   	pop    %rbp
    9aa8:	41 5c                	pop    %r12
    9aaa:	41 5d                	pop    %r13
    9aac:	c3                   	retq   

0000000000009aad <z_init_static_threads>:
{
    9aad:	f3 0f 1e fa          	endbr64 
    9ab1:	55                   	push   %rbp
    9ab2:	53                   	push   %rbx
    9ab3:	52                   	push   %rdx
	_FOREACH_STATIC_THREAD(thread_data) {
    9ab4:	48 8d 1d 65 5f 00 00 	lea    0x5f65(%rip),%rbx        # fa20 <_k_thread_data_processing_tid>
    9abb:	48 89 dd             	mov    %rbx,%rbp
    9abe:	48 3b 1d f3 34 00 00 	cmp    0x34f3(%rip),%rbx        # cfb8 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    9ac5:	73 3a                	jae    9b01 <z_init_static_threads+0x54>
		z_setup_new_thread(
    9ac7:	4c 8b 4b 28          	mov    0x28(%rbx),%r9
    9acb:	4c 8b 43 20          	mov    0x20(%rbx),%r8
    9acf:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    9ad3:	8b 53 10             	mov    0x10(%rbx),%edx
    9ad6:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    9ada:	ff 73 50             	pushq  0x50(%rbx)
    9add:	8b 43 3c             	mov    0x3c(%rbx),%eax
    9ae0:	50                   	push   %rax
    9ae1:	8b 43 38             	mov    0x38(%rbx),%eax
    9ae4:	50                   	push   %rax
    9ae5:	ff 73 30             	pushq  0x30(%rbx)
    9ae8:	48 8b 3b             	mov    (%rbx),%rdi
    9aeb:	e8 21 ff ff ff       	callq  9a11 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    9af0:	48 8b 03             	mov    (%rbx),%rax
		z_setup_new_thread(
    9af3:	48 83 c4 20          	add    $0x20,%rsp
		thread_data->init_thread->init_data = thread_data;
    9af7:	48 89 58 58          	mov    %rbx,0x58(%rax)
	_FOREACH_STATIC_THREAD(thread_data) {
    9afb:	48 83 c3 58          	add    $0x58,%rbx
    9aff:	eb bd                	jmp    9abe <z_init_static_threads+0x11>
	k_sched_lock();
    9b01:	e8 f1 f6 ff ff       	callq  91f7 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    9b06:	48 89 eb             	mov    %rbp,%rbx
					    K_MSEC(thread_data->init_delay));
    9b09:	31 ed                	xor    %ebp,%ebp
	_FOREACH_STATIC_THREAD(thread_data) {
    9b0b:	48 3b 1d a6 34 00 00 	cmp    0x34a6(%rip),%rbx        # cfb8 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    9b12:	73 46                	jae    9b5a <z_init_static_threads+0xad>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    9b14:	8b 43 40             	mov    0x40(%rbx),%eax
    9b17:	83 f8 ff             	cmp    $0xffffffff,%eax
    9b1a:	74 38                	je     9b54 <z_init_static_threads+0xa7>
					    K_MSEC(thread_data->init_delay));
    9b1c:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
    9b1e:	48 8b 3b             	mov    (%rbx),%rdi
					    K_MSEC(thread_data->init_delay));
    9b21:	0f 48 c5             	cmovs  %ebp,%eax
    9b24:	48 63 c8             	movslq %eax,%rcx
		t += off;
    9b27:	48 8d 41 09          	lea    0x9(%rcx),%rax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    9b2b:	48 85 c9             	test   %rcx,%rcx
    9b2e:	75 07                	jne    9b37 <z_init_static_threads+0x8a>
	z_impl_k_thread_start(thread);
    9b30:	e8 a8 fe ff ff       	callq  99dd <z_impl_k_thread_start>
}
    9b35:	eb 1d                	jmp    9b54 <z_init_static_threads+0xa7>
			return t / (from_hz / to_hz);
    9b37:	b9 0a 00 00 00       	mov    $0xa,%ecx
    9b3c:	31 d2                	xor    %edx,%edx
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    9b3e:	48 8d 35 d9 fb ff ff 	lea    -0x427(%rip),%rsi        # 971e <z_thread_timeout>
    9b45:	48 83 c7 28          	add    $0x28,%rdi
    9b49:	48 f7 f1             	div    %rcx
    9b4c:	48 89 c2             	mov    %rax,%rdx
    9b4f:	e8 d5 00 00 00       	callq  9c29 <z_add_timeout>
	_FOREACH_STATIC_THREAD(thread_data) {
    9b54:	48 83 c3 58          	add    $0x58,%rbx
    9b58:	eb b1                	jmp    9b0b <z_init_static_threads+0x5e>
}
    9b5a:	58                   	pop    %rax
    9b5b:	5b                   	pop    %rbx
    9b5c:	5d                   	pop    %rbp
	k_sched_unlock();
    9b5d:	e9 5e f9 ff ff       	jmpq   94c0 <k_sched_unlock>

0000000000009b62 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    9b62:	f3 0f 1e fa          	endbr64 
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    9b66:	48 8d 15 9d 09 00 00 	lea    0x99d(%rip),%rdx        # a50a <default_cmd+0x2aa>
    9b6d:	48 8d 35 59 1b 00 00 	lea    0x1b59(%rip),%rsi        # b6cd <default_cmd+0x146d>
    9b74:	31 c0                	xor    %eax,%eax
    9b76:	48 8d 3d 71 1b 00 00 	lea    0x1b71(%rip),%rdi        # b6ee <default_cmd+0x148e>
    9b7d:	e9 ad a6 ff ff       	jmpq   422f <printk>

0000000000009b82 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    9b82:	83 3d ff 6a 00 00 00 	cmpl   $0x0,0x6aff(%rip)        # 10688 <announce_remaining>
    9b89:	75 05                	jne    9b90 <elapsed+0xe>
    9b8b:	e9 a3 b5 ff ff       	jmpq   5133 <sys_clock_elapsed>
}
    9b90:	31 c0                	xor    %eax,%eax
    9b92:	c3                   	retq   

0000000000009b93 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    9b93:	48 8b 07             	mov    (%rdi),%rax
    9b96:	48 85 ff             	test   %rdi,%rdi
    9b99:	74 16                	je     9bb1 <remove_timeout+0x1e>
	return (node == list->tail) ? NULL : node->next;
    9b9b:	48 3b 3d 96 38 00 00 	cmp    0x3896(%rip),%rdi        # d438 <timeout_list+0x8>
    9ba2:	74 0d                	je     9bb1 <remove_timeout+0x1e>
	if (next(t) != NULL) {
    9ba4:	48 85 c0             	test   %rax,%rax
    9ba7:	74 08                	je     9bb1 <remove_timeout+0x1e>
		next(t)->dticks += t->dticks;
    9ba9:	48 8b 57 18          	mov    0x18(%rdi),%rdx
    9bad:	48 01 50 18          	add    %rdx,0x18(%rax)
	sys_dnode_t *const prev = node->prev;
    9bb1:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	prev->next = next;
    9bb5:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
    9bb8:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    9bbc:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
    9bc3:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    9bca:	00 
}
    9bcb:	c3                   	retq   

0000000000009bcc <next_timeout>:

static int32_t next_timeout(void)
{
    9bcc:	53                   	push   %rbx
	return list->head == list;
    9bcd:	48 8b 1d 5c 38 00 00 	mov    0x385c(%rip),%rbx        # d430 <timeout_list>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    9bd4:	48 8d 05 55 38 00 00 	lea    0x3855(%rip),%rax        # d430 <timeout_list>
    9bdb:	48 39 c3             	cmp    %rax,%rbx
    9bde:	75 02                	jne    9be2 <next_timeout+0x16>
    9be0:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    9be2:	e8 9b ff ff ff       	callq  9b82 <elapsed>
    9be7:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
    9be9:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    9bee:	48 85 db             	test   %rbx,%rbx
    9bf1:	74 21                	je     9c14 <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    9bf3:	48 63 c2             	movslq %edx,%rax
    9bf6:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    9bfa:	48 29 c2             	sub    %rax,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    9bfd:	31 c0                	xor    %eax,%eax
    9bff:	48 85 d2             	test   %rdx,%rdx
    9c02:	7e 10                	jle    9c14 <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    9c04:	48 81 fa ff ff ff 7f 	cmp    $0x7fffffff,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    9c0b:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    9c10:	48 0f 4e c2          	cmovle %rdx,%rax

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    9c14:	48 8d 15 e5 68 00 00 	lea    0x68e5(%rip),%rdx        # 10500 <_kernel>
    9c1b:	8b 52 20             	mov    0x20(%rdx),%edx
    9c1e:	85 d2                	test   %edx,%edx
    9c20:	74 05                	je     9c27 <next_timeout+0x5b>
    9c22:	39 d0                	cmp    %edx,%eax
    9c24:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    9c27:	5b                   	pop    %rbx
    9c28:	c3                   	retq   

0000000000009c29 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    9c29:	f3 0f 1e fa          	endbr64 
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    9c2d:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    9c31:	0f 84 0d 01 00 00    	je     9d44 <z_add_timeout+0x11b>
{
    9c37:	41 56                	push   %r14
    9c39:	49 89 f6             	mov    %rsi,%r14
    9c3c:	41 55                	push   %r13
    9c3e:	49 89 d5             	mov    %rdx,%r13
    9c41:	41 54                	push   %r12
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    9c43:	49 c7 c4 fe ff ff ff 	mov    $0xfffffffffffffffe,%r12
{
    9c4a:	55                   	push   %rbp
	k_ticks_t ticks = timeout.ticks + 1;
    9c4b:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
{
    9c4f:	53                   	push   %rbx
    9c50:	48 89 fb             	mov    %rdi,%rbx
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    9c53:	49 39 ec             	cmp    %rbp,%r12
    9c56:	78 17                	js     9c6f <z_add_timeout+0x46>
		ticks = Z_TICK_ABS(timeout.ticks) - (curr_tick + elapsed());
    9c58:	e8 25 ff ff ff       	callq  9b82 <elapsed>
    9c5d:	4c 89 e5             	mov    %r12,%rbp
    9c60:	48 2b 2d d1 69 00 00 	sub    0x69d1(%rip),%rbp        # 10638 <curr_tick>
    9c67:	4c 29 ed             	sub    %r13,%rbp
    9c6a:	48 98                	cltq   
    9c6c:	48 29 c5             	sub    %rax,%rbp
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    9c6f:	4c 89 73 10          	mov    %r14,0x10(%rbx)
	return posix_irq_lock();
    9c73:	e8 e7 d8 ff ff       	callq  755f <posix_irq_lock>
    9c78:	41 89 c4             	mov    %eax,%r12d
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    9c7b:	e8 02 ff ff ff       	callq  9b82 <elapsed>
	ticks = MAX(1, ticks);
    9c80:	48 85 ed             	test   %rbp,%rbp
    9c83:	ba 01 00 00 00       	mov    $0x1,%edx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    9c88:	48 8b 3d a9 37 00 00 	mov    0x37a9(%rip),%rdi        # d438 <timeout_list+0x8>
    9c8f:	48 0f 4e ea          	cmovle %rdx,%rbp
		to->dticks = ticks + elapsed();
    9c93:	48 98                	cltq   
	return list->head == list;
    9c95:	48 8d 15 94 37 00 00 	lea    0x3794(%rip),%rdx        # d430 <timeout_list>
    9c9c:	48 01 c5             	add    %rax,%rbp
    9c9f:	48 8b 05 8a 37 00 00 	mov    0x378a(%rip),%rax        # d430 <timeout_list>
    9ca6:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    9caa:	48 39 d0             	cmp    %rdx,%rax
    9cad:	74 3e                	je     9ced <z_add_timeout+0xc4>
		for (t = first(); t != NULL; t = next(t)) {
    9caf:	48 85 c0             	test   %rax,%rax
    9cb2:	74 39                	je     9ced <z_add_timeout+0xc4>
			if (t->dticks > to->dticks) {
    9cb4:	48 8b 70 18          	mov    0x18(%rax),%rsi
    9cb8:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    9cbc:	48 39 ce             	cmp    %rcx,%rsi
    9cbf:	7e 1b                	jle    9cdc <z_add_timeout+0xb3>
				t->dticks -= to->dticks;
    9cc1:	48 29 ce             	sub    %rcx,%rsi
	sys_dnode_t *const prev = successor->prev;
    9cc4:	48 8b 48 08          	mov    0x8(%rax),%rcx
    9cc8:	48 89 70 18          	mov    %rsi,0x18(%rax)
	node->prev = prev;
    9ccc:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	node->next = successor;
    9cd0:	48 89 03             	mov    %rax,(%rbx)
	prev->next = node;
    9cd3:	48 89 19             	mov    %rbx,(%rcx)
	successor->prev = node;
    9cd6:	48 89 58 08          	mov    %rbx,0x8(%rax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    9cda:	eb 29                	jmp    9d05 <z_add_timeout+0xdc>
			to->dticks -= t->dticks;
    9cdc:	48 29 f1             	sub    %rsi,%rcx
    9cdf:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
	return (node == list->tail) ? NULL : node->next;
    9ce3:	48 39 f8             	cmp    %rdi,%rax
    9ce6:	74 05                	je     9ced <z_add_timeout+0xc4>
    9ce8:	48 8b 00             	mov    (%rax),%rax
    9ceb:	eb c2                	jmp    9caf <z_add_timeout+0x86>
	sys_dnode_t *const tail = list->tail;
    9ced:	48 8b 05 44 37 00 00 	mov    0x3744(%rip),%rax        # d438 <timeout_list+0x8>
	node->next = list;
    9cf4:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    9cf7:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    9cfb:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    9cfe:	48 89 1d 33 37 00 00 	mov    %rbx,0x3733(%rip)        # d438 <timeout_list+0x8>
	return list->head == list;
    9d05:	48 8b 05 24 37 00 00 	mov    0x3724(%rip),%rax        # d430 <timeout_list>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    9d0c:	48 39 c3             	cmp    %rax,%rbx
    9d0f:	75 23                	jne    9d34 <z_add_timeout+0x10b>
    9d11:	48 39 d0             	cmp    %rdx,%rax
    9d14:	74 1e                	je     9d34 <z_add_timeout+0x10b>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    9d16:	e8 b1 fe ff ff       	callq  9bcc <next_timeout>
    9d1b:	89 c7                	mov    %eax,%edi

			if (next_time == 0 ||
    9d1d:	85 c0                	test   %eax,%eax
    9d1f:	74 0c                	je     9d2d <z_add_timeout+0x104>
			    _current_cpu->slice_ticks != next_time) {
    9d21:	48 8d 05 d8 67 00 00 	lea    0x67d8(%rip),%rax        # 10500 <_kernel>
			if (next_time == 0 ||
    9d28:	39 78 20             	cmp    %edi,0x20(%rax)
    9d2b:	74 07                	je     9d34 <z_add_timeout+0x10b>
				sys_clock_set_timeout(next_time, false);
    9d2d:	31 f6                	xor    %esi,%esi
    9d2f:	e8 d8 b3 ff ff       	callq  510c <sys_clock_set_timeout>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    9d34:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    9d35:	44 89 e7             	mov    %r12d,%edi
    9d38:	5d                   	pop    %rbp
    9d39:	41 5c                	pop    %r12
    9d3b:	41 5d                	pop    %r13
    9d3d:	41 5e                	pop    %r14
    9d3f:	e9 29 d8 ff ff       	jmpq   756d <posix_irq_unlock>
    9d44:	c3                   	retq   

0000000000009d45 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    9d45:	f3 0f 1e fa          	endbr64 
    9d49:	41 54                	push   %r12
    9d4b:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
    9d51:	48 83 ec 10          	sub    $0x10,%rsp
    9d55:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    9d5a:	e8 00 d8 ff ff       	callq  755f <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    9d5f:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    9d64:	41 89 c0             	mov    %eax,%r8d
    9d67:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    9d6b:	74 08                	je     9d75 <z_abort_timeout+0x30>
			remove_timeout(to);
    9d6d:	e8 21 fe ff ff       	callq  9b93 <remove_timeout>
			ret = 0;
    9d72:	45 31 e4             	xor    %r12d,%r12d
	posix_irq_unlock(key);
    9d75:	44 89 c7             	mov    %r8d,%edi
    9d78:	e8 f0 d7 ff ff       	callq  756d <posix_irq_unlock>
		}
	}

	return ret;
}
    9d7d:	48 83 c4 10          	add    $0x10,%rsp
    9d81:	44 89 e0             	mov    %r12d,%eax
    9d84:	41 5c                	pop    %r12
    9d86:	c3                   	retq   

0000000000009d87 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    9d87:	f3 0f 1e fa          	endbr64 
    9d8b:	41 54                	push   %r12
    9d8d:	55                   	push   %rbp
    9d8e:	89 fd                	mov    %edi,%ebp
    9d90:	53                   	push   %rbx
    9d91:	89 f3                	mov    %esi,%ebx
	return posix_irq_lock();
    9d93:	e8 c7 d7 ff ff       	callq  755f <posix_irq_lock>
    9d98:	41 89 c4             	mov    %eax,%r12d
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    9d9b:	e8 2c fe ff ff       	callq  9bcc <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
    9da0:	83 f8 ff             	cmp    $0xffffffff,%eax
    9da3:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
    9da6:	39 e8                	cmp    %ebp,%eax
    9da8:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    9dab:	08 d1                	or     %dl,%cl
    9dad:	74 14                	je     9dc3 <z_set_timeout_expiry+0x3c>
    9daf:	83 f8 01             	cmp    $0x1,%eax
    9db2:	7e 0f                	jle    9dc3 <z_set_timeout_expiry+0x3c>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    9db4:	39 e8                	cmp    %ebp,%eax
    9db6:	89 ef                	mov    %ebp,%edi
    9db8:	0f b6 f3             	movzbl %bl,%esi
    9dbb:	0f 4e f8             	cmovle %eax,%edi
    9dbe:	e8 49 b3 ff ff       	callq  510c <sys_clock_set_timeout>
		}
	}
}
    9dc3:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    9dc4:	44 89 e7             	mov    %r12d,%edi
    9dc7:	5d                   	pop    %rbp
    9dc8:	41 5c                	pop    %r12
    9dca:	e9 9e d7 ff ff       	jmpq   756d <posix_irq_unlock>

0000000000009dcf <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    9dcf:	f3 0f 1e fa          	endbr64 
    9dd3:	41 54                	push   %r12
    9dd5:	4c 8d 25 54 36 00 00 	lea    0x3654(%rip),%r12        # d430 <timeout_list>
    9ddc:	55                   	push   %rbp
    9ddd:	53                   	push   %rbx
    9dde:	89 fb                	mov    %edi,%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    9de0:	e8 ab f7 ff ff       	callq  9590 <z_time_slice>
	return posix_irq_lock();
    9de5:	e8 75 d7 ff ff       	callq  755f <posix_irq_lock>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    9dea:	89 1d 98 68 00 00    	mov    %ebx,0x6898(%rip)        # 10688 <announce_remaining>
    9df0:	89 c5                	mov    %eax,%ebp
    9df2:	48 63 15 8f 68 00 00 	movslq 0x688f(%rip),%rdx        # 10688 <announce_remaining>
    9df9:	49 8b 1c 24          	mov    (%r12),%rbx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    9dfd:	48 8b 35 34 68 00 00 	mov    0x6834(%rip),%rsi        # 10638 <curr_tick>
    9e04:	48 89 d1             	mov    %rdx,%rcx

	while (first() != NULL && first()->dticks <= announce_remaining) {
    9e07:	48 85 db             	test   %rbx,%rbx
    9e0a:	74 50                	je     9e5c <sys_clock_announce+0x8d>
    9e0c:	4c 39 e3             	cmp    %r12,%rbx
    9e0f:	74 4b                	je     9e5c <sys_clock_announce+0x8d>
    9e11:	48 8b 43 18          	mov    0x18(%rbx),%rax
    9e15:	48 39 d0             	cmp    %rdx,%rax
    9e18:	7f 3b                	jg     9e55 <sys_clock_announce+0x86>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
    9e1a:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    9e21:	00 
		curr_tick += dt;
    9e22:	48 63 d0             	movslq %eax,%rdx
		announce_remaining -= dt;
    9e25:	29 c1                	sub    %eax,%ecx
		remove_timeout(t);
    9e27:	48 89 df             	mov    %rbx,%rdi
		curr_tick += dt;
    9e2a:	48 01 f2             	add    %rsi,%rdx
		announce_remaining -= dt;
    9e2d:	89 0d 55 68 00 00    	mov    %ecx,0x6855(%rip)        # 10688 <announce_remaining>
		curr_tick += dt;
    9e33:	48 89 15 fe 67 00 00 	mov    %rdx,0x67fe(%rip)        # 10638 <curr_tick>
		remove_timeout(t);
    9e3a:	e8 54 fd ff ff       	callq  9b93 <remove_timeout>
	posix_irq_unlock(key);
    9e3f:	89 ef                	mov    %ebp,%edi
    9e41:	e8 27 d7 ff ff       	callq  756d <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    9e46:	48 89 df             	mov    %rbx,%rdi
    9e49:	ff 53 10             	callq  *0x10(%rbx)
	return posix_irq_lock();
    9e4c:	e8 0e d7 ff ff       	callq  755f <posix_irq_lock>
    9e51:	89 c5                	mov    %eax,%ebp
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    9e53:	eb 9d                	jmp    9df2 <sys_clock_announce+0x23>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    9e55:	48 29 d0             	sub    %rdx,%rax
    9e58:	48 89 43 18          	mov    %rax,0x18(%rbx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    9e5c:	c7 05 22 68 00 00 00 	movl   $0x0,0x6822(%rip)        # 10688 <announce_remaining>
    9e63:	00 00 00 
	curr_tick += announce_remaining;
    9e66:	48 01 f2             	add    %rsi,%rdx
    9e69:	48 89 15 c8 67 00 00 	mov    %rdx,0x67c8(%rip)        # 10638 <curr_tick>

	sys_clock_set_timeout(next_timeout(), false);
    9e70:	e8 57 fd ff ff       	callq  9bcc <next_timeout>
    9e75:	31 f6                	xor    %esi,%esi
    9e77:	89 c7                	mov    %eax,%edi
    9e79:	e8 8e b2 ff ff       	callq  510c <sys_clock_set_timeout>

	k_spin_unlock(&timeout_lock, key);
}
    9e7e:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    9e7f:	89 ef                	mov    %ebp,%edi
    9e81:	5d                   	pop    %rbp
    9e82:	41 5c                	pop    %r12
    9e84:	e9 e4 d6 ff ff       	jmpq   756d <posix_irq_unlock>

0000000000009e89 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    9e89:	f3 0f 1e fa          	endbr64 
    9e8d:	41 54                	push   %r12
    9e8f:	55                   	push   %rbp
    9e90:	50                   	push   %rax
	return posix_irq_lock();
    9e91:	e8 c9 d6 ff ff       	callq  755f <posix_irq_lock>
    9e96:	89 c5                	mov    %eax,%ebp
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    9e98:	e8 96 b2 ff ff       	callq  5133 <sys_clock_elapsed>
	posix_irq_unlock(key);
    9e9d:	89 ef                	mov    %ebp,%edi
    9e9f:	41 89 c4             	mov    %eax,%r12d
    9ea2:	4c 03 25 8f 67 00 00 	add    0x678f(%rip),%r12        # 10638 <curr_tick>
    9ea9:	e8 bf d6 ff ff       	callq  756d <posix_irq_unlock>
	}
	return t;
}
    9eae:	4c 89 e0             	mov    %r12,%rax
    9eb1:	5a                   	pop    %rdx
    9eb2:	5d                   	pop    %rbp
    9eb3:	41 5c                	pop    %r12
    9eb5:	c3                   	retq   

0000000000009eb6 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    9eb6:	f3 0f 1e fa          	endbr64 
    9eba:	50                   	push   %rax
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    9ebb:	e8 c9 ff ff ff       	callq  9e89 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    9ec0:	5a                   	pop    %rdx
    9ec1:	c3                   	retq   

0000000000009ec2 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    9ec2:	f3 0f 1e fa          	endbr64 
    9ec6:	50                   	push   %rax
	return posix_irq_lock();
    9ec7:	e8 93 d6 ff ff       	callq  755f <posix_irq_lock>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    9ecc:	e8 27 c6 ff ff       	callq  64f8 <arch_cpu_idle>
    9ed1:	eb f4                	jmp    9ec7 <idle+0x5>

0000000000009ed3 <k_heap_init>:
#include <ksched.h>
#include <wait_q.h>
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
    9ed3:	f3 0f 1e fa          	endbr64 
    9ed7:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = (sys_dnode_t *)list;
    9edb:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
    9edf:	48 89 47 20          	mov    %rax,0x20(%rdi)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    9ee3:	e9 ce a4 ff ff       	jmpq   43b6 <sys_heap_init>

0000000000009ee8 <statics_init>:
}

static int statics_init(const struct device *unused)
{
    9ee8:	f3 0f 1e fa          	endbr64 
    9eec:	53                   	push   %rbx
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    9eed:	48 8d 1d 34 5c 00 00 	lea    0x5c34(%rip),%rbx        # fb28 <key_iv_msgq>
    9ef4:	48 3b 1d c5 30 00 00 	cmp    0x30c5(%rip),%rbx        # cfc0 <_GLOBAL_OFFSET_TABLE_+0x1e8>
    9efb:	73 16                	jae    9f13 <statics_init+0x2b>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    9efd:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    9f01:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    9f05:	48 89 df             	mov    %rbx,%rdi
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    9f08:	48 83 c3 28          	add    $0x28,%rbx
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    9f0c:	e8 c2 ff ff ff       	callq  9ed3 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    9f11:	eb e1                	jmp    9ef4 <statics_init+0xc>
	}
	return 0;
}
    9f13:	31 c0                	xor    %eax,%eax
    9f15:	5b                   	pop    %rbx
    9f16:	c3                   	retq   

0000000000009f17 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
    9f17:	f3 0f 1e fa          	endbr64 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
    9f1b:	c3                   	retq   

Disassembly of section .fini:

0000000000009f1c <_fini>:
    9f1c:	f3 0f 1e fa          	endbr64 
    9f20:	48 83 ec 08          	sub    $0x8,%rsp
    9f24:	48 83 c4 08          	add    $0x8,%rsp
    9f28:	c3                   	retq   
