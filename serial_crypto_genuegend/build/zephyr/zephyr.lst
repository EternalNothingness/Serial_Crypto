
zephyr.elf:     file format elf64-x86-64


Disassembly of section .init:

0000000000002000 <_init>:
    2000:	f3 0f 1e fa          	endbr64 
    2004:	48 83 ec 08          	sub    $0x8,%rsp
    2008:	48 8b 05 b9 8f 00 00 	mov    0x8fb9(%rip),%rax        # afc8 <__gmon_start__>
    200f:	48 85 c0             	test   %rax,%rax
    2012:	74 02                	je     2016 <_init+0x16>
    2014:	ff d0                	callq  *%rax
    2016:	48 83 c4 08          	add    $0x8,%rsp
    201a:	c3                   	retq   

Disassembly of section .plt:

0000000000002020 <.plt>:
    2020:	ff 35 ba 8d 00 00    	pushq  0x8dba(%rip)        # ade0 <_GLOBAL_OFFSET_TABLE_+0x8>
    2026:	f2 ff 25 bb 8d 00 00 	bnd jmpq *0x8dbb(%rip)        # ade8 <_GLOBAL_OFFSET_TABLE_+0x10>
    202d:	0f 1f 00             	nopl   (%rax)
    2030:	f3 0f 1e fa          	endbr64 
    2034:	68 00 00 00 00       	pushq  $0x0
    2039:	f2 e9 e1 ff ff ff    	bnd jmpq 2020 <.plt>
    203f:	90                   	nop
    2040:	f3 0f 1e fa          	endbr64 
    2044:	68 01 00 00 00       	pushq  $0x1
    2049:	f2 e9 d1 ff ff ff    	bnd jmpq 2020 <.plt>
    204f:	90                   	nop
    2050:	f3 0f 1e fa          	endbr64 
    2054:	68 02 00 00 00       	pushq  $0x2
    2059:	f2 e9 c1 ff ff ff    	bnd jmpq 2020 <.plt>
    205f:	90                   	nop
    2060:	f3 0f 1e fa          	endbr64 
    2064:	68 03 00 00 00       	pushq  $0x3
    2069:	f2 e9 b1 ff ff ff    	bnd jmpq 2020 <.plt>
    206f:	90                   	nop
    2070:	f3 0f 1e fa          	endbr64 
    2074:	68 04 00 00 00       	pushq  $0x4
    2079:	f2 e9 a1 ff ff ff    	bnd jmpq 2020 <.plt>
    207f:	90                   	nop
    2080:	f3 0f 1e fa          	endbr64 
    2084:	68 05 00 00 00       	pushq  $0x5
    2089:	f2 e9 91 ff ff ff    	bnd jmpq 2020 <.plt>
    208f:	90                   	nop
    2090:	f3 0f 1e fa          	endbr64 
    2094:	68 06 00 00 00       	pushq  $0x6
    2099:	f2 e9 81 ff ff ff    	bnd jmpq 2020 <.plt>
    209f:	90                   	nop
    20a0:	f3 0f 1e fa          	endbr64 
    20a4:	68 07 00 00 00       	pushq  $0x7
    20a9:	f2 e9 71 ff ff ff    	bnd jmpq 2020 <.plt>
    20af:	90                   	nop
    20b0:	f3 0f 1e fa          	endbr64 
    20b4:	68 08 00 00 00       	pushq  $0x8
    20b9:	f2 e9 61 ff ff ff    	bnd jmpq 2020 <.plt>
    20bf:	90                   	nop
    20c0:	f3 0f 1e fa          	endbr64 
    20c4:	68 09 00 00 00       	pushq  $0x9
    20c9:	f2 e9 51 ff ff ff    	bnd jmpq 2020 <.plt>
    20cf:	90                   	nop
    20d0:	f3 0f 1e fa          	endbr64 
    20d4:	68 0a 00 00 00       	pushq  $0xa
    20d9:	f2 e9 41 ff ff ff    	bnd jmpq 2020 <.plt>
    20df:	90                   	nop
    20e0:	f3 0f 1e fa          	endbr64 
    20e4:	68 0b 00 00 00       	pushq  $0xb
    20e9:	f2 e9 31 ff ff ff    	bnd jmpq 2020 <.plt>
    20ef:	90                   	nop
    20f0:	f3 0f 1e fa          	endbr64 
    20f4:	68 0c 00 00 00       	pushq  $0xc
    20f9:	f2 e9 21 ff ff ff    	bnd jmpq 2020 <.plt>
    20ff:	90                   	nop
    2100:	f3 0f 1e fa          	endbr64 
    2104:	68 0d 00 00 00       	pushq  $0xd
    2109:	f2 e9 11 ff ff ff    	bnd jmpq 2020 <.plt>
    210f:	90                   	nop
    2110:	f3 0f 1e fa          	endbr64 
    2114:	68 0e 00 00 00       	pushq  $0xe
    2119:	f2 e9 01 ff ff ff    	bnd jmpq 2020 <.plt>
    211f:	90                   	nop
    2120:	f3 0f 1e fa          	endbr64 
    2124:	68 0f 00 00 00       	pushq  $0xf
    2129:	f2 e9 f1 fe ff ff    	bnd jmpq 2020 <.plt>
    212f:	90                   	nop
    2130:	f3 0f 1e fa          	endbr64 
    2134:	68 10 00 00 00       	pushq  $0x10
    2139:	f2 e9 e1 fe ff ff    	bnd jmpq 2020 <.plt>
    213f:	90                   	nop
    2140:	f3 0f 1e fa          	endbr64 
    2144:	68 11 00 00 00       	pushq  $0x11
    2149:	f2 e9 d1 fe ff ff    	bnd jmpq 2020 <.plt>
    214f:	90                   	nop
    2150:	f3 0f 1e fa          	endbr64 
    2154:	68 12 00 00 00       	pushq  $0x12
    2159:	f2 e9 c1 fe ff ff    	bnd jmpq 2020 <.plt>
    215f:	90                   	nop
    2160:	f3 0f 1e fa          	endbr64 
    2164:	68 13 00 00 00       	pushq  $0x13
    2169:	f2 e9 b1 fe ff ff    	bnd jmpq 2020 <.plt>
    216f:	90                   	nop
    2170:	f3 0f 1e fa          	endbr64 
    2174:	68 14 00 00 00       	pushq  $0x14
    2179:	f2 e9 a1 fe ff ff    	bnd jmpq 2020 <.plt>
    217f:	90                   	nop
    2180:	f3 0f 1e fa          	endbr64 
    2184:	68 15 00 00 00       	pushq  $0x15
    2189:	f2 e9 91 fe ff ff    	bnd jmpq 2020 <.plt>
    218f:	90                   	nop
    2190:	f3 0f 1e fa          	endbr64 
    2194:	68 16 00 00 00       	pushq  $0x16
    2199:	f2 e9 81 fe ff ff    	bnd jmpq 2020 <.plt>
    219f:	90                   	nop
    21a0:	f3 0f 1e fa          	endbr64 
    21a4:	68 17 00 00 00       	pushq  $0x17
    21a9:	f2 e9 71 fe ff ff    	bnd jmpq 2020 <.plt>
    21af:	90                   	nop
    21b0:	f3 0f 1e fa          	endbr64 
    21b4:	68 18 00 00 00       	pushq  $0x18
    21b9:	f2 e9 61 fe ff ff    	bnd jmpq 2020 <.plt>
    21bf:	90                   	nop
    21c0:	f3 0f 1e fa          	endbr64 
    21c4:	68 19 00 00 00       	pushq  $0x19
    21c9:	f2 e9 51 fe ff ff    	bnd jmpq 2020 <.plt>
    21cf:	90                   	nop
    21d0:	f3 0f 1e fa          	endbr64 
    21d4:	68 1a 00 00 00       	pushq  $0x1a
    21d9:	f2 e9 41 fe ff ff    	bnd jmpq 2020 <.plt>
    21df:	90                   	nop
    21e0:	f3 0f 1e fa          	endbr64 
    21e4:	68 1b 00 00 00       	pushq  $0x1b
    21e9:	f2 e9 31 fe ff ff    	bnd jmpq 2020 <.plt>
    21ef:	90                   	nop
    21f0:	f3 0f 1e fa          	endbr64 
    21f4:	68 1c 00 00 00       	pushq  $0x1c
    21f9:	f2 e9 21 fe ff ff    	bnd jmpq 2020 <.plt>
    21ff:	90                   	nop
    2200:	f3 0f 1e fa          	endbr64 
    2204:	68 1d 00 00 00       	pushq  $0x1d
    2209:	f2 e9 11 fe ff ff    	bnd jmpq 2020 <.plt>
    220f:	90                   	nop
    2210:	f3 0f 1e fa          	endbr64 
    2214:	68 1e 00 00 00       	pushq  $0x1e
    2219:	f2 e9 01 fe ff ff    	bnd jmpq 2020 <.plt>
    221f:	90                   	nop
    2220:	f3 0f 1e fa          	endbr64 
    2224:	68 1f 00 00 00       	pushq  $0x1f
    2229:	f2 e9 f1 fd ff ff    	bnd jmpq 2020 <.plt>
    222f:	90                   	nop
    2230:	f3 0f 1e fa          	endbr64 
    2234:	68 20 00 00 00       	pushq  $0x20
    2239:	f2 e9 e1 fd ff ff    	bnd jmpq 2020 <.plt>
    223f:	90                   	nop
    2240:	f3 0f 1e fa          	endbr64 
    2244:	68 21 00 00 00       	pushq  $0x21
    2249:	f2 e9 d1 fd ff ff    	bnd jmpq 2020 <.plt>
    224f:	90                   	nop
    2250:	f3 0f 1e fa          	endbr64 
    2254:	68 22 00 00 00       	pushq  $0x22
    2259:	f2 e9 c1 fd ff ff    	bnd jmpq 2020 <.plt>
    225f:	90                   	nop
    2260:	f3 0f 1e fa          	endbr64 
    2264:	68 23 00 00 00       	pushq  $0x23
    2269:	f2 e9 b1 fd ff ff    	bnd jmpq 2020 <.plt>
    226f:	90                   	nop
    2270:	f3 0f 1e fa          	endbr64 
    2274:	68 24 00 00 00       	pushq  $0x24
    2279:	f2 e9 a1 fd ff ff    	bnd jmpq 2020 <.plt>
    227f:	90                   	nop
    2280:	f3 0f 1e fa          	endbr64 
    2284:	68 25 00 00 00       	pushq  $0x25
    2289:	f2 e9 91 fd ff ff    	bnd jmpq 2020 <.plt>
    228f:	90                   	nop
    2290:	f3 0f 1e fa          	endbr64 
    2294:	68 26 00 00 00       	pushq  $0x26
    2299:	f2 e9 81 fd ff ff    	bnd jmpq 2020 <.plt>
    229f:	90                   	nop
    22a0:	f3 0f 1e fa          	endbr64 
    22a4:	68 27 00 00 00       	pushq  $0x27
    22a9:	f2 e9 71 fd ff ff    	bnd jmpq 2020 <.plt>
    22af:	90                   	nop
    22b0:	f3 0f 1e fa          	endbr64 
    22b4:	68 28 00 00 00       	pushq  $0x28
    22b9:	f2 e9 61 fd ff ff    	bnd jmpq 2020 <.plt>
    22bf:	90                   	nop
    22c0:	f3 0f 1e fa          	endbr64 
    22c4:	68 29 00 00 00       	pushq  $0x29
    22c9:	f2 e9 51 fd ff ff    	bnd jmpq 2020 <.plt>
    22cf:	90                   	nop
    22d0:	f3 0f 1e fa          	endbr64 
    22d4:	68 2a 00 00 00       	pushq  $0x2a
    22d9:	f2 e9 41 fd ff ff    	bnd jmpq 2020 <.plt>
    22df:	90                   	nop
    22e0:	f3 0f 1e fa          	endbr64 
    22e4:	68 2b 00 00 00       	pushq  $0x2b
    22e9:	f2 e9 31 fd ff ff    	bnd jmpq 2020 <.plt>
    22ef:	90                   	nop
    22f0:	f3 0f 1e fa          	endbr64 
    22f4:	68 2c 00 00 00       	pushq  $0x2c
    22f9:	f2 e9 21 fd ff ff    	bnd jmpq 2020 <.plt>
    22ff:	90                   	nop
    2300:	f3 0f 1e fa          	endbr64 
    2304:	68 2d 00 00 00       	pushq  $0x2d
    2309:	f2 e9 11 fd ff ff    	bnd jmpq 2020 <.plt>
    230f:	90                   	nop
    2310:	f3 0f 1e fa          	endbr64 
    2314:	68 2e 00 00 00       	pushq  $0x2e
    2319:	f2 e9 01 fd ff ff    	bnd jmpq 2020 <.plt>
    231f:	90                   	nop
    2320:	f3 0f 1e fa          	endbr64 
    2324:	68 2f 00 00 00       	pushq  $0x2f
    2329:	f2 e9 f1 fc ff ff    	bnd jmpq 2020 <.plt>
    232f:	90                   	nop
    2330:	f3 0f 1e fa          	endbr64 
    2334:	68 30 00 00 00       	pushq  $0x30
    2339:	f2 e9 e1 fc ff ff    	bnd jmpq 2020 <.plt>
    233f:	90                   	nop
    2340:	f3 0f 1e fa          	endbr64 
    2344:	68 31 00 00 00       	pushq  $0x31
    2349:	f2 e9 d1 fc ff ff    	bnd jmpq 2020 <.plt>
    234f:	90                   	nop
    2350:	f3 0f 1e fa          	endbr64 
    2354:	68 32 00 00 00       	pushq  $0x32
    2359:	f2 e9 c1 fc ff ff    	bnd jmpq 2020 <.plt>
    235f:	90                   	nop
    2360:	f3 0f 1e fa          	endbr64 
    2364:	68 33 00 00 00       	pushq  $0x33
    2369:	f2 e9 b1 fc ff ff    	bnd jmpq 2020 <.plt>
    236f:	90                   	nop

Disassembly of section .plt.got:

0000000000002370 <__cxa_finalize@plt>:
    2370:	f3 0f 1e fa          	endbr64 
    2374:	f2 ff 25 65 8c 00 00 	bnd jmpq *0x8c65(%rip)        # afe0 <__cxa_finalize@GLIBC_2.2.5>
    237b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .plt.sec:

0000000000002380 <ptsname@plt>:
    2380:	f3 0f 1e fa          	endbr64 
    2384:	f2 ff 25 65 8a 00 00 	bnd jmpq *0x8a65(%rip)        # adf0 <ptsname@GLIBC_2.2.5>
    238b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002390 <__snprintf_chk@plt>:
    2390:	f3 0f 1e fa          	endbr64 
    2394:	f2 ff 25 5d 8a 00 00 	bnd jmpq *0x8a5d(%rip)        # adf8 <__snprintf_chk@GLIBC_2.3.4>
    239b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023a0 <free@plt>:
    23a0:	f3 0f 1e fa          	endbr64 
    23a4:	f2 ff 25 55 8a 00 00 	bnd jmpq *0x8a55(%rip)        # ae00 <free@GLIBC_2.2.5>
    23ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023b0 <pthread_create@plt>:
    23b0:	f3 0f 1e fa          	endbr64 
    23b4:	f2 ff 25 4d 8a 00 00 	bnd jmpq *0x8a4d(%rip)        # ae08 <pthread_create@GLIBC_2.2.5>
    23bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023c0 <strcasecmp@plt>:
    23c0:	f3 0f 1e fa          	endbr64 
    23c4:	f2 ff 25 45 8a 00 00 	bnd jmpq *0x8a45(%rip)        # ae10 <strcasecmp@GLIBC_2.2.5>
    23cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023d0 <pthread_detach@plt>:
    23d0:	f3 0f 1e fa          	endbr64 
    23d4:	f2 ff 25 3d 8a 00 00 	bnd jmpq *0x8a3d(%rip)        # ae18 <pthread_detach@GLIBC_2.2.5>
    23db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023e0 <__vfprintf_chk@plt>:
    23e0:	f3 0f 1e fa          	endbr64 
    23e4:	f2 ff 25 35 8a 00 00 	bnd jmpq *0x8a35(%rip)        # ae20 <__vfprintf_chk@GLIBC_2.3.4>
    23eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000023f0 <__errno_location@plt>:
    23f0:	f3 0f 1e fa          	endbr64 
    23f4:	f2 ff 25 2d 8a 00 00 	bnd jmpq *0x8a2d(%rip)        # ae28 <__errno_location@GLIBC_2.2.5>
    23fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002400 <pthread_cond_broadcast@plt>:
    2400:	f3 0f 1e fa          	endbr64 
    2404:	f2 ff 25 25 8a 00 00 	bnd jmpq *0x8a25(%rip)        # ae30 <pthread_cond_broadcast@GLIBC_2.3.2>
    240b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002410 <pthread_cancel@plt>:
    2410:	f3 0f 1e fa          	endbr64 
    2414:	f2 ff 25 1d 8a 00 00 	bnd jmpq *0x8a1d(%rip)        # ae38 <pthread_cancel@GLIBC_2.2.5>
    241b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002420 <isatty@plt>:
    2420:	f3 0f 1e fa          	endbr64 
    2424:	f2 ff 25 15 8a 00 00 	bnd jmpq *0x8a15(%rip)        # ae40 <isatty@GLIBC_2.2.5>
    242b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002430 <sigaction@plt>:
    2430:	f3 0f 1e fa          	endbr64 
    2434:	f2 ff 25 0d 8a 00 00 	bnd jmpq *0x8a0d(%rip)        # ae48 <sigaction@GLIBC_2.2.5>
    243b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002440 <__pthread_register_cancel@plt>:
    2440:	f3 0f 1e fa          	endbr64 
    2444:	f2 ff 25 05 8a 00 00 	bnd jmpq *0x8a05(%rip)        # ae50 <__pthread_register_cancel@GLIBC_2.3.3>
    244b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002450 <strtod@plt>:
    2450:	f3 0f 1e fa          	endbr64 
    2454:	f2 ff 25 fd 89 00 00 	bnd jmpq *0x89fd(%rip)        # ae58 <strtod@GLIBC_2.2.5>
    245b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002460 <fcntl@plt>:
    2460:	f3 0f 1e fa          	endbr64 
    2464:	f2 ff 25 f5 89 00 00 	bnd jmpq *0x89f5(%rip)        # ae60 <fcntl@GLIBC_2.2.5>
    246b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002470 <clock_gettime@plt>:
    2470:	f3 0f 1e fa          	endbr64 
    2474:	f2 ff 25 ed 89 00 00 	bnd jmpq *0x89ed(%rip)        # ae68 <clock_gettime@GLIBC_2.17>
    247b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002480 <write@plt>:
    2480:	f3 0f 1e fa          	endbr64 
    2484:	f2 ff 25 e5 89 00 00 	bnd jmpq *0x89e5(%rip)        # ae70 <write@GLIBC_2.2.5>
    248b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002490 <pthread_cond_wait@plt>:
    2490:	f3 0f 1e fa          	endbr64 
    2494:	f2 ff 25 dd 89 00 00 	bnd jmpq *0x89dd(%rip)        # ae78 <pthread_cond_wait@GLIBC_2.3.2>
    249b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024a0 <__stack_chk_fail@plt>:
    24a0:	f3 0f 1e fa          	endbr64 
    24a4:	f2 ff 25 d5 89 00 00 	bnd jmpq *0x89d5(%rip)        # ae80 <__stack_chk_fail@GLIBC_2.4>
    24ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024b0 <system@plt>:
    24b0:	f3 0f 1e fa          	endbr64 
    24b4:	f2 ff 25 cd 89 00 00 	bnd jmpq *0x89cd(%rip)        # ae88 <system@GLIBC_2.2.5>
    24bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024c0 <snprintf@plt>:
    24c0:	f3 0f 1e fa          	endbr64 
    24c4:	f2 ff 25 c5 89 00 00 	bnd jmpq *0x89c5(%rip)        # ae90 <snprintf@GLIBC_2.2.5>
    24cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024d0 <nanosleep@plt>:
    24d0:	f3 0f 1e fa          	endbr64 
    24d4:	f2 ff 25 bd 89 00 00 	bnd jmpq *0x89bd(%rip)        # ae98 <nanosleep@GLIBC_2.2.5>
    24db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024e0 <strnlen@plt>:
    24e0:	f3 0f 1e fa          	endbr64 
    24e4:	f2 ff 25 b5 89 00 00 	bnd jmpq *0x89b5(%rip)        # aea0 <strnlen@GLIBC_2.2.5>
    24eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000024f0 <close@plt>:
    24f0:	f3 0f 1e fa          	endbr64 
    24f4:	f2 ff 25 ad 89 00 00 	bnd jmpq *0x89ad(%rip)        # aea8 <close@GLIBC_2.2.5>
    24fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002500 <read@plt>:
    2500:	f3 0f 1e fa          	endbr64 
    2504:	f2 ff 25 a5 89 00 00 	bnd jmpq *0x89a5(%rip)        # aeb0 <read@GLIBC_2.2.5>
    250b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002510 <strtoull@plt>:
    2510:	f3 0f 1e fa          	endbr64 
    2514:	f2 ff 25 9d 89 00 00 	bnd jmpq *0x899d(%rip)        # aeb8 <strtoull@GLIBC_2.2.5>
    251b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002520 <calloc@plt>:
    2520:	f3 0f 1e fa          	endbr64 
    2524:	f2 ff 25 95 89 00 00 	bnd jmpq *0x8995(%rip)        # aec0 <calloc@GLIBC_2.2.5>
    252b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002530 <strcmp@plt>:
    2530:	f3 0f 1e fa          	endbr64 
    2534:	f2 ff 25 8d 89 00 00 	bnd jmpq *0x898d(%rip)        # aec8 <strcmp@GLIBC_2.2.5>
    253b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002540 <strtoll@plt>:
    2540:	f3 0f 1e fa          	endbr64 
    2544:	f2 ff 25 85 89 00 00 	bnd jmpq *0x8985(%rip)        # aed0 <strtoll@GLIBC_2.2.5>
    254b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002550 <unlockpt@plt>:
    2550:	f3 0f 1e fa          	endbr64 
    2554:	f2 ff 25 7d 89 00 00 	bnd jmpq *0x897d(%rip)        # aed8 <unlockpt@GLIBC_2.2.5>
    255b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002560 <sigemptyset@plt>:
    2560:	f3 0f 1e fa          	endbr64 
    2564:	f2 ff 25 75 89 00 00 	bnd jmpq *0x8975(%rip)        # aee0 <sigemptyset@GLIBC_2.2.5>
    256b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002570 <strtol@plt>:
    2570:	f3 0f 1e fa          	endbr64 
    2574:	f2 ff 25 6d 89 00 00 	bnd jmpq *0x896d(%rip)        # aee8 <strtol@GLIBC_2.2.5>
    257b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002580 <pthread_mutex_unlock@plt>:
    2580:	f3 0f 1e fa          	endbr64 
    2584:	f2 ff 25 65 89 00 00 	bnd jmpq *0x8965(%rip)        # aef0 <pthread_mutex_unlock@GLIBC_2.2.5>
    258b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002590 <pthread_exit@plt>:
    2590:	f3 0f 1e fa          	endbr64 
    2594:	f2 ff 25 5d 89 00 00 	bnd jmpq *0x895d(%rip)        # aef8 <pthread_exit@GLIBC_2.2.5>
    259b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025a0 <malloc@plt>:
    25a0:	f3 0f 1e fa          	endbr64 
    25a4:	f2 ff 25 55 89 00 00 	bnd jmpq *0x8955(%rip)        # af00 <malloc@GLIBC_2.2.5>
    25ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025b0 <realloc@plt>:
    25b0:	f3 0f 1e fa          	endbr64 
    25b4:	f2 ff 25 4d 89 00 00 	bnd jmpq *0x894d(%rip)        # af08 <realloc@GLIBC_2.2.5>
    25bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025c0 <setvbuf@plt>:
    25c0:	f3 0f 1e fa          	endbr64 
    25c4:	f2 ff 25 45 89 00 00 	bnd jmpq *0x8945(%rip)        # af10 <setvbuf@GLIBC_2.2.5>
    25cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025d0 <pthread_self@plt>:
    25d0:	f3 0f 1e fa          	endbr64 
    25d4:	f2 ff 25 3d 89 00 00 	bnd jmpq *0x893d(%rip)        # af18 <pthread_self@GLIBC_2.2.5>
    25db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025e0 <tcgetattr@plt>:
    25e0:	f3 0f 1e fa          	endbr64 
    25e4:	f2 ff 25 35 89 00 00 	bnd jmpq *0x8935(%rip)        # af20 <tcgetattr@GLIBC_2.2.5>
    25eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000025f0 <tcsetattr@plt>:
    25f0:	f3 0f 1e fa          	endbr64 
    25f4:	f2 ff 25 2d 89 00 00 	bnd jmpq *0x892d(%rip)        # af28 <tcsetattr@GLIBC_2.2.5>
    25fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002600 <strtoul@plt>:
    2600:	f3 0f 1e fa          	endbr64 
    2604:	f2 ff 25 25 89 00 00 	bnd jmpq *0x8925(%rip)        # af30 <strtoul@GLIBC_2.2.5>
    260b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002610 <grantpt@plt>:
    2610:	f3 0f 1e fa          	endbr64 
    2614:	f2 ff 25 1d 89 00 00 	bnd jmpq *0x891d(%rip)        # af38 <grantpt@GLIBC_2.2.5>
    261b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002620 <__memset_chk@plt>:
    2620:	f3 0f 1e fa          	endbr64 
    2624:	f2 ff 25 15 89 00 00 	bnd jmpq *0x8915(%rip)        # af40 <__memset_chk@GLIBC_2.3.4>
    262b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002630 <__pthread_unwind_next@plt>:
    2630:	f3 0f 1e fa          	endbr64 
    2634:	f2 ff 25 0d 89 00 00 	bnd jmpq *0x890d(%rip)        # af48 <__pthread_unwind_next@GLIBC_2.3.3>
    263b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002640 <exit@plt>:
    2640:	f3 0f 1e fa          	endbr64 
    2644:	f2 ff 25 05 89 00 00 	bnd jmpq *0x8905(%rip)        # af50 <exit@GLIBC_2.2.5>
    264b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002650 <__fprintf_chk@plt>:
    2650:	f3 0f 1e fa          	endbr64 
    2654:	f2 ff 25 fd 88 00 00 	bnd jmpq *0x88fd(%rip)        # af58 <__fprintf_chk@GLIBC_2.3.4>
    265b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002660 <__sigsetjmp@plt>:
    2660:	f3 0f 1e fa          	endbr64 
    2664:	f2 ff 25 f5 88 00 00 	bnd jmpq *0x88f5(%rip)        # af60 <__sigsetjmp@GLIBC_2.2.5>
    266b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002670 <posix_openpt@plt>:
    2670:	f3 0f 1e fa          	endbr64 
    2674:	f2 ff 25 ed 88 00 00 	bnd jmpq *0x88ed(%rip)        # af68 <posix_openpt@GLIBC_2.2.5>
    267b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002680 <sleep@plt>:
    2680:	f3 0f 1e fa          	endbr64 
    2684:	f2 ff 25 e5 88 00 00 	bnd jmpq *0x88e5(%rip)        # af70 <sleep@GLIBC_2.2.5>
    268b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002690 <pthread_mutex_lock@plt>:
    2690:	f3 0f 1e fa          	endbr64 
    2694:	f2 ff 25 dd 88 00 00 	bnd jmpq *0x88dd(%rip)        # af78 <pthread_mutex_lock@GLIBC_2.2.5>
    269b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026a0 <__ctype_b_loc@plt>:
    26a0:	f3 0f 1e fa          	endbr64 
    26a4:	f2 ff 25 d5 88 00 00 	bnd jmpq *0x88d5(%rip)        # af80 <__ctype_b_loc@GLIBC_2.3>
    26ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026b0 <__sprintf_chk@plt>:
    26b0:	f3 0f 1e fa          	endbr64 
    26b4:	f2 ff 25 cd 88 00 00 	bnd jmpq *0x88cd(%rip)        # af88 <__sprintf_chk@GLIBC_2.3.4>
    26bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .text:

00000000000026c0 <_start>:
    26c0:	f3 0f 1e fa          	endbr64 
    26c4:	31 ed                	xor    %ebp,%ebp
    26c6:	49 89 d1             	mov    %rdx,%r9
    26c9:	5e                   	pop    %rsi
    26ca:	48 89 e2             	mov    %rsp,%rdx
    26cd:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    26d1:	50                   	push   %rax
    26d2:	54                   	push   %rsp
    26d3:	4c 8d 05 46 01 00 00 	lea    0x146(%rip),%r8        # 2820 <__libc_csu_fini>
    26da:	48 8d 0d cf 00 00 00 	lea    0xcf(%rip),%rcx        # 27b0 <__libc_csu_init>
    26e1:	48 8d 3d 3a 26 00 00 	lea    0x263a(%rip),%rdi        # 4d22 <main>
    26e8:	ff 15 d2 88 00 00    	callq  *0x88d2(%rip)        # afc0 <__libc_start_main@GLIBC_2.2.5>
    26ee:	f4                   	hlt    
    26ef:	90                   	nop

00000000000026f0 <deregister_tm_clones>:
    26f0:	48 8d 3d 69 8d 00 00 	lea    0x8d69(%rip),%rdi        # b460 <__TMC_END__>
    26f7:	48 8d 05 62 8d 00 00 	lea    0x8d62(%rip),%rax        # b460 <__TMC_END__>
    26fe:	48 39 f8             	cmp    %rdi,%rax
    2701:	74 15                	je     2718 <deregister_tm_clones+0x28>
    2703:	48 8b 05 8e 88 00 00 	mov    0x888e(%rip),%rax        # af98 <_ITM_deregisterTMCloneTable>
    270a:	48 85 c0             	test   %rax,%rax
    270d:	74 09                	je     2718 <deregister_tm_clones+0x28>
    270f:	ff e0                	jmpq   *%rax
    2711:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2718:	c3                   	retq   
    2719:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002720 <register_tm_clones>:
    2720:	48 8d 3d 39 8d 00 00 	lea    0x8d39(%rip),%rdi        # b460 <__TMC_END__>
    2727:	48 8d 35 32 8d 00 00 	lea    0x8d32(%rip),%rsi        # b460 <__TMC_END__>
    272e:	48 29 fe             	sub    %rdi,%rsi
    2731:	48 89 f0             	mov    %rsi,%rax
    2734:	48 c1 ee 3f          	shr    $0x3f,%rsi
    2738:	48 c1 f8 03          	sar    $0x3,%rax
    273c:	48 01 c6             	add    %rax,%rsi
    273f:	48 d1 fe             	sar    %rsi
    2742:	74 14                	je     2758 <register_tm_clones+0x38>
    2744:	48 8b 05 8d 88 00 00 	mov    0x888d(%rip),%rax        # afd8 <_ITM_registerTMCloneTable>
    274b:	48 85 c0             	test   %rax,%rax
    274e:	74 08                	je     2758 <register_tm_clones+0x38>
    2750:	ff e0                	jmpq   *%rax
    2752:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2758:	c3                   	retq   
    2759:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000002760 <__do_global_dtors_aux>:
    2760:	f3 0f 1e fa          	endbr64 
    2764:	80 3d ed b4 00 00 00 	cmpb   $0x0,0xb4ed(%rip)        # dc58 <completed.8060>
    276b:	75 2b                	jne    2798 <__do_global_dtors_aux+0x38>
    276d:	55                   	push   %rbp
    276e:	48 83 3d 6a 88 00 00 	cmpq   $0x0,0x886a(%rip)        # afe0 <__cxa_finalize@GLIBC_2.2.5>
    2775:	00 
    2776:	48 89 e5             	mov    %rsp,%rbp
    2779:	74 0c                	je     2787 <__do_global_dtors_aux+0x27>
    277b:	48 8b 3d 9e 8c 00 00 	mov    0x8c9e(%rip),%rdi        # b420 <__dso_handle>
    2782:	e8 e9 fb ff ff       	callq  2370 <__cxa_finalize@plt>
    2787:	e8 64 ff ff ff       	callq  26f0 <deregister_tm_clones>
    278c:	c6 05 c5 b4 00 00 01 	movb   $0x1,0xb4c5(%rip)        # dc58 <completed.8060>
    2793:	5d                   	pop    %rbp
    2794:	c3                   	retq   
    2795:	0f 1f 00             	nopl   (%rax)
    2798:	c3                   	retq   
    2799:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000027a0 <frame_dummy>:
    27a0:	f3 0f 1e fa          	endbr64 
    27a4:	e9 77 ff ff ff       	jmpq   2720 <register_tm_clones>
    27a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000027b0 <__libc_csu_init>:
    27b0:	f3 0f 1e fa          	endbr64 
    27b4:	41 57                	push   %r15
    27b6:	4c 8d 3d 93 83 00 00 	lea    0x8393(%rip),%r15        # ab50 <__frame_dummy_init_array_entry>
    27bd:	41 56                	push   %r14
    27bf:	49 89 d6             	mov    %rdx,%r14
    27c2:	41 55                	push   %r13
    27c4:	49 89 f5             	mov    %rsi,%r13
    27c7:	41 54                	push   %r12
    27c9:	41 89 fc             	mov    %edi,%r12d
    27cc:	55                   	push   %rbp
    27cd:	48 8d 2d 84 83 00 00 	lea    0x8384(%rip),%rbp        # ab58 <__do_global_dtors_aux_fini_array_entry>
    27d4:	53                   	push   %rbx
    27d5:	4c 29 fd             	sub    %r15,%rbp
    27d8:	48 83 ec 08          	sub    $0x8,%rsp
    27dc:	e8 1f f8 ff ff       	callq  2000 <_init>
    27e1:	48 c1 fd 03          	sar    $0x3,%rbp
    27e5:	74 1f                	je     2806 <__libc_csu_init+0x56>
    27e7:	31 db                	xor    %ebx,%ebx
    27e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    27f0:	4c 89 f2             	mov    %r14,%rdx
    27f3:	4c 89 ee             	mov    %r13,%rsi
    27f6:	44 89 e7             	mov    %r12d,%edi
    27f9:	41 ff 14 df          	callq  *(%r15,%rbx,8)
    27fd:	48 83 c3 01          	add    $0x1,%rbx
    2801:	48 39 dd             	cmp    %rbx,%rbp
    2804:	75 ea                	jne    27f0 <__libc_csu_init+0x40>
    2806:	48 83 c4 08          	add    $0x8,%rsp
    280a:	5b                   	pop    %rbx
    280b:	5d                   	pop    %rbp
    280c:	41 5c                	pop    %r12
    280e:	41 5d                	pop    %r13
    2810:	41 5e                	pop    %r14
    2812:	41 5f                	pop    %r15
    2814:	c3                   	retq   
    2815:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    281c:	00 00 00 00 

0000000000002820 <__libc_csu_fini>:
    2820:	f3 0f 1e fa          	endbr64 
    2824:	c3                   	retq   

0000000000002825 <uart_in>:
	}
}

// ## functions ##

void uart_in(void *ptr1, void *ptr2, void *ptr3){
    2825:	f3 0f 1e fa          	endbr64 
    2829:	53                   	push   %rbx
    282a:	48 83 ec 10          	sub    $0x10,%rsp
	unsigned char input;

	// ## main loop ##
	for(;;){
		// state machine
		switch(state){
    282e:	48 8d 1d e3 b3 00 00 	lea    0xb3e3(%rip),%rbx        # dc18 <state>
void uart_in(void *ptr1, void *ptr2, void *ptr3){
    2835:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    283c:	00 00 
    283e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2843:	31 c0                	xor    %eax,%eax
		switch(state){
    2845:	83 3b 00             	cmpl   $0x0,(%rbx)
    2848:	75 63                	jne    28ad <uart_in+0x88>
			case init:
				// Warten auf Daten
				if(!uart_poll_in(uart_dev, &input)){
    284a:	48 8d 05 e7 b2 00 00 	lea    0xb2e7(%rip),%rax        # db38 <uart_dev>
    2851:	48 8b 38             	mov    (%rax),%rdi
				      unsigned char *p_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	return api->poll_in(dev, p_char);
    2854:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2858:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
    285d:	ff 10                	callq  *(%rax)
    285f:	85 c0                	test   %eax,%eax
    2861:	75 4a                	jne    28ad <uart_in+0x88>
					printk("received data: %c\n", input);
    2863:	0f b6 74 24 07       	movzbl 0x7(%rsp),%esi
    2868:	48 8d 3d fd 58 00 00 	lea    0x58fd(%rip),%rdi        # 816c <default_cmd+0x14c>
    286f:	e8 5a 02 00 00       	callq  2ace <printk>
					switch(input){
    2874:	8a 44 24 07          	mov    0x7(%rsp),%al
    2878:	3c 2e                	cmp    $0x2e,%al
    287a:	74 1a                	je     2896 <uart_in+0x71>
    287c:	3c 50                	cmp    $0x50,%al
    287e:	75 2d                	jne    28ad <uart_in+0x88>
						case '.':
							// Punkt zuruecksenden
							k_msgq_put(&uart_msgq, ".\n", K_FOREVER);
							break;
						case 'P':
							printk("Changing state to avail\n");
    2880:	48 8d 3d fb 58 00 00 	lea    0x58fb(%rip),%rdi        # 8182 <default_cmd+0x162>
    2887:	31 c0                	xor    %eax,%eax
    2889:	e8 40 02 00 00       	callq  2ace <printk>
							state = avail;
    288e:	c7 03 01 00 00 00    	movl   $0x1,(%rbx)
							break;
    2894:	eb 17                	jmp    28ad <uart_in+0x88>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_PUT);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_put(msgq, data, timeout);
    2896:	48 8d 3d 73 aa 00 00 	lea    0xaa73(%rip),%rdi        # d310 <uart_msgq>
    289d:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    28a1:	48 8d 35 d7 58 00 00 	lea    0x58d7(%rip),%rsi        # 817f <default_cmd+0x15f>
    28a8:	e8 50 37 00 00       	callq  5ffd <z_impl_k_msgq_put>
	return z_impl_k_sleep(timeout);
    28ad:	bf 01 00 00 00       	mov    $0x1,%edi
    28b2:	e8 01 41 00 00       	callq  69b8 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
    28b7:	eb 8c                	jmp    2845 <uart_in+0x20>

00000000000028b9 <processing>:
		k_msleep(1); // Abgeben des Prozessors
	}
	return;
}

void processing(void *ptr1, void *ptr2, void *ptr3){
    28b9:	f3 0f 1e fa          	endbr64 
    28bd:	53                   	push   %rbx
	ARG_UNUSED(ptr3);

	// ## main loop ##
	for(;;){
		// state machine
		switch(state){
    28be:	48 8d 1d 53 b3 00 00 	lea    0xb353(%rip),%rbx        # dc18 <state>
    28c5:	83 3b 01             	cmpl   $0x1,(%rbx)
    28c8:	75 2b                	jne    28f5 <processing+0x3c>
	return z_impl_k_msgq_put(msgq, data, timeout);
    28ca:	48 8d 3d 3f aa 00 00 	lea    0xaa3f(%rip),%rdi        # d310 <uart_msgq>
    28d1:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    28d5:	48 8d 35 bf 58 00 00 	lea    0x58bf(%rip),%rsi        # 819b <default_cmd+0x17b>
    28dc:	e8 1c 37 00 00       	callq  5ffd <z_impl_k_msgq_put>
			case init:
				break;
			case avail:
				// Senden von "PROCESSING AVAILABLE" an den Benutzer
				k_msgq_put(&uart_msgq, "PROCESSING AVAILABLE\n", K_FOREVER);
				printk("Changing state to init\n");
    28e1:	48 8d 3d c9 58 00 00 	lea    0x58c9(%rip),%rdi        # 81b1 <default_cmd+0x191>
    28e8:	31 c0                	xor    %eax,%eax
    28ea:	e8 df 01 00 00       	callq  2ace <printk>
				state = init; // Nach erfolgreichen Senden Rueckkehr in init state
    28ef:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
	return z_impl_k_sleep(timeout);
    28f5:	bf 01 00 00 00       	mov    $0x1,%edi
    28fa:	e8 b9 40 00 00       	callq  69b8 <z_impl_k_sleep>
    28ff:	eb c4                	jmp    28c5 <processing+0xc>

0000000000002901 <uart_out>:
void uart_out(void *ptr1, void *ptr2, void *ptr3){
    2901:	f3 0f 1e fa          	endbr64 
    2905:	41 55                	push   %r13
	unsigned char *output=malloc(100*sizeof(char));
    2907:	bf 64 00 00 00       	mov    $0x64,%edi
void uart_out(void *ptr1, void *ptr2, void *ptr3){
    290c:	41 54                	push   %r12
		memset(output, 0, strlen(output)); // Inhalt resetten
    290e:	49 83 cc ff          	or     $0xffffffffffffffff,%r12
void uart_out(void *ptr1, void *ptr2, void *ptr3){
    2912:	55                   	push   %rbp
    2913:	53                   	push   %rbx
    2914:	50                   	push   %rax
	unsigned char *output=malloc(100*sizeof(char));
    2915:	e8 86 fc ff ff       	callq  25a0 <malloc@plt>
    291a:	48 89 c5             	mov    %rax,%rbp
		memset(output, 0, strlen(output)); // Inhalt resetten
    291d:	31 c0                	xor    %eax,%eax
    291f:	48 89 ef             	mov    %rbp,%rdi
    2922:	4c 89 e1             	mov    %r12,%rcx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    2925:	31 f6                	xor    %esi,%esi
    2927:	f2 ae                	repnz scas %es:(%rdi),%al
    2929:	48 89 ef             	mov    %rbp,%rdi
    292c:	48 89 c8             	mov    %rcx,%rax
    292f:	b9 64 00 00 00       	mov    $0x64,%ecx
    2934:	48 f7 d0             	not    %rax
    2937:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    293b:	e8 e0 fc ff ff       	callq  2620 <__memset_chk@plt>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
    2940:	48 8d 3d c9 a9 00 00 	lea    0xa9c9(%rip),%rdi        # d310 <uart_msgq>
    2947:	31 d2                	xor    %edx,%edx
    2949:	48 89 ee             	mov    %rbp,%rsi
    294c:	e8 a3 37 00 00       	callq  60f4 <z_impl_k_msgq_get>
    2951:	89 c3                	mov    %eax,%ebx
		if(k_msgq_get(&uart_msgq, output, K_NO_WAIT)==0){ // Abfrage der uart message queue
    2953:	85 c0                	test   %eax,%eax
    2955:	74 0c                	je     2963 <uart_out+0x62>
	return z_impl_k_sleep(timeout);
    2957:	bf 01 00 00 00       	mov    $0x1,%edi
    295c:	e8 57 40 00 00       	callq  69b8 <z_impl_k_sleep>
    2961:	eb ba                	jmp    291d <uart_out+0x1c>
			printk("Going to send data: <%s>\n", output);
    2963:	48 89 ee             	mov    %rbp,%rsi
    2966:	48 8d 3d 5c 58 00 00 	lea    0x585c(%rip),%rdi        # 81c9 <default_cmd+0x1a9>
    296d:	31 c0                	xor    %eax,%eax
    296f:	e8 5a 01 00 00       	callq  2ace <printk>
			for(int i=0; i<strlen(output); i++){
    2974:	31 c0                	xor    %eax,%eax
    2976:	4c 89 e1             	mov    %r12,%rcx
    2979:	48 89 ef             	mov    %rbp,%rdi
    297c:	48 63 d3             	movslq %ebx,%rdx
    297f:	f2 ae                	repnz scas %es:(%rdi),%al
    2981:	48 89 c8             	mov    %rcx,%rax
    2984:	48 f7 d0             	not    %rax
    2987:	48 ff c8             	dec    %rax
    298a:	48 39 c2             	cmp    %rax,%rdx
    298d:	73 c8                	jae    2957 <uart_out+0x56>
				uart_poll_out(uart_dev, *(output+i));
    298f:	48 8d 05 a2 b1 00 00 	lea    0xb1a2(%rip),%rax        # db38 <uart_dev>
    2996:	4c 8d 6c 15 00       	lea    0x0(%rbp,%rdx,1),%r13
    299b:	41 0f b6 75 00       	movzbl 0x0(%r13),%esi
    29a0:	48 8b 38             	mov    (%rax),%rdi
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    29a3:	48 8b 47 10          	mov    0x10(%rdi),%rax
			for(int i=0; i<strlen(output); i++){
    29a7:	ff c3                	inc    %ebx
    29a9:	ff 50 08             	callq  *0x8(%rax)
				printk("Sent data: <%x>\n", *(output+i));
    29ac:	41 0f b6 75 00       	movzbl 0x0(%r13),%esi
    29b1:	48 8d 3d 2b 58 00 00 	lea    0x582b(%rip),%rdi        # 81e3 <default_cmd+0x1c3>
    29b8:	31 c0                	xor    %eax,%eax
    29ba:	e8 0f 01 00 00       	callq  2ace <printk>
			for(int i=0; i<strlen(output); i++){
    29bf:	eb b3                	jmp    2974 <uart_out+0x73>

00000000000029c1 <zephyr_app_main>:
void main(void){
    29c1:	f3 0f 1e fa          	endbr64 
    29c5:	53                   	push   %rbx
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    29c6:	48 8d 3d 27 58 00 00 	lea    0x5827(%rip),%rdi        # 81f4 <default_cmd+0x1d4>
    29cd:	e8 45 34 00 00       	callq  5e17 <z_impl_device_get_binding>
	uart_dev = device_get_binding(DT_LABEL(UART_DEVICE));
    29d2:	48 8d 1d 5f b1 00 00 	lea    0xb15f(%rip),%rbx        # db38 <uart_dev>
		printk("UART not found\n");
    29d9:	48 8d 3d 1b 58 00 00 	lea    0x581b(%rip),%rdi        # 81fb <default_cmd+0x1db>
	uart_dev = device_get_binding(DT_LABEL(UART_DEVICE));
    29e0:	48 89 03             	mov    %rax,(%rbx)
	if(!uart_dev){
    29e3:	48 85 c0             	test   %rax,%rax
    29e6:	74 3f                	je     2a27 <zephyr_app_main+0x66>
	printk("UART found\n");
    29e8:	31 c0                	xor    %eax,%eax
    29ea:	48 8d 3d 1a 58 00 00 	lea    0x581a(%rip),%rdi        # 820b <default_cmd+0x1eb>
    29f1:	e8 d8 00 00 00       	callq  2ace <printk>
	uartconf.baudrate = 9600;
    29f6:	48 8d 35 33 b1 00 00 	lea    0xb133(%rip),%rsi        # db30 <uartconf>
	if(!uart_configure(uart_dev, &uartconf)){
    29fd:	48 8b 3b             	mov    (%rbx),%rdi
	uartconf.baudrate = 9600;
    2a00:	48 b8 80 25 00 00 00 	movabs $0x3010000002580,%rax
    2a07:	01 03 00 
    2a0a:	48 89 06             	mov    %rax,(%rsi)
					const struct uart_config *cfg)
{
	const struct uart_driver_api *api =
				(const struct uart_driver_api *)dev->api;

	if (api->configure == NULL) {
    2a0d:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2a11:	48 8b 40 18          	mov    0x18(%rax),%rax
    2a15:	48 85 c0             	test   %rax,%rax
    2a18:	74 13                	je     2a2d <zephyr_app_main+0x6c>
		return -ENOSYS;
	}
	return api->configure(dev, cfg);
    2a1a:	ff d0                	callq  *%rax
	if(!uart_configure(uart_dev, &uartconf)){
    2a1c:	85 c0                	test   %eax,%eax
    2a1e:	75 0d                	jne    2a2d <zephyr_app_main+0x6c>
		printk("Configuration of UART failed\n");
    2a20:	48 8d 3d f0 57 00 00 	lea    0x57f0(%rip),%rdi        # 8217 <default_cmd+0x1f7>
}
    2a27:	5b                   	pop    %rbx
		printk("Configuration of UART failed\n");
    2a28:	e9 a1 00 00 00       	jmpq   2ace <printk>
	printk("UART configured\n");
    2a2d:	48 8d 3d 01 58 00 00 	lea    0x5801(%rip),%rdi        # 8235 <default_cmd+0x215>
    2a34:	31 c0                	xor    %eax,%eax
		printk("\nmain is waiting for death\n"); // "main is still alive" ist mir irgendwie zu langweilig...
    2a36:	48 8d 1d 09 58 00 00 	lea    0x5809(%rip),%rbx        # 8246 <default_cmd+0x226>
	printk("UART configured\n");
    2a3d:	e8 8c 00 00 00       	callq  2ace <printk>
		printk("\nmain is waiting for death\n"); // "main is still alive" ist mir irgendwie zu langweilig...
    2a42:	48 89 df             	mov    %rbx,%rdi
    2a45:	31 c0                	xor    %eax,%eax
    2a47:	e8 82 00 00 00       	callq  2ace <printk>
    2a4c:	bf e8 03 00 00       	mov    $0x3e8,%edi
    2a51:	e8 62 3f 00 00       	callq  69b8 <z_impl_k_sleep>
    2a56:	eb ea                	jmp    2a42 <zephyr_app_main+0x81>

0000000000002a58 <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
    2a58:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    2a5c:	31 c0                	xor    %eax,%eax
    2a5e:	c3                   	retq   

0000000000002a5f <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    2a5f:	f3 0f 1e fa          	endbr64 
	struct out_context *ctx = ctx_p;

	ctx->count++;
	return _char_out(c);
    2a63:	48 8d 05 be 89 00 00 	lea    0x89be(%rip),%rax        # b428 <_char_out>
	ctx->count++;
    2a6a:	ff 06                	incl   (%rsi)
	return _char_out(c);
    2a6c:	ff 20                	jmpq   *(%rax)

0000000000002a6e <__printk_hook_install>:
{
    2a6e:	f3 0f 1e fa          	endbr64 
	_char_out = fn;
    2a72:	48 8d 05 af 89 00 00 	lea    0x89af(%rip),%rax        # b428 <_char_out>
    2a79:	48 89 38             	mov    %rdi,(%rax)
}
    2a7c:	c3                   	retq   

0000000000002a7d <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    2a7d:	f3 0f 1e fa          	endbr64 
    2a81:	48 83 ec 18          	sub    $0x18,%rsp
    2a85:	48 89 fa             	mov    %rdi,%rdx
    2a88:	48 89 f1             	mov    %rsi,%rcx
    2a8b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2a92:	00 00 
    2a94:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2a99:	31 c0                	xor    %eax,%eax
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    2a9b:	48 8d 74 24 04       	lea    0x4(%rsp),%rsi
    2aa0:	48 8d 3d b8 ff ff ff 	lea    -0x48(%rip),%rdi        # 2a5f <char_out>
	struct out_context ctx = { 0 };
    2aa7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
    2aae:	00 
	cbvprintf(char_out, &ctx, fmt, ap);
    2aaf:	e8 84 03 00 00       	callq  2e38 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    2ab4:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    2ab9:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    2ac0:	00 00 
    2ac2:	74 05                	je     2ac9 <vprintk+0x4c>
    2ac4:	e8 d7 f9 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    2ac9:	48 83 c4 18          	add    $0x18,%rsp
    2acd:	c3                   	retq   

0000000000002ace <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
    2ace:	f3 0f 1e fa          	endbr64 
    2ad2:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    2ad9:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    2ade:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    2ae3:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    2ae8:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    2aed:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    2af2:	84 c0                	test   %al,%al
    2af4:	74 37                	je     2b2d <printk+0x5f>
    2af6:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    2afb:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    2b00:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    2b05:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    2b0c:	00 
    2b0d:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    2b14:	00 
    2b15:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    2b1c:	00 
    2b1d:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    2b24:	00 
    2b25:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    2b2c:	00 
    2b2d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2b34:	00 00 
    2b36:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    2b3b:	31 c0                	xor    %eax,%eax
	va_list ap;

	va_start(ap, fmt);
    2b3d:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    2b44:	00 

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    2b45:	48 89 e6             	mov    %rsp,%rsi
	va_start(ap, fmt);
    2b48:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    2b4f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2b54:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    2b59:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    2b5e:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    2b65:	00 
		vprintk(fmt, ap);
    2b66:	e8 12 ff ff ff       	callq  2a7d <vprintk>
	}
	va_end(ap);
}
    2b6b:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    2b70:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    2b77:	00 00 
    2b79:	74 05                	je     2b80 <printk+0xb2>
    2b7b:	e8 20 f9 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    2b80:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    2b87:	c3                   	retq   

0000000000002b88 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    2b88:	f3 0f 1e fa          	endbr64 
    2b8c:	50                   	push   %rax
    2b8d:	58                   	pop    %rax
    2b8e:	49 89 f8             	mov    %rdi,%r8
    2b91:	50                   	push   %rax
    2b92:	48 89 f7             	mov    %rsi,%rdi
    2b95:	48 89 d6             	mov    %rdx,%rsi
    2b98:	48 89 ca             	mov    %rcx,%rdx
	entry(p1, p2, p3);
    2b9b:	41 ff d0             	callq  *%r8
	return z_impl_k_current_get();
    2b9e:	e8 4d 3e 00 00       	callq  69f0 <z_impl_k_current_get>
    2ba3:	48 89 c7             	mov    %rax,%rdi
	z_impl_k_thread_abort(thread);
    2ba6:	e8 5d 12 00 00       	callq  3e08 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    2bab:	ba 26 00 00 00       	mov    $0x26,%edx
    2bb0:	48 8d 35 d3 56 00 00 	lea    0x56d3(%rip),%rsi        # 828a <default_cmd+0x26a>
    2bb7:	31 c0                	xor    %eax,%eax
    2bb9:	48 8d 3d f3 56 00 00 	lea    0x56f3(%rip),%rdi        # 82b3 <default_cmd+0x293>
    2bc0:	e8 27 22 00 00       	callq  4dec <posix_print_error_and_exit>

0000000000002bc5 <chunk_size>:

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    2bc5:	89 f6                	mov    %esi,%esi
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    2bc7:	8b 44 f7 04          	mov    0x4(%rdi,%rsi,8),%eax
    2bcb:	d1 e8                	shr    %eax
}
    2bcd:	c3                   	retq   

0000000000002bce <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    2bce:	89 f6                	mov    %esi,%esi
{
    2bd0:	41 89 d0             	mov    %edx,%r8d
	void *cmem = &buf[c];
    2bd3:	48 8d 04 f7          	lea    (%rdi,%rsi,8),%rax

	if (big_heap(h)) {
		if (used) {
    2bd7:	8b 48 04             	mov    0x4(%rax),%ecx
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
    2bda:	89 ca                	mov    %ecx,%edx
    2bdc:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
    2bdf:	45 84 c0             	test   %r8b,%r8b
    2be2:	74 05                	je     2be9 <set_chunk_used+0x1b>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    2be4:	83 c9 01             	or     $0x1,%ecx
    2be7:	89 ca                	mov    %ecx,%edx
    2be9:	89 50 04             	mov    %edx,0x4(%rax)
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    2bec:	c3                   	retq   

0000000000002bed <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    2bed:	89 f2                	mov    %esi,%edx
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    2bef:	e8 d1 ff ff ff       	callq  2bc5 <chunk_size>
	if (!solo_free_header(h, c)) {
    2bf4:	83 f8 01             	cmp    $0x1,%eax
    2bf7:	74 5b                	je     2c54 <free_list_add+0x67>
	return chunksz * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    2bf9:	ff c8                	dec    %eax
	return 31 - __builtin_clz(usable_sz);
    2bfb:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    2c00:	0f bd c0             	bsr    %eax,%eax
    2c03:	83 f0 1f             	xor    $0x1f,%eax
    2c06:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
    2c08:	48 63 c1             	movslq %ecx,%rax
    2c0b:	4c 8d 14 87          	lea    (%rdi,%rax,4),%r10
    2c0f:	89 d0                	mov    %edx,%eax
    2c11:	41 8b 72 10          	mov    0x10(%r10),%esi
    2c15:	48 8d 04 c5 08 00 00 	lea    0x8(,%rax,8),%rax
    2c1c:	00 
    2c1d:	4c 8d 0c 07          	lea    (%rdi,%rax,1),%r9
    2c21:	4c 8d 44 07 04       	lea    0x4(%rdi,%rax,1),%r8
    2c26:	85 f6                	test   %esi,%esi
    2c28:	75 15                	jne    2c3f <free_list_add+0x52>
		h->avail_buckets |= (1 << bidx);
    2c2a:	b8 01 00 00 00       	mov    $0x1,%eax
    2c2f:	d3 e0                	shl    %cl,%eax
    2c31:	09 47 0c             	or     %eax,0xc(%rdi)
		b->next = c;
    2c34:	41 89 52 10          	mov    %edx,0x10(%r10)
		((uint32_t *)cmem)[f] = val;
    2c38:	41 89 11             	mov    %edx,(%r9)
    2c3b:	41 89 10             	mov    %edx,(%r8)
}
    2c3e:	c3                   	retq   
	void *cmem = &buf[c];
    2c3f:	89 f0                	mov    %esi,%eax
		return ((uint32_t *)cmem)[f];
    2c41:	48 8d 4c c7 08       	lea    0x8(%rdi,%rax,8),%rcx
    2c46:	8b 01                	mov    (%rcx),%eax
		((uint32_t *)cmem)[f] = val;
    2c48:	41 89 01             	mov    %eax,(%r9)
    2c4b:	41 89 30             	mov    %esi,(%r8)
    2c4e:	89 54 c7 0c          	mov    %edx,0xc(%rdi,%rax,8)
    2c52:	89 11                	mov    %edx,(%rcx)
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
	}
}
    2c54:	c3                   	retq   

0000000000002c55 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    2c55:	f3 0f 1e fa          	endbr64 
    2c59:	49 89 f8             	mov    %rdi,%r8
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    2c5c:	4c 8d 4c 16 f8       	lea    -0x8(%rsi,%rdx,1),%r9
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    2c61:	48 8d 7e 07          	lea    0x7(%rsi),%rdi
	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    2c65:	ba 20 00 00 00       	mov    $0x20,%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    2c6a:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    2c6e:	49 83 e1 f8          	and    $0xfffffffffffffff8,%r9
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    2c72:	49 29 f9             	sub    %rdi,%r9
	heap->heap = h;
    2c75:	49 89 38             	mov    %rdi,(%r8)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    2c78:	49 c1 e9 03          	shr    $0x3,%r9
	h->avail_buckets = 0;
    2c7c:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    2c83:	41 8d 41 ff          	lea    -0x1(%r9),%eax
	h->end_chunk = heap_sz;
    2c87:	44 89 4f 08          	mov    %r9d,0x8(%rdi)
	return 31 - __builtin_clz(usable_sz);
    2c8b:	0f bd c0             	bsr    %eax,%eax
    2c8e:	83 f0 1f             	xor    $0x1f,%eax
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    2c91:	29 c2                	sub    %eax,%edx
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    2c93:	48 63 c2             	movslq %edx,%rax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    2c96:	4c 8d 14 85 17 00 00 	lea    0x17(,%rax,4),%r10
    2c9d:	00 
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    2c9e:	31 c0                	xor    %eax,%eax
    2ca0:	49 c1 ea 03          	shr    $0x3,%r10
    2ca4:	39 c2                	cmp    %eax,%edx
    2ca6:	7e 0d                	jle    2cb5 <sys_heap_init+0x60>
		h->buckets[i].next = 0;
    2ca8:	c7 44 87 10 00 00 00 	movl   $0x0,0x10(%rdi,%rax,4)
    2caf:	00 
	for (int i = 0; i < nb_buckets; i++) {
    2cb0:	48 ff c0             	inc    %rax
    2cb3:	eb ef                	jmp    2ca4 <sys_heap_init+0x4f>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    2cb5:	43 8d 04 12          	lea    (%r10,%r10,1),%eax
		((uint32_t *)cmem)[f] = val;
    2cb9:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
    2cbf:	ba 01 00 00 00       	mov    $0x1,%edx
    2cc4:	31 f6                	xor    %esi,%esi
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    2cc6:	89 47 04             	mov    %eax,0x4(%rdi)
    2cc9:	e8 00 ff ff ff       	callq  2bce <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    2cce:	44 89 ca             	mov    %r9d,%edx
		((uint32_t *)cmem)[f] = val;
    2cd1:	46 89 14 d7          	mov    %r10d,(%rdi,%r10,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
    2cd5:	44 89 ce             	mov    %r9d,%esi
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    2cd8:	44 29 d2             	sub    %r10d,%edx
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    2cdb:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
    2cde:	42 89 44 d7 04       	mov    %eax,0x4(%rdi,%r10,8)
	void *cmem = &buf[c];
    2ce3:	44 89 c8             	mov    %r9d,%eax
		((uint32_t *)cmem)[f] = val;
    2ce6:	89 14 c7             	mov    %edx,(%rdi,%rax,8)
	set_chunk_used(h, heap_sz, true);
    2ce9:	ba 01 00 00 00       	mov    $0x1,%edx
    2cee:	c7 44 c7 04 00 00 00 	movl   $0x0,0x4(%rdi,%rax,8)
    2cf5:	00 
    2cf6:	e8 d3 fe ff ff       	callq  2bce <set_chunk_used>

	free_list_add(h, chunk0_size);
    2cfb:	44 89 d6             	mov    %r10d,%esi
    2cfe:	e9 ea fe ff ff       	jmpq   2bed <free_list_add>

0000000000002d03 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    2d03:	41 56                	push   %r14
    2d05:	49 89 f6             	mov    %rsi,%r14
    2d08:	41 55                	push   %r13
    2d0a:	49 89 fd             	mov    %rdi,%r13
    2d0d:	41 54                	push   %r12
    2d0f:	49 89 cc             	mov    %rcx,%r12
    2d12:	55                   	push   %rbp
    2d13:	48 89 d5             	mov    %rdx,%rbp
    2d16:	53                   	push   %rbx
	size_t count = 0;
    2d17:	31 db                	xor    %ebx,%ebx

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    2d19:	48 8d 44 1d 00       	lea    0x0(%rbp,%rbx,1),%rax
    2d1e:	49 39 c4             	cmp    %rax,%r12
    2d21:	76 16                	jbe    2d39 <outs+0x36>
		int rc = out((int)*sp++, ctx);
    2d23:	31 c0                	xor    %eax,%eax
    2d25:	0f be 7c 1d 00       	movsbl 0x0(%rbp,%rbx,1),%edi
    2d2a:	4c 89 f6             	mov    %r14,%rsi
    2d2d:	41 ff d5             	callq  *%r13

		if (rc < 0) {
    2d30:	85 c0                	test   %eax,%eax
    2d32:	78 17                	js     2d4b <outs+0x48>
			return rc;
		}
		++count;
    2d34:	48 ff c3             	inc    %rbx
    2d37:	eb e0                	jmp    2d19 <outs+0x16>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    2d39:	4d 85 e4             	test   %r12,%r12
    2d3c:	74 04                	je     2d42 <outs+0x3f>
	}

	return (int)count;
    2d3e:	89 d8                	mov    %ebx,%eax
    2d40:	eb 09                	jmp    2d4b <outs+0x48>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    2d42:	80 7c 1d 00 00       	cmpb   $0x0,0x0(%rbp,%rbx,1)
    2d47:	75 da                	jne    2d23 <outs+0x20>
    2d49:	eb f3                	jmp    2d3e <outs+0x3b>
}
    2d4b:	5b                   	pop    %rbx
    2d4c:	5d                   	pop    %rbp
    2d4d:	41 5c                	pop    %r12
    2d4f:	41 5d                	pop    %r13
    2d51:	41 5e                	pop    %r14
    2d53:	c3                   	retq   

0000000000002d54 <extract_decimal>:
{
    2d54:	55                   	push   %rbp
    2d55:	53                   	push   %rbx
    2d56:	48 89 fb             	mov    %rdi,%rbx
    2d59:	51                   	push   %rcx
	const char *sp = *str;
    2d5a:	48 8b 2f             	mov    (%rdi),%rbp
	while (isdigit((int)(unsigned char)*sp)) {
    2d5d:	e8 3e f9 ff ff       	callq  26a0 <__ctype_b_loc@plt>
    2d62:	48 8b 08             	mov    (%rax),%rcx
	size_t val = 0;
    2d65:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
    2d67:	48 0f be 55 00       	movsbq 0x0(%rbp),%rdx
    2d6c:	0f b6 f2             	movzbl %dl,%esi
    2d6f:	f6 44 71 01 08       	testb  $0x8,0x1(%rcx,%rsi,2)
    2d74:	74 0e                	je     2d84 <extract_decimal+0x30>
		val = 10U * val + *sp++ - '0';
    2d76:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    2d7a:	48 ff c5             	inc    %rbp
    2d7d:	48 8d 44 10 d0       	lea    -0x30(%rax,%rdx,1),%rax
    2d82:	eb e3                	jmp    2d67 <extract_decimal+0x13>
	*str = sp;
    2d84:	48 89 2b             	mov    %rbp,(%rbx)
}
    2d87:	5a                   	pop    %rdx
    2d88:	5b                   	pop    %rbx
    2d89:	5d                   	pop    %rbp
    2d8a:	c3                   	retq   

0000000000002d8b <encode_uint>:
{
    2d8b:	41 55                	push   %r13
    2d8d:	49 89 fd             	mov    %rdi,%r13
    2d90:	41 54                	push   %r12
    2d92:	49 89 cc             	mov    %rcx,%r12
    2d95:	55                   	push   %rbp
    2d96:	48 89 d5             	mov    %rdx,%rbp
    2d99:	53                   	push   %rbx
    2d9a:	48 89 f3             	mov    %rsi,%rbx
    2d9d:	41 50                	push   %r8
	bool upcase = isupper((int)conv->specifier);
    2d9f:	e8 fc f8 ff ff       	callq  26a0 <__ctype_b_loc@plt>
    2da4:	0f b6 4b 03          	movzbl 0x3(%rbx),%ecx
    2da8:	49 89 c0             	mov    %rax,%r8
    2dab:	49 8b 10             	mov    (%r8),%rdx
    2dae:	48 89 c8             	mov    %rcx,%rax
	switch (specifier) {
    2db1:	41 b8 08 00 00 00    	mov    $0x8,%r8d
    2db7:	66 8b 0c 4a          	mov    (%rdx,%rcx,2),%cx
    2dbb:	66 81 e1 00 01       	and    $0x100,%cx
    2dc0:	3c 6f                	cmp    $0x6f,%al
    2dc2:	74 3b                	je     2dff <encode_uint+0x74>
    2dc4:	77 04                	ja     2dca <encode_uint+0x3f>
		return 16;
    2dc6:	3c 58                	cmp    $0x58,%al
    2dc8:	eb 05                	jmp    2dcf <encode_uint+0x44>
	switch (specifier) {
    2dca:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
    2dcd:	3c 70                	cmp    $0x70,%al
    2dcf:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
    2dd5:	b8 10 00 00 00       	mov    $0x10,%eax
    2dda:	4c 0f 44 c0          	cmove  %rax,%r8
	char *bp = bps + (bpe - bps);
    2dde:	eb 1f                	jmp    2dff <encode_uint+0x74>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    2de0:	8d 72 57             	lea    0x57(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    2de3:	66 85 c9             	test   %cx,%cx
    2de6:	74 03                	je     2deb <encode_uint+0x60>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    2de8:	8d 72 37             	lea    0x37(%rdx),%esi
		*--bp = (lsv <= 9) ? ('0' + lsv)
    2deb:	49 ff cc             	dec    %r12
    2dee:	41 88 34 24          	mov    %sil,(%r12)
	} while ((value != 0) && (bps < bp));
    2df2:	4d 39 c5             	cmp    %r8,%r13
    2df5:	72 1b                	jb     2e12 <encode_uint+0x87>
    2df7:	49 39 ec             	cmp    %rbp,%r12
    2dfa:	76 16                	jbe    2e12 <encode_uint+0x87>
		value /= radix;
    2dfc:	49 89 c5             	mov    %rax,%r13
		unsigned int lsv = (unsigned int)(value % radix);
    2dff:	4c 89 e8             	mov    %r13,%rax
    2e02:	31 d2                	xor    %edx,%edx
    2e04:	49 f7 f0             	div    %r8
		*--bp = (lsv <= 9) ? ('0' + lsv)
    2e07:	8d 72 30             	lea    0x30(%rdx),%esi
    2e0a:	48 83 fa 09          	cmp    $0x9,%rdx
    2e0e:	76 db                	jbe    2deb <encode_uint+0x60>
    2e10:	eb ce                	jmp    2de0 <encode_uint+0x55>
	if (conv->flag_hash) {
    2e12:	f6 03 20             	testb  $0x20,(%rbx)
    2e15:	74 16                	je     2e2d <encode_uint+0xa2>
		if (radix == 8) {
    2e17:	49 83 f8 08          	cmp    $0x8,%r8
    2e1b:	75 06                	jne    2e23 <encode_uint+0x98>
			conv->altform_0 = true;
    2e1d:	80 4b 02 08          	orb    $0x8,0x2(%rbx)
    2e21:	eb 0a                	jmp    2e2d <encode_uint+0xa2>
		} else if (radix == 16) {
    2e23:	49 83 f8 10          	cmp    $0x10,%r8
    2e27:	75 04                	jne    2e2d <encode_uint+0xa2>
			conv->altform_0c = true;
    2e29:	80 4b 02 10          	orb    $0x10,0x2(%rbx)
}
    2e2d:	5a                   	pop    %rdx
    2e2e:	4c 89 e0             	mov    %r12,%rax
    2e31:	5b                   	pop    %rbx
    2e32:	5d                   	pop    %rbp
    2e33:	41 5c                	pop    %r12
    2e35:	41 5d                	pop    %r13
    2e37:	c3                   	retq   

0000000000002e38 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    2e38:	f3 0f 1e fa          	endbr64 
    2e3c:	41 57                	push   %r15
    2e3e:	49 89 f7             	mov    %rsi,%r15
    2e41:	41 56                	push   %r14
    2e43:	49 89 fe             	mov    %rdi,%r14
    2e46:	41 55                	push   %r13
    2e48:	49 89 d5             	mov    %rdx,%r13
    2e4b:	41 54                	push   %r12
    2e4d:	49 89 cc             	mov    %rcx,%r12
    2e50:	55                   	push   %rbp
    2e51:	53                   	push   %rbx
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    2e52:	31 db                	xor    %ebx,%ebx
{
    2e54:	48 83 ec 78          	sub    $0x78,%rsp
    2e58:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2e5f:	00 00 
    2e61:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    2e66:	31 c0                	xor    %eax,%eax
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    2e68:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
    2e6d:	40 84 ff             	test   %dil,%dil
    2e70:	0f 84 d2 09 00 00    	je     3848 <cbvprintf+0xa10>
		if (*fp != '%') {
    2e76:	49 8d 6d 01          	lea    0x1(%r13),%rbp
			OUTC(*fp++);
    2e7a:	4c 89 fe             	mov    %r15,%rsi
		if (*fp != '%') {
    2e7d:	40 80 ff 25          	cmp    $0x25,%dil
    2e81:	0f 85 89 06 00 00    	jne    3510 <cbvprintf+0x6d8>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    2e87:	31 c0                	xor    %eax,%eax
    2e89:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    2e8e:	b9 08 00 00 00       	mov    $0x8,%ecx
    2e93:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (*sp == '%') {
    2e95:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
    2e9a:	41 80 7d 01 25       	cmpb   $0x25,0x1(%r13)
    2e9f:	75 1c                	jne    2ebd <cbvprintf+0x85>
		conv->specifier = *sp++;
    2ea1:	c6 44 24 43 25       	movb   $0x25,0x43(%rsp)
    2ea6:	49 8d 6d 02          	lea    0x2(%r13),%rbp
		return sp;
    2eaa:	e9 df 02 00 00       	jmpq   318e <cbvprintf+0x356>
		switch (*sp) {
    2eaf:	7e 15                	jle    2ec6 <cbvprintf+0x8e>
    2eb1:	3c 2d                	cmp    $0x2d,%al
    2eb3:	75 1b                	jne    2ed0 <cbvprintf+0x98>
			conv->flag_dash = true;
    2eb5:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
			++sp;
    2eba:	48 ff c5             	inc    %rbp
		switch (*sp) {
    2ebd:	8a 45 00             	mov    0x0(%rbp),%al
    2ec0:	3c 2b                	cmp    $0x2b,%al
    2ec2:	75 eb                	jne    2eaf <cbvprintf+0x77>
    2ec4:	eb 25                	jmp    2eeb <cbvprintf+0xb3>
    2ec6:	3c 20                	cmp    $0x20,%al
    2ec8:	74 28                	je     2ef2 <cbvprintf+0xba>
    2eca:	3c 23                	cmp    $0x23,%al
    2ecc:	74 2b                	je     2ef9 <cbvprintf+0xc1>
    2ece:	eb 04                	jmp    2ed4 <cbvprintf+0x9c>
    2ed0:	3c 30                	cmp    $0x30,%al
    2ed2:	74 2c                	je     2f00 <cbvprintf+0xc8>
	if (conv->flag_zero && conv->flag_dash) {
    2ed4:	8a 44 24 40          	mov    0x40(%rsp),%al
    2ed8:	89 c2                	mov    %eax,%edx
    2eda:	83 e2 44             	and    $0x44,%edx
    2edd:	80 fa 44             	cmp    $0x44,%dl
    2ee0:	75 25                	jne    2f07 <cbvprintf+0xcf>
		conv->flag_zero = false;
    2ee2:	83 e0 bf             	and    $0xffffffbf,%eax
    2ee5:	88 44 24 40          	mov    %al,0x40(%rsp)
    2ee9:	eb 1c                	jmp    2f07 <cbvprintf+0xcf>
			conv->flag_plus = true;
    2eeb:	80 4c 24 40 08       	orb    $0x8,0x40(%rsp)
			break;
    2ef0:	eb c8                	jmp    2eba <cbvprintf+0x82>
			conv->flag_space = true;
    2ef2:	80 4c 24 40 10       	orb    $0x10,0x40(%rsp)
			break;
    2ef7:	eb c1                	jmp    2eba <cbvprintf+0x82>
			conv->flag_hash = true;
    2ef9:	80 4c 24 40 20       	orb    $0x20,0x40(%rsp)
			break;
    2efe:	eb ba                	jmp    2eba <cbvprintf+0x82>
			conv->flag_zero = true;
    2f00:	80 4c 24 40 40       	orb    $0x40,0x40(%rsp)
			break;
    2f05:	eb b3                	jmp    2eba <cbvprintf+0x82>
	conv->width_present = true;
    2f07:	80 4c 24 40 80       	orb    $0x80,0x40(%rsp)
    2f0c:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	if (*sp == '*') {
    2f11:	80 7d 00 2a          	cmpb   $0x2a,0x0(%rbp)
    2f15:	75 0a                	jne    2f21 <cbvprintf+0xe9>
		conv->width_star = true;
    2f17:	80 4c 24 41 01       	orb    $0x1,0x41(%rsp)
		return ++sp;
    2f1c:	48 ff c5             	inc    %rbp
    2f1f:	eb 5d                	jmp    2f7e <cbvprintf+0x146>
	size_t width = extract_decimal(&sp);
    2f21:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    2f26:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    2f2b:	e8 24 fe ff ff       	callq  2d54 <extract_decimal>
	if (sp != wp) {
    2f30:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    2f35:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    2f3a:	48 39 e9             	cmp    %rbp,%rcx
    2f3d:	74 3f                	je     2f7e <cbvprintf+0x146>
		conv->width_present = true;
    2f3f:	8a 54 24 40          	mov    0x40(%rsp),%dl
		conv->width_value = width;
    2f43:	89 44 24 44          	mov    %eax,0x44(%rsp)
				      || (width != (size_t)conv->width_value));
    2f47:	bf 01 00 00 00       	mov    $0x1,%edi
		conv->width_present = true;
    2f4c:	83 ca 80             	or     $0xffffff80,%edx
    2f4f:	88 54 24 40          	mov    %dl,0x40(%rsp)
		conv->unsupported |= ((conv->width_value < 0)
    2f53:	d0 ea                	shr    %dl
    2f55:	83 e2 01             	and    $0x1,%edx
				      || (width != (size_t)conv->width_value));
    2f58:	85 c0                	test   %eax,%eax
    2f5a:	78 0e                	js     2f6a <cbvprintf+0x132>
    2f5c:	48 63 f8             	movslq %eax,%rdi
    2f5f:	48 39 c7             	cmp    %rax,%rdi
    2f62:	40 0f 95 c7          	setne  %dil
    2f66:	40 0f b6 ff          	movzbl %dil,%edi
		conv->unsupported |= ((conv->width_value < 0)
    2f6a:	8a 44 24 40          	mov    0x40(%rsp),%al
    2f6e:	09 fa                	or     %edi,%edx
    2f70:	48 89 cd             	mov    %rcx,%rbp
    2f73:	01 d2                	add    %edx,%edx
    2f75:	83 e0 fd             	and    $0xfffffffd,%eax
    2f78:	09 c2                	or     %eax,%edx
    2f7a:	88 54 24 40          	mov    %dl,0x40(%rsp)
	sp = extract_prec(conv, sp);
    2f7e:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	conv->prec_present = (*sp == '.');
    2f83:	8a 4d 00             	mov    0x0(%rbp),%cl
    2f86:	80 f9 2e             	cmp    $0x2e,%cl
    2f89:	0f 94 c0             	sete   %al
    2f8c:	8d 14 00             	lea    (%rax,%rax,1),%edx
    2f8f:	8a 44 24 41          	mov    0x41(%rsp),%al
    2f93:	83 e0 fd             	and    $0xfffffffd,%eax
    2f96:	09 d0                	or     %edx,%eax
    2f98:	88 44 24 41          	mov    %al,0x41(%rsp)
	if (!conv->prec_present) {
    2f9c:	80 f9 2e             	cmp    $0x2e,%cl
    2f9f:	75 6b                	jne    300c <cbvprintf+0x1d4>
	++sp;
    2fa1:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    2fa5:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
	if (*sp == '*') {
    2faa:	80 7d 01 2a          	cmpb   $0x2a,0x1(%rbp)
    2fae:	75 0d                	jne    2fbd <cbvprintf+0x185>
		conv->prec_star = true;
    2fb0:	83 c8 04             	or     $0x4,%eax
		return ++sp;
    2fb3:	48 83 c5 02          	add    $0x2,%rbp
		conv->prec_star = true;
    2fb7:	88 44 24 41          	mov    %al,0x41(%rsp)
		return ++sp;
    2fbb:	eb 4f                	jmp    300c <cbvprintf+0x1d4>
	size_t prec = extract_decimal(&sp);
    2fbd:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    2fc2:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    2fc7:	e8 88 fd ff ff       	callq  2d54 <extract_decimal>
			      || (prec != (size_t)conv->prec_value));
    2fcc:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    2fd1:	b9 01 00 00 00       	mov    $0x1,%ecx
	size_t prec = extract_decimal(&sp);
    2fd6:	48 89 c2             	mov    %rax,%rdx
	conv->prec_value = prec;
    2fd9:	89 44 24 48          	mov    %eax,0x48(%rsp)
	conv->unsupported |= ((conv->prec_value < 0)
    2fdd:	8a 44 24 40          	mov    0x40(%rsp),%al
    2fe1:	d0 e8                	shr    %al
    2fe3:	83 e0 01             	and    $0x1,%eax
			      || (prec != (size_t)conv->prec_value));
    2fe6:	85 d2                	test   %edx,%edx
    2fe8:	78 0c                	js     2ff6 <cbvprintf+0x1be>
    2fea:	48 63 ca             	movslq %edx,%rcx
    2fed:	48 39 d1             	cmp    %rdx,%rcx
    2ff0:	0f 95 c1             	setne  %cl
    2ff3:	0f b6 c9             	movzbl %cl,%ecx
	conv->unsupported |= ((conv->prec_value < 0)
    2ff6:	8a 54 24 40          	mov    0x40(%rsp),%dl
    2ffa:	09 c8                	or     %ecx,%eax
	return sp;
    2ffc:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
	conv->unsupported |= ((conv->prec_value < 0)
    3001:	01 c0                	add    %eax,%eax
    3003:	83 e2 fd             	and    $0xfffffffd,%edx
    3006:	09 d0                	or     %edx,%eax
    3008:	88 44 24 40          	mov    %al,0x40(%rsp)
	switch (*sp) {
    300c:	8a 4d 00             	mov    0x0(%rbp),%cl
    300f:	48 8d 55 01          	lea    0x1(%rbp),%rdx
    3013:	80 f9 6c             	cmp    $0x6c,%cl
    3016:	74 54                	je     306c <cbvprintf+0x234>
    3018:	7f 22                	jg     303c <cbvprintf+0x204>
    301a:	80 f9 68             	cmp    $0x68,%cl
    301d:	74 33                	je     3052 <cbvprintf+0x21a>
    301f:	80 f9 6a             	cmp    $0x6a,%cl
    3022:	74 6e                	je     3092 <cbvprintf+0x25a>
    3024:	80 f9 4c             	cmp    $0x4c,%cl
    3027:	75 7d                	jne    30a6 <cbvprintf+0x26e>
		conv->unsupported = true;
    3029:	8b 44 24 40          	mov    0x40(%rsp),%eax
    302d:	66 25 fd 87          	and    $0x87fd,%ax
    3031:	66 0d 02 40          	or     $0x4002,%ax
    3035:	66 89 44 24 40       	mov    %ax,0x40(%rsp)
		break;
    303a:	eb 72                	jmp    30ae <cbvprintf+0x276>
	switch (*sp) {
    303c:	80 f9 74             	cmp    $0x74,%cl
    303f:	8a 44 24 41          	mov    0x41(%rsp),%al
    3043:	74 59                	je     309e <cbvprintf+0x266>
    3045:	80 f9 7a             	cmp    $0x7a,%cl
    3048:	75 5c                	jne    30a6 <cbvprintf+0x26e>
		conv->length_mod = LENGTH_Z;
    304a:	83 e0 87             	and    $0xffffff87,%eax
    304d:	83 c8 30             	or     $0x30,%eax
    3050:	eb 3a                	jmp    308c <cbvprintf+0x254>
		if (*++sp == 'h') {
    3052:	80 7d 01 68          	cmpb   $0x68,0x1(%rbp)
    3056:	8a 44 24 41          	mov    0x41(%rsp),%al
    305a:	75 08                	jne    3064 <cbvprintf+0x22c>
			conv->length_mod = LENGTH_HH;
    305c:	83 e0 87             	and    $0xffffff87,%eax
    305f:	83 c8 08             	or     $0x8,%eax
    3062:	eb 18                	jmp    307c <cbvprintf+0x244>
			conv->length_mod = LENGTH_H;
    3064:	83 e0 87             	and    $0xffffff87,%eax
    3067:	83 c8 10             	or     $0x10,%eax
    306a:	eb 20                	jmp    308c <cbvprintf+0x254>
		if (*++sp == 'l') {
    306c:	80 7d 01 6c          	cmpb   $0x6c,0x1(%rbp)
    3070:	8a 44 24 41          	mov    0x41(%rsp),%al
    3074:	75 10                	jne    3086 <cbvprintf+0x24e>
			conv->length_mod = LENGTH_LL;
    3076:	83 e0 87             	and    $0xffffff87,%eax
    3079:	83 c8 20             	or     $0x20,%eax
    307c:	88 44 24 41          	mov    %al,0x41(%rsp)
			++sp;
    3080:	48 8d 55 02          	lea    0x2(%rbp),%rdx
    3084:	eb 28                	jmp    30ae <cbvprintf+0x276>
			conv->length_mod = LENGTH_L;
    3086:	83 e0 87             	and    $0xffffff87,%eax
    3089:	83 c8 18             	or     $0x18,%eax
    308c:	88 44 24 41          	mov    %al,0x41(%rsp)
    3090:	eb 1c                	jmp    30ae <cbvprintf+0x276>
		conv->length_mod = LENGTH_J;
    3092:	8a 44 24 41          	mov    0x41(%rsp),%al
    3096:	83 e0 87             	and    $0xffffff87,%eax
    3099:	83 c8 28             	or     $0x28,%eax
    309c:	eb ee                	jmp    308c <cbvprintf+0x254>
		conv->length_mod = LENGTH_T;
    309e:	83 e0 87             	and    $0xffffff87,%eax
    30a1:	83 c8 38             	or     $0x38,%eax
    30a4:	eb e6                	jmp    308c <cbvprintf+0x254>
		conv->length_mod = LENGTH_NONE;
    30a6:	80 64 24 41 87       	andb   $0x87,0x41(%rsp)
		break;
    30ab:	48 89 ea             	mov    %rbp,%rdx
	conv->specifier = *sp++;
    30ae:	8a 02                	mov    (%rdx),%al
    30b0:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
    30b4:	8a 54 24 41          	mov    0x41(%rsp),%dl
    30b8:	88 44 24 43          	mov    %al,0x43(%rsp)
	switch (conv->specifier) {
    30bc:	3c 78                	cmp    $0x78,%al
    30be:	0f 8f ab 00 00 00    	jg     316f <cbvprintf+0x337>
    30c4:	3c 57                	cmp    $0x57,%al
    30c6:	7f 11                	jg     30d9 <cbvprintf+0x2a1>
    30c8:	3c 41                	cmp    $0x41,%al
    30ca:	74 62                	je     312e <cbvprintf+0x2f6>
    30cc:	83 e8 45             	sub    $0x45,%eax
    30cf:	3c 02                	cmp    $0x2,%al
    30d1:	0f 87 98 00 00 00    	ja     316f <cbvprintf+0x337>
    30d7:	eb 55                	jmp    312e <cbvprintf+0x2f6>
    30d9:	8d 48 a8             	lea    -0x58(%rax),%ecx
    30dc:	80 f9 20             	cmp    $0x20,%cl
    30df:	0f 87 8a 00 00 00    	ja     316f <cbvprintf+0x337>
    30e5:	48 8d 3d 7c 4f 00 00 	lea    0x4f7c(%rip),%rdi        # 8068 <default_cmd+0x48>
    30ec:	0f b6 c9             	movzbl %cl,%ecx
    30ef:	48 63 0c 8f          	movslq (%rdi,%rcx,4),%rcx
    30f3:	48 01 f9             	add    %rdi,%rcx
    30f6:	3e ff e1             	notrack jmpq *%rcx
		conv->specifier_cat = SPECIFIER_SINT;
    30f9:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    30fd:	83 e1 f8             	and    $0xfffffff8,%ecx
    3100:	83 c9 01             	or     $0x1,%ecx
    3103:	eb 0a                	jmp    310f <cbvprintf+0x2d7>
		conv->specifier_cat = SPECIFIER_UINT;
    3105:	8a 4c 24 42          	mov    0x42(%rsp),%cl
    3109:	83 e1 f8             	and    $0xfffffff8,%ecx
    310c:	83 c9 02             	or     $0x2,%ecx
    310f:	f3 0f 1e fa          	endbr64 
		if (conv->length_mod == LENGTH_UPPER_L) {
    3113:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
    3116:	88 4c 24 42          	mov    %cl,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    311a:	80 fa 40             	cmp    $0x40,%dl
    311d:	75 05                	jne    3124 <cbvprintf+0x2ec>
			conv->invalid = true;
    311f:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    3124:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
    3126:	3c 63                	cmp    $0x63,%al
    3128:	75 4c                	jne    3176 <cbvprintf+0x33e>
			unsupported = (conv->length_mod != LENGTH_NONE);
    312a:	84 d2                	test   %dl,%dl
    312c:	eb 3c                	jmp    316a <cbvprintf+0x332>
		conv->specifier_cat = SPECIFIER_FP;
    312e:	8a 44 24 42          	mov    0x42(%rsp),%al
			unsupported = true;
    3132:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
    3134:	83 e0 f8             	and    $0xfffffff8,%eax
    3137:	83 c8 04             	or     $0x4,%eax
    313a:	88 44 24 42          	mov    %al,0x42(%rsp)
			break;
    313e:	eb 36                	jmp    3176 <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    3140:	8a 44 24 42          	mov    0x42(%rsp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
    3144:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
    3147:	83 e0 f8             	and    $0xfffffff8,%eax
    314a:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    314d:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    3150:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    3154:	0f 94 c1             	sete   %cl
    3157:	eb 1d                	jmp    3176 <cbvprintf+0x33e>
		conv->specifier_cat = SPECIFIER_PTR;
    3159:	8a 44 24 42          	mov    0x42(%rsp),%al
    315d:	83 e0 f8             	and    $0xfffffff8,%eax
    3160:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
    3163:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    3166:	88 44 24 42          	mov    %al,0x42(%rsp)
		if (conv->length_mod != LENGTH_NONE) {
    316a:	0f 95 c1             	setne  %cl
    316d:	eb 07                	jmp    3176 <cbvprintf+0x33e>
		conv->invalid = true;
    316f:	80 4c 24 40 01       	orb    $0x1,0x40(%rsp)
	bool unsupported = false;
    3174:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
    3176:	8a 54 24 40          	mov    0x40(%rsp),%dl
    317a:	89 d0                	mov    %edx,%eax
    317c:	83 e2 fd             	and    $0xfffffffd,%edx
    317f:	d0 e8                	shr    %al
    3181:	83 e0 01             	and    $0x1,%eax
    3184:	09 c8                	or     %ecx,%eax
    3186:	01 c0                	add    %eax,%eax
    3188:	09 d0                	or     %edx,%eax
    318a:	88 44 24 40          	mov    %al,0x40(%rsp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set with if present.
		 */
		if (conv->width_star) {
    318e:	8a 4c 24 41          	mov    0x41(%rsp),%cl
    3192:	f6 c1 01             	test   $0x1,%cl
    3195:	74 3c                	je     31d3 <cbvprintf+0x39b>
			width = va_arg(ap, int);
    3197:	41 8b 14 24          	mov    (%r12),%edx
    319b:	83 fa 2f             	cmp    $0x2f,%edx
    319e:	77 10                	ja     31b0 <cbvprintf+0x378>
    31a0:	89 d0                	mov    %edx,%eax
    31a2:	83 c2 08             	add    $0x8,%edx
    31a5:	49 03 44 24 10       	add    0x10(%r12),%rax
    31aa:	41 89 14 24          	mov    %edx,(%r12)
    31ae:	eb 0e                	jmp    31be <cbvprintf+0x386>
    31b0:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    31b5:	48 8d 50 08          	lea    0x8(%rax),%rdx
    31b9:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    31be:	8b 00                	mov    (%rax),%eax
    31c0:	89 44 24 08          	mov    %eax,0x8(%rsp)

			if (width < 0) {
    31c4:	85 c0                	test   %eax,%eax
    31c6:	79 22                	jns    31ea <cbvprintf+0x3b2>
				conv->flag_dash = true;
    31c8:	80 4c 24 40 04       	orb    $0x4,0x40(%rsp)
				width = -width;
    31cd:	f7 5c 24 08          	negl   0x8(%rsp)
    31d1:	eb 17                	jmp    31ea <cbvprintf+0x3b2>
			}
		} else if (conv->width_present) {
    31d3:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
		int width = -1;
    31d8:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%rsp)
    31df:	ff 
		} else if (conv->width_present) {
    31e0:	79 08                	jns    31ea <cbvprintf+0x3b2>
			width = conv->width_value;
    31e2:	8b 44 24 44          	mov    0x44(%rsp),%eax
    31e6:	89 44 24 08          	mov    %eax,0x8(%rsp)

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    31ea:	f6 c1 04             	test   $0x4,%cl
    31ed:	74 3a                	je     3229 <cbvprintf+0x3f1>
			int arg = va_arg(ap, int);
    31ef:	41 8b 14 24          	mov    (%r12),%edx
    31f3:	83 fa 2f             	cmp    $0x2f,%edx
    31f6:	77 10                	ja     3208 <cbvprintf+0x3d0>
    31f8:	89 d0                	mov    %edx,%eax
    31fa:	83 c2 08             	add    $0x8,%edx
    31fd:	49 03 44 24 10       	add    0x10(%r12),%rax
    3202:	41 89 14 24          	mov    %edx,(%r12)
    3206:	eb 0e                	jmp    3216 <cbvprintf+0x3de>
    3208:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    320d:	48 8d 50 08          	lea    0x8(%rax),%rdx
    3211:	49 89 54 24 08       	mov    %rdx,0x8(%r12)
    3216:	44 8b 10             	mov    (%rax),%r10d

			if (arg < 0) {
    3219:	45 85 d2             	test   %r10d,%r10d
    321c:	79 19                	jns    3237 <cbvprintf+0x3ff>
				conv->prec_present = false;
    321e:	80 64 24 41 fd       	andb   $0xfd,0x41(%rsp)
		int precision = -1;
    3223:	41 83 ca ff          	or     $0xffffffff,%r10d
    3227:	eb 0e                	jmp    3237 <cbvprintf+0x3ff>
    3229:	41 83 ca ff          	or     $0xffffffff,%r10d
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
    322d:	80 e1 02             	and    $0x2,%cl
    3230:	74 05                	je     3237 <cbvprintf+0x3ff>
			precision = conv->prec_value;
    3232:	44 8b 54 24 48       	mov    0x48(%rsp),%r10d
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    3237:	8a 54 24 41          	mov    0x41(%rsp),%dl
			= (enum specifier_cat_enum)conv->specifier_cat;
    323b:	8a 44 24 42          	mov    0x42(%rsp),%al
		conv->pad0_value = 0;
    323f:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
    3246:	00 00 
			= (enum length_mod_enum)conv->length_mod;
    3248:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
    324b:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
    324e:	83 e2 0f             	and    $0xf,%edx
		enum length_mod_enum length_mod
    3251:	0f b6 ca             	movzbl %dl,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    3254:	83 f8 01             	cmp    $0x1,%eax
    3257:	0f 85 d8 00 00 00    	jne    3335 <cbvprintf+0x4fd>
			switch (length_mod) {
    325d:	41 8b 04 24          	mov    (%r12),%eax
    3261:	80 fa 05             	cmp    $0x5,%dl
    3264:	0f 84 1e 01 00 00    	je     3388 <cbvprintf+0x550>
    326a:	77 10                	ja     327c <cbvprintf+0x444>
    326c:	80 fa 03             	cmp    $0x3,%dl
    326f:	74 3f                	je     32b0 <cbvprintf+0x478>
    3271:	80 fa 04             	cmp    $0x4,%dl
    3274:	0f 84 0e 01 00 00    	je     3388 <cbvprintf+0x550>
    327a:	eb 0c                	jmp    3288 <cbvprintf+0x450>
    327c:	8d 7a 0a             	lea    0xa(%rdx),%edi
    327f:	83 e7 0f             	and    $0xf,%edi
    3282:	40 80 ff 01          	cmp    $0x1,%dil
    3286:	76 5e                	jbe    32e6 <cbvprintf+0x4ae>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
    3288:	83 f8 2f             	cmp    $0x2f,%eax
    328b:	77 10                	ja     329d <cbvprintf+0x465>
    328d:	89 c7                	mov    %eax,%edi
    328f:	83 c0 08             	add    $0x8,%eax
    3292:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    3297:	41 89 04 24          	mov    %eax,(%r12)
    329b:	eb 0e                	jmp    32ab <cbvprintf+0x473>
    329d:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    32a2:	48 8d 47 08          	lea    0x8(%rdi),%rax
    32a6:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    32ab:	48 63 07             	movslq (%rdi),%rax
    32ae:	eb 5c                	jmp    330c <cbvprintf+0x4d4>
				break;
			case LENGTH_L:
				if (WCHAR_IS_SIGNED
    32b0:	80 7c 24 43 63       	cmpb   $0x63,0x43(%rsp)
    32b5:	0f 85 cd 00 00 00    	jne    3388 <cbvprintf+0x550>
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
    32bb:	83 f8 2f             	cmp    $0x2f,%eax
    32be:	77 10                	ja     32d0 <cbvprintf+0x498>
    32c0:	89 c1                	mov    %eax,%ecx
    32c2:	83 c0 08             	add    $0x8,%eax
    32c5:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    32ca:	41 89 04 24          	mov    %eax,(%r12)
    32ce:	eb 0e                	jmp    32de <cbvprintf+0x4a6>
    32d0:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    32d5:	48 8d 41 08          	lea    0x8(%rcx),%rax
    32d9:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    32de:	48 63 01             	movslq (%rcx),%rax
    32e1:	e9 b1 01 00 00       	jmpq   3497 <cbvprintf+0x65f>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    32e6:	83 f8 2f             	cmp    $0x2f,%eax
    32e9:	77 10                	ja     32fb <cbvprintf+0x4c3>
    32eb:	89 c7                	mov    %eax,%edi
    32ed:	83 c0 08             	add    $0x8,%eax
    32f0:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    32f5:	41 89 04 24          	mov    %eax,(%r12)
    32f9:	eb 0e                	jmp    3309 <cbvprintf+0x4d1>
    32fb:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    3300:	48 8d 47 08          	lea    0x8(%rdi),%rax
    3304:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3309:	48 8b 07             	mov    (%rdi),%rax
				value->sint =
    330c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    3311:	83 f9 01             	cmp    $0x1,%ecx
    3314:	75 0b                	jne    3321 <cbvprintf+0x4e9>
				value->sint = (char)value->sint;
    3316:	48 0f be 44 24 30    	movsbq 0x30(%rsp),%rax
    331c:	e9 76 01 00 00       	jmpq   3497 <cbvprintf+0x65f>
			} else if (length_mod == LENGTH_H) {
    3321:	83 f9 02             	cmp    $0x2,%ecx
    3324:	0f 85 72 01 00 00    	jne    349c <cbvprintf+0x664>
				value->sint = (short)value->sint;
    332a:	48 0f bf 44 24 30    	movswq 0x30(%rsp),%rax
    3330:	e9 62 01 00 00       	jmpq   3497 <cbvprintf+0x65f>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    3335:	83 f8 02             	cmp    $0x2,%eax
    3338:	0f 85 ca 00 00 00    	jne    3408 <cbvprintf+0x5d0>
			switch (length_mod) {
    333e:	41 8b 04 24          	mov    (%r12),%eax
    3342:	80 fa 05             	cmp    $0x5,%dl
    3345:	74 41                	je     3388 <cbvprintf+0x550>
    3347:	77 0c                	ja     3355 <cbvprintf+0x51d>
    3349:	80 fa 03             	cmp    $0x3,%dl
    334c:	74 3a                	je     3388 <cbvprintf+0x550>
    334e:	80 fa 04             	cmp    $0x4,%dl
    3351:	74 35                	je     3388 <cbvprintf+0x550>
    3353:	eb 0c                	jmp    3361 <cbvprintf+0x529>
    3355:	8d 7a 0a             	lea    0xa(%rdx),%edi
    3358:	83 e7 0f             	and    $0xf,%edi
    335b:	40 80 ff 01          	cmp    $0x1,%dil
    335f:	76 52                	jbe    33b3 <cbvprintf+0x57b>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->uint = va_arg(ap, unsigned int);
    3361:	83 f8 2f             	cmp    $0x2f,%eax
    3364:	77 10                	ja     3376 <cbvprintf+0x53e>
    3366:	89 c7                	mov    %eax,%edi
    3368:	83 c0 08             	add    $0x8,%eax
    336b:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    3370:	41 89 04 24          	mov    %eax,(%r12)
    3374:	eb 0e                	jmp    3384 <cbvprintf+0x54c>
    3376:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    337b:	48 8d 47 08          	lea    0x8(%rdi),%rax
    337f:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3384:	8b 07                	mov    (%rdi),%eax
    3386:	eb 51                	jmp    33d9 <cbvprintf+0x5a1>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
    3388:	83 f8 2f             	cmp    $0x2f,%eax
    338b:	77 10                	ja     339d <cbvprintf+0x565>
    338d:	89 c1                	mov    %eax,%ecx
    338f:	83 c0 08             	add    $0x8,%eax
    3392:	49 03 4c 24 10       	add    0x10(%r12),%rcx
    3397:	41 89 04 24          	mov    %eax,(%r12)
    339b:	eb 0e                	jmp    33ab <cbvprintf+0x573>
    339d:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    33a2:	48 8d 41 08          	lea    0x8(%rcx),%rax
    33a6:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    33ab:	48 8b 01             	mov    (%rcx),%rax
    33ae:	e9 e4 00 00 00       	jmpq   3497 <cbvprintf+0x65f>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    33b3:	83 f8 2f             	cmp    $0x2f,%eax
    33b6:	77 10                	ja     33c8 <cbvprintf+0x590>
    33b8:	89 c7                	mov    %eax,%edi
    33ba:	83 c0 08             	add    $0x8,%eax
    33bd:	49 03 7c 24 10       	add    0x10(%r12),%rdi
    33c2:	41 89 04 24          	mov    %eax,(%r12)
    33c6:	eb 0e                	jmp    33d6 <cbvprintf+0x59e>
    33c8:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    33cd:	48 8d 47 08          	lea    0x8(%rdi),%rax
    33d1:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    33d6:	48 8b 07             	mov    (%rdi),%rax
				value->uint =
    33d9:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    33de:	83 f9 01             	cmp    $0x1,%ecx
    33e1:	75 0e                	jne    33f1 <cbvprintf+0x5b9>
				value->uint = (unsigned char)value->uint;
    33e3:	48 81 64 24 30 ff 00 	andq   $0xff,0x30(%rsp)
    33ea:	00 00 
    33ec:	e9 ab 00 00 00       	jmpq   349c <cbvprintf+0x664>
			} else if (length_mod == LENGTH_H) {
    33f1:	83 f9 02             	cmp    $0x2,%ecx
    33f4:	0f 85 a2 00 00 00    	jne    349c <cbvprintf+0x664>
				value->uint = (unsigned short)value->uint;
    33fa:	48 81 64 24 30 ff ff 	andq   $0xffff,0x30(%rsp)
    3401:	00 00 
    3403:	e9 94 00 00 00       	jmpq   349c <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    3408:	83 f8 04             	cmp    $0x4,%eax
    340b:	75 5b                	jne    3468 <cbvprintf+0x630>
			if (length_mod == LENGTH_UPPER_L) {
    340d:	83 f9 08             	cmp    $0x8,%ecx
    3410:	75 1e                	jne    3430 <cbvprintf+0x5f8>
				value->ldbl = va_arg(ap, long double);
    3412:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3417:	48 83 c0 0f          	add    $0xf,%rax
    341b:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    341f:	48 8d 48 10          	lea    0x10(%rax),%rcx
    3423:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    3428:	db 28                	fldt   (%rax)
    342a:	db 7c 24 30          	fstpt  0x30(%rsp)
    342e:	eb 6c                	jmp    349c <cbvprintf+0x664>
			} else {
				value->dbl = va_arg(ap, double);
    3430:	41 8b 4c 24 04       	mov    0x4(%r12),%ecx
    3435:	81 f9 af 00 00 00    	cmp    $0xaf,%ecx
    343b:	77 11                	ja     344e <cbvprintf+0x616>
    343d:	89 c8                	mov    %ecx,%eax
    343f:	83 c1 10             	add    $0x10,%ecx
    3442:	49 03 44 24 10       	add    0x10(%r12),%rax
    3447:	41 89 4c 24 04       	mov    %ecx,0x4(%r12)
    344c:	eb 0e                	jmp    345c <cbvprintf+0x624>
    344e:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3453:	48 8d 48 08          	lea    0x8(%rax),%rcx
    3457:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    345c:	f2 0f 10 00          	movsd  (%rax),%xmm0
    3460:	f2 0f 11 44 24 30    	movsd  %xmm0,0x30(%rsp)
    3466:	eb 34                	jmp    349c <cbvprintf+0x664>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    3468:	83 f8 03             	cmp    $0x3,%eax
    346b:	75 2f                	jne    349c <cbvprintf+0x664>
			value->ptr = va_arg(ap, void *);
    346d:	41 8b 0c 24          	mov    (%r12),%ecx
    3471:	83 f9 2f             	cmp    $0x2f,%ecx
    3474:	77 10                	ja     3486 <cbvprintf+0x64e>
    3476:	89 c8                	mov    %ecx,%eax
    3478:	83 c1 08             	add    $0x8,%ecx
    347b:	49 03 44 24 10       	add    0x10(%r12),%rax
    3480:	41 89 0c 24          	mov    %ecx,(%r12)
    3484:	eb 0e                	jmp    3494 <cbvprintf+0x65c>
    3486:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    348b:	48 8d 48 08          	lea    0x8(%rax),%rcx
    348f:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    3494:	48 8b 00             	mov    (%rax),%rax
    3497:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    349c:	8a 4c 24 40          	mov    0x40(%rsp),%cl
    34a0:	f6 c1 03             	test   $0x3,%cl
    34a3:	74 23                	je     34c8 <cbvprintf+0x690>
			OUTS(sp, fp);
    34a5:	48 89 e9             	mov    %rbp,%rcx
    34a8:	4c 89 ea             	mov    %r13,%rdx
    34ab:	4c 89 fe             	mov    %r15,%rsi
    34ae:	4c 89 f7             	mov    %r14,%rdi
    34b1:	e8 4d f8 ff ff       	callq  2d03 <outs>
    34b6:	85 c0                	test   %eax,%eax
    34b8:	0f 88 8c 03 00 00    	js     384a <cbvprintf+0xa12>
    34be:	48 98                	cltq   
    34c0:	48 01 c3             	add    %rax,%rbx
			continue;
    34c3:	e9 78 03 00 00       	jmpq   3840 <cbvprintf+0xa08>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    34c8:	8a 44 24 43          	mov    0x43(%rsp),%al
    34cc:	3c 78                	cmp    $0x78,%al
    34ce:	0f 87 6c 03 00 00    	ja     3840 <cbvprintf+0xa08>
    34d4:	3c 62                	cmp    $0x62,%al
    34d6:	77 11                	ja     34e9 <cbvprintf+0x6b1>
    34d8:	3c 25                	cmp    $0x25,%al
    34da:	74 2c                	je     3508 <cbvprintf+0x6d0>
    34dc:	3c 58                	cmp    $0x58,%al
    34de:	0f 84 c6 00 00 00    	je     35aa <cbvprintf+0x772>
    34e4:	e9 57 03 00 00       	jmpq   3840 <cbvprintf+0xa08>
    34e9:	83 e8 63             	sub    $0x63,%eax
    34ec:	3c 15                	cmp    $0x15,%al
    34ee:	0f 87 4c 03 00 00    	ja     3840 <cbvprintf+0xa08>
    34f4:	48 8d 3d f1 4b 00 00 	lea    0x4bf1(%rip),%rdi        # 80ec <default_cmd+0xcc>
    34fb:	0f b6 c0             	movzbl %al,%eax
    34fe:	48 63 04 87          	movslq (%rdi,%rax,4),%rax
    3502:	48 01 f8             	add    %rdi,%rax
    3505:	3e ff e0             	notrack jmpq *%rax
		case '%':
			OUTC('%');
    3508:	4c 89 fe             	mov    %r15,%rsi
    350b:	bf 25 00 00 00       	mov    $0x25,%edi
    3510:	31 c0                	xor    %eax,%eax
    3512:	41 ff d6             	callq  *%r14
    3515:	85 c0                	test   %eax,%eax
    3517:	0f 88 2d 03 00 00    	js     384a <cbvprintf+0xa12>
    351d:	48 ff c3             	inc    %rbx
			break;
    3520:	e9 1b 03 00 00       	jmpq   3840 <cbvprintf+0xa08>
		case 's': {
			bps = (const char *)value->ptr;
    3525:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13

			size_t len;

			if (precision >= 0) {
    352a:	45 85 d2             	test   %r10d,%r10d
    352d:	78 0d                	js     353c <cbvprintf+0x704>
				len = strnlen(bps, precision);
    352f:	49 63 f2             	movslq %r10d,%rsi
    3532:	4c 89 ef             	mov    %r13,%rdi
    3535:	e8 a6 ef ff ff       	callq  24e0 <strnlen@plt>
    353a:	eb 14                	jmp    3550 <cbvprintf+0x718>
			} else {
				len = strlen(bps);
    353c:	31 c0                	xor    %eax,%eax
    353e:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3542:	4c 89 ef             	mov    %r13,%rdi
    3545:	f2 ae                	repnz scas %es:(%rdi),%al
    3547:	48 89 c8             	mov    %rcx,%rax
    354a:	48 f7 d0             	not    %rax
    354d:	48 ff c8             	dec    %rax
			}

			bpe = bps + len;
    3550:	4c 01 e8             	add    %r13,%rax
		char sign = 0;
    3553:	45 31 c9             	xor    %r9d,%r9d
			bpe = bps + len;
    3556:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			precision = -1;

			break;
    355b:	e9 55 01 00 00       	jmpq   36b5 <cbvprintf+0x87d>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    3560:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			bpe = buf + 1;
			break;
    3565:	45 31 c9             	xor    %r9d,%r9d
			bps = buf;
    3568:	4c 8d 6c 24 52       	lea    0x52(%rsp),%r13
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    356d:	88 44 24 52          	mov    %al,0x52(%rsp)
			bpe = buf + 1;
    3571:	48 8d 44 24 53       	lea    0x53(%rsp),%rax
    3576:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			break;
    357b:	e9 3e 01 00 00       	jmpq   36be <cbvprintf+0x886>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
    3580:	41 b1 2b             	mov    $0x2b,%r9b
			if (conv->flag_plus) {
    3583:	f6 c1 08             	test   $0x8,%cl
    3586:	75 0b                	jne    3593 <cbvprintf+0x75b>
			} else if (conv->flag_space) {
				sign = ' ';
    3588:	80 e1 10             	and    $0x10,%cl
    358b:	41 0f 95 c1          	setne  %r9b
    358f:	41 c1 e1 05          	shl    $0x5,%r9d

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    3593:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
			if (sint < 0) {
    3598:	48 85 c0             	test   %rax,%rax
    359b:	79 10                	jns    35ad <cbvprintf+0x775>
				sign = '-';
				value->uint = (uint_value_type)-sint;
    359d:	48 f7 d8             	neg    %rax
				sign = '-';
    35a0:	41 b1 2d             	mov    $0x2d,%r9b
				value->uint = (uint_value_type)-sint;
    35a3:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    35a8:	eb 03                	jmp    35ad <cbvprintf+0x775>
		switch (conv->specifier) {
    35aa:	45 31 c9             	xor    %r9d,%r9d
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    35ad:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    35b2:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    35b7:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    35bc:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    35c1:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    35c6:	e8 c0 f7 ff ff       	callq  2d8b <encode_uint>
    35cb:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
    35d0:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    35d5:	49 89 c5             	mov    %rax,%r13
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    35d8:	45 85 d2             	test   %r10d,%r10d
    35db:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
    35e0:	0f 88 ca 00 00 00    	js     36b0 <cbvprintf+0x878>
				size_t len = bpe - bps;
    35e6:	48 89 c1             	mov    %rax,%rcx
				 * conversions with precision.
				 */
				conv->flag_zero = false;

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    35e9:	49 63 d2             	movslq %r10d,%rdx
				conv->flag_zero = false;
    35ec:	80 64 24 40 bf       	andb   $0xbf,0x40(%rsp)
				size_t len = bpe - bps;
    35f1:	4c 29 e9             	sub    %r13,%rcx
		const char *bpe = buf + sizeof(buf);
    35f4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
				if (len < (size_t)precision) {
    35f9:	48 39 ca             	cmp    %rcx,%rdx
    35fc:	0f 86 b3 00 00 00    	jbe    36b5 <cbvprintf+0x87d>
					conv->pad0_value = precision - (int)len;
    3602:	41 29 ca             	sub    %ecx,%r10d
    3605:	44 89 54 24 44       	mov    %r10d,0x44(%rsp)
    360a:	e9 a6 00 00 00       	jmpq   36b5 <cbvprintf+0x87d>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    360f:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    3614:	48 8d 05 c2 4c 00 00 	lea    0x4cc2(%rip),%rax        # 82dd <default_cmd+0x2bd>
    361b:	45 31 c9             	xor    %r9d,%r9d
    361e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			bps = "(nil)";
    3623:	4c 8d 68 fb          	lea    -0x5(%rax),%r13
			if (value->ptr != NULL) {
    3627:	48 85 ff             	test   %rdi,%rdi
    362a:	0f 84 8e 00 00 00    	je     36be <cbvprintf+0x886>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    3630:	48 8d 54 24 52       	lea    0x52(%rsp),%rdx
    3635:	48 8d 4c 24 68       	lea    0x68(%rsp),%rcx
    363a:	44 88 4c 24 18       	mov    %r9b,0x18(%rsp)
    363f:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    3644:	e8 42 f7 ff ff       	callq  2d8b <encode_uint>
				goto prec_int_pad0;
    3649:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    364e:	44 8a 4c 24 18       	mov    0x18(%rsp),%r9b
				bps = encode_uint((uintptr_t)value->ptr, conv,
    3653:	49 89 c5             	mov    %rax,%r13
				conv->altform_0c = true;
    3656:	66 8b 44 24 42       	mov    0x42(%rsp),%ax
    365b:	66 25 ef 00          	and    $0xef,%ax
    365f:	66 0d 10 78          	or     $0x7810,%ax
    3663:	66 89 44 24 42       	mov    %ax,0x42(%rsp)
				goto prec_int_pad0;
    3668:	e9 6b ff ff ff       	jmpq   35d8 <cbvprintf+0x7a0>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    366d:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    3672:	48 63 c3             	movslq %ebx,%rax
    3675:	80 fa 07             	cmp    $0x7,%dl
    3678:	0f 87 c2 01 00 00    	ja     3840 <cbvprintf+0xa08>
    367e:	48 8d 35 bf 4a 00 00 	lea    0x4abf(%rip),%rsi        # 8144 <default_cmd+0x124>
    3685:	0f b6 d2             	movzbl %dl,%edx
    3688:	48 63 14 96          	movslq (%rsi,%rdx,4),%rdx
    368c:	48 01 f2             	add    %rsi,%rdx
    368f:	3e ff e2             	notrack jmpq *%rdx
		*(int *)dp = count;
    3692:	89 01                	mov    %eax,(%rcx)
		break;
    3694:	e9 a7 01 00 00       	jmpq   3840 <cbvprintf+0xa08>
		*(signed char *)dp = (signed char)count;
    3699:	88 19                	mov    %bl,(%rcx)
		break;
    369b:	e9 a0 01 00 00       	jmpq   3840 <cbvprintf+0xa08>
		*(short *)dp = (short)count;
    36a0:	66 89 19             	mov    %bx,(%rcx)
		break;
    36a3:	e9 98 01 00 00       	jmpq   3840 <cbvprintf+0xa08>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    36a8:	48 89 01             	mov    %rax,(%rcx)
		break;
    36ab:	e9 90 01 00 00       	jmpq   3840 <cbvprintf+0xa08>
		const char *bpe = buf + sizeof(buf);
    36b0:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    36b5:	4d 85 ed             	test   %r13,%r13
    36b8:	0f 84 82 01 00 00    	je     3840 <cbvprintf+0xa08>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    36be:	48 8b 44 24 10       	mov    0x10(%rsp),%rax

		if (sign != 0) {
			nj_len += 1U;
		}

		if (conv->altform_0c) {
    36c3:	8a 4c 24 42          	mov    0x42(%rsp),%cl
		size_t nj_len = (bpe - bps);
    36c7:	4c 29 e8             	sub    %r13,%rax
			nj_len += 1U;
    36ca:	41 80 f9 01          	cmp    $0x1,%r9b
    36ce:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		if (conv->altform_0c) {
    36d2:	f6 c1 10             	test   $0x10,%cl
    36d5:	74 06                	je     36dd <cbvprintf+0x8a5>
			nj_len += 2U;
    36d7:	48 83 c0 02          	add    $0x2,%rax
    36db:	eb 0c                	jmp    36e9 <cbvprintf+0x8b1>
		} else if (conv->altform_0) {
    36dd:	89 ca                	mov    %ecx,%edx
    36df:	83 e2 08             	and    $0x8,%edx
			nj_len += 1U;
    36e2:	80 fa 01             	cmp    $0x1,%dl
    36e5:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		}

		nj_len += conv->pad0_value;
    36e9:	48 63 54 24 44       	movslq 0x44(%rsp),%rdx
    36ee:	48 01 d0             	add    %rdx,%rax
		if (conv->pad_fp) {
    36f1:	80 e1 40             	and    $0x40,%cl
    36f4:	74 08                	je     36fe <cbvprintf+0x8c6>
			nj_len += conv->pad0_pre_exp;
    36f6:	48 63 54 24 48       	movslq 0x48(%rsp),%rdx
    36fb:	48 01 d0             	add    %rdx,%rax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    36fe:	83 7c 24 08 00       	cmpl   $0x0,0x8(%rsp)
    3703:	7e 73                	jle    3778 <cbvprintf+0x940>
			width -= (int)nj_len;
    3705:	29 44 24 08          	sub    %eax,0x8(%rsp)

			if (!conv->flag_dash) {
    3709:	8a 44 24 40          	mov    0x40(%rsp),%al
    370d:	a8 04                	test   $0x4,%al
    370f:	75 67                	jne    3778 <cbvprintf+0x940>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    3711:	a8 40                	test   $0x40,%al
    3713:	74 21                	je     3736 <cbvprintf+0x8fe>
					if (sign != 0) {
    3715:	45 84 c9             	test   %r9b,%r9b
    3718:	74 20                	je     373a <cbvprintf+0x902>
						OUTC(sign);
    371a:	31 c0                	xor    %eax,%eax
    371c:	41 0f be f9          	movsbl %r9b,%edi
    3720:	4c 89 fe             	mov    %r15,%rsi
    3723:	41 ff d6             	callq  *%r14
    3726:	85 c0                	test   %eax,%eax
    3728:	0f 88 1c 01 00 00    	js     384a <cbvprintf+0xa12>
    372e:	48 ff c3             	inc    %rbx
						sign = 0;
    3731:	45 31 c9             	xor    %r9d,%r9d
    3734:	eb 04                	jmp    373a <cbvprintf+0x902>
				char pad = ' ';
    3736:	b0 20                	mov    $0x20,%al
    3738:	eb 02                	jmp    373c <cbvprintf+0x904>
					}
					pad = '0';
    373a:	b0 30                	mov    $0x30,%al
    373c:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
				}

				while (width-- > 0) {
					OUTC(pad);
    3740:	0f be d0             	movsbl %al,%edx
				while (width-- > 0) {
    3743:	ff 4c 24 08          	decl   0x8(%rsp)
    3747:	85 c9                	test   %ecx,%ecx
    3749:	7e 2d                	jle    3778 <cbvprintf+0x940>
					OUTC(pad);
    374b:	31 c0                	xor    %eax,%eax
    374d:	44 88 4c 24 1f       	mov    %r9b,0x1f(%rsp)
    3752:	4c 89 fe             	mov    %r15,%rsi
    3755:	89 d7                	mov    %edx,%edi
    3757:	89 54 24 18          	mov    %edx,0x18(%rsp)
    375b:	41 ff d6             	callq  *%r14
    375e:	85 c0                	test   %eax,%eax
    3760:	0f 88 e4 00 00 00    	js     384a <cbvprintf+0xa12>
				while (width-- > 0) {
    3766:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
    376a:	8b 54 24 18          	mov    0x18(%rsp),%edx
					OUTC(pad);
    376e:	48 ff c3             	inc    %rbx
    3771:	44 8a 4c 24 1f       	mov    0x1f(%rsp),%r9b
    3776:	eb cb                	jmp    3743 <cbvprintf+0x90b>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    3778:	45 84 c9             	test   %r9b,%r9b
    377b:	74 17                	je     3794 <cbvprintf+0x95c>
			OUTC(sign);
    377d:	31 c0                	xor    %eax,%eax
    377f:	41 0f be f9          	movsbl %r9b,%edi
    3783:	4c 89 fe             	mov    %r15,%rsi
    3786:	41 ff d6             	callq  *%r14
    3789:	85 c0                	test   %eax,%eax
    378b:	0f 88 b9 00 00 00    	js     384a <cbvprintf+0xa12>
    3791:	48 ff c3             	inc    %rbx
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    3794:	8a 44 24 42          	mov    0x42(%rsp),%al
    3798:	a8 10                	test   $0x10,%al
    379a:	75 04                	jne    37a0 <cbvprintf+0x968>
    379c:	a8 08                	test   $0x8,%al
    379e:	74 18                	je     37b8 <cbvprintf+0x980>
				OUTC('0');
    37a0:	31 c0                	xor    %eax,%eax
    37a2:	4c 89 fe             	mov    %r15,%rsi
    37a5:	bf 30 00 00 00       	mov    $0x30,%edi
    37aa:	41 ff d6             	callq  *%r14
    37ad:	85 c0                	test   %eax,%eax
    37af:	0f 88 95 00 00 00    	js     384a <cbvprintf+0xa12>
    37b5:	48 ff c3             	inc    %rbx
			}

			if (conv->altform_0c) {
    37b8:	f6 44 24 42 10       	testb  $0x10,0x42(%rsp)
    37bd:	74 14                	je     37d3 <cbvprintf+0x99b>
				OUTC(conv->specifier);
    37bf:	31 c0                	xor    %eax,%eax
    37c1:	0f b6 7c 24 43       	movzbl 0x43(%rsp),%edi
    37c6:	4c 89 fe             	mov    %r15,%rsi
    37c9:	41 ff d6             	callq  *%r14
    37cc:	85 c0                	test   %eax,%eax
    37ce:	78 7a                	js     384a <cbvprintf+0xa12>
    37d0:	48 ff c3             	inc    %rbx
			}

			pad_len = conv->pad0_value;
			while (pad_len-- > 0) {
    37d3:	8b 44 24 44          	mov    0x44(%rsp),%eax
    37d7:	01 d8                	add    %ebx,%eax
    37d9:	89 44 24 18          	mov    %eax,0x18(%rsp)
    37dd:	8b 44 24 18          	mov    0x18(%rsp),%eax
    37e1:	29 d8                	sub    %ebx,%eax
    37e3:	85 c0                	test   %eax,%eax
    37e5:	7e 16                	jle    37fd <cbvprintf+0x9c5>
				OUTC('0');
    37e7:	31 c0                	xor    %eax,%eax
    37e9:	4c 89 fe             	mov    %r15,%rsi
    37ec:	bf 30 00 00 00       	mov    $0x30,%edi
    37f1:	41 ff d6             	callq  *%r14
    37f4:	85 c0                	test   %eax,%eax
    37f6:	78 52                	js     384a <cbvprintf+0xa12>
    37f8:	48 ff c3             	inc    %rbx
    37fb:	eb e0                	jmp    37dd <cbvprintf+0x9a5>
			}

			OUTS(bps, bpe);
    37fd:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    3802:	4c 89 ea             	mov    %r13,%rdx
    3805:	4c 89 fe             	mov    %r15,%rsi
    3808:	4c 89 f7             	mov    %r14,%rdi
    380b:	e8 f3 f4 ff ff       	callq  2d03 <outs>
    3810:	85 c0                	test   %eax,%eax
    3812:	78 36                	js     384a <cbvprintf+0xa12>
    3814:	44 8b 6c 24 08       	mov    0x8(%rsp),%r13d
    3819:	48 98                	cltq   
    381b:	48 01 c3             	add    %rax,%rbx
    381e:	41 01 dd             	add    %ebx,%r13d
		}

		/* Finish left justification */
		while (width > 0) {
    3821:	44 89 e8             	mov    %r13d,%eax
    3824:	29 d8                	sub    %ebx,%eax
    3826:	85 c0                	test   %eax,%eax
    3828:	7e 16                	jle    3840 <cbvprintf+0xa08>
			OUTC(' ');
    382a:	31 c0                	xor    %eax,%eax
    382c:	4c 89 fe             	mov    %r15,%rsi
    382f:	bf 20 00 00 00       	mov    $0x20,%edi
    3834:	41 ff d6             	callq  *%r14
    3837:	85 c0                	test   %eax,%eax
    3839:	78 0f                	js     384a <cbvprintf+0xa12>
    383b:	48 ff c3             	inc    %rbx
			--width;
    383e:	eb e1                	jmp    3821 <cbvprintf+0x9e9>
			OUTS(bps, bpe);
    3840:	49 89 ed             	mov    %rbp,%r13
    3843:	e9 20 f6 ff ff       	jmpq   2e68 <cbvprintf+0x30>
		}
	}

	return count;
    3848:	89 d8                	mov    %ebx,%eax
#undef OUTS
#undef OUTC
}
    384a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
    384f:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    3856:	00 00 
    3858:	74 05                	je     385f <cbvprintf+0xa27>
    385a:	e8 41 ec ff ff       	callq  24a0 <__stack_chk_fail@plt>
    385f:	48 83 c4 78          	add    $0x78,%rsp
    3863:	5b                   	pop    %rbx
    3864:	5d                   	pop    %rbp
    3865:	41 5c                	pop    %r12
    3867:	41 5d                	pop    %r13
    3869:	41 5e                	pop    %r14
    386b:	41 5f                	pop    %r15
    386d:	c3                   	retq   

000000000000386e <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
    386e:	f3 0f 1e fa          	endbr64 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    3872:	c3                   	retq   

0000000000003873 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    3873:	f3 0f 1e fa          	endbr64 
    3877:	50                   	push   %rax
    3878:	48 8d 3d 75 49 00 00 	lea    0x4975(%rip),%rdi        # 81f4 <default_cmd+0x1d4>
    387f:	e8 93 25 00 00       	callq  5e17 <z_impl_device_get_binding>
	__printk_hook_install(console_out);
    3884:	48 8d 3d 10 00 00 00 	lea    0x10(%rip),%rdi        # 389b <console_out>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    388b:	48 89 05 ae a2 00 00 	mov    %rax,0xa2ae(%rip)        # db40 <uart_console_dev>
	__printk_hook_install(console_out);
    3892:	e8 d7 f1 ff ff       	callq  2a6e <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
    3897:	31 c0                	xor    %eax,%eax
    3899:	5a                   	pop    %rdx
    389a:	c3                   	retq   

000000000000389b <console_out>:
{
    389b:	f3 0f 1e fa          	endbr64 
    389f:	41 54                	push   %r12
    38a1:	41 89 fc             	mov    %edi,%r12d
	if ('\n' == c) {
    38a4:	83 ff 0a             	cmp    $0xa,%edi
    38a7:	75 13                	jne    38bc <console_out+0x21>
    38a9:	48 8b 3d 90 a2 00 00 	mov    0xa290(%rip),%rdi        # db40 <uart_console_dev>
	api->poll_out(dev, out_char);
    38b0:	48 8b 47 10          	mov    0x10(%rdi),%rax
    38b4:	be 0d 00 00 00       	mov    $0xd,%esi
    38b9:	ff 50 08             	callq  *0x8(%rax)
	uart_poll_out(uart_console_dev, c);
    38bc:	48 8b 3d 7d a2 00 00 	mov    0xa27d(%rip),%rdi        # db40 <uart_console_dev>
    38c3:	48 8b 47 10          	mov    0x10(%rdi),%rax
    38c7:	41 0f b6 f4          	movzbl %r12b,%esi
    38cb:	ff 50 08             	callq  *0x8(%rax)
}
    38ce:	44 89 e0             	mov    %r12d,%eax
    38d1:	41 5c                	pop    %r12
    38d3:	c3                   	retq   

00000000000038d4 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
    38d4:	f3 0f 1e fa          	endbr64 
    38d8:	50                   	push   %rax
	setvbuf(stdout, NULL, _IOLBF, 512);
    38d9:	48 8b 05 c0 76 00 00 	mov    0x76c0(%rip),%rax        # afa0 <stdout@GLIBC_2.2.5>
    38e0:	b9 00 02 00 00       	mov    $0x200,%ecx
    38e5:	31 f6                	xor    %esi,%esi
    38e7:	ba 01 00 00 00       	mov    $0x1,%edx
    38ec:	48 8b 38             	mov    (%rax),%rdi
    38ef:	e8 cc ec ff ff       	callq  25c0 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
    38f4:	48 8b 05 ed 76 00 00 	mov    0x76ed(%rip),%rax        # afe8 <stderr@GLIBC_2.2.5>
    38fb:	ba 01 00 00 00       	mov    $0x1,%edx
    3900:	31 f6                	xor    %esi,%esi
    3902:	b9 00 02 00 00       	mov    $0x200,%ecx
    3907:	48 8b 38             	mov    (%rax),%rdi
    390a:	e8 b1 ec ff ff       	callq  25c0 <setvbuf@plt>
	__printk_hook_install(putchar);
    390f:	48 8b 3d 7a 76 00 00 	mov    0x767a(%rip),%rdi        # af90 <putchar@GLIBC_2.2.5>
    3916:	e8 53 f1 ff ff       	callq  2a6e <__printk_hook_install>
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    391b:	31 c0                	xor    %eax,%eax
    391d:	5a                   	pop    %rdx
    391e:	c3                   	retq   

000000000000391f <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
    391f:	f3 0f 1e fa          	endbr64 
    3923:	50                   	push   %rax
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
    3924:	e8 cc 0a 00 00       	callq  43f5 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    3929:	48 8b 35 18 a2 00 00 	mov    0xa218(%rip),%rsi        # db48 <last_tick_time>
    3930:	48 8b 0d 19 a2 00 00 	mov    0xa219(%rip),%rcx        # db50 <tick_period>
    3937:	31 d2                	xor    %edx,%edx
    3939:	48 29 f0             	sub    %rsi,%rax
    393c:	48 f7 f1             	div    %rcx

	last_tick_time += elapsed_ticks*tick_period;
    393f:	48 63 d0             	movslq %eax,%rdx
	sys_clock_announce(elapsed_ticks);
    3942:	89 c7                	mov    %eax,%edi
	last_tick_time += elapsed_ticks*tick_period;
    3944:	48 0f af d1          	imul   %rcx,%rdx
    3948:	48 01 f2             	add    %rsi,%rdx
    394b:	48 89 15 f6 a1 00 00 	mov    %rdx,0xa1f6(%rip)        # db48 <last_tick_time>
}
    3952:	5a                   	pop    %rdx
	sys_clock_announce(elapsed_ticks);
    3953:	e9 65 35 00 00       	jmpq   6ebd <sys_clock_announce>

0000000000003958 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int sys_clock_driver_init(const struct device *dev)
{
    3958:	f3 0f 1e fa          	endbr64 
    395c:	50                   	push   %rax
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    395d:	48 c7 05 e8 a1 00 00 	movq   $0x2710,0xa1e8(%rip)        # db50 <tick_period>
    3964:	10 27 00 00 

	last_tick_time = hwm_get_time();
    3968:	e8 88 0a 00 00       	callq  43f5 <hwm_get_time>
	hwtimer_enable(tick_period);
    396d:	48 8b 3d dc a1 00 00 	mov    0xa1dc(%rip),%rdi        # db50 <tick_period>
	last_tick_time = hwm_get_time();
    3974:	48 89 05 cd a1 00 00 	mov    %rax,0xa1cd(%rip)        # db48 <last_tick_time>
	hwtimer_enable(tick_period);
    397b:	e8 16 0d 00 00       	callq  4696 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    3980:	31 c9                	xor    %ecx,%ecx
    3982:	48 8d 15 96 ff ff ff 	lea    -0x6a(%rip),%rdx        # 391f <np_timer_isr>
    3989:	31 f6                	xor    %esi,%esi
    398b:	31 ff                	xor    %edi,%edi
    398d:	e8 ee 10 00 00       	callq  4a80 <posix_isr_declare>
    3992:	31 d2                	xor    %edx,%edx
    3994:	be 01 00 00 00       	mov    $0x1,%esi
    3999:	31 ff                	xor    %edi,%edi
    399b:	e8 05 11 00 00       	callq  4aa5 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    39a0:	31 ff                	xor    %edi,%edi
    39a2:	e8 57 00 00 00       	callq  39fe <arch_irq_enable>

	return 0;
}
    39a7:	31 c0                	xor    %eax,%eax
    39a9:	5a                   	pop    %rdx
    39aa:	c3                   	retq   

00000000000039ab <sys_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    39ab:	f3 0f 1e fa          	endbr64 

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with sys_clock_announce() is INT_MAX
	 */
	if (ticks == K_TICKS_FOREVER) {
		silent_ticks = INT64_MAX;
    39af:	49 b8 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%r8
    39b6:	ff ff 7f 
	if (ticks == K_TICKS_FOREVER) {
    39b9:	83 ff ff             	cmp    $0xffffffff,%edi
    39bc:	74 0c                	je     39ca <sys_clock_set_timeout+0x1f>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    39be:	45 31 c0             	xor    %r8d,%r8d
	} else if (ticks > 0) {
    39c1:	85 ff                	test   %edi,%edi
    39c3:	7e 05                	jle    39ca <sys_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
    39c5:	ff cf                	dec    %edi
    39c7:	4c 63 c7             	movslq %edi,%r8
	}
	hwtimer_set_silent_ticks(silent_ticks);
    39ca:	4c 89 c7             	mov    %r8,%rdi
    39cd:	e9 76 0e 00 00       	jmpq   4848 <hwtimer_set_silent_ticks>

00000000000039d2 <sys_clock_elapsed>:
 * last call to sys_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
uint32_t sys_clock_elapsed(void)
{
    39d2:	f3 0f 1e fa          	endbr64 
    39d6:	50                   	push   %rax
	return (hwm_get_time() - last_tick_time)/tick_period;
    39d7:	e8 19 0a 00 00       	callq  43f5 <hwm_get_time>
    39dc:	31 d2                	xor    %edx,%edx
    39de:	48 2b 05 63 a1 00 00 	sub    0xa163(%rip),%rax        # db48 <last_tick_time>
    39e5:	48 f7 35 64 a1 00 00 	divq   0xa164(%rip)        # db50 <tick_period>
}
    39ec:	5a                   	pop    %rdx
    39ed:	c3                   	retq   

00000000000039ee <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
    39ee:	f3 0f 1e fa          	endbr64 
    39f2:	50                   	push   %rax
	sys_trace_idle();
	posix_irq_full_unlock();
    39f3:	e8 74 10 00 00       	callq  4a6c <posix_irq_full_unlock>
	posix_halt_cpu();
}
    39f8:	5a                   	pop    %rdx
	posix_halt_cpu();
    39f9:	e9 42 06 00 00       	jmpq   4040 <posix_halt_cpu>

00000000000039fe <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
    39fe:	f3 0f 1e fa          	endbr64 
	posix_irq_enable(irq);
    3a02:	e9 70 10 00 00       	jmpq   4a77 <posix_irq_enable>

0000000000003a07 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    3a07:	85 ff                	test   %edi,%edi
    3a09:	74 0e                	je     3a19 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    3a0b:	48 8d 3d d6 48 00 00 	lea    0x48d6(%rip),%rdi        # 82e8 <default_cmd+0x2c8>
    3a12:	31 c0                	xor    %eax,%eax
    3a14:	e9 d3 13 00 00       	jmpq   4dec <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    3a19:	c3                   	retq   

0000000000003a1a <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
    3a1a:	50                   	push   %rax
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    3a1b:	48 8d 3d 3e 9b 00 00 	lea    0x9b3e(%rip),%rdi        # d560 <mtx_threads>
    3a22:	e8 59 eb ff ff       	callq  2580 <pthread_mutex_unlock@plt>
    3a27:	48 8d 35 d4 48 00 00 	lea    0x48d4(%rip),%rsi        # 8302 <default_cmd+0x2e2>
    3a2e:	89 c7                	mov    %eax,%edi
    3a30:	e8 d2 ff ff ff       	callq  3a07 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    3a35:	e8 96 eb ff ff       	callq  25d0 <pthread_self@plt>
}
    3a3a:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    3a3b:	48 89 c7             	mov    %rax,%rdi
    3a3e:	e9 8d e9 ff ff       	jmpq   23d0 <pthread_detach@plt>

0000000000003a43 <abort_tail>:
{
    3a43:	50                   	push   %rax
    3a44:	58                   	pop    %rax
	threads_table[this_th_nbr].running = false;
    3a45:	48 63 ff             	movslq %edi,%rdi
{
    3a48:	50                   	push   %rax
	threads_table[this_th_nbr].running = false;
    3a49:	48 c1 e7 05          	shl    $0x5,%rdi
    3a4d:	48 03 3d 04 a1 00 00 	add    0xa104(%rip),%rdi        # db58 <threads_table>
    3a54:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
	threads_table[this_th_nbr].state = ABORTED;
    3a58:	c7 07 03 00 00 00    	movl   $0x3,(%rdi)
	posix_preexit_cleanup();
    3a5e:	e8 b7 ff ff ff       	callq  3a1a <posix_preexit_cleanup>
	pthread_exit(NULL);
    3a63:	31 ff                	xor    %edi,%edi
    3a65:	e8 26 eb ff ff       	callq  2590 <pthread_exit@plt>

0000000000003a6a <posix_wait_until_allowed>:
{
    3a6a:	41 54                	push   %r12
	threads_table[this_th_nbr].running = false;
    3a6c:	48 8b 05 e5 a0 00 00 	mov    0xa0e5(%rip),%rax        # db58 <threads_table>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    3a73:	4c 8d 25 e6 9a 00 00 	lea    0x9ae6(%rip),%r12        # d560 <mtx_threads>
{
    3a7a:	55                   	push   %rbp
    3a7b:	53                   	push   %rbx
    3a7c:	48 63 df             	movslq %edi,%rbx
    3a7f:	48 89 dd             	mov    %rbx,%rbp
	threads_table[this_th_nbr].running = false;
    3a82:	48 c1 e3 05          	shl    $0x5,%rbx
    3a86:	c6 44 18 04 00       	movb   $0x0,0x4(%rax,%rbx,1)
	while (this_th_nbr != currently_allowed_thread) {
    3a8b:	39 2d 8f a1 00 00    	cmp    %ebp,0xa18f(%rip)        # dc20 <currently_allowed_thread>
    3a91:	74 28                	je     3abb <posix_wait_until_allowed+0x51>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    3a93:	4c 89 e6             	mov    %r12,%rsi
    3a96:	48 8d 3d 03 9b 00 00 	lea    0x9b03(%rip),%rdi        # d5a0 <cond_threads>
    3a9d:	e8 ee e9 ff ff       	callq  2490 <pthread_cond_wait@plt>
		if (threads_table &&
    3aa2:	48 8b 05 af a0 00 00 	mov    0xa0af(%rip),%rax        # db58 <threads_table>
    3aa9:	48 85 c0             	test   %rax,%rax
    3aac:	74 dd                	je     3a8b <posix_wait_until_allowed+0x21>
    3aae:	83 3c 18 02          	cmpl   $0x2,(%rax,%rbx,1)
    3ab2:	75 d7                	jne    3a8b <posix_wait_until_allowed+0x21>
			abort_tail(this_th_nbr);
    3ab4:	89 ef                	mov    %ebp,%edi
    3ab6:	e8 88 ff ff ff       	callq  3a43 <abort_tail>
	threads_table[this_th_nbr].running = true;
    3abb:	48 8b 05 96 a0 00 00 	mov    0xa096(%rip),%rax        # db58 <threads_table>
    3ac2:	c6 44 18 04 01       	movb   $0x1,0x4(%rax,%rbx,1)
}
    3ac7:	5b                   	pop    %rbx
    3ac8:	5d                   	pop    %rbp
    3ac9:	41 5c                	pop    %r12
    3acb:	c3                   	retq   

0000000000003acc <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
    3acc:	f3 0f 1e fa          	endbr64 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    3ad0:	80 3d 82 a1 00 00 00 	cmpb   $0x0,0xa182(%rip)        # dc59 <terminate>
    3ad7:	74 29                	je     3b02 <posix_cleanup_handler+0x36>
{
    3ad9:	50                   	push   %rax
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    3ada:	48 8d 3d 7f 9a 00 00 	lea    0x9a7f(%rip),%rdi        # d560 <mtx_threads>
    3ae1:	e8 9a ea ff ff       	callq  2580 <pthread_mutex_unlock@plt>
    3ae6:	48 8d 35 15 48 00 00 	lea    0x4815(%rip),%rsi        # 8302 <default_cmd+0x2e2>
    3aed:	89 c7                	mov    %eax,%edi
    3aef:	e8 13 ff ff ff       	callq  3a07 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    3af4:	e8 d7 ea ff ff       	callq  25d0 <pthread_self@plt>
}
    3af9:	5a                   	pop    %rdx
	pthread_detach(pthread_self());
    3afa:	48 89 c7             	mov    %rax,%rdi
    3afd:	e9 ce e8 ff ff       	jmpq   23d0 <pthread_detach@plt>
    3b02:	c3                   	retq   

0000000000003b03 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    3b03:	f3 0f 1e fa          	endbr64 
    3b07:	50                   	push   %rax
    3b08:	58                   	pop    %rax
    3b09:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    3b10:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    3b15:	48 8d 3d 44 9a 00 00 	lea    0x9a44(%rip),%rdi        # d560 <mtx_threads>
{
    3b1c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3b23:	00 00 
    3b25:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    3b2a:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    3b2c:	e8 5f eb ff ff       	callq  2690 <pthread_mutex_lock@plt>
    3b31:	48 8d 35 ed 47 00 00 	lea    0x47ed(%rip),%rsi        # 8325 <default_cmd+0x305>
    3b38:	89 c7                	mov    %eax,%edi
    3b3a:	e8 c8 fe ff ff       	callq  3a07 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    3b3f:	48 83 3d 11 a0 00 00 	cmpq   $0x0,0xa011(%rip)        # db58 <threads_table>
    3b46:	00 
    3b47:	75 11                	jne    3b5a <posix_thread_starter+0x57>
		posix_cleanup_handler(arg);
    3b49:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    3b4e:	e8 79 ff ff ff       	callq  3acc <posix_cleanup_handler>
		pthread_exit(NULL);
    3b53:	31 ff                	xor    %edi,%edi
    3b55:	e8 36 ea ff ff       	callq  2590 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    3b5a:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    3b5f:	31 f6                	xor    %esi,%esi
    3b61:	e8 fa ea ff ff       	callq  2660 <__sigsetjmp@plt>
    3b66:	f3 0f 1e fa          	endbr64 
    3b6a:	85 c0                	test   %eax,%eax
    3b6c:	74 14                	je     3b82 <posix_thread_starter+0x7f>
    3b6e:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    3b73:	e8 54 ff ff ff       	callq  3acc <posix_cleanup_handler>
    3b78:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    3b7d:	e8 ae ea ff ff       	callq  2630 <__pthread_unwind_next@plt>
    3b82:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    3b87:	e8 b4 e8 ff ff       	callq  2440 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    3b8c:	8b 7c 24 08          	mov    0x8(%rsp),%edi
    3b90:	e8 d5 fe ff ff       	callq  3a6a <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    3b95:	e8 92 03 00 00       	callq  3f2c <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    3b9a:	48 63 44 24 08       	movslq 0x8(%rsp),%rax
    3b9f:	48 c1 e0 05          	shl    $0x5,%rax
    3ba3:	48 03 05 ae 9f 00 00 	add    0x9fae(%rip),%rax        # db58 <threads_table>
    3baa:	48 8b 40 18          	mov    0x18(%rax),%rax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    3bae:	48 8b 48 18          	mov    0x18(%rax),%rcx
    3bb2:	48 8b 50 10          	mov    0x10(%rax),%rdx
    3bb6:	48 8b 70 08          	mov    0x8(%rax),%rsi
    3bba:	48 8b 38             	mov    (%rax),%rdi
    3bbd:	e8 c6 ef ff ff       	callq  2b88 <z_thread_entry>

0000000000003bc2 <posix_swap>:
{
    3bc2:	f3 0f 1e fa          	endbr64 
    3bc6:	55                   	push   %rbp
    3bc7:	89 f5                	mov    %esi,%ebp
	currently_allowed_thread = next_allowed_th;
    3bc9:	89 3d 51 a0 00 00    	mov    %edi,0xa051(%rip)        # dc20 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    3bcf:	48 8d 3d ca 99 00 00 	lea    0x99ca(%rip),%rdi        # d5a0 <cond_threads>
    3bd6:	e8 25 e8 ff ff       	callq  2400 <pthread_cond_broadcast@plt>
    3bdb:	48 8d 35 64 47 00 00 	lea    0x4764(%rip),%rsi        # 8346 <default_cmd+0x326>
    3be2:	89 c7                	mov    %eax,%edi
    3be4:	e8 1e fe ff ff       	callq  3a07 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    3be9:	48 63 c5             	movslq %ebp,%rax
		abort_tail(this_th_nbr);
    3bec:	89 ef                	mov    %ebp,%edi
	if (threads_table[this_th_nbr].state == ABORTING) {
    3bee:	48 c1 e0 05          	shl    $0x5,%rax
    3bf2:	48 03 05 5f 9f 00 00 	add    0x9f5f(%rip),%rax        # db58 <threads_table>
    3bf9:	83 38 02             	cmpl   $0x2,(%rax)
    3bfc:	75 05                	jne    3c03 <posix_swap+0x41>
		abort_tail(this_th_nbr);
    3bfe:	e8 40 fe ff ff       	callq  3a43 <abort_tail>
}
    3c03:	5d                   	pop    %rbp
		posix_wait_until_allowed(this_th_nbr);
    3c04:	e9 61 fe ff ff       	jmpq   3a6a <posix_wait_until_allowed>

0000000000003c09 <posix_main_thread_start>:
{
    3c09:	f3 0f 1e fa          	endbr64 
    3c0d:	50                   	push   %rax
	currently_allowed_thread = next_allowed_th;
    3c0e:	89 3d 0c a0 00 00    	mov    %edi,0xa00c(%rip)        # dc20 <currently_allowed_thread>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    3c14:	48 8d 3d 85 99 00 00 	lea    0x9985(%rip),%rdi        # d5a0 <cond_threads>
    3c1b:	e8 e0 e7 ff ff       	callq  2400 <pthread_cond_broadcast@plt>
    3c20:	48 8d 35 1f 47 00 00 	lea    0x471f(%rip),%rsi        # 8346 <default_cmd+0x326>
    3c27:	89 c7                	mov    %eax,%edi
    3c29:	e8 d9 fd ff ff       	callq  3a07 <pc_safe_call>
	posix_preexit_cleanup();
    3c2e:	e8 e7 fd ff ff       	callq  3a1a <posix_preexit_cleanup>
	pthread_exit(NULL);
    3c33:	31 ff                	xor    %edi,%edi
    3c35:	e8 56 e9 ff ff       	callq  2590 <pthread_exit@plt>

0000000000003c3a <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    3c3a:	f3 0f 1e fa          	endbr64 
    3c3e:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    3c3f:	8b 35 e3 9f 00 00    	mov    0x9fe3(%rip),%esi        # dc28 <threads_table_size>
{
    3c45:	48 89 fb             	mov    %rdi,%rbx
	for (int i = 0; i < threads_table_size; i++) {
    3c48:	31 c0                	xor    %eax,%eax
		if ((threads_table[i].state == NOTUSED)
    3c4a:	48 8b 3d 07 9f 00 00 	mov    0x9f07(%rip),%rdi        # db58 <threads_table>
    3c51:	41 89 c0             	mov    %eax,%r8d
	for (int i = 0; i < threads_table_size; i++) {
    3c54:	39 c6                	cmp    %eax,%esi
    3c56:	7e 13                	jle    3c6b <posix_new_thread+0x31>
		if ((threads_table[i].state == NOTUSED)
    3c58:	48 ff c0             	inc    %rax
    3c5b:	48 89 c2             	mov    %rax,%rdx
    3c5e:	48 c1 e2 05          	shl    $0x5,%rdx
    3c62:	83 7c 17 e0 00       	cmpl   $0x0,-0x20(%rdi,%rdx,1)
    3c67:	75 e8                	jne    3c51 <posix_new_thread+0x17>
    3c69:	eb 52                	jmp    3cbd <posix_new_thread+0x83>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
    3c6b:	83 c6 40             	add    $0x40,%esi
    3c6e:	48 63 f6             	movslq %esi,%rsi
	threads_table = realloc(threads_table,
    3c71:	48 c1 e6 05          	shl    $0x5,%rsi
    3c75:	e8 36 e9 ff ff       	callq  25b0 <realloc@plt>
    3c7a:	48 89 05 d7 9e 00 00 	mov    %rax,0x9ed7(%rip)        # db58 <threads_table>
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    3c81:	48 85 c0             	test   %rax,%rax
    3c84:	75 0c                	jne    3c92 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    3c86:	48 8d 3d df 46 00 00 	lea    0x46df(%rip),%rdi        # 836c <default_cmd+0x34c>
    3c8d:	e8 5a 11 00 00       	callq  4dec <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
    3c92:	48 63 15 8f 9f 00 00 	movslq 0x9f8f(%rip),%rdx        # dc28 <threads_table_size>
    3c99:	31 c0                	xor    %eax,%eax
    3c9b:	b9 00 02 00 00       	mov    $0x200,%ecx
    3ca0:	49 89 d0             	mov    %rdx,%r8
    3ca3:	48 c1 e2 05          	shl    $0x5,%rdx
    3ca7:	48 03 15 aa 9e 00 00 	add    0x9eaa(%rip),%rdx        # db58 <threads_table>
    3cae:	48 89 d7             	mov    %rdx,%rdi
    3cb1:	f3 ab                	rep stos %eax,%es:(%rdi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    3cb3:	41 8d 40 40          	lea    0x40(%r8),%eax
    3cb7:	89 05 6b 9f 00 00    	mov    %eax,0x9f6b(%rip)        # dc28 <threads_table_size>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
    3cbd:	49 63 c8             	movslq %r8d,%rcx
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3cc0:	8b 05 5e 9f 00 00    	mov    0x9f5e(%rip),%eax        # dc24 <thread_create_count>
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    3cc6:	31 f6                	xor    %esi,%esi
	threads_table[t_slot].state = USED;
    3cc8:	48 89 cf             	mov    %rcx,%rdi
    3ccb:	48 c1 e7 05          	shl    $0x5,%rdi
    3ccf:	48 03 3d 82 9e 00 00 	add    0x9e82(%rip),%rdi        # db58 <threads_table>
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3cd6:	8d 50 01             	lea    0x1(%rax),%edx
	threads_table[t_slot].t_status = ptr;
    3cd9:	48 89 5f 18          	mov    %rbx,0x18(%rdi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    3cdd:	48 83 c7 08          	add    $0x8,%rdi
	threads_table[t_slot].state = USED;
    3ce1:	c7 47 f8 01 00 00 00 	movl   $0x1,-0x8(%rdi)
	threads_table[t_slot].running = false;
    3ce8:	c6 47 fc 00          	movb   $0x0,-0x4(%rdi)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3cec:	89 47 08             	mov    %eax,0x8(%rdi)
	ptr->thread_idx = t_slot;
    3cef:	44 89 43 20          	mov    %r8d,0x20(%rbx)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    3cf3:	89 15 2b 9f 00 00    	mov    %edx,0x9f2b(%rip)        # dc24 <thread_create_count>
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    3cf9:	48 8d 15 03 fe ff ff 	lea    -0x1fd(%rip),%rdx        # 3b03 <posix_thread_starter>
    3d00:	e8 ab e6 ff ff       	callq  23b0 <pthread_create@plt>
    3d05:	48 8d 35 88 46 00 00 	lea    0x4688(%rip),%rsi        # 8394 <default_cmd+0x374>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    3d0c:	5b                   	pop    %rbx
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    3d0d:	89 c7                	mov    %eax,%edi
    3d0f:	e9 f3 fc ff ff       	jmpq   3a07 <pc_safe_call>

0000000000003d14 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    3d14:	f3 0f 1e fa          	endbr64 
    3d18:	52                   	push   %rdx
	thread_create_count = 0;

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    3d19:	be 20 00 00 00       	mov    $0x20,%esi
    3d1e:	bf 40 00 00 00       	mov    $0x40,%edi
	thread_create_count = 0;
    3d23:	c7 05 f7 9e 00 00 00 	movl   $0x0,0x9ef7(%rip)        # dc24 <thread_create_count>
    3d2a:	00 00 00 
	currently_allowed_thread = -1;
    3d2d:	c7 05 e9 9e 00 00 ff 	movl   $0xffffffff,0x9ee9(%rip)        # dc20 <currently_allowed_thread>
    3d34:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    3d37:	e8 e4 e7 ff ff       	callq  2520 <calloc@plt>
    3d3c:	48 89 05 15 9e 00 00 	mov    %rax,0x9e15(%rip)        # db58 <threads_table>
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    3d43:	48 85 c0             	test   %rax,%rax
    3d46:	75 0c                	jne    3d54 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    3d48:	48 8d 3d 1d 46 00 00 	lea    0x461d(%rip),%rdi        # 836c <default_cmd+0x34c>
    3d4f:	e8 98 10 00 00       	callq  4dec <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    3d54:	48 8d 3d 05 98 00 00 	lea    0x9805(%rip),%rdi        # d560 <mtx_threads>
	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    3d5b:	c7 05 c3 9e 00 00 40 	movl   $0x40,0x9ec3(%rip)        # dc28 <threads_table_size>
    3d62:	00 00 00 
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    3d65:	e8 26 e9 ff ff       	callq  2690 <pthread_mutex_lock@plt>
    3d6a:	48 8d 35 b4 45 00 00 	lea    0x45b4(%rip),%rsi        # 8325 <default_cmd+0x305>
    3d71:	89 c7                	mov    %eax,%edi
}
    3d73:	58                   	pop    %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    3d74:	e9 8e fc ff ff       	jmpq   3a07 <pc_safe_call>

0000000000003d79 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
    3d79:	f3 0f 1e fa          	endbr64 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    3d7d:	48 83 3d d3 9d 00 00 	cmpq   $0x0,0x9dd3(%rip)        # db58 <threads_table>
    3d84:	00 
    3d85:	74 62                	je     3de9 <posix_core_clean_up+0x70>
{
    3d87:	55                   	push   %rbp
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
    3d88:	48 8d 2d 69 46 00 00 	lea    0x4669(%rip),%rbp        # 83f8 <default_cmd+0x3d8>
{
    3d8f:	53                   	push   %rbx
	for (int i = 0; i < threads_table_size; i++) {
    3d90:	31 db                	xor    %ebx,%ebx
{
    3d92:	52                   	push   %rdx
	terminate = true;
    3d93:	c6 05 bf 9e 00 00 01 	movb   $0x1,0x9ebf(%rip)        # dc59 <terminate>
	for (int i = 0; i < threads_table_size; i++) {
    3d9a:	39 1d 88 9e 00 00    	cmp    %ebx,0x9e88(%rip)        # dc28 <threads_table_size>
    3da0:	48 8b 3d b1 9d 00 00 	mov    0x9db1(%rip),%rdi        # db58 <threads_table>
    3da7:	7e 2c                	jle    3dd5 <posix_core_clean_up+0x5c>
		if (threads_table[i].state != USED) {
    3da9:	48 63 c3             	movslq %ebx,%rax
    3dac:	48 c1 e0 05          	shl    $0x5,%rax
    3db0:	48 01 c7             	add    %rax,%rdi
    3db3:	83 3f 01             	cmpl   $0x1,(%rdi)
    3db6:	75 19                	jne    3dd1 <posix_core_clean_up+0x58>
		if (pthread_cancel(threads_table[i].thread)) {
    3db8:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
    3dbc:	e8 4f e6 ff ff       	callq  2410 <pthread_cancel@plt>
    3dc1:	85 c0                	test   %eax,%eax
    3dc3:	74 0c                	je     3dd1 <posix_core_clean_up+0x58>
			posix_print_warning(
    3dc5:	89 de                	mov    %ebx,%esi
    3dc7:	48 89 ef             	mov    %rbp,%rdi
    3dca:	31 c0                	xor    %eax,%eax
    3dcc:	e8 f4 10 00 00       	callq  4ec5 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
    3dd1:	ff c3                	inc    %ebx
    3dd3:	eb c5                	jmp    3d9a <posix_core_clean_up+0x21>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    3dd5:	e8 c6 e5 ff ff       	callq  23a0 <free@plt>
	threads_table = NULL;
    3dda:	48 c7 05 73 9d 00 00 	movq   $0x0,0x9d73(%rip)        # db58 <threads_table>
    3de1:	00 00 00 00 
}
    3de5:	58                   	pop    %rax
    3de6:	5b                   	pop    %rbx
    3de7:	5d                   	pop    %rbp
    3de8:	c3                   	retq   
    3de9:	c3                   	retq   

0000000000003dea <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
    3dea:	f3 0f 1e fa          	endbr64 
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    3dee:	48 63 ff             	movslq %edi,%rdi
    3df1:	48 c1 e7 05          	shl    $0x5,%rdi
    3df5:	48 03 3d 5c 9d 00 00 	add    0x9d5c(%rip),%rdi        # db58 <threads_table>
    3dfc:	83 3f 01             	cmpl   $0x1,(%rdi)
    3dff:	75 06                	jne    3e07 <posix_abort_thread+0x1d>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    3e01:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    3e07:	c3                   	retq   

0000000000003e08 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
    3e08:	f3 0f 1e fa          	endbr64 
    3e0c:	41 55                	push   %r13
    3e0e:	41 54                	push   %r12
    3e10:	55                   	push   %rbp
    3e11:	48 89 fd             	mov    %rdi,%rbp
    3e14:	53                   	push   %rbx
    3e15:	52                   	push   %rdx
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    3e16:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    3e1a:	44 8b 6b 20          	mov    0x20(%rbx),%r13d
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    3e1e:	e8 32 0c 00 00       	callq  4a55 <posix_irq_lock>
    3e23:	41 89 c4             	mov    %eax,%r12d

	key = irq_lock();

	if (_current == thread) {
    3e26:	48 8d 05 b3 9c 00 00 	lea    0x9cb3(%rip),%rax        # dae0 <_kernel>
    3e2d:	48 39 68 10          	cmp    %rbp,0x10(%rax)
    3e31:	75 34                	jne    3e67 <z_impl_k_thread_abort+0x5f>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    3e33:	83 7b 24 00          	cmpl   $0x0,0x24(%rbx)
    3e37:	75 09                	jne    3e42 <z_impl_k_thread_abort+0x3a>
			tstatus->aborted = 1;
    3e39:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
    3e40:	eb 11                	jmp    3e53 <z_impl_k_thread_abort+0x4b>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    3e42:	44 89 ee             	mov    %r13d,%esi
    3e45:	48 8d 3d e0 45 00 00 	lea    0x45e0(%rip),%rdi        # 842c <default_cmd+0x40c>
    3e4c:	31 c0                	xor    %eax,%eax
    3e4e:	e8 72 10 00 00       	callq  4ec5 <posix_print_warning>
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    3e53:	49 63 c5             	movslq %r13d,%rax
    3e56:	48 c1 e0 05          	shl    $0x5,%rax
    3e5a:	48 03 05 f7 9c 00 00 	add    0x9cf7(%rip),%rax        # db58 <threads_table>
    3e61:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
    3e67:	48 89 ef             	mov    %rbp,%rdi
    3e6a:	e8 91 2b 00 00       	callq  6a00 <z_thread_abort>

	if (tstatus->aborted == 0) {
    3e6f:	83 7b 24 00          	cmpl   $0x0,0x24(%rbx)
    3e73:	75 0f                	jne    3e84 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
    3e75:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%rbx)
		posix_abort_thread(thread_idx);
    3e7c:	44 89 ef             	mov    %r13d,%edi
    3e7f:	e8 66 ff ff ff       	callq  3dea <posix_abort_thread>
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
}
    3e84:	58                   	pop    %rax
	z_reschedule_irqlock(key);
    3e85:	44 89 e7             	mov    %r12d,%edi
}
    3e88:	5b                   	pop    %rbx
    3e89:	5d                   	pop    %rbp
    3e8a:	41 5c                	pop    %r12
    3e8c:	41 5d                	pop    %r13
	z_reschedule_irqlock(key);
    3e8e:	e9 60 24 00 00       	jmpq   62f3 <z_reschedule_irqlock>

0000000000003e93 <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <power/power.h>

int arch_swap(unsigned int key)
{
    3e93:	f3 0f 1e fa          	endbr64 
    3e97:	53                   	push   %rbx
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
    3e98:	48 8d 1d 41 9c 00 00 	lea    0x9c41(%rip),%rbx        # dae0 <_kernel>
    3e9f:	48 8b 43 10          	mov    0x10(%rbx),%rax
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    3ea3:	48 8b 53 38          	mov    0x38(%rbx),%rdx
	_current->callee_saved.key = key;
    3ea7:	89 78 48             	mov    %edi,0x48(%rax)
	posix_thread_status_t *ready_thread_ptr =
    3eaa:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
	_current->callee_saved.retval = -EAGAIN;
    3eae:	c7 40 4c f5 ff ff ff 	movl   $0xfffffff5,0x4c(%rax)

	posix_thread_status_t *this_thread_ptr  =
    3eb5:	48 8b 40 50          	mov    0x50(%rax),%rax
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
    3eb9:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    3ebd:	8b 79 20             	mov    0x20(%rcx),%edi
    3ec0:	8b 70 20             	mov    0x20(%rax),%esi
    3ec3:	e8 fa fc ff ff       	callq  3bc2 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
    3ec8:	48 8b 43 10          	mov    0x10(%rbx),%rax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    3ecc:	8b 78 48             	mov    0x48(%rax),%edi
    3ecf:	e8 8f 0b 00 00       	callq  4a63 <posix_irq_unlock>

	return _current->callee_saved.retval;
    3ed4:	48 8b 43 10          	mov    0x10(%rbx),%rax
}
    3ed8:	5b                   	pop    %rbx
	return _current->callee_saved.retval;
    3ed9:	8b 40 4c             	mov    0x4c(%rax),%eax
}
    3edc:	c3                   	retq   

0000000000003edd <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    3edd:	f3 0f 1e fa          	endbr64 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    3ee1:	48 8d 05 f8 9b 00 00 	lea    0x9bf8(%rip),%rax        # dae0 <_kernel>
    3ee8:	48 8b 50 38          	mov    0x38(%rax),%rdx
	posix_thread_status_t *ready_thread_ptr =
    3eec:	48 8b 4a 50          	mov    0x50(%rdx),%rcx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
    3ef0:	48 89 50 10          	mov    %rdx,0x10(%rax)

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    3ef4:	8b 79 20             	mov    0x20(%rcx),%edi
    3ef7:	e9 0d fd ff ff       	jmpq   3c09 <posix_main_thread_start>

0000000000003efc <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    3efc:	f3 0f 1e fa          	endbr64 

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
    3f00:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
{
    3f05:	49 89 fa             	mov    %rdi,%r10
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
    3f08:	48 8d 7a d8          	lea    -0x28(%rdx),%rdi
	thread_status->entry_point = entry;
    3f0c:	48 89 4a d8          	mov    %rcx,-0x28(%rdx)
	thread_status->arg1 = p1;
    3f10:	4c 89 42 e0          	mov    %r8,-0x20(%rdx)
	thread_status->arg2 = p2;
    3f14:	4c 89 4a e8          	mov    %r9,-0x18(%rdx)
	thread_status->arg3 = p3;
    3f18:	48 89 42 f0          	mov    %rax,-0x10(%rdx)
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
    3f1c:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%rdx)
#endif

	thread->callee_saved.thread_status = thread_status;
    3f23:	49 89 7a 50          	mov    %rdi,0x50(%r10)

	posix_new_thread(thread_status);
    3f27:	e9 0e fd ff ff       	jmpq   3c3a <posix_new_thread>

0000000000003f2c <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
    3f2c:	f3 0f 1e fa          	endbr64 
	posix_irq_full_unlock();
    3f30:	e9 37 0b 00 00       	jmpq   4a6c <posix_irq_full_unlock>

0000000000003f35 <pc_safe_call>:
	if (unlikely(test)) {
    3f35:	85 ff                	test   %edi,%edi
    3f37:	74 0e                	je     3f47 <pc_safe_call+0x12>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    3f39:	48 8d 3d a8 43 00 00 	lea    0x43a8(%rip),%rdi        # 82e8 <default_cmd+0x2c8>
    3f40:	31 c0                	xor    %eax,%eax
    3f42:	e9 a5 0e 00 00       	jmpq   4dec <posix_print_error_and_exit>
}
    3f47:	c3                   	retq   

0000000000003f48 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
    3f48:	f3 0f 1e fa          	endbr64 
    3f4c:	50                   	push   %rax
    3f4d:	58                   	pop    %rax
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3f4e:	48 8d 3d 8b 96 00 00 	lea    0x968b(%rip),%rdi        # d5e0 <mtx_cpu>
{
    3f55:	50                   	push   %rax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3f56:	e8 35 e7 ff ff       	callq  2690 <pthread_mutex_lock@plt>
    3f5b:	48 8d 35 46 45 00 00 	lea    0x4546(%rip),%rsi        # 84a8 <default_cmd+0x488>
    3f62:	89 c7                	mov    %eax,%edi
    3f64:	e8 cc ff ff ff       	callq  3f35 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    3f69:	48 8d 3d 70 96 00 00 	lea    0x9670(%rip),%rdi        # d5e0 <mtx_cpu>
    3f70:	e8 0b e6 ff ff       	callq  2580 <pthread_mutex_unlock@plt>
    3f75:	48 8d 35 49 45 00 00 	lea    0x4549(%rip),%rsi        # 84c5 <default_cmd+0x4a5>
    3f7c:	89 c7                	mov    %eax,%edi
    3f7e:	e8 b2 ff ff ff       	callq  3f35 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    3f83:	e8 8c fd ff ff       	callq  3d14 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    3f88:	e8 44 1f 00 00       	callq  5ed1 <z_cstart>

0000000000003f8d <posix_is_cpu_running>:
{
    3f8d:	f3 0f 1e fa          	endbr64 
	return !cpu_halted;
    3f91:	8a 05 c5 74 00 00    	mov    0x74c5(%rip),%al        # b45c <cpu_halted>
    3f97:	83 f0 01             	xor    $0x1,%eax
    3f9a:	0f b6 c0             	movzbl %al,%eax
}
    3f9d:	c3                   	retq   

0000000000003f9e <posix_change_cpu_state_and_wait>:
{
    3f9e:	f3 0f 1e fa          	endbr64 
    3fa2:	55                   	push   %rbp
    3fa3:	89 fd                	mov    %edi,%ebp
    3fa5:	53                   	push   %rbx
    3fa6:	89 fb                	mov    %edi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3fa8:	48 8d 3d 31 96 00 00 	lea    0x9631(%rip),%rdi        # d5e0 <mtx_cpu>
{
    3faf:	52                   	push   %rdx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    3fb0:	e8 db e6 ff ff       	callq  2690 <pthread_mutex_lock@plt>
    3fb5:	48 8d 35 ec 44 00 00 	lea    0x44ec(%rip),%rsi        # 84a8 <default_cmd+0x488>
    3fbc:	89 c7                	mov    %eax,%edi
    3fbe:	e8 72 ff ff ff       	callq  3f35 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    3fc3:	48 8d 3d 56 96 00 00 	lea    0x9656(%rip),%rdi        # d620 <cond_cpu>
	cpu_halted = halted;
    3fca:	88 1d 8c 74 00 00    	mov    %bl,0x748c(%rip)        # b45c <cpu_halted>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    3fd0:	48 8d 1d 09 96 00 00 	lea    0x9609(%rip),%rbx        # d5e0 <mtx_cpu>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    3fd7:	e8 24 e4 ff ff       	callq  2400 <pthread_cond_broadcast@plt>
    3fdc:	48 8d 35 01 45 00 00 	lea    0x4501(%rip),%rsi        # 84e4 <default_cmd+0x4c4>
    3fe3:	89 c7                	mov    %eax,%edi
    3fe5:	e8 4b ff ff ff       	callq  3f35 <pc_safe_call>
	while (cpu_halted == halted) {
    3fea:	40 38 2d 6b 74 00 00 	cmp    %bpl,0x746b(%rip)        # b45c <cpu_halted>
    3ff1:	75 11                	jne    4004 <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    3ff3:	48 89 de             	mov    %rbx,%rsi
    3ff6:	48 8d 3d 23 96 00 00 	lea    0x9623(%rip),%rdi        # d620 <cond_cpu>
    3ffd:	e8 8e e4 ff ff       	callq  2490 <pthread_cond_wait@plt>
    4002:	eb e6                	jmp    3fea <posix_change_cpu_state_and_wait+0x4c>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    4004:	48 8d 3d d5 95 00 00 	lea    0x95d5(%rip),%rdi        # d5e0 <mtx_cpu>
    400b:	e8 70 e5 ff ff       	callq  2580 <pthread_mutex_unlock@plt>
    4010:	48 8d 35 ae 44 00 00 	lea    0x44ae(%rip),%rsi        # 84c5 <default_cmd+0x4a5>
    4017:	89 c7                	mov    %eax,%edi
}
    4019:	58                   	pop    %rax
    401a:	5b                   	pop    %rbx
    401b:	5d                   	pop    %rbp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    401c:	e9 14 ff ff ff       	jmpq   3f35 <pc_safe_call>

0000000000004021 <posix_interrupt_raised>:
{
    4021:	f3 0f 1e fa          	endbr64 
    4025:	51                   	push   %rcx
	posix_change_cpu_state_and_wait(false);
    4026:	31 ff                	xor    %edi,%edi
    4028:	e8 71 ff ff ff       	callq  3f9e <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
    402d:	80 3d 26 9c 00 00 00 	cmpb   $0x0,0x9c26(%rip)        # dc5a <soc_terminate>
    4034:	74 08                	je     403e <posix_interrupt_raised+0x1d>
		posix_exit(0);
    4036:	31 ff                	xor    %edi,%edi
}
    4038:	5a                   	pop    %rdx
		posix_exit(0);
    4039:	e9 b2 0c 00 00       	jmpq   4cf0 <posix_exit>
}
    403e:	58                   	pop    %rax
    403f:	c3                   	retq   

0000000000004040 <posix_halt_cpu>:
{
    4040:	f3 0f 1e fa          	endbr64 
    4044:	50                   	push   %rax
	posix_change_cpu_state_and_wait(true);
    4045:	bf 01 00 00 00       	mov    $0x1,%edi
    404a:	e8 4f ff ff ff       	callq  3f9e <posix_change_cpu_state_and_wait>
}
    404f:	5a                   	pop    %rdx
	posix_irq_handler();
    4050:	e9 c6 08 00 00       	jmpq   491b <posix_irq_handler>

0000000000004055 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    4055:	f3 0f 1e fa          	endbr64 
    4059:	53                   	push   %rbx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    405a:	48 8d 3d 7f 95 00 00 	lea    0x957f(%rip),%rdi        # d5e0 <mtx_cpu>
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    4061:	48 8d 1d 78 95 00 00 	lea    0x9578(%rip),%rbx        # d5e0 <mtx_cpu>
{
    4068:	48 83 ec 10          	sub    $0x10,%rsp
    406c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4073:	00 00 
    4075:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    407a:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    407c:	e8 0f e6 ff ff       	callq  2690 <pthread_mutex_lock@plt>
    4081:	48 8d 35 20 44 00 00 	lea    0x4420(%rip),%rsi        # 84a8 <default_cmd+0x488>
    4088:	89 c7                	mov    %eax,%edi
    408a:	e8 a6 fe ff ff       	callq  3f35 <pc_safe_call>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    408f:	48 89 e7             	mov    %rsp,%rdi
    4092:	31 c9                	xor    %ecx,%ecx
    4094:	31 f6                	xor    %esi,%esi
    4096:	48 8d 15 ab fe ff ff 	lea    -0x155(%rip),%rdx        # 3f48 <zephyr_wrapper>
	cpu_halted = false;
    409d:	c6 05 b8 73 00 00 00 	movb   $0x0,0x73b8(%rip)        # b45c <cpu_halted>
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    40a4:	e8 07 e3 ff ff       	callq  23b0 <pthread_create@plt>
    40a9:	48 8d 35 56 44 00 00 	lea    0x4456(%rip),%rsi        # 8506 <default_cmd+0x4e6>
    40b0:	89 c7                	mov    %eax,%edi
    40b2:	e8 7e fe ff ff       	callq  3f35 <pc_safe_call>
	while (cpu_halted == false) {
    40b7:	80 3d 9e 73 00 00 00 	cmpb   $0x0,0x739e(%rip)        # b45c <cpu_halted>
    40be:	75 11                	jne    40d1 <posix_boot_cpu+0x7c>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    40c0:	48 89 de             	mov    %rbx,%rsi
    40c3:	48 8d 3d 56 95 00 00 	lea    0x9556(%rip),%rdi        # d620 <cond_cpu>
    40ca:	e8 c1 e3 ff ff       	callq  2490 <pthread_cond_wait@plt>
    40cf:	eb e6                	jmp    40b7 <posix_boot_cpu+0x62>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    40d1:	48 8d 3d 08 95 00 00 	lea    0x9508(%rip),%rdi        # d5e0 <mtx_cpu>
    40d8:	e8 a3 e4 ff ff       	callq  2580 <pthread_mutex_unlock@plt>
    40dd:	48 8d 35 e1 43 00 00 	lea    0x43e1(%rip),%rsi        # 84c5 <default_cmd+0x4a5>
    40e4:	89 c7                	mov    %eax,%edi
    40e6:	e8 4a fe ff ff       	callq  3f35 <pc_safe_call>

	if (soc_terminate) {
    40eb:	80 3d 68 9b 00 00 00 	cmpb   $0x0,0x9b68(%rip)        # dc5a <soc_terminate>
    40f2:	74 07                	je     40fb <posix_boot_cpu+0xa6>
		posix_exit(0);
    40f4:	31 ff                	xor    %edi,%edi
    40f6:	e8 f5 0b 00 00       	callq  4cf0 <posix_exit>
	}
}
    40fb:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    4100:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4107:	00 00 
    4109:	74 05                	je     4110 <posix_boot_cpu+0xbb>
    410b:	e8 90 e3 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    4110:	48 83 c4 10          	add    $0x10,%rsp
    4114:	5b                   	pop    %rbx
    4115:	c3                   	retq   

0000000000004116 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
    4116:	f3 0f 1e fa          	endbr64 
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    411a:	48 8d 05 3f 6a 00 00 	lea    0x6a3f(%rip),%rax        # ab60 <native_pre_tasks.6323>
    4121:	48 63 d7             	movslq %edi,%rdx
{
    4124:	41 54                	push   %r12
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    4126:	ff c7                	inc    %edi
{
    4128:	55                   	push   %rbp
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    4129:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    412d:	49 89 c4             	mov    %rax,%r12
{
    4130:	53                   	push   %rbx
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    4131:	48 63 df             	movslq %edi,%rbx
    4134:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    4138:	76 11                	jbe    414b <run_native_tasks+0x35>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    413a:	48 8b 45 00          	mov    0x0(%rbp),%rax
    413e:	48 85 c0             	test   %rax,%rax
    4141:	74 02                	je     4145 <run_native_tasks+0x2f>
			(*fptr)();
    4143:	ff d0                	callq  *%rax
		fptr++) {
    4145:	48 83 c5 08          	add    $0x8,%rbp
    4149:	eb e9                	jmp    4134 <run_native_tasks+0x1e>
		}
	}
}
    414b:	5b                   	pop    %rbx
    414c:	5d                   	pop    %rbp
    414d:	41 5c                	pop    %r12
    414f:	c3                   	retq   

0000000000004150 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    4150:	f3 0f 1e fa          	endbr64 
    4154:	51                   	push   %rcx
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    4155:	80 3d 00 73 00 00 00 	cmpb   $0x0,0x7300(%rip)        # b45c <cpu_halted>
    415c:	74 10                	je     416e <posix_soc_clean_up+0x1e>

		posix_core_clean_up();
    415e:	e8 16 fc ff ff       	callq  3d79 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    4163:	bf 04 00 00 00       	mov    $0x4,%edi
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    4168:	5a                   	pop    %rdx
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    4169:	e9 a8 ff ff ff       	jmpq   4116 <run_native_tasks>
	} else if (soc_terminate == false) {
    416e:	80 3d e5 9a 00 00 00 	cmpb   $0x0,0x9ae5(%rip)        # dc5a <soc_terminate>
    4175:	75 68                	jne    41df <posix_soc_clean_up+0x8f>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4177:	48 8d 3d 62 94 00 00 	lea    0x9462(%rip),%rdi        # d5e0 <mtx_cpu>
		soc_terminate = true;
    417e:	c6 05 d5 9a 00 00 01 	movb   $0x1,0x9ad5(%rip)        # dc5a <soc_terminate>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4185:	e8 06 e5 ff ff       	callq  2690 <pthread_mutex_lock@plt>
    418a:	48 8d 35 17 43 00 00 	lea    0x4317(%rip),%rsi        # 84a8 <default_cmd+0x488>
    4191:	89 c7                	mov    %eax,%edi
    4193:	e8 9d fd ff ff       	callq  3f35 <pc_safe_call>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    4198:	48 8d 3d 81 94 00 00 	lea    0x9481(%rip),%rdi        # d620 <cond_cpu>
		cpu_halted = true;
    419f:	c6 05 b6 72 00 00 01 	movb   $0x1,0x72b6(%rip)        # b45c <cpu_halted>
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    41a6:	e8 55 e2 ff ff       	callq  2400 <pthread_cond_broadcast@plt>
    41ab:	48 8d 35 32 43 00 00 	lea    0x4332(%rip),%rsi        # 84e4 <default_cmd+0x4c4>
    41b2:	89 c7                	mov    %eax,%edi
    41b4:	e8 7c fd ff ff       	callq  3f35 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    41b9:	48 8d 3d 20 94 00 00 	lea    0x9420(%rip),%rdi        # d5e0 <mtx_cpu>
    41c0:	e8 bb e3 ff ff       	callq  2580 <pthread_mutex_unlock@plt>
    41c5:	48 8d 35 f9 42 00 00 	lea    0x42f9(%rip),%rsi        # 84c5 <default_cmd+0x4a5>
    41cc:	89 c7                	mov    %eax,%edi
    41ce:	e8 62 fd ff ff       	callq  3f35 <pc_safe_call>
			sleep(1);
    41d3:	bf 01 00 00 00       	mov    $0x1,%edi
    41d8:	e8 a3 e4 ff ff       	callq  2680 <sleep@plt>
		while (1) {
    41dd:	eb f4                	jmp    41d3 <posix_soc_clean_up+0x83>
}
    41df:	58                   	pop    %rax
    41e0:	c3                   	retq   

00000000000041e1 <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
    41e1:	f3 0f 1e fa          	endbr64 
	signaled_end = 1;
    41e5:	c7 05 3d 9a 00 00 01 	movl   $0x1,0x9a3d(%rip)        # dc2c <signaled_end>
    41ec:	00 00 00 
}
    41ef:	c3                   	retq   

00000000000041f0 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    41f0:	f3 0f 1e fa          	endbr64 
    41f4:	55                   	push   %rbp
    41f5:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    41fc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4203:	00 00 
    4205:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    420c:	00 
    420d:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
    420f:	48 8d 05 cb ff ff ff 	lea    -0x35(%rip),%rax        # 41e1 <hwm_signal_end_handler>
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    4216:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
	act.sa_handler = hwm_signal_end_handler;
    421b:	48 89 04 24          	mov    %rax,(%rsp)
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    421f:	e8 3c e3 ff ff       	callq  2560 <sigemptyset@plt>
	if (unlikely(test)) {
    4224:	85 c0                	test   %eax,%eax
    4226:	74 15                	je     423d <hwm_set_sig_handler+0x4d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    4228:	48 8d 35 12 43 00 00 	lea    0x4312(%rip),%rsi        # 8541 <default_cmd+0x521>
    422f:	48 8d 3d b2 40 00 00 	lea    0x40b2(%rip),%rdi        # 82e8 <default_cmd+0x2c8>
    4236:	31 c0                	xor    %eax,%eax
    4238:	e8 af 0b 00 00       	callq  4dec <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    423d:	48 89 e5             	mov    %rsp,%rbp
    4240:	31 d2                	xor    %edx,%edx
    4242:	bf 0f 00 00 00       	mov    $0xf,%edi
	act.sa_flags = SA_RESETHAND;
    4247:	c7 84 24 88 00 00 00 	movl   $0x80000000,0x88(%rsp)
    424e:	00 00 00 80 
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    4252:	48 89 ee             	mov    %rbp,%rsi
    4255:	e8 d6 e1 ff ff       	callq  2430 <sigaction@plt>
	if (unlikely(test)) {
    425a:	85 c0                	test   %eax,%eax
    425c:	74 15                	je     4273 <hwm_set_sig_handler+0x83>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    425e:	48 8d 35 f6 42 00 00 	lea    0x42f6(%rip),%rsi        # 855b <default_cmd+0x53b>
    4265:	48 8d 3d 7c 40 00 00 	lea    0x407c(%rip),%rdi        # 82e8 <default_cmd+0x2c8>
    426c:	31 c0                	xor    %eax,%eax
    426e:	e8 79 0b 00 00       	callq  4dec <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    4273:	31 d2                	xor    %edx,%edx
    4275:	48 89 ee             	mov    %rbp,%rsi
    4278:	bf 02 00 00 00       	mov    $0x2,%edi
    427d:	e8 ae e1 ff ff       	callq  2430 <sigaction@plt>
	if (unlikely(test)) {
    4282:	85 c0                	test   %eax,%eax
    4284:	74 15                	je     429b <hwm_set_sig_handler+0xab>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    4286:	48 8d 35 ed 42 00 00 	lea    0x42ed(%rip),%rsi        # 857a <default_cmd+0x55a>
    428d:	48 8d 3d 54 40 00 00 	lea    0x4054(%rip),%rdi        # 82e8 <default_cmd+0x2c8>
    4294:	31 c0                	xor    %eax,%eax
    4296:	e8 51 0b 00 00       	callq  4dec <posix_print_error_and_exit>
}
    429b:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
    42a2:	00 
    42a3:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    42aa:	00 00 
    42ac:	74 05                	je     42b3 <hwm_set_sig_handler+0xc3>
    42ae:	e8 ed e1 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    42b3:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    42ba:	5d                   	pop    %rbp
    42bb:	c3                   	retq   

00000000000042bc <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
    42bc:	f3 0f 1e fa          	endbr64 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
    42c0:	48 8d 05 e1 98 00 00 	lea    0x98e1(%rip),%rax        # dba8 <hw_timer_timer>
	next_timer_index = 0;
    42c7:	c7 05 7f 71 00 00 00 	movl   $0x0,0x717f(%rip)        # b450 <next_timer_index>
    42ce:	00 00 00 
	next_timer_time  = *Timer_list[0];
    42d1:	48 8b 10             	mov    (%rax),%rdx

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    42d4:	48 8d 05 65 71 00 00 	lea    0x7165(%rip),%rax        # b440 <irq_ctrl_timer>
    42db:	48 8b 00             	mov    (%rax),%rax
	next_timer_time  = *Timer_list[0];
    42de:	48 89 15 7b 98 00 00 	mov    %rdx,0x987b(%rip)        # db60 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    42e5:	48 39 c2             	cmp    %rax,%rdx
    42e8:	76 11                	jbe    42fb <hwm_find_next_timer+0x3f>
			next_timer_index = i;
    42ea:	c7 05 5c 71 00 00 01 	movl   $0x1,0x715c(%rip)        # b450 <next_timer_index>
    42f1:	00 00 00 
			next_timer_time = *Timer_list[i];
    42f4:	48 89 05 65 98 00 00 	mov    %rax,0x9865(%rip)        # db60 <next_timer_time>
		if (next_timer_time > *Timer_list[i]) {
    42fb:	48 8d 05 f6 98 00 00 	lea    0x98f6(%rip),%rax        # dbf8 <hw_counter_timer>
    4302:	48 8b 00             	mov    (%rax),%rax
    4305:	48 3b 05 54 98 00 00 	cmp    0x9854(%rip),%rax        # db60 <next_timer_time>
    430c:	73 11                	jae    431f <hwm_find_next_timer+0x63>
			next_timer_index = i;
    430e:	c7 05 38 71 00 00 02 	movl   $0x2,0x7138(%rip)        # b450 <next_timer_index>
    4315:	00 00 00 
			next_timer_time = *Timer_list[i];
    4318:	48 89 05 41 98 00 00 	mov    %rax,0x9841(%rip)        # db60 <next_timer_time>
		}
	}
}
    431f:	c3                   	retq   

0000000000004320 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    4320:	f3 0f 1e fa          	endbr64 
    4324:	48 83 ec 18          	sub    $0x18,%rsp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    4328:	48 8b 35 31 98 00 00 	mov    0x9831(%rip),%rsi        # db60 <next_timer_time>
    432f:	48 8b 15 32 98 00 00 	mov    0x9832(%rip),%rdx        # db68 <simu_time>
    4336:	48 39 d6             	cmp    %rdx,%rsi
    4339:	72 09                	jb     4344 <hwm_main_loop+0x24>
		simu_time = next_timer_time;
    433b:	48 89 35 26 98 00 00 	mov    %rsi,0x9826(%rip)        # db68 <simu_time>
    4342:	eb 14                	jmp    4358 <hwm_main_loop+0x38>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    4344:	8b 0d 06 71 00 00    	mov    0x7106(%rip),%ecx        # b450 <next_timer_index>
    434a:	48 8d 3d 47 42 00 00 	lea    0x4247(%rip),%rdi        # 8598 <default_cmd+0x578>
    4351:	31 c0                	xor    %eax,%eax
    4353:	e8 6d 0b 00 00       	callq  4ec5 <posix_print_warning>
	if (signaled_end || (simu_time > end_of_time)) {
    4358:	8b 15 ce 98 00 00    	mov    0x98ce(%rip),%edx        # dc2c <signaled_end>
    435e:	48 8b 05 03 98 00 00 	mov    0x9803(%rip),%rax        # db68 <simu_time>
    4365:	85 d2                	test   %edx,%edx
    4367:	75 09                	jne    4372 <hwm_main_loop+0x52>
    4369:	48 39 05 c0 70 00 00 	cmp    %rax,0x70c0(%rip)        # b430 <end_of_time>
    4370:	73 36                	jae    43a8 <hwm_main_loop+0x88>
				((long double)simu_time)/1.0e6);
    4372:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4377:	df 6c 24 08          	fildll 0x8(%rsp)
    437b:	48 85 c0             	test   %rax,%rax
    437e:	79 06                	jns    4386 <hwm_main_loop+0x66>
    4380:	d8 05 de 3d 00 00    	fadds  0x3dde(%rip)        # 8164 <default_cmd+0x144>
		posix_print_trace("\nStopped at %.3Lfs\n",
    4386:	d8 35 dc 3d 00 00    	fdivs  0x3ddc(%rip)        # 8168 <default_cmd+0x148>
    438c:	50                   	push   %rax
    438d:	48 8d 3d 39 42 00 00 	lea    0x4239(%rip),%rdi        # 85cd <default_cmd+0x5ad>
    4394:	50                   	push   %rax
    4395:	31 c0                	xor    %eax,%eax
    4397:	db 3c 24             	fstpt  (%rsp)
    439a:	e8 f5 0b 00 00       	callq  4f94 <posix_print_trace>
    439f:	5a                   	pop    %rdx
		posix_exit(0);
    43a0:	31 ff                	xor    %edi,%edi
		posix_print_trace("\nStopped at %.3Lfs\n",
    43a2:	59                   	pop    %rcx
		posix_exit(0);
    43a3:	e8 48 09 00 00       	callq  4cf0 <posix_exit>
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    43a8:	8b 05 a2 70 00 00    	mov    0x70a2(%rip),%eax        # b450 <next_timer_index>
    43ae:	83 f8 01             	cmp    $0x1,%eax
    43b1:	74 10                	je     43c3 <hwm_main_loop+0xa3>
    43b3:	83 f8 02             	cmp    $0x2,%eax
    43b6:	74 12                	je     43ca <hwm_main_loop+0xaa>
    43b8:	85 c0                	test   %eax,%eax
    43ba:	75 15                	jne    43d1 <hwm_main_loop+0xb1>
		case HWTIMER:
			hwtimer_timer_reached();
    43bc:	e8 02 03 00 00       	callq  46c3 <hwtimer_timer_reached>
			break;
    43c1:	eb 1c                	jmp    43df <hwm_main_loop+0xbf>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
    43c3:	e8 11 09 00 00       	callq  4cd9 <hw_irq_ctrl_timer_triggered>
			break;
    43c8:	eb 15                	jmp    43df <hwm_main_loop+0xbf>
		case HW_COUNTER:
			hw_counter_triggered();
    43ca:	e8 29 16 00 00       	callq  59f8 <hw_counter_triggered>
			break;
    43cf:	eb 0e                	jmp    43df <hwm_main_loop+0xbf>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    43d1:	48 8d 3d 09 42 00 00 	lea    0x4209(%rip),%rdi        # 85e1 <default_cmd+0x5c1>
    43d8:	31 c0                	xor    %eax,%eax
    43da:	e8 0d 0a 00 00       	callq  4dec <posix_print_error_and_exit>
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    43df:	e8 d8 fe ff ff       	callq  42bc <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    43e4:	e9 3f ff ff ff       	jmpq   4328 <hwm_main_loop+0x8>

00000000000043e9 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
    43e9:	f3 0f 1e fa          	endbr64 
	end_of_time = new_end_of_time;
    43ed:	48 89 3d 3c 70 00 00 	mov    %rdi,0x703c(%rip)        # b430 <end_of_time>
}
    43f4:	c3                   	retq   

00000000000043f5 <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
    43f5:	f3 0f 1e fa          	endbr64 
	return simu_time;
}
    43f9:	48 8b 05 68 97 00 00 	mov    0x9768(%rip),%rax        # db68 <simu_time>
    4400:	c3                   	retq   

0000000000004401 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    4401:	f3 0f 1e fa          	endbr64 
    4405:	50                   	push   %rax
	hwm_set_sig_handler();
    4406:	e8 e5 fd ff ff       	callq  41f0 <hwm_set_sig_handler>
	hwtimer_init();
    440b:	e8 7e 01 00 00       	callq  458e <hwtimer_init>
	hw_counter_init();
    4410:	e8 a8 15 00 00       	callq  59bd <hw_counter_init>
	hw_irq_ctrl_init();
    4415:	e8 f3 06 00 00       	callq  4b0d <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    441a:	5a                   	pop    %rdx
	hwm_find_next_timer();
    441b:	e9 9c fe ff ff       	jmpq   42bc <hwm_find_next_timer>

0000000000004420 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    4420:	f3 0f 1e fa          	endbr64 
    4424:	50                   	push   %rax
	hwtimer_cleanup();
    4425:	e8 67 02 00 00       	callq  4691 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    442a:	5a                   	pop    %rdx
	hw_irq_ctrl_cleanup();
    442b:	e9 1c 07 00 00       	jmpq   4b4c <hw_irq_ctrl_cleanup>

0000000000004430 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    4430:	48 8d 15 61 97 00 00 	lea    0x9761(%rip),%rdx        # db98 <hw_timer_awake_timer>
    4437:	48 8d 05 62 97 00 00 	lea    0x9762(%rip),%rax        # dba0 <hw_timer_tick_timer>
    443e:	48 8b 00             	mov    (%rax),%rax
    4441:	48 39 02             	cmp    %rax,(%rdx)
    4444:	48 0f 46 02          	cmovbe (%rdx),%rax
    4448:	48 8d 15 59 97 00 00 	lea    0x9759(%rip),%rdx        # dba8 <hw_timer_timer>
    444f:	48 89 02             	mov    %rax,(%rdx)
}
    4452:	c3                   	retq   

0000000000004453 <native_add_time_options>:
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}

static void native_add_time_options(void)
{
    4453:	f3 0f 1e fa          	endbr64 
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    4457:	48 8d 3d a2 6b 00 00 	lea    0x6ba2(%rip),%rdi        # b000 <timer_options.3187>
    445e:	e9 e8 13 00 00       	jmpq   584b <native_add_command_line_opts>

0000000000004463 <cmd_stop_at_found>:
{
    4463:	f3 0f 1e fa          	endbr64 
	if (args.stop_at < 0) {
    4467:	0f 57 c0             	xorps  %xmm0,%xmm0
{
    446a:	52                   	push   %rdx
	if (args.stop_at < 0) {
    446b:	66 0f 2f 05 ed 91 00 	comisd 0x91ed(%rip),%xmm0        # d660 <args>
    4472:	00 
    4473:	76 11                	jbe    4486 <cmd_stop_at_found+0x23>
    4475:	48 89 fe             	mov    %rdi,%rsi
		posix_print_error_and_exit("Error: stop-at must be positive "
    4478:	31 c0                	xor    %eax,%eax
    447a:	48 8d 3d 7c 41 00 00 	lea    0x417c(%rip),%rdi        # 85fd <default_cmd+0x5dd>
    4481:	e8 66 09 00 00       	callq  4dec <posix_print_error_and_exit>
	hwm_set_end_of_time(args.stop_at*1e6);
    4486:	f2 0f 10 05 aa 3b 00 	movsd  0x3baa(%rip),%xmm0        # 8038 <default_cmd+0x18>
    448d:	00 
    448e:	f2 0f 59 05 ca 91 00 	mulsd  0x91ca(%rip),%xmm0        # d660 <args>
    4495:	00 
    4496:	f2 0f 10 0d a2 3b 00 	movsd  0x3ba2(%rip),%xmm1        # 8040 <default_cmd+0x20>
    449d:	00 
    449e:	66 0f 2f c1          	comisd %xmm1,%xmm0
    44a2:	73 07                	jae    44ab <cmd_stop_at_found+0x48>
    44a4:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    44a9:	eb 0e                	jmp    44b9 <cmd_stop_at_found+0x56>
    44ab:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    44af:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    44b4:	48 0f ba ff 3f       	btc    $0x3f,%rdi
}
    44b9:	58                   	pop    %rax
	hwm_set_end_of_time(args.stop_at*1e6);
    44ba:	e9 2a ff ff ff       	jmpq   43e9 <hwm_set_end_of_time>

00000000000044bf <hwtimer_set_real_time_mode>:
{
    44bf:	f3 0f 1e fa          	endbr64 
	real_time_mode = new_rt;
    44c3:	40 88 3d 93 6f 00 00 	mov    %dil,0x6f93(%rip)        # b45d <real_time_mode>
}
    44ca:	c3                   	retq   

00000000000044cb <cmd_no_realtime_found>:
{
    44cb:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(false);
    44cf:	31 ff                	xor    %edi,%edi
    44d1:	e9 e9 ff ff ff       	jmpq   44bf <hwtimer_set_real_time_mode>

00000000000044d6 <cmd_realtime_found>:
{
    44d6:	f3 0f 1e fa          	endbr64 
	hwtimer_set_real_time_mode(true);
    44da:	bf 01 00 00 00       	mov    $0x1,%edi
    44df:	e9 db ff ff ff       	jmpq   44bf <hwtimer_set_real_time_mode>

00000000000044e4 <get_host_us_time>:
{
    44e4:	f3 0f 1e fa          	endbr64 
    44e8:	48 83 ec 28          	sub    $0x28,%rsp
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    44ec:	bf 04 00 00 00       	mov    $0x4,%edi
{
    44f1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    44f8:	00 00 
    44fa:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    44ff:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    4501:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    4506:	e8 65 df ff ff       	callq  2470 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    450b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    4510:	48 85 d2             	test   %rdx,%rdx
    4513:	78 07                	js     451c <get_host_us_time+0x38>
    4515:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    451a:	eb 15                	jmp    4531 <get_host_us_time+0x4d>
    451c:	48 89 d0             	mov    %rdx,%rax
    451f:	83 e2 01             	and    $0x1,%edx
    4522:	48 d1 e8             	shr    %rax
    4525:	48 09 d0             	or     %rdx,%rax
    4528:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    452d:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    4531:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    4536:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    453b:	f2 0f 59 05 f5 3a 00 	mulsd  0x3af5(%rip),%xmm0        # 8038 <default_cmd+0x18>
    4542:	00 
    4543:	48 99                	cqto   
    4545:	48 f7 f9             	idiv   %rcx
    4548:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    454d:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    4551:	f2 0f 10 0d e7 3a 00 	movsd  0x3ae7(%rip),%xmm1        # 8040 <default_cmd+0x20>
    4558:	00 
    4559:	66 0f 2f c1          	comisd %xmm1,%xmm0
    455d:	73 07                	jae    4566 <get_host_us_time+0x82>
    455f:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    4564:	eb 0e                	jmp    4574 <get_host_us_time+0x90>
    4566:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    456a:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    456f:	48 0f ba f8 3f       	btc    $0x3f,%rax
}
    4574:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    4579:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    4580:	00 00 
    4582:	74 05                	je     4589 <get_host_us_time+0xa5>
    4584:	e8 17 df ff ff       	callq  24a0 <__stack_chk_fail@plt>
    4589:	48 83 c4 28          	add    $0x28,%rsp
    458d:	c3                   	retq   

000000000000458e <hwtimer_init>:
{
    458e:	f3 0f 1e fa          	endbr64 
    4592:	48 83 ec 28          	sub    $0x28,%rsp
    4596:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    459d:	00 00 
    459f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    45a4:	31 c0                	xor    %eax,%eax
	hw_timer_tick_timer = NEVER;
    45a6:	48 8d 05 f3 95 00 00 	lea    0x95f3(%rip),%rax        # dba0 <hw_timer_tick_timer>
	silent_ticks = 0;
    45ad:	48 c7 05 d0 95 00 00 	movq   $0x0,0x95d0(%rip)        # db88 <silent_ticks>
    45b4:	00 00 00 00 
	hw_timer_tick_timer = NEVER;
    45b8:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hw_timer_awake_timer = NEVER;
    45bf:	48 8d 05 d2 95 00 00 	lea    0x95d2(%rip),%rax        # db98 <hw_timer_awake_timer>
    45c6:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    45cd:	e8 5e fe ff ff       	callq  4430 <hwtimer_update_timer>
	if (real_time_mode) {
    45d2:	80 3d 84 6e 00 00 00 	cmpb   $0x0,0x6e84(%rip)        # b45d <real_time_mode>
    45d9:	74 17                	je     45f2 <hwtimer_init+0x64>
		boot_time = get_host_us_time();
    45db:	e8 04 ff ff ff       	callq  44e4 <get_host_us_time>
		last_radj_stime = 0U;
    45e0:	48 c7 05 85 95 00 00 	movq   $0x0,0x9585(%rip)        # db70 <last_radj_stime>
    45e7:	00 00 00 00 
		last_radj_rtime = boot_time;
    45eb:	48 89 05 86 95 00 00 	mov    %rax,0x9586(%rip)        # db78 <last_radj_rtime>
	if (!reset_rtc) {
    45f2:	80 3d 62 96 00 00 00 	cmpb   $0x0,0x9662(%rip)        # dc5b <reset_rtc>
    45f9:	75 7c                	jne    4677 <hwtimer_init+0xe9>
		clock_gettime(CLOCK_REALTIME, &tv);
    45fb:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    4600:	31 ff                	xor    %edi,%edi
    4602:	e8 69 de ff ff       	callq  2470 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    4607:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    460c:	48 85 d2             	test   %rdx,%rdx
    460f:	78 07                	js     4618 <hwtimer_init+0x8a>
    4611:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
    4616:	eb 15                	jmp    462d <hwtimer_init+0x9f>
    4618:	48 89 d0             	mov    %rdx,%rax
    461b:	83 e2 01             	and    $0x1,%edx
    461e:	48 d1 e8             	shr    %rax
    4621:	48 09 d0             	or     %rdx,%rax
    4624:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    4629:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
    462d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    4632:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    4637:	f2 0f 59 05 f9 39 00 	mulsd  0x39f9(%rip),%xmm0        # 8038 <default_cmd+0x18>
    463e:	00 
    463f:	48 99                	cqto   
    4641:	48 f7 f9             	idiv   %rcx
    4644:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    4649:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
    464d:	f2 0f 10 0d eb 39 00 	movsd  0x39eb(%rip),%xmm1        # 8040 <default_cmd+0x20>
    4654:	00 
    4655:	66 0f 2f c1          	comisd %xmm1,%xmm0
    4659:	73 07                	jae    4662 <hwtimer_init+0xd4>
    465b:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    4660:	eb 0e                	jmp    4670 <hwtimer_init+0xe2>
    4662:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    4666:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    466b:	48 0f ba f8 3f       	btc    $0x3f,%rax
		rtc_offset += realhosttime;
    4670:	48 01 05 09 95 00 00 	add    %rax,0x9509(%rip)        # db80 <rtc_offset>
}
    4677:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    467c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4683:	00 00 
    4685:	74 05                	je     468c <hwtimer_init+0xfe>
    4687:	e8 14 de ff ff       	callq  24a0 <__stack_chk_fail@plt>
    468c:	48 83 c4 28          	add    $0x28,%rsp
    4690:	c3                   	retq   

0000000000004691 <hwtimer_cleanup>:
{
    4691:	f3 0f 1e fa          	endbr64 
}
    4695:	c3                   	retq   

0000000000004696 <hwtimer_enable>:
{
    4696:	f3 0f 1e fa          	endbr64 
    469a:	50                   	push   %rax
	tick_p = period;
    469b:	48 89 3d ee 94 00 00 	mov    %rdi,0x94ee(%rip)        # db90 <tick_p>
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    46a2:	e8 4e fd ff ff       	callq  43f5 <hwm_get_time>
    46a7:	48 8d 15 f2 94 00 00 	lea    0x94f2(%rip),%rdx        # dba0 <hw_timer_tick_timer>
    46ae:	48 03 05 db 94 00 00 	add    0x94db(%rip),%rax        # db90 <tick_p>
    46b5:	48 89 02             	mov    %rax,(%rdx)
	hwtimer_update_timer();
    46b8:	e8 73 fd ff ff       	callq  4430 <hwtimer_update_timer>
}
    46bd:	5a                   	pop    %rdx
	hwm_find_next_timer();
    46be:	e9 f9 fb ff ff       	jmpq   42bc <hwm_find_next_timer>

00000000000046c3 <hwtimer_timer_reached>:
{
    46c3:	f3 0f 1e fa          	endbr64 
    46c7:	55                   	push   %rbp
    46c8:	53                   	push   %rbx
    46c9:	48 83 ec 38          	sub    $0x38,%rsp
    46cd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    46d4:	00 00 
    46d6:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    46db:	31 c0                	xor    %eax,%eax
	uint64_t Now = hw_timer_timer;
    46dd:	48 8d 05 c4 94 00 00 	lea    0x94c4(%rip),%rax        # dba8 <hw_timer_timer>
    46e4:	48 8b 18             	mov    (%rax),%rbx
	if (hw_timer_awake_timer == Now) {
    46e7:	48 8d 05 aa 94 00 00 	lea    0x94aa(%rip),%rax        # db98 <hw_timer_awake_timer>
    46ee:	48 39 18             	cmp    %rbx,(%rax)
    46f1:	75 16                	jne    4709 <hwtimer_timer_reached+0x46>
	hw_timer_awake_timer = NEVER;
    46f3:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	hwtimer_update_timer();
    46fa:	e8 31 fd ff ff       	callq  4430 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    46ff:	bf ff ff 00 00       	mov    $0xffff,%edi
    4704:	e8 5a 05 00 00       	callq  4c63 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
    4709:	48 8d 2d 90 94 00 00 	lea    0x9490(%rip),%rbp        # dba0 <hw_timer_tick_timer>
    4710:	48 39 5d 00          	cmp    %rbx,0x0(%rbp)
    4714:	0f 85 12 01 00 00    	jne    482c <hwtimer_timer_reached+0x169>
	if (real_time_mode) {
    471a:	80 3d 3c 6d 00 00 00 	cmpb   $0x0,0x6d3c(%rip)        # b45d <real_time_mode>
    4721:	0f 84 d6 00 00 00    	je     47fd <hwtimer_timer_reached+0x13a>
				    / clock_ratio
    4727:	48 2b 1d 42 94 00 00 	sub    0x9442(%rip),%rbx        # db70 <last_radj_stime>
    472e:	78 07                	js     4737 <hwtimer_timer_reached+0x74>
    4730:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    4735:	eb 15                	jmp    474c <hwtimer_timer_reached+0x89>
    4737:	48 89 d8             	mov    %rbx,%rax
    473a:	83 e3 01             	and    $0x1,%ebx
    473d:	48 d1 e8             	shr    %rax
    4740:	48 09 d8             	or     %rbx,%rax
    4743:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
    4748:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
				    + last_radj_rtime;
    474c:	48 8b 15 25 94 00 00 	mov    0x9425(%rip),%rdx        # db78 <last_radj_rtime>
				    / clock_ratio
    4753:	f2 0f 5e 05 dd 6c 00 	divsd  0x6cdd(%rip),%xmm0        # b438 <clock_ratio>
    475a:	00 
				    + last_radj_rtime;
    475b:	48 85 d2             	test   %rdx,%rdx
    475e:	78 07                	js     4767 <hwtimer_timer_reached+0xa4>
    4760:	f2 48 0f 2a ca       	cvtsi2sd %rdx,%xmm1
    4765:	eb 15                	jmp    477c <hwtimer_timer_reached+0xb9>
    4767:	48 89 d0             	mov    %rdx,%rax
    476a:	83 e2 01             	and    $0x1,%edx
    476d:	48 d1 e8             	shr    %rax
    4770:	48 09 d0             	or     %rdx,%rax
    4773:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
    4778:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
    477c:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    4780:	f2 0f 10 0d b8 38 00 	movsd  0x38b8(%rip),%xmm1        # 8040 <default_cmd+0x20>
    4787:	00 
    4788:	66 0f 2f c1          	comisd %xmm1,%xmm0
    478c:	73 07                	jae    4795 <hwtimer_timer_reached+0xd2>
    478e:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    4793:	eb 0e                	jmp    47a3 <hwtimer_timer_reached+0xe0>
    4795:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    4799:	f2 48 0f 2c d8       	cvttsd2si %xmm0,%rbx
    479e:	48 0f ba fb 3f       	btc    $0x3f,%rbx
		uint64_t real_time = get_host_us_time();
    47a3:	e8 3c fd ff ff       	callq  44e4 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
    47a8:	48 29 c3             	sub    %rax,%rbx
		if (diff > 0) { /* we need to slow down */
    47ab:	48 85 db             	test   %rbx,%rbx
    47ae:	7e 4d                	jle    47fd <hwtimer_timer_reached+0x13a>
			requested_time.tv_sec  = diff / 1e6;
    47b0:	f2 48 0f 2a c3       	cvtsi2sd %rbx,%xmm0
    47b5:	f2 0f 10 1d 7b 38 00 	movsd  0x387b(%rip),%xmm3        # 8038 <default_cmd+0x18>
    47bc:	00 
			(void) nanosleep(&requested_time, &remaining);
    47bd:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    47c2:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
			requested_time.tv_sec  = diff / 1e6;
    47c7:	66 0f 28 d0          	movapd %xmm0,%xmm2
    47cb:	f2 0f 5e d3          	divsd  %xmm3,%xmm2
    47cf:	f2 48 0f 2c c2       	cvttsd2si %xmm2,%rax
						 requested_time.tv_sec*1e6)*1e3;
    47d4:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
			requested_time.tv_sec  = diff / 1e6;
    47d9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
						 requested_time.tv_sec*1e6)*1e3;
    47de:	f2 0f 59 cb          	mulsd  %xmm3,%xmm1
			requested_time.tv_nsec = (diff -
    47e2:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
						 requested_time.tv_sec*1e6)*1e3;
    47e6:	f2 0f 59 05 5a 38 00 	mulsd  0x385a(%rip),%xmm0        # 8048 <default_cmd+0x28>
    47ed:	00 
			requested_time.tv_nsec = (diff -
    47ee:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
    47f3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
			(void) nanosleep(&requested_time, &remaining);
    47f8:	e8 d3 dc ff ff       	callq  24d0 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
    47fd:	48 8b 05 8c 93 00 00 	mov    0x938c(%rip),%rax        # db90 <tick_p>
    4804:	48 01 45 00          	add    %rax,0x0(%rbp)
	hwtimer_update_timer();
    4808:	e8 23 fc ff ff       	callq  4430 <hwtimer_update_timer>
	if (silent_ticks > 0) {
    480d:	48 8b 05 74 93 00 00 	mov    0x9374(%rip),%rax        # db88 <silent_ticks>
    4814:	48 85 c0             	test   %rax,%rax
    4817:	7e 0c                	jle    4825 <hwtimer_timer_reached+0x162>
		silent_ticks -= 1;
    4819:	48 ff c8             	dec    %rax
    481c:	48 89 05 65 93 00 00 	mov    %rax,0x9365(%rip)        # db88 <silent_ticks>
    4823:	eb 07                	jmp    482c <hwtimer_timer_reached+0x169>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    4825:	31 ff                	xor    %edi,%edi
    4827:	e8 37 04 00 00       	callq  4c63 <hw_irq_ctrl_set_irq>
}
    482c:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    4831:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4838:	00 00 
    483a:	74 05                	je     4841 <hwtimer_timer_reached+0x17e>
    483c:	e8 5f dc ff ff       	callq  24a0 <__stack_chk_fail@plt>
    4841:	48 83 c4 38          	add    $0x38,%rsp
    4845:	5b                   	pop    %rbx
    4846:	5d                   	pop    %rbp
    4847:	c3                   	retq   

0000000000004848 <hwtimer_set_silent_ticks>:
{
    4848:	f3 0f 1e fa          	endbr64 
	silent_ticks = sys_ticks;
    484c:	48 89 3d 35 93 00 00 	mov    %rdi,0x9335(%rip)        # db88 <silent_ticks>
}
    4853:	c3                   	retq   

0000000000004854 <hwtimer_reset_rtc>:
{
    4854:	f3 0f 1e fa          	endbr64 
	reset_rtc = true;
    4858:	c6 05 fc 93 00 00 01 	movb   $0x1,0x93fc(%rip)        # dc5b <reset_rtc>
}
    485f:	c3                   	retq   

0000000000004860 <cmd_rtcreset_found>:
{
    4860:	f3 0f 1e fa          	endbr64 
	hwtimer_reset_rtc();
    4864:	e9 eb ff ff ff       	jmpq   4854 <hwtimer_reset_rtc>

0000000000004869 <hwtimer_set_rtc_offset>:
{
    4869:	f3 0f 1e fa          	endbr64 
	rtc_offset = offset;
    486d:	48 89 3d 0c 93 00 00 	mov    %rdi,0x930c(%rip)        # db80 <rtc_offset>
}
    4874:	c3                   	retq   

0000000000004875 <cmd_rtcoffset_found>:
{
    4875:	f3 0f 1e fa          	endbr64 
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    4879:	f2 0f 10 05 b7 37 00 	movsd  0x37b7(%rip),%xmm0        # 8038 <default_cmd+0x18>
    4880:	00 
    4881:	f2 0f 59 05 df 8d 00 	mulsd  0x8ddf(%rip),%xmm0        # d668 <args+0x8>
    4888:	00 
    4889:	f2 48 0f 2c f8       	cvttsd2si %xmm0,%rdi
    488e:	e9 d6 ff ff ff       	jmpq   4869 <hwtimer_set_rtc_offset>

0000000000004893 <hwtimer_set_rt_ratio>:
{
    4893:	f3 0f 1e fa          	endbr64 
	clock_ratio = ratio;
    4897:	f2 0f 11 05 99 6b 00 	movsd  %xmm0,0x6b99(%rip)        # b438 <clock_ratio>
    489e:	00 
}
    489f:	c3                   	retq   

00000000000048a0 <cmd_rt_ratio_found>:
{
    48a0:	f3 0f 1e fa          	endbr64 
	if ((args.rt_ratio <= 0)) {
    48a4:	0f 57 c0             	xorps  %xmm0,%xmm0
    48a7:	66 0f 2f 05 c9 8d 00 	comisd 0x8dc9(%rip),%xmm0        # d678 <args+0x18>
    48ae:	00 
    48af:	72 1a                	jb     48cb <cmd_rt_ratio_found+0x2b>
{
    48b1:	50                   	push   %rax
		posix_print_error_and_exit("The ratio needs to be > 0. "
    48b2:	48 8d 3d 6a 3d 00 00 	lea    0x3d6a(%rip),%rdi        # 8623 <default_cmd+0x603>
    48b9:	31 c0                	xor    %eax,%eax
    48bb:	e8 2c 05 00 00       	callq  4dec <posix_print_error_and_exit>
	hwtimer_set_rt_ratio(args.rt_ratio);
    48c0:	f2 0f 10 05 b0 8d 00 	movsd  0x8db0(%rip),%xmm0        # d678 <args+0x18>
    48c7:	00 
}
    48c8:	5a                   	pop    %rdx
    48c9:	eb 08                	jmp    48d3 <cmd_rt_ratio_found+0x33>
	hwtimer_set_rt_ratio(args.rt_ratio);
    48cb:	f2 0f 10 05 a5 8d 00 	movsd  0x8da5(%rip),%xmm0        # d678 <args+0x18>
    48d2:	00 
    48d3:	e9 bb ff ff ff       	jmpq   4893 <hwtimer_set_rt_ratio>

00000000000048d8 <cmd_rt_drift_found>:
{
    48d8:	f3 0f 1e fa          	endbr64 
    48dc:	52                   	push   %rdx
	if (!(args.rt_drift > -1)) {
    48dd:	f2 0f 10 05 8b 8d 00 	movsd  0x8d8b(%rip),%xmm0        # d670 <args+0x10>
    48e4:	00 
    48e5:	66 0f 2f 05 63 37 00 	comisd 0x3763(%rip),%xmm0        # 8050 <default_cmd+0x30>
    48ec:	00 
    48ed:	77 0e                	ja     48fd <cmd_rt_drift_found+0x25>
		posix_print_error_and_exit("The drift needs to be > -1. "
    48ef:	48 8d 3d 69 3d 00 00 	lea    0x3d69(%rip),%rdi        # 865f <default_cmd+0x63f>
    48f6:	31 c0                	xor    %eax,%eax
    48f8:	e8 ef 04 00 00       	callq  4dec <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
    48fd:	f2 0f 10 05 53 37 00 	movsd  0x3753(%rip),%xmm0        # 8058 <default_cmd+0x38>
    4904:	00 
    4905:	f2 0f 58 05 63 8d 00 	addsd  0x8d63(%rip),%xmm0        # d670 <args+0x10>
    490c:	00 
    490d:	f2 0f 11 05 63 8d 00 	movsd  %xmm0,0x8d63(%rip)        # d678 <args+0x18>
    4914:	00 
}
    4915:	58                   	pop    %rax
	hwtimer_set_rt_ratio(args.rt_ratio);
    4916:	e9 78 ff ff ff       	jmpq   4893 <hwtimer_set_rt_ratio>

000000000000491b <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    491b:	f3 0f 1e fa          	endbr64 
    491f:	41 56                	push   %r14
    4921:	41 55                	push   %r13
    4923:	41 54                	push   %r12
    4925:	55                   	push   %rbp
    4926:	53                   	push   %rbx
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    4927:	e8 5e 02 00 00       	callq  4b8a <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    492c:	85 c0                	test   %eax,%eax
    492e:	0f 85 e6 00 00 00    	jne    4a1a <posix_irq_handler+0xff>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
    4934:	48 8d 1d a5 91 00 00 	lea    0x91a5(%rip),%rbx        # dae0 <_kernel>
    493b:	8b 03                	mov    (%rbx),%eax
    493d:	85 c0                	test   %eax,%eax
    493f:	75 0a                	jne    494b <posix_irq_handler+0x30>
		may_swap = 0;
    4941:	c7 05 e5 92 00 00 00 	movl   $0x0,0x92e5(%rip)        # dc30 <may_swap.5208>
    4948:	00 00 00 
	}

	_kernel.cpus[0].nested++;
    494b:	ff c0                	inc    %eax
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    494d:	4c 8d 2d 2c 8d 00 00 	lea    0x8d2c(%rip),%r13        # d680 <irq_vector_table>
	_kernel.cpus[0].nested++;
    4954:	89 03                	mov    %eax,(%rbx)

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    4956:	e8 7a 02 00 00       	callq  4bd5 <hw_irq_ctrl_get_highest_prio_irq>
    495b:	89 c5                	mov    %eax,%ebp
    495d:	83 f8 ff             	cmp    $0xffffffff,%eax
    4960:	0f 84 84 00 00 00    	je     49ea <posix_irq_handler+0xcf>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    4966:	e8 f1 01 00 00       	callq  4b5c <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    496b:	89 ef                	mov    %ebp,%edi
		int last_running_irq = currently_running_irq;
    496d:	44 8b 35 e0 6a 00 00 	mov    0x6ae0(%rip),%r14d        # b454 <currently_running_irq>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    4974:	41 89 c4             	mov    %eax,%r12d
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    4977:	e8 fd 01 00 00       	callq  4b79 <hw_irq_ctrl_get_prio>
    497c:	0f b6 f8             	movzbl %al,%edi
    497f:	e8 cd 01 00 00       	callq  4b51 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    4984:	89 ef                	mov    %ebp,%edi
    4986:	e8 b9 02 00 00       	callq  4c44 <hw_irq_ctrl_clear_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    498b:	48 63 c5             	movslq %ebp,%rax

		currently_running_irq = irq_nbr;
    498e:	89 2d c0 6a 00 00    	mov    %ebp,0x6ac0(%rip)        # b454 <currently_running_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    4994:	48 6b c0 18          	imul   $0x18,%rax,%rax
    4998:	4c 01 e8             	add    %r13,%rax
    499b:	48 8b 50 08          	mov    0x8(%rax),%rdx
    499f:	48 85 d2             	test   %rdx,%rdx
    49a2:	75 12                	jne    49b6 <posix_irq_handler+0x9b>
		posix_print_error_and_exit("Received irq %i without a "
    49a4:	89 ee                	mov    %ebp,%esi
    49a6:	48 8d 3d c8 40 00 00 	lea    0x40c8(%rip),%rdi        # 8a75 <default_cmd+0xa55>
    49ad:	31 c0                	xor    %eax,%eax
    49af:	e8 38 04 00 00       	callq  4dec <posix_print_error_and_exit>
    49b4:	eb 20                	jmp    49d6 <posix_irq_handler+0xbb>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    49b6:	f6 40 04 01          	testb  $0x1,0x4(%rax)
    49ba:	74 0a                	je     49c6 <posix_irq_handler+0xab>
			*may_swap |= ((direct_irq_f_ptr)
    49bc:	ff d2                	callq  *%rdx
    49be:	09 05 6c 92 00 00    	or     %eax,0x926c(%rip)        # dc30 <may_swap.5208>
    49c4:	eb 10                	jmp    49d6 <posix_irq_handler+0xbb>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    49c6:	48 8b 78 10          	mov    0x10(%rax),%rdi
    49ca:	ff d2                	callq  *%rdx
			*may_swap = 1;
    49cc:	c7 05 5a 92 00 00 01 	movl   $0x1,0x925a(%rip)        # dc30 <may_swap.5208>
    49d3:	00 00 00 
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    49d6:	44 89 e7             	mov    %r12d,%edi
		currently_running_irq = last_running_irq;
    49d9:	44 89 35 74 6a 00 00 	mov    %r14d,0x6a74(%rip)        # b454 <currently_running_irq>
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    49e0:	e8 6c 01 00 00       	callq  4b51 <hw_irq_ctrl_set_cur_prio>
    49e5:	e9 6c ff ff ff       	jmpq   4956 <posix_irq_handler+0x3b>
	}

	_kernel.cpus[0].nested--;
    49ea:	ff 0b                	decl   (%rbx)
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    49ec:	83 3d 3d 92 00 00 00 	cmpl   $0x0,0x923d(%rip)        # dc30 <may_swap.5208>
    49f3:	74 25                	je     4a1a <posix_irq_handler+0xff>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    49f5:	e8 62 01 00 00       	callq  4b5c <hw_irq_ctrl_get_cur_prio>
    49fa:	3d 00 01 00 00       	cmp    $0x100,%eax
    49ff:	75 19                	jne    4a1a <posix_irq_handler+0xff>
		&& (_kernel.ready_q.cache != _current)) {
    4a01:	48 8b 43 10          	mov    0x10(%rbx),%rax
    4a05:	48 39 43 38          	cmp    %rax,0x38(%rbx)
    4a09:	74 0f                	je     4a1a <posix_irq_handler+0xff>

		(void)z_swap_irqlock(irq_lock);
	}
}
    4a0b:	5b                   	pop    %rbx

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
    4a0c:	31 ff                	xor    %edi,%edi
    4a0e:	5d                   	pop    %rbp
    4a0f:	41 5c                	pop    %r12
    4a11:	41 5d                	pop    %r13
    4a13:	41 5e                	pop    %r14
    4a15:	e9 79 f4 ff ff       	jmpq   3e93 <arch_swap>
    4a1a:	5b                   	pop    %rbx
    4a1b:	5d                   	pop    %rbp
    4a1c:	41 5c                	pop    %r12
    4a1e:	41 5d                	pop    %r13
    4a20:	41 5e                	pop    %r14
    4a22:	c3                   	retq   

0000000000004a23 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    4a23:	f3 0f 1e fa          	endbr64 
    4a27:	51                   	push   %rcx
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    4a28:	e8 a8 01 00 00       	callq  4bd5 <hw_irq_ctrl_get_highest_prio_irq>
    4a2d:	ff c0                	inc    %eax
    4a2f:	74 22                	je     4a53 <posix_irq_handler_im_from_sw+0x30>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    4a31:	e8 57 f5 ff ff       	callq  3f8d <posix_is_cpu_running>
    4a36:	85 c0                	test   %eax,%eax
    4a38:	75 13                	jne    4a4d <posix_irq_handler_im_from_sw+0x2a>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    4a3a:	48 8d 35 bf 35 00 00 	lea    0x35bf(%rip),%rsi        # 8000 <__func__.5217>
    4a41:	48 8d 3d 5b 40 00 00 	lea    0x405b(%rip),%rdi        # 8aa3 <default_cmd+0xa83>
    4a48:	e8 9f 03 00 00       	callq  4dec <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    4a4d:	5a                   	pop    %rdx
		posix_irq_handler();
    4a4e:	e9 c8 fe ff ff       	jmpq   491b <posix_irq_handler>
}
    4a53:	58                   	pop    %rax
    4a54:	c3                   	retq   

0000000000004a55 <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
    4a55:	f3 0f 1e fa          	endbr64 
	return hw_irq_ctrl_change_lock(true);
    4a59:	bf 01 00 00 00       	mov    $0x1,%edi
    4a5e:	e9 33 01 00 00       	jmpq   4b96 <hw_irq_ctrl_change_lock>

0000000000004a63 <posix_irq_unlock>:
 *
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
    4a63:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(key);
    4a67:	e9 2a 01 00 00       	jmpq   4b96 <hw_irq_ctrl_change_lock>

0000000000004a6c <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
    4a6c:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_change_lock(false);
    4a70:	31 ff                	xor    %edi,%edi
    4a72:	e9 1f 01 00 00       	jmpq   4b96 <hw_irq_ctrl_change_lock>

0000000000004a77 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
    4a77:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_enable_irq(irq);
    4a7b:	e9 31 02 00 00       	jmpq   4cb1 <hw_irq_ctrl_enable_irq>

0000000000004a80 <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
    4a80:	f3 0f 1e fa          	endbr64 
	irq_vector_table[irq_p].irq   = irq_p;
    4a84:	89 f8                	mov    %edi,%eax
{
    4a86:	49 89 d0             	mov    %rdx,%r8
	irq_vector_table[irq_p].irq   = irq_p;
    4a89:	48 6b d0 18          	imul   $0x18,%rax,%rdx
    4a8d:	48 8d 05 ec 8b 00 00 	lea    0x8bec(%rip),%rax        # d680 <irq_vector_table>
    4a94:	48 01 d0             	add    %rdx,%rax
    4a97:	89 38                	mov    %edi,(%rax)
	irq_vector_table[irq_p].func  = isr_p;
    4a99:	4c 89 40 08          	mov    %r8,0x8(%rax)
	irq_vector_table[irq_p].param = isr_param_p;
    4a9d:	48 89 48 10          	mov    %rcx,0x10(%rax)
	irq_vector_table[irq_p].flags = flags;
    4aa1:	89 70 04             	mov    %esi,0x4(%rax)
}
    4aa4:	c3                   	retq   

0000000000004aa5 <posix_irq_priority_set>:
 * Lower values take priority over higher values.
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    4aa5:	f3 0f 1e fa          	endbr64 
	hw_irq_ctrl_prio_set(irq, prio);
    4aa9:	e9 b9 00 00 00       	jmpq   4b67 <hw_irq_ctrl_prio_set>

0000000000004aae <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    4aae:	80 3d a8 91 00 00 00 	cmpb   $0x0,0x91a8(%rip)        # dc5d <irqs_locked>
    4ab5:	74 09                	je     4ac0 <irq_raising_from_hw_now+0x12>
    4ab7:	80 3d 9e 91 00 00 00 	cmpb   $0x0,0x919e(%rip)        # dc5c <lock_ignore>
    4abe:	74 0c                	je     4acc <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
    4ac0:	c6 05 95 91 00 00 00 	movb   $0x0,0x9195(%rip)        # dc5c <lock_ignore>
		posix_interrupt_raised();
    4ac7:	e9 55 f5 ff ff       	jmpq   4021 <posix_interrupt_raised>
	}
}
    4acc:	c3                   	retq   

0000000000004acd <hw_irq_ctrl_irq_raise_prefix>:
{
    4acd:	89 f9                	mov    %edi,%ecx
	if (irq < N_IRQS) {
    4acf:	83 ff 1f             	cmp    $0x1f,%edi
    4ad2:	77 29                	ja     4afd <hw_irq_ctrl_irq_raise_prefix+0x30>
		if (irq_mask & (1 << irq)) {
    4ad4:	b8 01 00 00 00       	mov    $0x1,%eax
		irq_premask |= ((uint64_t)1<<irq);
    4ad9:	ba 01 00 00 00       	mov    $0x1,%edx
		if (irq_mask & (1 << irq)) {
    4ade:	d3 e0                	shl    %cl,%eax
		irq_premask |= ((uint64_t)1<<irq);
    4ae0:	48 d3 e2             	shl    %cl,%rdx
    4ae3:	48 09 15 ce 90 00 00 	or     %rdx,0x90ce(%rip)        # dbb8 <irq_premask>
		if (irq_mask & (1 << irq)) {
    4aea:	48 98                	cltq   
    4aec:	48 85 05 bd 90 00 00 	test   %rax,0x90bd(%rip)        # dbb0 <irq_mask>
    4af3:	74 17                	je     4b0c <hw_irq_ctrl_irq_raise_prefix+0x3f>
			irq_status |= ((uint64_t)1<<irq);
    4af5:	48 09 15 c4 90 00 00 	or     %rdx,0x90c4(%rip)        # dbc0 <irq_status>
    4afc:	c3                   	retq   
	} else if (irq == PHONY_HARD_IRQ) {
    4afd:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
    4b03:	75 07                	jne    4b0c <hw_irq_ctrl_irq_raise_prefix+0x3f>
		lock_ignore = true;
    4b05:	c6 05 50 91 00 00 01 	movb   $0x1,0x9150(%rip)        # dc5c <lock_ignore>
}
    4b0c:	c3                   	retq   

0000000000004b0d <hw_irq_ctrl_init>:
{
    4b0d:	f3 0f 1e fa          	endbr64 
	irqs_locked = false;
    4b11:	c6 05 45 91 00 00 00 	movb   $0x0,0x9145(%rip)        # dc5d <irqs_locked>
    4b18:	48 8d 05 61 8e 00 00 	lea    0x8e61(%rip),%rax        # d980 <irq_prio>
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    4b1f:	48 c7 05 86 90 00 00 	movq   $0x0,0x9086(%rip)        # dbb0 <irq_mask>
    4b26:	00 00 00 00 
	irq_premask = 0U;
    4b2a:	48 8d 50 20          	lea    0x20(%rax),%rdx
    4b2e:	48 c7 05 7f 90 00 00 	movq   $0x0,0x907f(%rip)        # dbb8 <irq_premask>
    4b35:	00 00 00 00 
	lock_ignore = false;
    4b39:	c6 05 1c 91 00 00 00 	movb   $0x0,0x911c(%rip)        # dc5c <lock_ignore>
		irq_prio[i] = 255U;
    4b40:	c6 00 ff             	movb   $0xff,(%rax)
	for (int i = 0 ; i < N_IRQS; i++) {
    4b43:	48 ff c0             	inc    %rax
    4b46:	48 39 d0             	cmp    %rdx,%rax
    4b49:	75 f5                	jne    4b40 <hw_irq_ctrl_init+0x33>
}
    4b4b:	c3                   	retq   

0000000000004b4c <hw_irq_ctrl_cleanup>:
{
    4b4c:	f3 0f 1e fa          	endbr64 
}
    4b50:	c3                   	retq   

0000000000004b51 <hw_irq_ctrl_set_cur_prio>:
{
    4b51:	f3 0f 1e fa          	endbr64 
	currently_running_prio = new;
    4b55:	89 3d fd 68 00 00    	mov    %edi,0x68fd(%rip)        # b458 <currently_running_prio>
}
    4b5b:	c3                   	retq   

0000000000004b5c <hw_irq_ctrl_get_cur_prio>:
{
    4b5c:	f3 0f 1e fa          	endbr64 
}
    4b60:	8b 05 f2 68 00 00    	mov    0x68f2(%rip),%eax        # b458 <currently_running_prio>
    4b66:	c3                   	retq   

0000000000004b67 <hw_irq_ctrl_prio_set>:
{
    4b67:	f3 0f 1e fa          	endbr64 
	irq_prio[irq] = prio;
    4b6b:	89 ff                	mov    %edi,%edi
    4b6d:	48 8d 05 0c 8e 00 00 	lea    0x8e0c(%rip),%rax        # d980 <irq_prio>
    4b74:	40 88 34 38          	mov    %sil,(%rax,%rdi,1)
}
    4b78:	c3                   	retq   

0000000000004b79 <hw_irq_ctrl_get_prio>:
{
    4b79:	f3 0f 1e fa          	endbr64 
	return irq_prio[irq];
    4b7d:	89 ff                	mov    %edi,%edi
    4b7f:	48 8d 05 fa 8d 00 00 	lea    0x8dfa(%rip),%rax        # d980 <irq_prio>
    4b86:	8a 04 38             	mov    (%rax,%rdi,1),%al
}
    4b89:	c3                   	retq   

0000000000004b8a <hw_irq_ctrl_get_current_lock>:
{
    4b8a:	f3 0f 1e fa          	endbr64 
	return irqs_locked;
    4b8e:	0f b6 05 c8 90 00 00 	movzbl 0x90c8(%rip),%eax        # dc5d <irqs_locked>
}
    4b95:	c3                   	retq   

0000000000004b96 <hw_irq_ctrl_change_lock>:
{
    4b96:	f3 0f 1e fa          	endbr64 
	irqs_locked = new_lock;
    4b9a:	85 ff                	test   %edi,%edi
{
    4b9c:	41 54                	push   %r12
	uint32_t previous_lock = irqs_locked;
    4b9e:	44 0f b6 25 b7 90 00 	movzbl 0x90b7(%rip),%r12d        # dc5d <irqs_locked>
    4ba5:	00 
	irqs_locked = new_lock;
    4ba6:	0f 95 05 b0 90 00 00 	setne  0x90b0(%rip)        # dc5d <irqs_locked>
	if ((previous_lock == true) && (new_lock == false)) {
    4bad:	75 14                	jne    4bc3 <hw_irq_ctrl_change_lock+0x2d>
    4baf:	45 84 e4             	test   %r12b,%r12b
    4bb2:	74 0f                	je     4bc3 <hw_irq_ctrl_change_lock+0x2d>
		if (irq_status != 0U) {
    4bb4:	48 83 3d 04 90 00 00 	cmpq   $0x0,0x9004(%rip)        # dbc0 <irq_status>
    4bbb:	00 
    4bbc:	74 05                	je     4bc3 <hw_irq_ctrl_change_lock+0x2d>
			posix_irq_handler_im_from_sw();
    4bbe:	e8 60 fe ff ff       	callq  4a23 <posix_irq_handler_im_from_sw>
}
    4bc3:	44 89 e0             	mov    %r12d,%eax
    4bc6:	41 5c                	pop    %r12
    4bc8:	c3                   	retq   

0000000000004bc9 <hw_irq_ctrl_get_irq_status>:
{
    4bc9:	f3 0f 1e fa          	endbr64 
}
    4bcd:	48 8b 05 ec 8f 00 00 	mov    0x8fec(%rip),%rax        # dbc0 <irq_status>
    4bd4:	c3                   	retq   

0000000000004bd5 <hw_irq_ctrl_get_highest_prio_irq>:
{
    4bd5:	f3 0f 1e fa          	endbr64 
	if (irqs_locked) {
    4bd9:	80 3d 7d 90 00 00 00 	cmpb   $0x0,0x907d(%rip)        # dc5d <irqs_locked>
    4be0:	75 55                	jne    4c37 <hw_irq_ctrl_get_highest_prio_irq+0x62>
{
    4be2:	51                   	push   %rcx
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
    4be3:	e8 e1 ff ff ff       	callq  4bc9 <hw_irq_ctrl_get_irq_status>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    4be8:	8b 3d 6a 68 00 00    	mov    0x686a(%rip),%edi        # b458 <currently_running_prio>
	int winner_prio = 256;
    4bee:	be 00 01 00 00       	mov    $0x100,%esi
	int winner = -1;
    4bf3:	41 83 c8 ff          	or     $0xffffffff,%r8d
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	return __builtin_ffs(op);
    4bf7:	41 83 c9 ff          	or     $0xffffffff,%r9d
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    4bfb:	41 ba 01 00 00 00    	mov    $0x1,%r10d
		if ((winner_prio > (int)irq_prio[irq_nbr])
    4c01:	4c 8d 1d 78 8d 00 00 	lea    0x8d78(%rip),%r11        # d980 <irq_prio>
	while (irq_status != 0U) {
    4c08:	48 85 c0             	test   %rax,%rax
    4c0b:	74 32                	je     4c3f <hw_irq_ctrl_get_highest_prio_irq+0x6a>
    4c0d:	0f bc c8             	bsf    %eax,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    4c10:	4c 89 d2             	mov    %r10,%rdx
		int irq_nbr = find_lsb_set(irq_status) - 1;
    4c13:	41 0f 44 c9          	cmove  %r9d,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    4c17:	48 d3 e2             	shl    %cl,%rdx
    4c1a:	48 f7 d2             	not    %rdx
    4c1d:	48 21 d0             	and    %rdx,%rax
		if ((winner_prio > (int)irq_prio[irq_nbr])
    4c20:	48 63 d1             	movslq %ecx,%rdx
    4c23:	41 0f b6 14 13       	movzbl (%r11,%rdx,1),%edx
    4c28:	39 f2                	cmp    %esi,%edx
    4c2a:	7d dc                	jge    4c08 <hw_irq_ctrl_get_highest_prio_irq+0x33>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    4c2c:	39 fa                	cmp    %edi,%edx
    4c2e:	0f 4c f2             	cmovl  %edx,%esi
    4c31:	44 0f 4c c1          	cmovl  %ecx,%r8d
    4c35:	eb d1                	jmp    4c08 <hw_irq_ctrl_get_highest_prio_irq+0x33>
    4c37:	41 83 c8 ff          	or     $0xffffffff,%r8d
}
    4c3b:	44 89 c0             	mov    %r8d,%eax
    4c3e:	c3                   	retq   
    4c3f:	44 89 c0             	mov    %r8d,%eax
    4c42:	5a                   	pop    %rdx
    4c43:	c3                   	retq   

0000000000004c44 <hw_irq_ctrl_clear_irq>:
{
    4c44:	f3 0f 1e fa          	endbr64 
	irq_status  &= ~((uint64_t)1<<irq);
    4c48:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    4c4f:	89 f9                	mov    %edi,%ecx
    4c51:	48 d3 c0             	rol    %cl,%rax
    4c54:	48 21 05 65 8f 00 00 	and    %rax,0x8f65(%rip)        # dbc0 <irq_status>
	irq_premask &= ~((uint64_t)1<<irq);
    4c5b:	48 21 05 56 8f 00 00 	and    %rax,0x8f56(%rip)        # dbb8 <irq_premask>
}
    4c62:	c3                   	retq   

0000000000004c63 <hw_irq_ctrl_set_irq>:
{
    4c63:	f3 0f 1e fa          	endbr64 
    4c67:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    4c68:	e8 60 fe ff ff       	callq  4acd <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    4c6d:	80 3d e9 8f 00 00 00 	cmpb   $0x0,0x8fe9(%rip)        # dc5d <irqs_locked>
    4c74:	74 09                	je     4c7f <hw_irq_ctrl_set_irq+0x1c>
    4c76:	80 3d df 8f 00 00 00 	cmpb   $0x0,0x8fdf(%rip)        # dc5c <lock_ignore>
    4c7d:	74 15                	je     4c94 <hw_irq_ctrl_set_irq+0x31>
		irq_ctrl_timer = hwm_get_time();
    4c7f:	e8 71 f7 ff ff       	callq  43f5 <hwm_get_time>
    4c84:	48 8d 15 b5 67 00 00 	lea    0x67b5(%rip),%rdx        # b440 <irq_ctrl_timer>
    4c8b:	48 89 02             	mov    %rax,(%rdx)
}
    4c8e:	5a                   	pop    %rdx
		hwm_find_next_timer();
    4c8f:	e9 28 f6 ff ff       	jmpq   42bc <hwm_find_next_timer>
}
    4c94:	58                   	pop    %rax
    4c95:	c3                   	retq   

0000000000004c96 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    4c96:	f3 0f 1e fa          	endbr64 
    4c9a:	51                   	push   %rcx
	hw_irq_ctrl_irq_raise_prefix(irq);
    4c9b:	e8 2d fe ff ff       	callq  4acd <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    4ca0:	80 3d b6 8f 00 00 00 	cmpb   $0x0,0x8fb6(%rip)        # dc5d <irqs_locked>
    4ca7:	75 06                	jne    4caf <hw_irq_ctrl_raise_im_from_sw+0x19>
		posix_irq_handler_im_from_sw();
	}
}
    4ca9:	5a                   	pop    %rdx
		posix_irq_handler_im_from_sw();
    4caa:	e9 74 fd ff ff       	jmpq   4a23 <posix_irq_handler_im_from_sw>
}
    4caf:	58                   	pop    %rax
    4cb0:	c3                   	retq   

0000000000004cb1 <hw_irq_ctrl_enable_irq>:
{
    4cb1:	f3 0f 1e fa          	endbr64 
	irq_mask |= ((uint64_t)1<<irq);
    4cb5:	b8 01 00 00 00       	mov    $0x1,%eax
    4cba:	89 f9                	mov    %edi,%ecx
    4cbc:	48 d3 e0             	shl    %cl,%rax
    4cbf:	48 09 05 ea 8e 00 00 	or     %rax,0x8eea(%rip)        # dbb0 <irq_mask>
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    4cc6:	48 8b 05 eb 8e 00 00 	mov    0x8eeb(%rip),%rax        # dbb8 <irq_premask>
    4ccd:	48 0f a3 f8          	bt     %rdi,%rax
    4cd1:	73 05                	jae    4cd8 <hw_irq_ctrl_enable_irq+0x27>
		hw_irq_ctrl_raise_im_from_sw(irq);
    4cd3:	e9 be ff ff ff       	jmpq   4c96 <hw_irq_ctrl_raise_im_from_sw>
}
    4cd8:	c3                   	retq   

0000000000004cd9 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
    4cd9:	f3 0f 1e fa          	endbr64 
	irq_ctrl_timer = NEVER;
    4cdd:	48 8d 05 5c 67 00 00 	lea    0x675c(%rip),%rax        # b440 <irq_ctrl_timer>
    4ce4:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	irq_raising_from_hw_now();
    4ceb:	e9 be fd ff ff       	jmpq   4aae <irq_raising_from_hw_now>

0000000000004cf0 <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    4cf0:	f3 0f 1e fa          	endbr64 
    4cf4:	50                   	push   %rax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    4cf5:	39 3d 39 8f 00 00    	cmp    %edi,0x8f39(%rip)        # dc34 <max_exit_code.2396>
    4cfb:	0f 4d 3d 32 8f 00 00 	cmovge 0x8f32(%rip),%edi        # dc34 <max_exit_code.2396>
    4d02:	89 3d 2c 8f 00 00    	mov    %edi,0x8f2c(%rip)        # dc34 <max_exit_code.2396>
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    4d08:	e8 43 f4 ff ff       	callq  4150 <posix_soc_clean_up>
	hwm_cleanup();
    4d0d:	e8 0e f7 ff ff       	callq  4420 <hwm_cleanup>
	native_cleanup_cmd_line();
    4d12:	e8 10 0b 00 00       	callq  5827 <native_cleanup_cmd_line>
	exit(max_exit_code);
    4d17:	8b 3d 17 8f 00 00    	mov    0x8f17(%rip),%edi        # dc34 <max_exit_code.2396>
    4d1d:	e8 1e d9 ff ff       	callq  2640 <exit@plt>

0000000000004d22 <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    4d22:	f3 0f 1e fa          	endbr64 
    4d26:	55                   	push   %rbp
    4d27:	89 fd                	mov    %edi,%ebp
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    4d29:	31 ff                	xor    %edi,%edi
{
    4d2b:	48 83 ec 10          	sub    $0x10,%rsp
    4d2f:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    4d34:	e8 dd f3 ff ff       	callq  4116 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
    4d39:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    4d3e:	89 ef                	mov    %ebp,%edi
    4d40:	e8 bd 0b 00 00       	callq  5902 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    4d45:	bf 01 00 00 00       	mov    $0x1,%edi
    4d4a:	e8 c7 f3 ff ff       	callq  4116 <run_native_tasks>

	hwm_init();
    4d4f:	e8 ad f6 ff ff       	callq  4401 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    4d54:	bf 02 00 00 00       	mov    $0x2,%edi
    4d59:	e8 b8 f3 ff ff       	callq  4116 <run_native_tasks>

	posix_boot_cpu();
    4d5e:	e8 f2 f2 ff ff       	callq  4055 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    4d63:	bf 03 00 00 00       	mov    $0x3,%edi
    4d68:	e8 a9 f3 ff ff       	callq  4116 <run_native_tasks>

	hwm_main_loop();
    4d6d:	e8 ae f5 ff ff       	callq  4320 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    4d72:	48 83 c4 10          	add    $0x10,%rsp
    4d76:	b8 01 00 00 00       	mov    $0x1,%eax
    4d7b:	5d                   	pop    %rbp
    4d7c:	c3                   	retq   

0000000000004d7d <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
    4d7d:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 0;
    4d81:	48 c7 05 bc 66 00 00 	movq   $0x0,0x66bc(%rip)        # b448 <is_a_tty>
    4d88:	00 00 00 00 
	is_a_tty[1] = 0;
}
    4d8c:	c3                   	retq   

0000000000004d8d <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
    4d8d:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = -1;
    4d91:	48 c7 05 ac 66 00 00 	movq   $0xffffffffffffffff,0x66ac(%rip)        # b448 <is_a_tty>
    4d98:	ff ff ff ff 
	is_a_tty[1] = -1;

}
    4d9c:	c3                   	retq   

0000000000004d9d <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
    4d9d:	f3 0f 1e fa          	endbr64 
	is_a_tty[0] = 1;
    4da1:	48 b8 01 00 00 00 01 	movabs $0x100000001,%rax
    4da8:	00 00 00 
    4dab:	48 89 05 96 66 00 00 	mov    %rax,0x6696(%rip)        # b448 <is_a_tty>
	is_a_tty[1] = 1;
}
    4db2:	c3                   	retq   

0000000000004db3 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    4db3:	f3 0f 1e fa          	endbr64 
    4db7:	52                   	push   %rdx
	if (is_a_tty[0] == -1) {
    4db8:	83 3d 89 66 00 00 ff 	cmpl   $0xffffffff,0x6689(%rip)        # b448 <is_a_tty>
    4dbf:	75 10                	jne    4dd1 <decide_about_color+0x1e>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    4dc1:	bf 01 00 00 00       	mov    $0x1,%edi
    4dc6:	e8 55 d6 ff ff       	callq  2420 <isatty@plt>
    4dcb:	89 05 77 66 00 00    	mov    %eax,0x6677(%rip)        # b448 <is_a_tty>
	}
	if (is_a_tty[1] == -1) {
    4dd1:	83 3d 74 66 00 00 ff 	cmpl   $0xffffffff,0x6674(%rip)        # b44c <is_a_tty+0x4>
    4dd8:	75 10                	jne    4dea <decide_about_color+0x37>
		is_a_tty[1] = isatty(STDERR_FILENO);
    4dda:	bf 02 00 00 00       	mov    $0x2,%edi
    4ddf:	e8 3c d6 ff ff       	callq  2420 <isatty@plt>
    4de4:	89 05 62 66 00 00    	mov    %eax,0x6662(%rip)        # b44c <is_a_tty+0x4>
	}
}
    4dea:	58                   	pop    %rax
    4deb:	c3                   	retq   

0000000000004dec <posix_print_error_and_exit>:
{
    4dec:	f3 0f 1e fa          	endbr64 
    4df0:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4df7:	49 89 fa             	mov    %rdi,%r10
    4dfa:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    4dff:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4e04:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    4e09:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    4e0e:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    4e13:	84 c0                	test   %al,%al
    4e15:	74 37                	je     4e4e <posix_print_error_and_exit+0x62>
    4e17:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    4e1c:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    4e21:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    4e26:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    4e2d:	00 
    4e2e:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    4e35:	00 
    4e36:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    4e3d:	00 
    4e3e:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4e45:	00 
    4e46:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    4e4d:	00 
    4e4e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4e55:	00 00 
    4e57:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4e5c:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    4e5e:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    4e65:	00 

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    4e66:	48 89 e1             	mov    %rsp,%rcx
    4e69:	4c 89 d2             	mov    %r10,%rdx
    4e6c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4e71:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    4e76:	be 01 00 00 00       	mov    $0x1,%esi
    4e7b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    4e80:	48 8b 05 61 61 00 00 	mov    0x6161(%rip),%rax        # afe8 <stderr@GLIBC_2.2.5>
    4e87:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    4e8e:	48 8b 38             	mov    (%rax),%rdi
    4e91:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    4e98:	00 
    4e99:	e8 42 d5 ff ff       	callq  23e0 <__vfprintf_chk@plt>
	posix_exit(1);
    4e9e:	bf 01 00 00 00       	mov    $0x1,%edi
    4ea3:	e8 48 fe ff ff       	callq  4cf0 <posix_exit>
}
    4ea8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    4ead:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4eb4:	00 00 
    4eb6:	74 05                	je     4ebd <posix_print_error_and_exit+0xd1>
    4eb8:	e8 e3 d5 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    4ebd:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    4ec4:	c3                   	retq   

0000000000004ec5 <posix_print_warning>:
{
    4ec5:	f3 0f 1e fa          	endbr64 
    4ec9:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4ed0:	49 89 fa             	mov    %rdi,%r10
    4ed3:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    4ed8:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4edd:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    4ee2:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    4ee7:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    4eec:	84 c0                	test   %al,%al
    4eee:	74 37                	je     4f27 <posix_print_warning+0x62>
    4ef0:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    4ef5:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    4efa:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    4eff:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    4f06:	00 
    4f07:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    4f0e:	00 
    4f0f:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    4f16:	00 
    4f17:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4f1e:	00 
    4f1f:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    4f26:	00 
    4f27:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4f2e:	00 00 
    4f30:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4f35:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    4f37:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    4f3e:	00 
    4f3f:	48 89 e1             	mov    %rsp,%rcx
    4f42:	4c 89 d2             	mov    %r10,%rdx
    4f45:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    4f4a:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    4f4f:	be 01 00 00 00       	mov    $0x1,%esi
    4f54:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    4f59:	48 8b 05 88 60 00 00 	mov    0x6088(%rip),%rax        # afe8 <stderr@GLIBC_2.2.5>
    4f60:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    4f67:	48 8b 38             	mov    (%rax),%rdi
    4f6a:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    4f71:	00 
    4f72:	e8 69 d4 ff ff       	callq  23e0 <__vfprintf_chk@plt>
}
    4f77:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    4f7c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4f83:	00 00 
    4f85:	74 05                	je     4f8c <posix_print_warning+0xc7>
    4f87:	e8 14 d5 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    4f8c:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    4f93:	c3                   	retq   

0000000000004f94 <posix_print_trace>:
{
    4f94:	f3 0f 1e fa          	endbr64 
    4f98:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4f9f:	49 89 fa             	mov    %rdi,%r10
    4fa2:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    4fa7:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4fac:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    4fb1:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    4fb6:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    4fbb:	84 c0                	test   %al,%al
    4fbd:	74 37                	je     4ff6 <posix_print_trace+0x62>
    4fbf:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    4fc4:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    4fc9:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    4fce:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    4fd5:	00 
    4fd6:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    4fdd:	00 
    4fde:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    4fe5:	00 
    4fe6:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    4fed:	00 
    4fee:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    4ff5:	00 
    4ff6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4ffd:	00 00 
    4fff:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5004:	31 c0                	xor    %eax,%eax
	va_start(variable_args, format);
    5006:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    500d:	00 
    500e:	48 89 e1             	mov    %rsp,%rcx
    5011:	4c 89 d2             	mov    %r10,%rdx
    5014:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    5019:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    501e:	be 01 00 00 00       	mov    $0x1,%esi
    5023:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    5028:	48 8b 05 71 5f 00 00 	mov    0x5f71(%rip),%rax        # afa0 <stdout@GLIBC_2.2.5>
    502f:	c7 04 24 08 00 00 00 	movl   $0x8,(%rsp)
    5036:	48 8b 38             	mov    (%rax),%rdi
    5039:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    5040:	00 
    5041:	e8 9a d3 ff ff       	callq  23e0 <__vfprintf_chk@plt>
}
    5046:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    504b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5052:	00 00 
    5054:	74 05                	je     505b <posix_print_trace+0xc7>
    5056:	e8 45 d4 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    505b:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5062:	c3                   	retq   

0000000000005063 <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
    5063:	f3 0f 1e fa          	endbr64 
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    5067:	48 8d 3d 52 61 00 00 	lea    0x6152(%rip),%rdi        # b1c0 <trace_options.3560>
    506e:	e9 d8 07 00 00       	jmpq   584b <native_add_command_line_opts>

0000000000005073 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    5073:	41 55                	push   %r13
    5075:	41 bd 46 00 00 00    	mov    $0x46,%r13d
    507b:	41 54                	push   %r12
    507d:	49 89 f4             	mov    %rsi,%r12
    5080:	55                   	push   %rbp
    5081:	48 89 fd             	mov    %rdi,%rbp
    5084:	53                   	push   %rbx
    5085:	41 53                	push   %r11

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    5087:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
    508b:	75 0c                	jne    5099 <cmd_gen_switch_syntax.constprop.0+0x26>
		*buf++ = '[';
    508d:	c6 07 5b             	movb   $0x5b,(%rdi)
    5090:	48 ff c5             	inc    %rbp
		size--;
    5093:	41 bd 45 00 00 00    	mov    $0x45,%r13d
	}

	if (args_s_el->is_switch == true) {
    5099:	41 80 7c 24 02 00    	cmpb   $0x0,0x2(%r12)
    509f:	4d 8b 4c 24 08       	mov    0x8(%r12),%r9
    50a4:	49 63 f5             	movslq %r13d,%rsi
    50a7:	74 1c                	je     50c5 <cmd_gen_switch_syntax.constprop.0+0x52>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    50a9:	4c 8d 05 e0 3a 00 00 	lea    0x3ae0(%rip),%r8        # 8b90 <default_cmd+0xb70>
    50b0:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    50b4:	48 89 ef             	mov    %rbp,%rdi
    50b7:	31 c0                	xor    %eax,%eax
    50b9:	ba 01 00 00 00       	mov    $0x1,%edx
    50be:	e8 cd d2 ff ff       	callq  2390 <__snprintf_chk@plt>
    50c3:	eb 38                	jmp    50fd <cmd_gen_switch_syntax.constprop.0+0x8a>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
    50c5:	41 80 7c 24 18 6c    	cmpb   $0x6c,0x18(%r12)
    50cb:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    50d0:	74 0c                	je     50de <cmd_gen_switch_syntax.constprop.0+0x6b>
    50d2:	4c 8d 05 bb 3a 00 00 	lea    0x3abb(%rip),%r8        # 8b94 <default_cmd+0xb74>
    50d9:	41 52                	push   %r10
    50db:	50                   	push   %rax
    50dc:	eb 0a                	jmp    50e8 <cmd_gen_switch_syntax.constprop.0+0x75>
    50de:	41 50                	push   %r8
    50e0:	4c 8d 05 b6 3a 00 00 	lea    0x3ab6(%rip),%r8        # 8b9d <default_cmd+0xb7d>
    50e7:	50                   	push   %rax
    50e8:	48 89 ef             	mov    %rbp,%rdi
    50eb:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    50ef:	ba 01 00 00 00       	mov    $0x1,%edx
    50f4:	31 c0                	xor    %eax,%eax
    50f6:	e8 95 d2 ff ff       	callq  2390 <__snprintf_chk@plt>
    50fb:	5e                   	pop    %rsi
    50fc:	5f                   	pop    %rdi
    50fd:	48 63 d8             	movslq %eax,%rbx
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    5100:	85 db                	test   %ebx,%ebx
    5102:	79 1a                	jns    511e <cmd_gen_switch_syntax.constprop.0+0xab>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    5104:	ba 07 01 00 00       	mov    $0x107,%edx
    5109:	48 8d 35 99 3a 00 00 	lea    0x3a99(%rip),%rsi        # 8ba9 <default_cmd+0xb89>
    5110:	48 8d 3d d0 3a 00 00 	lea    0x3ad0(%rip),%rdi        # 8be7 <default_cmd+0xbc7>
    5117:	31 c0                	xor    %eax,%eax
    5119:	e8 ce fc ff ff       	callq  4dec <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    511e:	41 29 dd             	sub    %ebx,%r13d
    5121:	78 2c                	js     514f <cmd_gen_switch_syntax.constprop.0+0xdc>
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    5123:	41 80 7c 24 01 00    	cmpb   $0x0,0x1(%r12)
	buf += ret;
    5129:	48 8d 7c 1d 00       	lea    0x0(%rbp,%rbx,1),%rdi
	if (args_s_el->is_mandatory == false) {
    512e:	49 63 f5             	movslq %r13d,%rsi
    5131:	48 8d 15 ca 3a 00 00 	lea    0x3aca(%rip),%rdx        # 8c02 <default_cmd+0xbe2>
    5138:	74 07                	je     5141 <cmd_gen_switch_syntax.constprop.0+0xce>
    513a:	48 8d 15 c2 3a 00 00 	lea    0x3ac2(%rip),%rdx        # 8c03 <default_cmd+0xbe3>
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    5141:	59                   	pop    %rcx
    5142:	31 c0                	xor    %eax,%eax
    5144:	5b                   	pop    %rbx
    5145:	5d                   	pop    %rbp
    5146:	41 5c                	pop    %r12
    5148:	41 5d                	pop    %r13
    514a:	e9 71 d3 ff ff       	jmpq   24c0 <snprintf@plt>
    514f:	58                   	pop    %rax
    5150:	5b                   	pop    %rbx
    5151:	5d                   	pop    %rbp
    5152:	41 5c                	pop    %r12
    5154:	41 5d                	pop    %r13
    5156:	c3                   	retq   

0000000000005157 <cmd_is_option>:
{
    5157:	f3 0f 1e fa          	endbr64 
    515b:	41 54                	push   %r12
    515d:	49 89 f8             	mov    %rdi,%r8
    5160:	41 89 d4             	mov    %edx,%r12d
    5163:	55                   	push   %rbp
    5164:	48 89 f5             	mov    %rsi,%rbp
    5167:	53                   	push   %rbx
	int of = 0;
    5168:	31 db                	xor    %ebx,%ebx
    516a:	80 3f 2d             	cmpb   $0x2d,(%rdi)
	if (arg[of] == '-') {
    516d:	0f 94 c0             	sete   %al
	int of = 0;
    5170:	0f 94 c3             	sete   %bl
	if (arg[of] == '-') {
    5173:	0f b6 c0             	movzbl %al,%eax
    5176:	80 3c 07 2d          	cmpb   $0x2d,(%rdi,%rax,1)
    517a:	75 02                	jne    517e <cmd_is_option+0x27>
		of++;
    517c:	ff c3                	inc    %ebx
	if (!with_value) {
    517e:	45 85 e4             	test   %r12d,%r12d
    5181:	75 28                	jne    51ab <cmd_is_option+0x54>
		if (strcmp(&arg[of], option) != 0) {
    5183:	48 63 fb             	movslq %ebx,%rdi
    5186:	48 89 ee             	mov    %rbp,%rsi
    5189:	4c 01 c7             	add    %r8,%rdi
    518c:	e8 9f d3 ff ff       	callq  2530 <strcmp@plt>
    5191:	85 c0                	test   %eax,%eax
    5193:	75 68                	jne    51fd <cmd_is_option+0xa6>
	size_t to_match_len = strlen(option);
    5195:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    5199:	48 89 ef             	mov    %rbp,%rdi
    519c:	f2 ae                	repnz scas %es:(%rdi),%al
    519e:	48 89 c8             	mov    %rcx,%rax
    51a1:	48 f7 d0             	not    %rax
			return of + to_match_len;
    51a4:	44 8d 64 03 ff       	lea    -0x1(%rbx,%rax,1),%r12d
    51a9:	eb 52                	jmp    51fd <cmd_is_option+0xa6>
    51ab:	31 d2                	xor    %edx,%edx
    51ad:	44 8d 24 13          	lea    (%rbx,%rdx,1),%r12d
	while (!(arg[of] == 0 && *option == 0)) {
    51b1:	8a 4c 15 00          	mov    0x0(%rbp,%rdx,1),%cl
    51b5:	49 63 c4             	movslq %r12d,%rax
    51b8:	41 8a 04 00          	mov    (%r8,%rax,1),%al
    51bc:	89 c6                	mov    %eax,%esi
    51be:	40 08 ce             	or     %cl,%sil
    51c1:	74 24                	je     51e7 <cmd_is_option+0x90>
		if (*option == 0) {
    51c3:	84 c9                	test   %cl,%cl
    51c5:	75 17                	jne    51de <cmd_is_option+0x87>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    51c7:	3c 3a                	cmp    $0x3a,%al
    51c9:	74 04                	je     51cf <cmd_is_option+0x78>
    51cb:	3c 3d                	cmp    $0x3d,%al
    51cd:	75 2b                	jne    51fa <cmd_is_option+0xa3>
				of++;
    51cf:	41 ff c4             	inc    %r12d
	if (arg[of] == 0) { /* we need a value to follow */
    51d2:	49 63 c4             	movslq %r12d,%rax
    51d5:	41 80 3c 00 00       	cmpb   $0x0,(%r8,%rax,1)
    51da:	75 21                	jne    51fd <cmd_is_option+0xa6>
    51dc:	eb 09                	jmp    51e7 <cmd_is_option+0x90>
		if (arg[of] != *option) {
    51de:	48 ff c2             	inc    %rdx
    51e1:	38 c8                	cmp    %cl,%al
    51e3:	74 c8                	je     51ad <cmd_is_option+0x56>
    51e5:	eb 13                	jmp    51fa <cmd_is_option+0xa3>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    51e7:	4c 89 c6             	mov    %r8,%rsi
    51ea:	48 8d 3d 14 3a 00 00 	lea    0x3a14(%rip),%rdi        # 8c05 <default_cmd+0xbe5>
    51f1:	31 c0                	xor    %eax,%eax
    51f3:	e8 f4 fb ff ff       	callq  4dec <posix_print_error_and_exit>
    51f8:	eb 03                	jmp    51fd <cmd_is_option+0xa6>
			return 0;
    51fa:	45 31 e4             	xor    %r12d,%r12d
}
    51fd:	44 89 e0             	mov    %r12d,%eax
    5200:	5b                   	pop    %rbx
    5201:	5d                   	pop    %rbp
    5202:	41 5c                	pop    %r12
    5204:	c3                   	retq   

0000000000005205 <cmd_is_help_option>:
{
    5205:	f3 0f 1e fa          	endbr64 
    5209:	55                   	push   %rbp
	if (arg[0] == '-') {
    520a:	80 3f 2d             	cmpb   $0x2d,(%rdi)
{
    520d:	48 89 fd             	mov    %rdi,%rbp
	if (arg[0] == '-') {
    5210:	75 0f                	jne    5221 <cmd_is_help_option+0x1c>
	if (arg[0] == '-') {
    5212:	80 7f 01 2d          	cmpb   $0x2d,0x1(%rdi)
    5216:	74 05                	je     521d <cmd_is_help_option+0x18>
		arg++;
    5218:	48 ff c5             	inc    %rbp
    521b:	eb 04                	jmp    5221 <cmd_is_help_option+0x1c>
		arg++;
    521d:	48 83 c5 02          	add    $0x2,%rbp
	if ((strcasecmp(arg, "?") == 0) ||
    5221:	48 8d 35 37 3a 00 00 	lea    0x3a37(%rip),%rsi        # 8c5f <default_cmd+0xc3f>
    5228:	48 89 ef             	mov    %rbp,%rdi
    522b:	e8 90 d1 ff ff       	callq  23c0 <strcasecmp@plt>
    5230:	41 89 c0             	mov    %eax,%r8d
		return 1;
    5233:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    5238:	45 85 c0             	test   %r8d,%r8d
    523b:	74 33                	je     5270 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
    523d:	48 8d 35 1d 3a 00 00 	lea    0x3a1d(%rip),%rsi        # 8c61 <default_cmd+0xc41>
    5244:	48 89 ef             	mov    %rbp,%rdi
    5247:	e8 74 d1 ff ff       	callq  23c0 <strcasecmp@plt>
    524c:	41 89 c0             	mov    %eax,%r8d
		return 1;
    524f:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    5254:	45 85 c0             	test   %r8d,%r8d
    5257:	74 17                	je     5270 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
    5259:	48 8d 35 a1 3a 00 00 	lea    0x3aa1(%rip),%rsi        # 8d01 <default_cmd+0xce1>
    5260:	48 89 ef             	mov    %rbp,%rdi
    5263:	e8 58 d1 ff ff       	callq  23c0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
    5268:	85 c0                	test   %eax,%eax
    526a:	0f 94 c0             	sete   %al
    526d:	0f b6 c0             	movzbl %al,%eax
}
    5270:	5d                   	pop    %rbp
    5271:	c3                   	retq   

0000000000005272 <cmd_read_option_value>:
{
    5272:	f3 0f 1e fa          	endbr64 
    5276:	41 54                	push   %r12
    5278:	49 89 fc             	mov    %rdi,%r12
    527b:	55                   	push   %rbp
    527c:	48 89 cd             	mov    %rcx,%rbp
    527f:	53                   	push   %rbx
    5280:	48 89 f3             	mov    %rsi,%rbx
    5283:	48 83 ec 10          	sub    $0x10,%rsp
    5287:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    528e:	00 00 
    5290:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    5295:	31 c0                	xor    %eax,%eax
	char *endptr = NULL;
    5297:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    529e:	00 
	switch (type) {
    529f:	80 fa 64             	cmp    $0x64,%dl
    52a2:	0f 84 11 01 00 00    	je     53b9 <cmd_read_option_value+0x147>
    52a8:	7f 26                	jg     52d0 <cmd_read_option_value+0x5e>
    52aa:	80 fa 55             	cmp    $0x55,%dl
    52ad:	0f 84 f1 00 00 00    	je     53a4 <cmd_read_option_value+0x132>
    52b3:	80 fa 62             	cmp    $0x62,%dl
    52b6:	74 42                	je     52fa <cmd_read_option_value+0x88>
    52b8:	80 fa 49             	cmp    $0x49,%dl
    52bb:	0f 85 06 01 00 00    	jne    53c7 <cmd_read_option_value+0x155>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    52c1:	48 89 e6             	mov    %rsp,%rsi
    52c4:	31 d2                	xor    %edx,%edx
    52c6:	e8 75 d2 ff ff       	callq  2540 <strtoll@plt>
    52cb:	e9 e4 00 00 00       	jmpq   53b4 <cmd_read_option_value+0x142>
	switch (type) {
    52d0:	80 fa 73             	cmp    $0x73,%dl
    52d3:	0f 84 aa 00 00 00    	je     5383 <cmd_read_option_value+0x111>
    52d9:	80 fa 75             	cmp    $0x75,%dl
    52dc:	0f 84 b6 00 00 00    	je     5398 <cmd_read_option_value+0x126>
    52e2:	80 fa 69             	cmp    $0x69,%dl
    52e5:	0f 85 dc 00 00 00    	jne    53c7 <cmd_read_option_value+0x155>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    52eb:	48 89 e6             	mov    %rsp,%rsi
    52ee:	31 d2                	xor    %edx,%edx
    52f0:	e8 7b d2 ff ff       	callq  2570 <strtol@plt>
    52f5:	e9 b6 00 00 00       	jmpq   53b0 <cmd_read_option_value+0x13e>
		if (strcasecmp(str, "false") == 0) {
    52fa:	48 8d 35 62 39 00 00 	lea    0x3962(%rip),%rsi        # 8c63 <default_cmd+0xc43>
    5301:	e8 ba d0 ff ff       	callq  23c0 <strcasecmp@plt>
    5306:	85 c0                	test   %eax,%eax
    5308:	75 0a                	jne    5314 <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
    530a:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 5;
    530d:	49 8d 44 24 05       	lea    0x5(%r12),%rax
    5312:	eb 1b                	jmp    532f <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "0") == 0) {
    5314:	48 8d 35 36 3e 00 00 	lea    0x3e36(%rip),%rsi        # 9151 <default_cmd+0x1131>
    531b:	4c 89 e7             	mov    %r12,%rdi
    531e:	e8 0d d2 ff ff       	callq  2530 <strcmp@plt>
    5323:	85 c0                	test   %eax,%eax
    5325:	75 11                	jne    5338 <cmd_read_option_value+0xc6>
			*(bool *)dest = false;
    5327:	c6 03 00             	movb   $0x0,(%rbx)
			endptr = (char *)str + 1;
    532a:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    532f:	48 89 04 24          	mov    %rax,(%rsp)
	if (!error && endptr && *endptr != 0) {
    5333:	e9 a0 00 00 00       	jmpq   53d8 <cmd_read_option_value+0x166>
		} else if (strcasecmp(str, "true") == 0) {
    5338:	48 8d 35 2a 39 00 00 	lea    0x392a(%rip),%rsi        # 8c69 <default_cmd+0xc49>
    533f:	4c 89 e7             	mov    %r12,%rdi
    5342:	e8 79 d0 ff ff       	callq  23c0 <strcasecmp@plt>
    5347:	85 c0                	test   %eax,%eax
    5349:	75 0a                	jne    5355 <cmd_read_option_value+0xe3>
			*(bool *)dest = true;
    534b:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 4;
    534e:	49 8d 44 24 04       	lea    0x4(%r12),%rax
    5353:	eb da                	jmp    532f <cmd_read_option_value+0xbd>
		} else if (strcmp(str, "1") == 0) {
    5355:	48 8d 35 12 39 00 00 	lea    0x3912(%rip),%rsi        # 8c6e <default_cmd+0xc4e>
    535c:	4c 89 e7             	mov    %r12,%rdi
    535f:	e8 cc d1 ff ff       	callq  2530 <strcmp@plt>
    5364:	85 c0                	test   %eax,%eax
    5366:	74 16                	je     537e <cmd_read_option_value+0x10c>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    5368:	4c 89 e2             	mov    %r12,%rdx
    536b:	48 89 ee             	mov    %rbp,%rsi
    536e:	48 8d 3d fb 38 00 00 	lea    0x38fb(%rip),%rdi        # 8c70 <default_cmd+0xc50>
    5375:	31 c0                	xor    %eax,%eax
    5377:	e8 70 fa ff ff       	callq  4dec <posix_print_error_and_exit>
    537c:	eb 68                	jmp    53e6 <cmd_read_option_value+0x174>
			*(bool *)dest = true;
    537e:	c6 03 01             	movb   $0x1,(%rbx)
			endptr = (char *)str + 1;
    5381:	eb a7                	jmp    532a <cmd_read_option_value+0xb8>
		*(char **)dest = (char *)str;
    5383:	48 89 3b             	mov    %rdi,(%rbx)
		endptr = (char *)str + strlen(str);
    5386:	31 c0                	xor    %eax,%eax
    5388:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    538c:	f2 ae                	repnz scas %es:(%rdi),%al
    538e:	48 f7 d1             	not    %rcx
    5391:	49 8d 44 0c ff       	lea    -0x1(%r12,%rcx,1),%rax
    5396:	eb 97                	jmp    532f <cmd_read_option_value+0xbd>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
    5398:	48 89 e6             	mov    %rsp,%rsi
    539b:	31 d2                	xor    %edx,%edx
    539d:	e8 5e d2 ff ff       	callq  2600 <strtoul@plt>
    53a2:	eb 0c                	jmp    53b0 <cmd_read_option_value+0x13e>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
    53a4:	48 89 e6             	mov    %rsp,%rsi
    53a7:	31 d2                	xor    %edx,%edx
    53a9:	e8 62 d1 ff ff       	callq  2510 <strtoull@plt>
    53ae:	eb 04                	jmp    53b4 <cmd_read_option_value+0x142>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    53b0:	89 03                	mov    %eax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    53b2:	eb 24                	jmp    53d8 <cmd_read_option_value+0x166>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    53b4:	48 89 03             	mov    %rax,(%rbx)
	if (!error && endptr && *endptr != 0) {
    53b7:	eb 1f                	jmp    53d8 <cmd_read_option_value+0x166>
		*(double *)dest = strtod(str, &endptr);
    53b9:	48 89 e6             	mov    %rsp,%rsi
    53bc:	e8 8f d0 ff ff       	callq  2450 <strtod@plt>
    53c1:	f2 0f 11 03          	movsd  %xmm0,(%rbx)
	if (!error && endptr && *endptr != 0) {
    53c5:	eb 11                	jmp    53d8 <cmd_read_option_value+0x166>
	switch (type) {
    53c7:	0f be f2             	movsbl %dl,%esi
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    53ca:	48 8d 3d e1 38 00 00 	lea    0x38e1(%rip),%rdi        # 8cb2 <default_cmd+0xc92>
    53d1:	31 c0                	xor    %eax,%eax
    53d3:	e8 14 fa ff ff       	callq  4dec <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
    53d8:	48 8b 04 24          	mov    (%rsp),%rax
    53dc:	48 85 c0             	test   %rax,%rax
    53df:	74 05                	je     53e6 <cmd_read_option_value+0x174>
    53e1:	80 38 00             	cmpb   $0x0,(%rax)
    53e4:	75 82                	jne    5368 <cmd_read_option_value+0xf6>
}
    53e6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    53eb:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    53f2:	00 00 
    53f4:	74 05                	je     53fb <cmd_read_option_value+0x189>
    53f6:	e8 a5 d0 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    53fb:	48 83 c4 10          	add    $0x10,%rsp
    53ff:	5b                   	pop    %rbx
    5400:	5d                   	pop    %rbp
    5401:	41 5c                	pop    %r12
    5403:	c3                   	retq   

0000000000005404 <cmd_args_set_defaults>:
{
    5404:	f3 0f 1e fa          	endbr64 
    5408:	55                   	push   %rbp
	int count = 0;
    5409:	31 ed                	xor    %ebp,%ebp
{
    540b:	53                   	push   %rbx
    540c:	48 89 fb             	mov    %rdi,%rbx
    540f:	52                   	push   %rdx
	while (args_struct[count].option != NULL) {
    5410:	48 63 d5             	movslq %ebp,%rdx
    5413:	48 6b d2 38          	imul   $0x38,%rdx,%rdx
    5417:	48 01 da             	add    %rbx,%rdx
    541a:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
    541f:	0f 84 a0 00 00 00    	je     54c5 <cmd_args_set_defaults+0xc1>
		if (args_struct[count].dest == NULL) {
    5425:	48 8b 42 20          	mov    0x20(%rdx),%rax
    5429:	ff c5                	inc    %ebp
    542b:	48 85 c0             	test   %rax,%rax
    542e:	74 e0                	je     5410 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    5430:	0f be 72 18          	movsbl 0x18(%rdx),%esi
    5434:	40 80 fe 64          	cmp    $0x64,%sil
    5438:	74 69                	je     54a3 <cmd_args_set_defaults+0x9f>
    543a:	7f 2d                	jg     5469 <cmd_args_set_defaults+0x65>
    543c:	40 80 fe 55          	cmp    $0x55,%sil
    5440:	74 55                	je     5497 <cmd_args_set_defaults+0x93>
    5442:	7f 1a                	jg     545e <cmd_args_set_defaults+0x5a>
    5444:	40 84 f6             	test   %sil,%sil
    5447:	74 c7                	je     5410 <cmd_args_set_defaults+0xc>
    5449:	40 80 fe 49          	cmp    $0x49,%sil
    544d:	75 63                	jne    54b2 <cmd_args_set_defaults+0xae>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
    544f:	48 b9 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rcx
    5456:	ff ff 7f 
    5459:	48 89 08             	mov    %rcx,(%rax)
			break;
    545c:	eb b2                	jmp    5410 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    545e:	40 80 fe 62          	cmp    $0x62,%sil
    5462:	75 4e                	jne    54b2 <cmd_args_set_defaults+0xae>
			*(bool *)args_struct[count].dest = false;
    5464:	c6 00 00             	movb   $0x0,(%rax)
			break;
    5467:	eb a7                	jmp    5410 <cmd_args_set_defaults+0xc>
		switch (args_struct[count].type) {
    5469:	40 80 fe 73          	cmp    $0x73,%sil
    546d:	74 14                	je     5483 <cmd_args_set_defaults+0x7f>
    546f:	40 80 fe 75          	cmp    $0x75,%sil
    5473:	74 17                	je     548c <cmd_args_set_defaults+0x88>
    5475:	40 80 fe 69          	cmp    $0x69,%sil
    5479:	75 37                	jne    54b2 <cmd_args_set_defaults+0xae>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
    547b:	c7 00 ff ff ff 7f    	movl   $0x7fffffff,(%rax)
			break;
    5481:	eb 8d                	jmp    5410 <cmd_args_set_defaults+0xc>
			*(char **)args_struct[count].dest = NULL;
    5483:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			break;
    548a:	eb 84                	jmp    5410 <cmd_args_set_defaults+0xc>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
    548c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
			break;
    5492:	e9 79 ff ff ff       	jmpq   5410 <cmd_args_set_defaults+0xc>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
    5497:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
			break;
    549e:	e9 6d ff ff ff       	jmpq   5410 <cmd_args_set_defaults+0xc>
			*(double *)args_struct[count].dest = NAN;
    54a3:	48 8b 0d b6 2b 00 00 	mov    0x2bb6(%rip),%rcx        # 8060 <default_cmd+0x40>
    54aa:	48 89 08             	mov    %rcx,(%rax)
			break;
    54ad:	e9 5e ff ff ff       	jmpq   5410 <cmd_args_set_defaults+0xc>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    54b2:	48 8d 3d f9 37 00 00 	lea    0x37f9(%rip),%rdi        # 8cb2 <default_cmd+0xc92>
    54b9:	31 c0                	xor    %eax,%eax
    54bb:	e8 2c f9 ff ff       	callq  4dec <posix_print_error_and_exit>
			break;
    54c0:	e9 4b ff ff ff       	jmpq   5410 <cmd_args_set_defaults+0xc>
}
    54c5:	58                   	pop    %rax
    54c6:	5b                   	pop    %rbx
    54c7:	5d                   	pop    %rbp
    54c8:	c3                   	retq   

00000000000054c9 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    54c9:	f3 0f 1e fa          	endbr64 
    54cd:	41 56                	push   %r14
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    54cf:	be 01 00 00 00       	mov    $0x1,%esi
    54d4:	48 8d 0d fc 37 00 00 	lea    0x37fc(%rip),%rcx        # 8cd7 <default_cmd+0xcb7>
    54db:	48 8d 15 0e 38 00 00 	lea    0x380e(%rip),%rdx        # 8cf0 <default_cmd+0xcd0>
    54e2:	41 55                	push   %r13
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    54e4:	41 be 19 00 00 00    	mov    $0x19,%r14d
	int count = 0;
    54ea:	45 31 ed             	xor    %r13d,%r13d
{
    54ed:	41 54                	push   %r12
    54ef:	49 89 fc             	mov    %rdi,%r12
    54f2:	55                   	push   %rbp
    54f3:	53                   	push   %rbx
    54f4:	48 83 ec 50          	sub    $0x50,%rsp

	fprintf(stdout, "%s ", _HELP_SWITCH);
    54f8:	48 8b 1d a1 5a 00 00 	mov    0x5aa1(%rip),%rbx        # afa0 <stdout@GLIBC_2.2.5>
{
    54ff:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5506:	00 00 
    5508:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    550d:	31 c0                	xor    %eax,%eax

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    550f:	48 8d 6c 24 02       	lea    0x2(%rsp),%rbp
    5514:	48 8b 3b             	mov    (%rbx),%rdi
    5517:	e8 34 d1 ff ff       	callq  2650 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
    551c:	49 63 f5             	movslq %r13d,%rsi
    551f:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    5523:	4c 01 e6             	add    %r12,%rsi
    5526:	48 83 7e 08 00       	cmpq   $0x0,0x8(%rsi)
    552b:	74 6e                	je     559b <cmd_print_switches_help+0xd2>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    552d:	48 89 ef             	mov    %rbp,%rdi
    5530:	e8 3e fb ff ff       	callq  5073 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    5535:	31 c0                	xor    %eax,%eax
    5537:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    553b:	48 89 ef             	mov    %rbp,%rdi
    553e:	f2 ae                	repnz scas %es:(%rdi),%al
    5540:	49 63 c6             	movslq %r14d,%rax
    5543:	48 f7 d1             	not    %rcx
    5546:	48 8d 44 01 ff       	lea    -0x1(%rcx,%rax,1),%rax
    554b:	48 83 f8 64          	cmp    $0x64,%rax
    554f:	76 19                	jbe    556a <cmd_print_switches_help+0xa1>
    5551:	48 8b 3b             	mov    (%rbx),%rdi
    5554:	48 8d 15 15 38 00 00 	lea    0x3815(%rip),%rdx        # 8d70 <default_cmd+0xd50>
    555b:	31 c0                	xor    %eax,%eax
			fprintf(stdout, "\n");
			printed_in_line = 0;
    555d:	45 31 f6             	xor    %r14d,%r14d
    5560:	be 01 00 00 00       	mov    $0x1,%esi
    5565:	e8 e6 d0 ff ff       	callq  2650 <__fprintf_chk@plt>
    556a:	48 8b 3b             	mov    (%rbx),%rdi
    556d:	48 89 e9             	mov    %rbp,%rcx
    5570:	48 8d 15 1a 36 00 00 	lea    0x361a(%rip),%rdx        # 8b91 <default_cmd+0xb71>
    5577:	31 c0                	xor    %eax,%eax
    5579:	be 01 00 00 00       	mov    $0x1,%esi
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
		count++;
    557e:	41 ff c5             	inc    %r13d
    5581:	e8 ca d0 ff ff       	callq  2650 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
    5586:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    558a:	31 c0                	xor    %eax,%eax
    558c:	48 89 ef             	mov    %rbp,%rdi
    558f:	f2 ae                	repnz scas %es:(%rdi),%al
    5591:	48 f7 d1             	not    %rcx
    5594:	45 8d 74 0e ff       	lea    -0x1(%r14,%rcx,1),%r14d
		count++;
    5599:	eb 81                	jmp    551c <cmd_print_switches_help+0x53>
    559b:	48 8b 3b             	mov    (%rbx),%rdi
    559e:	31 c0                	xor    %eax,%eax
    55a0:	be 01 00 00 00       	mov    $0x1,%esi
    55a5:	48 8d 15 c4 37 00 00 	lea    0x37c4(%rip),%rdx        # 8d70 <default_cmd+0xd50>
    55ac:	e8 9f d0 ff ff       	callq  2650 <__fprintf_chk@plt>
	}

	fprintf(stdout, "\n");
}
    55b1:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    55b6:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    55bd:	00 00 
    55bf:	74 05                	je     55c6 <cmd_print_switches_help+0xfd>
    55c1:	e8 da ce ff ff       	callq  24a0 <__stack_chk_fail@plt>
    55c6:	48 83 c4 50          	add    $0x50,%rsp
    55ca:	5b                   	pop    %rbx
    55cb:	5d                   	pop    %rbp
    55cc:	41 5c                	pop    %r12
    55ce:	41 5d                	pop    %r13
    55d0:	41 5e                	pop    %r14
    55d2:	c3                   	retq   

00000000000055d3 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    55d3:	f3 0f 1e fa          	endbr64 
    55d7:	41 57                	push   %r15
    55d9:	4c 8d 3d 91 37 00 00 	lea    0x3791(%rip),%r15        # 8d71 <default_cmd+0xd51>
    55e0:	41 56                	push   %r14
    55e2:	41 55                	push   %r13
	int ret;
	int count = 0;
    55e4:	45 31 ed             	xor    %r13d,%r13d
{
    55e7:	41 54                	push   %r12
    55e9:	49 89 fc             	mov    %rdi,%r12
    55ec:	55                   	push   %rbp
    55ed:	53                   	push   %rbx
    55ee:	48 83 ec 68          	sub    $0x68,%rsp
    55f2:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    55f9:	00 00 
    55fb:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    5600:	31 c0                	xor    %eax,%eax
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    5602:	e8 c2 fe ff ff       	callq  54c9 <cmd_print_switches_help>

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
    5607:	48 8b 1d 92 59 00 00 	mov    0x5992(%rip),%rbx        # afa0 <stdout@GLIBC_2.2.5>
    560e:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    5613:	31 c0                	xor    %eax,%eax
    5615:	4c 8d 0d d8 36 00 00 	lea    0x36d8(%rip),%r9        # 8cf4 <default_cmd+0xcd4>
    561c:	4c 8d 05 b4 36 00 00 	lea    0x36b4(%rip),%r8        # 8cd7 <default_cmd+0xcb7>
    5623:	be 01 00 00 00       	mov    $0x1,%esi
    5628:	48 8b 3b             	mov    (%rbx),%rdi
    562b:	48 8d 15 d4 36 00 00 	lea    0x36d4(%rip),%rdx        # 8d06 <default_cmd+0xce6>
    5632:	e8 19 d0 ff ff       	callq  2650 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    5637:	49 63 ed             	movslq %r13d,%rbp
    563a:	48 6b ed 38          	imul   $0x38,%rbp,%rbp
    563e:	4c 01 e5             	add    %r12,%rbp
    5641:	48 83 7d 08 00       	cmpq   $0x0,0x8(%rbp)
    5646:	0f 84 c8 00 00 00    	je     5714 <cmd_print_long_help+0x141>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    564c:	4c 8d 44 24 12       	lea    0x12(%rsp),%r8
    5651:	48 89 ee             	mov    %rbp,%rsi
    5654:	4c 89 c7             	mov    %r8,%rdi
    5657:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    565c:	e8 12 fa ff ff       	callq  5073 <cmd_gen_switch_syntax.constprop.0>
    5661:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    5666:	48 8b 3b             	mov    (%rbx),%rdi
    5669:	31 c0                	xor    %eax,%eax
    566b:	b9 1d 00 00 00       	mov    $0x1d,%ecx
    5670:	48 8d 15 9a 36 00 00 	lea    0x369a(%rip),%rdx        # 8d11 <default_cmd+0xcf1>
    5677:	be 01 00 00 00       	mov    $0x1,%esi
    567c:	e8 cf cf ff ff       	callq  2650 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    5681:	4c 8b 75 30          	mov    0x30(%rbp),%r14
		total_to_print = strlen(toprint);
    5685:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    5689:	48 8d 15 88 36 00 00 	lea    0x3688(%rip),%rdx        # 8d18 <default_cmd+0xcf8>
    5690:	41 89 c0             	mov    %eax,%r8d
    5693:	31 c0                	xor    %eax,%eax
    5695:	be 01 00 00 00       	mov    $0x1,%esi
    569a:	4c 89 f7             	mov    %r14,%rdi
    569d:	f2 ae                	repnz scas %es:(%rdi),%al
    569f:	48 8b 3b             	mov    (%rbx),%rdi
    56a2:	48 f7 d1             	not    %rcx
    56a5:	8d 41 ff             	lea    -0x1(%rcx),%eax
		ret = fprintf(stdout, "%.*s\n",
    56a8:	b9 64 00 00 00       	mov    $0x64,%ecx
		total_to_print = strlen(toprint);
    56ad:	89 44 24 08          	mov    %eax,0x8(%rsp)
		ret = fprintf(stdout, "%.*s\n",
    56b1:	44 29 c1             	sub    %r8d,%ecx
    56b4:	31 c0                	xor    %eax,%eax
    56b6:	4d 89 f0             	mov    %r14,%r8
    56b9:	e8 92 cf ff ff       	callq  2650 <__fprintf_chk@plt>
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    56be:	8d 68 ff             	lea    -0x1(%rax),%ebp

		while (printed_right < total_to_print) {
    56c1:	3b 6c 24 08          	cmp    0x8(%rsp),%ebp
    56c5:	7d 45                	jge    570c <cmd_print_long_help+0x139>
    56c7:	48 8b 3b             	mov    (%rbx),%rdi
    56ca:	4d 89 f8             	mov    %r15,%r8
    56cd:	b9 1e 00 00 00       	mov    $0x1e,%ecx
    56d2:	be 01 00 00 00       	mov    $0x1,%esi
    56d7:	48 8d 15 40 36 00 00 	lea    0x3640(%rip),%rdx        # 8d1e <default_cmd+0xcfe>
    56de:	31 c0                	xor    %eax,%eax
    56e0:	e8 6b cf ff ff       	callq  2650 <__fprintf_chk@plt>
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    56e5:	4c 63 c5             	movslq %ebp,%r8
    56e8:	48 8b 3b             	mov    (%rbx),%rdi
    56eb:	b9 46 00 00 00       	mov    $0x46,%ecx
    56f0:	4d 01 f0             	add    %r14,%r8
    56f3:	48 8d 15 1e 36 00 00 	lea    0x361e(%rip),%rdx        # 8d18 <default_cmd+0xcf8>
    56fa:	be 01 00 00 00       	mov    $0x1,%esi
    56ff:	31 c0                	xor    %eax,%eax
    5701:	e8 4a cf ff ff       	callq  2650 <__fprintf_chk@plt>
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    5706:	8d 6c 05 ff          	lea    -0x1(%rbp,%rax,1),%ebp
    570a:	eb b5                	jmp    56c1 <cmd_print_long_help+0xee>
		}
		count++;
    570c:	41 ff c5             	inc    %r13d
    570f:	e9 23 ff ff ff       	jmpq   5637 <cmd_print_long_help+0x64>
    5714:	48 8b 3b             	mov    (%rbx),%rdi
    5717:	48 8d 15 52 36 00 00 	lea    0x3652(%rip),%rdx        # 8d70 <default_cmd+0xd50>
    571e:	be 01 00 00 00       	mov    $0x1,%esi
    5723:	31 c0                	xor    %eax,%eax
    5725:	e8 26 cf ff ff       	callq  2650 <__fprintf_chk@plt>
    572a:	48 8b 3b             	mov    (%rbx),%rdi
    572d:	31 c0                	xor    %eax,%eax
    572f:	be 01 00 00 00       	mov    $0x1,%esi
    5734:	48 8d 15 e7 35 00 00 	lea    0x35e7(%rip),%rdx        # 8d22 <default_cmd+0xd02>
    573b:	e8 10 cf ff ff       	callq  2650 <__fprintf_chk@plt>
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    5740:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    5745:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    574c:	00 00 
    574e:	74 05                	je     5755 <cmd_print_long_help+0x182>
    5750:	e8 4b cd ff ff       	callq  24a0 <__stack_chk_fail@plt>
    5755:	48 83 c4 68          	add    $0x68,%rsp
    5759:	5b                   	pop    %rbx
    575a:	5d                   	pop    %rbp
    575b:	41 5c                	pop    %r12
    575d:	41 5d                	pop    %r13
    575f:	41 5e                	pop    %r14
    5761:	41 5f                	pop    %r15
    5763:	c3                   	retq   

0000000000005764 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    5764:	f3 0f 1e fa          	endbr64 
    5768:	41 56                	push   %r14
    576a:	41 55                	push   %r13
    576c:	49 89 f5             	mov    %rsi,%r13
    576f:	41 54                	push   %r12
    5771:	55                   	push   %rbp
    5772:	48 89 fd             	mov    %rdi,%rbp
    5775:	53                   	push   %rbx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    5776:	e8 8a fa ff ff       	callq  5205 <cmd_is_help_option>
    577b:	85 c0                	test   %eax,%eax
    577d:	74 0f                	je     578e <cmd_parse_one_arg+0x2a>
		cmd_print_long_help(args_struct);
    577f:	4c 89 ef             	mov    %r13,%rdi
    5782:	e8 4c fe ff ff       	callq  55d3 <cmd_print_long_help>
		posix_exit(0);
    5787:	31 ff                	xor    %edi,%edi
    5789:	e8 62 f5 ff ff       	callq  4cf0 <posix_exit>
{
    578e:	45 31 f6             	xor    %r14d,%r14d
	}

	while (args_struct[count].option != NULL) {
    5791:	49 63 de             	movslq %r14d,%rbx
    5794:	48 6b db 38          	imul   $0x38,%rbx,%rbx
    5798:	4c 01 eb             	add    %r13,%rbx
    579b:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    579f:	48 85 f6             	test   %rsi,%rsi
    57a2:	74 78                	je     581c <cmd_parse_one_arg+0xb8>
		if (args_struct[count].manual) {
    57a4:	80 3b 00             	cmpb   $0x0,(%rbx)
    57a7:	75 6b                	jne    5814 <cmd_parse_one_arg+0xb0>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
				    !args_struct[count].is_switch);
    57a9:	8a 53 02             	mov    0x2(%rbx),%dl
		ret = cmd_is_option(argv, args_struct[count].option,
    57ac:	48 89 ef             	mov    %rbp,%rdi
				    !args_struct[count].is_switch);
    57af:	83 f2 01             	xor    $0x1,%edx
		ret = cmd_is_option(argv, args_struct[count].option,
    57b2:	0f b6 d2             	movzbl %dl,%edx
    57b5:	e8 9d f9 ff ff       	callq  5157 <cmd_is_option>
    57ba:	41 89 c4             	mov    %eax,%r12d
		if (ret) {
    57bd:	85 c0                	test   %eax,%eax
    57bf:	74 53                	je     5814 <cmd_parse_one_arg+0xb0>
	if (arg_element->dest != NULL) {
    57c1:	48 8b 73 20          	mov    0x20(%rbx),%rsi
    57c5:	48 85 f6             	test   %rsi,%rsi
    57c8:	74 33                	je     57fd <cmd_parse_one_arg+0x99>
		if (arg_element->is_switch) {
    57ca:	80 7b 02 00          	cmpb   $0x0,0x2(%rbx)
    57ce:	0f be 53 18          	movsbl 0x18(%rbx),%edx
    57d2:	74 1a                	je     57ee <cmd_parse_one_arg+0x8a>
			if (arg_element->type == 'b') {
    57d4:	80 fa 62             	cmp    $0x62,%dl
    57d7:	75 05                	jne    57de <cmd_parse_one_arg+0x7a>
				*(bool *)arg_element->dest = true;
    57d9:	c6 06 01             	movb   $0x1,(%rsi)
    57dc:	eb 1f                	jmp    57fd <cmd_parse_one_arg+0x99>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    57de:	48 8d 3d 8d 35 00 00 	lea    0x358d(%rip),%rdi        # 8d72 <default_cmd+0xd52>
    57e5:	31 c0                	xor    %eax,%eax
    57e7:	e8 00 f6 ff ff       	callq  4dec <posix_print_error_and_exit>
    57ec:	eb 0f                	jmp    57fd <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
    57ee:	48 63 f8             	movslq %eax,%rdi
    57f1:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    57f5:	48 01 ef             	add    %rbp,%rdi
    57f8:	e8 75 fa ff ff       	callq  5272 <cmd_read_option_value>
	if (arg_element->call_when_found) {
    57fd:	48 8b 53 28          	mov    0x28(%rbx),%rdx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    5801:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
    5803:	48 85 d2             	test   %rdx,%rdx
    5806:	74 16                	je     581e <cmd_parse_one_arg+0xba>
		arg_element->call_when_found(argv, offset);
    5808:	44 89 e6             	mov    %r12d,%esi
    580b:	48 89 ef             	mov    %rbp,%rdi
    580e:	ff d2                	callq  *%rdx
			return true;
    5810:	b0 01                	mov    $0x1,%al
    5812:	eb 0a                	jmp    581e <cmd_parse_one_arg+0xba>
    5814:	41 ff c6             	inc    %r14d
    5817:	e9 75 ff ff ff       	jmpq   5791 <cmd_parse_one_arg+0x2d>
		}
		count++;
	}
	return false;
    581c:	31 c0                	xor    %eax,%eax
}
    581e:	5b                   	pop    %rbx
    581f:	5d                   	pop    %rbp
    5820:	41 5c                	pop    %r12
    5822:	41 5d                	pop    %r13
    5824:	41 5e                	pop    %r14
    5826:	c3                   	retq   

0000000000005827 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
    5827:	f3 0f 1e fa          	endbr64 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    582b:	48 8b 3d 96 83 00 00 	mov    0x8396(%rip),%rdi        # dbc8 <args_struct>
    5832:	48 85 ff             	test   %rdi,%rdi
    5835:	74 13                	je     584a <native_cleanup_cmd_line+0x23>
{
    5837:	50                   	push   %rax
		free(args_struct);
    5838:	e8 63 cb ff ff       	callq  23a0 <free@plt>
		args_struct = NULL;
    583d:	48 c7 05 80 83 00 00 	movq   $0x0,0x8380(%rip)        # dbc8 <args_struct>
    5844:	00 00 00 00 
	}
}
    5848:	5a                   	pop    %rdx
    5849:	c3                   	retq   
    584a:	c3                   	retq   

000000000000584b <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    584b:	f3 0f 1e fa          	endbr64 
    584f:	41 54                	push   %r12
    5851:	55                   	push   %rbp
    5852:	48 89 fd             	mov    %rdi,%rbp
    5855:	53                   	push   %rbx
	int count = 0;
    5856:	31 db                	xor    %ebx,%ebx

	while (args[count].option != NULL) {
    5858:	48 63 c3             	movslq %ebx,%rax
    585b:	ff c3                	inc    %ebx
    585d:	48 6b c0 38          	imul   $0x38,%rax,%rax
    5861:	48 83 7c 05 08 00    	cmpq   $0x0,0x8(%rbp,%rax,1)
    5867:	75 ef                	jne    5858 <native_add_command_line_opts+0xd>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    5869:	8b 15 cd 83 00 00    	mov    0x83cd(%rip),%edx        # dc3c <used_args>
    586f:	8b 05 c3 83 00 00    	mov    0x83c3(%rip),%eax        # dc38 <args_aval>
    5875:	01 da                	add    %ebx,%edx
    5877:	39 c2                	cmp    %eax,%edx
    5879:	7c 44                	jl     58bf <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    587b:	83 fb 14             	cmp    $0x14,%ebx
    587e:	41 bc 14 00 00 00    	mov    $0x14,%r12d
		struct args_struct_t *new_args_struct = realloc(args_struct,
    5884:	48 8b 3d 3d 83 00 00 	mov    0x833d(%rip),%rdi        # dbc8 <args_struct>
				      (args_aval + growby)*
    588b:	44 0f 4d e3          	cmovge %ebx,%r12d
    588f:	41 01 c4             	add    %eax,%r12d
    5892:	49 63 f4             	movslq %r12d,%rsi
		struct args_struct_t *new_args_struct = realloc(args_struct,
    5895:	48 6b f6 38          	imul   $0x38,%rsi,%rsi
    5899:	e8 12 cd ff ff       	callq  25b0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
    589e:	44 89 25 93 83 00 00 	mov    %r12d,0x8393(%rip)        # dc38 <args_aval>
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    58a5:	48 85 c0             	test   %rax,%rax
    58a8:	75 0e                	jne    58b8 <native_add_command_line_opts+0x6d>
			posix_print_error_and_exit("Could not allocate memory");
    58aa:	48 8d 3d 0c 35 00 00 	lea    0x350c(%rip),%rdi        # 8dbd <default_cmd+0xd9d>
    58b1:	e8 36 f5 ff ff       	callq  4dec <posix_print_error_and_exit>
    58b6:	eb 07                	jmp    58bf <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
    58b8:	48 89 05 09 83 00 00 	mov    %rax,0x8309(%rip)        # dbc8 <args_struct>
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    58bf:	48 63 05 76 83 00 00 	movslq 0x8376(%rip),%rax        # dc3c <used_args>
    58c6:	48 63 cb             	movslq %ebx,%rcx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    58c9:	48 89 ee             	mov    %rbp,%rsi
    58cc:	48 6b c9 38          	imul   $0x38,%rcx,%rcx
    58d0:	48 89 c2             	mov    %rax,%rdx
    58d3:	48 6b c0 38          	imul   $0x38,%rax,%rax
    58d7:	48 03 05 ea 82 00 00 	add    0x82ea(%rip),%rax        # dbc8 <args_struct>
    58de:	48 89 c7             	mov    %rax,%rdi
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    58e1:	8d 44 1a ff          	lea    -0x1(%rdx,%rbx,1),%eax
    58e5:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    58e7:	89 05 4f 83 00 00    	mov    %eax,0x834f(%rip)        # dc3c <used_args>
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    58ed:	5b                   	pop    %rbx
    58ee:	5d                   	pop    %rbp
    58ef:	41 5c                	pop    %r12
    58f1:	c3                   	retq   

00000000000058f2 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
    58f2:	f3 0f 1e fa          	endbr64 
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    58f6:	48 8d 3d a3 59 00 00 	lea    0x59a3(%rip),%rdi        # b2a0 <testargs_options.2552>
    58fd:	e9 49 ff ff ff       	jmpq   584b <native_add_command_line_opts>

0000000000005902 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    5902:	f3 0f 1e fa          	endbr64 
    5906:	41 57                	push   %r15

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    5908:	4c 8d 3d c8 34 00 00 	lea    0x34c8(%rip),%r15        # 8dd7 <default_cmd+0xdb7>
{
    590f:	41 56                	push   %r14
    5911:	41 55                	push   %r13
    5913:	41 54                	push   %r12
    5915:	49 89 f4             	mov    %rsi,%r12
    5918:	55                   	push   %rbp
	for (i = 1; i < argc; i++) {
    5919:	bd 01 00 00 00       	mov    $0x1,%ebp
{
    591e:	53                   	push   %rbx
    591f:	89 fb                	mov    %edi,%ebx
    5921:	52                   	push   %rdx
	native_add_tracing_options();
    5922:	e8 3c f7 ff ff       	callq  5063 <native_add_tracing_options>
	native_add_testargs_option();
    5927:	e8 c6 ff ff ff       	callq  58f2 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
    592c:	48 8b 3d 95 82 00 00 	mov    0x8295(%rip),%rdi        # dbc8 <args_struct>
	s_argv = argv;
    5933:	4c 89 25 9e 82 00 00 	mov    %r12,0x829e(%rip)        # dbd8 <s_argv>
	s_argc = argc;
    593a:	89 1d 04 83 00 00    	mov    %ebx,0x8304(%rip)        # dc44 <s_argc>
	cmd_args_set_defaults(args_struct);
    5940:	e8 bf fa ff ff       	callq  5404 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
    5945:	41 89 ee             	mov    %ebp,%r14d
    5948:	39 eb                	cmp    %ebp,%ebx
    594a:	7e 65                	jle    59b1 <native_handle_cmd_line+0xaf>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
    594c:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    5950:	31 d2                	xor    %edx,%edx
    5952:	4c 89 fe             	mov    %r15,%rsi
    5955:	4c 8d 6d 01          	lea    0x1(%rbp),%r13
    5959:	e8 f9 f7 ff ff       	callq  5157 <cmd_is_option>
    595e:	85 c0                	test   %eax,%eax
    5960:	74 18                	je     597a <native_handle_cmd_line+0x78>
			test_argc = argc - i - 1;
    5962:	ff cb                	dec    %ebx
			test_argv = &argv[i+1];
    5964:	4b 8d 04 ec          	lea    (%r12,%r13,8),%rax
			test_argc = argc - i - 1;
    5968:	44 29 f3             	sub    %r14d,%ebx
			test_argv = &argv[i+1];
    596b:	48 89 05 5e 82 00 00 	mov    %rax,0x825e(%rip)        # dbd0 <test_argv>
			test_argc = argc - i - 1;
    5972:	89 1d c8 82 00 00    	mov    %ebx,0x82c8(%rip)        # dc40 <test_argc>
			break;
    5978:	eb 37                	jmp    59b1 <native_handle_cmd_line+0xaf>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    597a:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
    597e:	48 8b 35 43 82 00 00 	mov    0x8243(%rip),%rsi        # dbc8 <args_struct>
    5985:	e8 da fd ff ff       	callq  5764 <cmd_parse_one_arg>
    598a:	84 c0                	test   %al,%al
    598c:	75 1e                	jne    59ac <native_handle_cmd_line+0xaa>
			cmd_print_switches_help(args_struct);
    598e:	48 8b 3d 33 82 00 00 	mov    0x8233(%rip),%rdi        # dbc8 <args_struct>
    5995:	e8 2f fb ff ff       	callq  54c9 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    599a:	49 8b 34 ec          	mov    (%r12,%rbp,8),%rsi
    599e:	48 8d 3d 3b 34 00 00 	lea    0x343b(%rip),%rdi        # 8de0 <default_cmd+0xdc0>
    59a5:	31 c0                	xor    %eax,%eax
    59a7:	e8 40 f4 ff ff       	callq  4dec <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
    59ac:	4c 89 ed             	mov    %r13,%rbp
    59af:	eb 94                	jmp    5945 <native_handle_cmd_line+0x43>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    59b1:	58                   	pop    %rax
    59b2:	5b                   	pop    %rbx
    59b3:	5d                   	pop    %rbp
    59b4:	41 5c                	pop    %r12
    59b6:	41 5d                	pop    %r13
    59b8:	41 5e                	pop    %r14
    59ba:	41 5f                	pop    %r15
    59bc:	c3                   	retq   

00000000000059bd <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
    59bd:	f3 0f 1e fa          	endbr64 
	hw_counter_timer = NEVER;
    59c1:	48 8d 05 30 82 00 00 	lea    0x8230(%rip),%rax        # dbf8 <hw_counter_timer>
	counter_target = NEVER;
	counter_value = 0;
	counter_running = false;
    59c8:	c6 05 8f 82 00 00 00 	movb   $0x0,0x828f(%rip)        # dc5e <counter_running>
	counter_target = NEVER;
    59cf:	48 c7 05 0e 82 00 00 	movq   $0xffffffffffffffff,0x820e(%rip)        # dbe8 <counter_target>
    59d6:	ff ff ff ff 
	hw_counter_timer = NEVER;
    59da:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
	counter_value = 0;
    59e1:	48 c7 05 04 82 00 00 	movq   $0x0,0x8204(%rip)        # dbf0 <counter_value>
    59e8:	00 00 00 00 
	counter_period = NEVER;
    59ec:	48 c7 05 e9 81 00 00 	movq   $0xffffffffffffffff,0x81e9(%rip)        # dbe0 <counter_period>
    59f3:	ff ff ff ff 
}
    59f7:	c3                   	retq   

00000000000059f8 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
    59f8:	f3 0f 1e fa          	endbr64 
	if (!counter_running) {
    59fc:	80 3d 5b 82 00 00 00 	cmpb   $0x0,0x825b(%rip)        # dc5e <counter_running>
{
    5a03:	53                   	push   %rbx
    5a04:	48 8d 1d ed 81 00 00 	lea    0x81ed(%rip),%rbx        # dbf8 <hw_counter_timer>
	if (!counter_running) {
    5a0b:	75 09                	jne    5a16 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
    5a0d:	48 c7 03 ff ff ff ff 	movq   $0xffffffffffffffff,(%rbx)
		return;
    5a14:	eb 34                	jmp    5a4a <hw_counter_triggered+0x52>
	}

	hw_counter_timer = hwm_get_time() + counter_period;
    5a16:	e8 da e9 ff ff       	callq  43f5 <hwm_get_time>
    5a1b:	48 03 05 be 81 00 00 	add    0x81be(%rip),%rax        # dbe0 <counter_period>
    5a22:	48 89 03             	mov    %rax,(%rbx)
	counter_value = counter_value + 1;
    5a25:	48 8b 05 c4 81 00 00 	mov    0x81c4(%rip),%rax        # dbf0 <counter_value>
    5a2c:	48 ff c0             	inc    %rax

	if (counter_value == counter_target) {
    5a2f:	48 3b 05 b2 81 00 00 	cmp    0x81b2(%rip),%rax        # dbe8 <counter_target>
	counter_value = counter_value + 1;
    5a36:	48 89 05 b3 81 00 00 	mov    %rax,0x81b3(%rip)        # dbf0 <counter_value>
	if (counter_value == counter_target) {
    5a3d:	75 0b                	jne    5a4a <hw_counter_triggered+0x52>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    5a3f:	bf 02 00 00 00       	mov    $0x2,%edi
	}
}
    5a44:	5b                   	pop    %rbx
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    5a45:	e9 19 f2 ff ff       	jmpq   4c63 <hw_irq_ctrl_set_irq>
}
    5a4a:	5b                   	pop    %rbx
    5a4b:	c3                   	retq   

0000000000005a4c <np_uart_tty_poll_in>:
 * @retval 0 If a character arrived and was stored in p_char
 * @retval -1 If no character was available to read
 */
static int np_uart_tty_poll_in(const struct device *dev,
			       unsigned char *p_char)
{
    5a4c:	f3 0f 1e fa          	endbr64 
    5a50:	50                   	push   %rax
	int n = -1;
	int in_f = ((struct native_uart_status *)dev->data)->in_fd;
    5a51:	48 8b 47 20          	mov    0x20(%rdi),%rax
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
    5a55:	ba 01 00 00 00       	mov    $0x1,%edx
    5a5a:	8b 78 04             	mov    0x4(%rax),%edi
    5a5d:	e8 9e ca ff ff       	callq  2500 <read@plt>
	n = read(in_f, p_char, 1);
	if (n == -1) {
		return -1;
	}
	return 0;
}
    5a62:	5a                   	pop    %rdx
	if (n == -1) {
    5a63:	ff c0                	inc    %eax
    5a65:	0f 94 c0             	sete   %al
    5a68:	0f b6 c0             	movzbl %al,%eax
    5a6b:	f7 d8                	neg    %eax
}
    5a6d:	c3                   	retq   

0000000000005a6e <np_cleanup_uart>:

	native_add_command_line_opts(uart_options);
}

static void np_cleanup_uart(void)
{
    5a6e:	f3 0f 1e fa          	endbr64 
	if (IS_ENABLED(CONFIG_NATIVE_UART_0_ON_OWN_PTY)) {
		if (native_uart_status_0.in_fd != 0) {
    5a72:	8b 3d 8c 81 00 00    	mov    0x818c(%rip),%edi        # dc04 <native_uart_status_0+0x4>
    5a78:	85 ff                	test   %edi,%edi
    5a7a:	74 05                	je     5a81 <np_cleanup_uart+0x13>
			close(native_uart_status_0.in_fd);
    5a7c:	e9 6f ca ff ff       	jmpq   24f0 <close@plt>
#if defined(CONFIG_UART_NATIVE_POSIX_PORT_1_ENABLE)
	if (native_uart_status_1.in_fd != 0) {
		close(native_uart_status_1.in_fd);
	}
#endif
}
    5a81:	c3                   	retq   

0000000000005a82 <np_add_uart_options>:
{
    5a82:	f3 0f 1e fa          	endbr64 
	native_add_command_line_opts(uart_options);
    5a86:	48 8d 3d 93 58 00 00 	lea    0x5893(%rip),%rdi        # b320 <uart_options.7281>
    5a8d:	e9 b9 fd ff ff       	jmpq   584b <native_add_command_line_opts>

0000000000005a92 <np_uart_0_init>:
{
    5a92:	f3 0f 1e fa          	endbr64 
    5a96:	55                   	push   %rbp
    5a97:	48 89 e5             	mov    %rsp,%rbp
    5a9a:	41 57                	push   %r15
    5a9c:	41 56                	push   %r14
    5a9e:	41 55                	push   %r13
    5aa0:	41 54                	push   %r12
    5aa2:	53                   	push   %rbx
    5aa3:	48 83 ec 68          	sub    $0x68,%rsp
	d = (struct native_uart_status *)dev->data;
    5aa7:	4c 8b 6f 20          	mov    0x20(%rdi),%r13
	master_pty = posix_openpt(O_RDWR | O_NOCTTY);
    5aab:	bf 02 01 00 00       	mov    $0x102,%edi
		int tty_fn = open_tty(d, DT_INST_LABEL(0),
    5ab0:	44 8a 3d a8 81 00 00 	mov    0x81a8(%rip),%r15b        # dc5f <auto_attach>
{
    5ab7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5abe:	00 00 
    5ac0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5ac4:	31 c0                	xor    %eax,%eax
	master_pty = posix_openpt(O_RDWR | O_NOCTTY);
    5ac6:	e8 a5 cb ff ff       	callq  2670 <posix_openpt@plt>
    5acb:	89 c3                	mov    %eax,%ebx
	if (master_pty == -1) {
    5acd:	ff c0                	inc    %eax
    5acf:	75 0e                	jne    5adf <np_uart_0_init+0x4d>
		ERROR("Could not open a new TTY for the UART\n");
    5ad1:	48 8d 3d c4 33 00 00 	lea    0x33c4(%rip),%rdi        # 8e9c <default_cmd+0xe7c>
    5ad8:	31 c0                	xor    %eax,%eax
    5ada:	e8 0d f3 ff ff       	callq  4dec <posix_print_error_and_exit>
	ret = grantpt(master_pty);
    5adf:	89 df                	mov    %ebx,%edi
    5ae1:	e8 2a cb ff ff       	callq  2610 <grantpt@plt>
	if (ret == -1) {
    5ae6:	ff c0                	inc    %eax
    5ae8:	75 21                	jne    5b0b <np_uart_0_init+0x79>
		err_nbr = errno;
    5aea:	e8 01 c9 ff ff       	callq  23f0 <__errno_location@plt>
		close(master_pty);
    5aef:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    5af1:	49 89 c4             	mov    %rax,%r12
		close(master_pty);
    5af4:	e8 f7 c9 ff ff       	callq  24f0 <close@plt>
		ERROR("Could not grant access to the slave PTY side (%i)\n",
    5af9:	41 8b 34 24          	mov    (%r12),%esi
    5afd:	48 8d 3d bf 33 00 00 	lea    0x33bf(%rip),%rdi        # 8ec3 <default_cmd+0xea3>
    5b04:	31 c0                	xor    %eax,%eax
    5b06:	e8 e1 f2 ff ff       	callq  4dec <posix_print_error_and_exit>
	ret = unlockpt(master_pty);
    5b0b:	89 df                	mov    %ebx,%edi
    5b0d:	e8 3e ca ff ff       	callq  2550 <unlockpt@plt>
	if (ret == -1) {
    5b12:	ff c0                	inc    %eax
    5b14:	75 21                	jne    5b37 <np_uart_0_init+0xa5>
		err_nbr = errno;
    5b16:	e8 d5 c8 ff ff       	callq  23f0 <__errno_location@plt>
		close(master_pty);
    5b1b:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    5b1d:	49 89 c4             	mov    %rax,%r12
		close(master_pty);
    5b20:	e8 cb c9 ff ff       	callq  24f0 <close@plt>
		ERROR("Could not unlock the slave PTY side (%i)\n", errno);
    5b25:	41 8b 34 24          	mov    (%r12),%esi
    5b29:	48 8d 3d c6 33 00 00 	lea    0x33c6(%rip),%rdi        # 8ef6 <default_cmd+0xed6>
    5b30:	31 c0                	xor    %eax,%eax
    5b32:	e8 b5 f2 ff ff       	callq  4dec <posix_print_error_and_exit>
	slave_pty_name = ptsname(master_pty);
    5b37:	89 df                	mov    %ebx,%edi
    5b39:	e8 42 c8 ff ff       	callq  2380 <ptsname@plt>
    5b3e:	49 89 c4             	mov    %rax,%r12
	if (slave_pty_name == NULL) {
    5b41:	48 85 c0             	test   %rax,%rax
    5b44:	75 20                	jne    5b66 <np_uart_0_init+0xd4>
		err_nbr = errno;
    5b46:	e8 a5 c8 ff ff       	callq  23f0 <__errno_location@plt>
		close(master_pty);
    5b4b:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    5b4d:	49 89 c6             	mov    %rax,%r14
		close(master_pty);
    5b50:	e8 9b c9 ff ff       	callq  24f0 <close@plt>
		ERROR("Error getting slave PTY device name (%i)\n", errno);
    5b55:	41 8b 36             	mov    (%r14),%esi
    5b58:	48 8d 3d c1 33 00 00 	lea    0x33c1(%rip),%rdi        # 8f20 <default_cmd+0xf00>
    5b5f:	31 c0                	xor    %eax,%eax
    5b61:	e8 86 f2 ff ff       	callq  4dec <posix_print_error_and_exit>
	flags = fcntl(master_pty, F_GETFL);
    5b66:	be 03 00 00 00       	mov    $0x3,%esi
    5b6b:	89 df                	mov    %ebx,%edi
    5b6d:	31 c0                	xor    %eax,%eax
    5b6f:	e8 ec c8 ff ff       	callq  2460 <fcntl@plt>
    5b74:	41 89 c6             	mov    %eax,%r14d
	if (flags == -1) {
    5b77:	83 f8 ff             	cmp    $0xffffffff,%eax
    5b7a:	75 2a                	jne    5ba6 <np_uart_0_init+0x114>
		err_nbr = errno;
    5b7c:	e8 6f c8 ff ff       	callq  23f0 <__errno_location@plt>
		close(master_pty);
    5b81:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    5b83:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		close(master_pty);
    5b8a:	e8 61 c9 ff ff       	callq  24f0 <close@plt>
		ERROR("Could not read the master PTY file status flags (%i)\n",
    5b8f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
    5b96:	48 8d 3d ad 33 00 00 	lea    0x33ad(%rip),%rdi        # 8f4a <default_cmd+0xf2a>
    5b9d:	31 c0                	xor    %eax,%eax
    5b9f:	8b 32                	mov    (%rdx),%esi
    5ba1:	e8 46 f2 ff ff       	callq  4dec <posix_print_error_and_exit>
	ret = fcntl(master_pty, F_SETFL, flags | O_NONBLOCK);
    5ba6:	44 89 f2             	mov    %r14d,%edx
    5ba9:	31 c0                	xor    %eax,%eax
    5bab:	be 04 00 00 00       	mov    $0x4,%esi
    5bb0:	89 df                	mov    %ebx,%edi
    5bb2:	80 ce 08             	or     $0x8,%dh
    5bb5:	e8 a6 c8 ff ff       	callq  2460 <fcntl@plt>
	if (ret == -1) {
    5bba:	ff c0                	inc    %eax
    5bbc:	75 20                	jne    5bde <np_uart_0_init+0x14c>
		err_nbr = errno;
    5bbe:	e8 2d c8 ff ff       	callq  23f0 <__errno_location@plt>
		close(master_pty);
    5bc3:	89 df                	mov    %ebx,%edi
		err_nbr = errno;
    5bc5:	49 89 c6             	mov    %rax,%r14
		close(master_pty);
    5bc8:	e8 23 c9 ff ff       	callq  24f0 <close@plt>
		ERROR("Could not set the master PTY as non-blocking (%i)\n",
    5bcd:	41 8b 36             	mov    (%r14),%esi
    5bd0:	48 8d 3d a9 33 00 00 	lea    0x33a9(%rip),%rdi        # 8f80 <default_cmd+0xf60>
    5bd7:	31 c0                	xor    %eax,%eax
    5bd9:	e8 0e f2 ff ff       	callq  4dec <posix_print_error_and_exit>
	ret = tcgetattr(master_pty, &ter);
    5bde:	4c 8d 75 8c          	lea    -0x74(%rbp),%r14
    5be2:	89 df                	mov    %ebx,%edi
    5be4:	4c 89 f6             	mov    %r14,%rsi
    5be7:	e8 f4 c9 ff ff       	callq  25e0 <tcgetattr@plt>
	if (ret == -1) {
    5bec:	ff c0                	inc    %eax
    5bee:	75 0e                	jne    5bfe <np_uart_0_init+0x16c>
		ERROR("Could not read terminal driver settings\n");
    5bf0:	48 8d 3d bc 33 00 00 	lea    0x33bc(%rip),%rdi        # 8fb3 <default_cmd+0xf93>
    5bf7:	31 c0                	xor    %eax,%eax
    5bf9:	e8 ee f1 ff ff       	callq  4dec <posix_print_error_and_exit>
	ret = tcsetattr(master_pty, TCSANOW, &ter);
    5bfe:	31 f6                	xor    %esi,%esi
    5c00:	4c 89 f2             	mov    %r14,%rdx
    5c03:	89 df                	mov    %ebx,%edi
	ter.c_lflag &= ~(ICANON | ISIG | IEXTEN | ECHO);
    5c05:	81 65 98 f4 7f ff ff 	andl   $0xffff7ff4,-0x68(%rbp)
	ter.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR | INPCK
    5c0c:	48 b8 04 fa ff ff fe 	movabs $0xfffffffefffffa04,%rax
    5c13:	ff ff ff 
	ter.c_cc[VTIME] = 0;
    5c16:	66 c7 45 a2 00 00    	movw   $0x0,-0x5e(%rbp)
	ter.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR | INPCK
    5c1c:	48 21 45 8c          	and    %rax,-0x74(%rbp)
	ret = tcsetattr(master_pty, TCSANOW, &ter);
    5c20:	e8 cb c9 ff ff       	callq  25f0 <tcsetattr@plt>
	if (ret == -1) {
    5c25:	ff c0                	inc    %eax
    5c27:	75 0e                	jne    5c37 <np_uart_0_init+0x1a5>
		ERROR("Could not change terminal driver settings\n");
    5c29:	48 8d 3d ac 33 00 00 	lea    0x33ac(%rip),%rdi        # 8fdc <default_cmd+0xfbc>
    5c30:	31 c0                	xor    %eax,%eax
    5c32:	e8 b5 f1 ff ff       	callq  4dec <posix_print_error_and_exit>
	posix_print_trace("%s connected to pseudotty: %s\n",
    5c37:	31 c0                	xor    %eax,%eax
    5c39:	4c 89 e2             	mov    %r12,%rdx
    5c3c:	48 8d 35 b1 25 00 00 	lea    0x25b1(%rip),%rsi        # 81f4 <default_cmd+0x1d4>
    5c43:	48 8d 3d bd 33 00 00 	lea    0x33bd(%rip),%rdi        # 9007 <default_cmd+0xfe7>
    5c4a:	e8 45 f3 ff ff       	callq  4f94 <posix_print_trace>
	if (do_auto_attach) {
    5c4f:	45 84 ff             	test   %r15b,%r15b
    5c52:	0f 84 da 00 00 00    	je     5d32 <np_uart_0_init+0x2a0>
	if (auto_attach_cmd == NULL) {
    5c58:	48 83 3d a8 7f 00 00 	cmpq   $0x0,0x7fa8(%rip)        # dc08 <auto_attach_cmd>
    5c5f:	00 
{
    5c60:	49 89 e6             	mov    %rsp,%r14
	if (auto_attach_cmd == NULL) {
    5c63:	75 0e                	jne    5c73 <np_uart_0_init+0x1e1>
		auto_attach_cmd = (char *)default_cmd;
    5c65:	48 8d 05 b4 23 00 00 	lea    0x23b4(%rip),%rax        # 8020 <default_cmd>
    5c6c:	48 89 05 95 7f 00 00 	mov    %rax,0x7f95(%rip)        # dc08 <auto_attach_cmd>
	char command[strlen(auto_attach_cmd) + strlen(slave_tty) + 1];
    5c73:	4c 8b 0d 8e 7f 00 00 	mov    0x7f8e(%rip),%r9        # dc08 <auto_attach_cmd>
    5c7a:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    5c7e:	31 c0                	xor    %eax,%eax
    5c80:	48 89 f1             	mov    %rsi,%rcx
    5c83:	4c 89 cf             	mov    %r9,%rdi
    5c86:	f2 ae                	repnz scas %es:(%rdi),%al
    5c88:	4c 89 e7             	mov    %r12,%rdi
    5c8b:	48 f7 d1             	not    %rcx
    5c8e:	48 89 ca             	mov    %rcx,%rdx
    5c91:	48 89 f1             	mov    %rsi,%rcx
    5c94:	f2 ae                	repnz scas %es:(%rdi),%al
    5c96:	48 89 c8             	mov    %rcx,%rax
    5c99:	48 89 e1             	mov    %rsp,%rcx
    5c9c:	48 f7 d0             	not    %rax
    5c9f:	48 8d 54 02 0e       	lea    0xe(%rdx,%rax,1),%rdx
    5ca4:	48 89 d0             	mov    %rdx,%rax
    5ca7:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    5cae:	48 29 d1             	sub    %rdx,%rcx
    5cb1:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    5cb5:	48 89 ca             	mov    %rcx,%rdx
    5cb8:	48 39 d4             	cmp    %rdx,%rsp
    5cbb:	74 12                	je     5ccf <np_uart_0_init+0x23d>
    5cbd:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
    5cc4:	48 83 8c 24 f8 0f 00 	orq    $0x0,0xff8(%rsp)
    5ccb:	00 00 
    5ccd:	eb e9                	jmp    5cb8 <np_uart_0_init+0x226>
    5ccf:	25 ff 0f 00 00       	and    $0xfff,%eax
    5cd4:	48 29 c4             	sub    %rax,%rsp
    5cd7:	48 85 c0             	test   %rax,%rax
    5cda:	74 06                	je     5ce2 <np_uart_0_init+0x250>
    5cdc:	48 83 4c 04 f8 00    	orq    $0x0,-0x8(%rsp,%rax,1)
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
    5ce2:	4d 89 e0             	mov    %r12,%r8
    5ce5:	4c 89 c9             	mov    %r9,%rcx
    5ce8:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    5cec:	be 01 00 00 00       	mov    $0x1,%esi
    5cf1:	48 89 e7             	mov    %rsp,%rdi
    5cf4:	31 c0                	xor    %eax,%eax
    5cf6:	e8 b5 c9 ff ff       	callq  26b0 <__sprintf_chk@plt>
	int ret = system(command);
    5cfb:	48 89 e7             	mov    %rsp,%rdi
    5cfe:	e8 ad c7 ff ff       	callq  24b0 <system@plt>
    5d03:	41 89 c4             	mov    %eax,%r12d
	if (ret != 0) {
    5d06:	85 c0                	test   %eax,%eax
    5d08:	74 25                	je     5d2f <np_uart_0_init+0x29d>
		WARN("Could not attach to the UART with \"%s\"\n", command);
    5d0a:	48 89 e6             	mov    %rsp,%rsi
    5d0d:	48 8d 3d 12 33 00 00 	lea    0x3312(%rip),%rdi        # 9026 <default_cmd+0x1006>
    5d14:	31 c0                	xor    %eax,%eax
    5d16:	e8 aa f1 ff ff       	callq  4ec5 <posix_print_warning>
		WARN("The command returned %i\n", WEXITSTATUS(ret));
    5d1b:	44 89 e0             	mov    %r12d,%eax
    5d1e:	48 8d 3d 29 33 00 00 	lea    0x3329(%rip),%rdi        # 904e <default_cmd+0x102e>
    5d25:	0f b6 f4             	movzbl %ah,%esi
    5d28:	31 c0                	xor    %eax,%eax
    5d2a:	e8 96 f1 ff ff       	callq  4ec5 <posix_print_warning>
    5d2f:	4c 89 f4             	mov    %r14,%rsp
		np_uart_driver_api_0.poll_in = np_uart_tty_poll_in;
    5d32:	48 8d 05 13 fd ff ff 	lea    -0x2ed(%rip),%rax        # 5a4c <np_uart_tty_poll_in>
		d->in_fd = tty_fn;
    5d39:	41 89 5d 04          	mov    %ebx,0x4(%r13)
		d->out_fd = tty_fn;
    5d3d:	41 89 5d 00          	mov    %ebx,0x0(%r13)
		np_uart_driver_api_0.poll_in = np_uart_tty_poll_in;
    5d41:	48 89 05 98 56 00 00 	mov    %rax,0x5698(%rip)        # b3e0 <np_uart_driver_api_0>
}
    5d48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    5d4c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5d53:	00 00 
    5d55:	74 05                	je     5d5c <np_uart_0_init+0x2ca>
    5d57:	e8 44 c7 ff ff       	callq  24a0 <__stack_chk_fail@plt>
    5d5c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    5d60:	31 c0                	xor    %eax,%eax
    5d62:	5b                   	pop    %rbx
    5d63:	41 5c                	pop    %r12
    5d65:	41 5d                	pop    %r13
    5d67:	41 5e                	pop    %r14
    5d69:	41 5f                	pop    %r15
    5d6b:	5d                   	pop    %rbp
    5d6c:	c3                   	retq   

0000000000005d6d <np_uart_poll_out>:
{
    5d6d:	f3 0f 1e fa          	endbr64 
    5d71:	48 83 ec 18          	sub    $0x18,%rsp
	ret = write(d->out_fd, &out_char, 1);
    5d75:	48 8b 47 20          	mov    0x20(%rdi),%rax
    5d79:	ba 01 00 00 00       	mov    $0x1,%edx
{
    5d7e:	40 88 74 24 0c       	mov    %sil,0xc(%rsp)
	ret = write(d->out_fd, &out_char, 1);
    5d83:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
    5d88:	8b 38                	mov    (%rax),%edi
    5d8a:	e8 f1 c6 ff ff       	callq  2480 <write@plt>
}
    5d8f:	48 83 c4 18          	add    $0x18,%rsp
    5d93:	c3                   	retq   

0000000000005d94 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
    5d94:	f3 0f 1e fa          	endbr64 
	while (dev < __device_end) {
		device_pm_state_init(dev);
		z_object_init(dev);
		++dev;
	}
}
    5d98:	c3                   	retq   

0000000000005d99 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    5d99:	f3 0f 1e fa          	endbr64 
    5d9d:	41 55                	push   %r13
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    5d9f:	48 8d 05 fa 4d 00 00 	lea    0x4dfa(%rip),%rax        # aba0 <levels.4940>
{
    5da6:	41 54                	push   %r12
    5da8:	49 89 c4             	mov    %rax,%r12
    5dab:	55                   	push   %rbp
    5dac:	53                   	push   %rbx
    5dad:	52                   	push   %rdx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    5dae:	48 63 d7             	movslq %edi,%rdx
    5db1:	ff c7                	inc    %edi
    5db3:	48 8b 2c d0          	mov    (%rax,%rdx,8),%rbp
    5db7:	48 63 df             	movslq %edi,%rbx
    5dba:	49 39 2c dc          	cmp    %rbp,(%r12,%rbx,8)
    5dbe:	76 39                	jbe    5df9 <z_sys_init_run_level+0x60>
		const struct device *dev = entry->dev;
    5dc0:	4c 8b 6d 08          	mov    0x8(%rbp),%r13
		int rc = entry->init(dev);
    5dc4:	4c 89 ef             	mov    %r13,%rdi
    5dc7:	ff 55 00             	callq  *0x0(%rbp)

		if (dev != NULL) {
    5dca:	4d 85 ed             	test   %r13,%r13
    5dcd:	74 24                	je     5df3 <z_sys_init_run_level+0x5a>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
    5dcf:	49 8b 55 18          	mov    0x18(%r13),%rdx
    5dd3:	85 c0                	test   %eax,%eax
    5dd5:	74 18                	je     5def <z_sys_init_run_level+0x56>
				if (rc < 0) {
    5dd7:	89 c1                	mov    %eax,%ecx
    5dd9:	c1 f9 1f             	sar    $0x1f,%ecx
    5ddc:	31 c8                	xor    %ecx,%eax
    5dde:	29 c8                	sub    %ecx,%eax
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    5de0:	b9 ff 00 00 00       	mov    $0xff,%ecx
    5de5:	3d ff 00 00 00       	cmp    $0xff,%eax
    5dea:	0f 4f c1             	cmovg  %ecx,%eax
    5ded:	88 02                	mov    %al,(%rdx)
			}
			dev->state->initialized = true;
    5def:	80 4a 01 01          	orb    $0x1,0x1(%rdx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    5df3:	48 83 c5 10          	add    $0x10,%rbp
    5df7:	eb c1                	jmp    5dba <z_sys_init_run_level+0x21>
		}
	}
}
    5df9:	58                   	pop    %rax
    5dfa:	5b                   	pop    %rbx
    5dfb:	5d                   	pop    %rbp
    5dfc:	41 5c                	pop    %r12
    5dfe:	41 5d                	pop    %r13
    5e00:	c3                   	retq   

0000000000005e01 <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
    5e01:	f3 0f 1e fa          	endbr64 
	return dev->state->initialized && (dev->state->init_res == 0U);
    5e05:	48 8b 47 18          	mov    0x18(%rdi),%rax
    5e09:	8b 00                	mov    (%rax),%eax
    5e0b:	66 25 ff 01          	and    $0x1ff,%ax
    5e0f:	66 3d 00 01          	cmp    $0x100,%ax
    5e13:	0f 94 c0             	sete   %al
}
    5e16:	c3                   	retq   

0000000000005e17 <z_impl_device_get_binding>:
{
    5e17:	f3 0f 1e fa          	endbr64 
    5e1b:	41 54                	push   %r12
    5e1d:	55                   	push   %rbp
    5e1e:	53                   	push   %rbx
	if ((name == NULL) || (name[0] == '\0')) {
    5e1f:	48 85 ff             	test   %rdi,%rdi
    5e22:	75 05                	jne    5e29 <z_impl_device_get_binding+0x12>
		return NULL;
    5e24:	45 31 e4             	xor    %r12d,%r12d
    5e27:	eb 61                	jmp    5e8a <z_impl_device_get_binding+0x73>
	if ((name == NULL) || (name[0] == '\0')) {
    5e29:	80 3f 00             	cmpb   $0x0,(%rdi)
    5e2c:	48 89 fb             	mov    %rdi,%rbx
    5e2f:	74 f3                	je     5e24 <z_impl_device_get_binding+0xd>
	for (dev = __device_start; dev != __device_end; dev++) {
    5e31:	4c 8d 25 70 73 00 00 	lea    0x7370(%rip),%r12        # d1a8 <__device_dts_ord_10>
    5e38:	4c 89 e5             	mov    %r12,%rbp
    5e3b:	4c 3b 25 8e 51 00 00 	cmp    0x518e(%rip),%r12        # afd0 <_GLOBAL_OFFSET_TABLE_+0x1f8>
    5e42:	74 18                	je     5e5c <z_impl_device_get_binding+0x45>
		if (z_device_ready(dev) && (dev->name == name)) {
    5e44:	4c 89 e7             	mov    %r12,%rdi
    5e47:	e8 b5 ff ff ff       	callq  5e01 <z_device_ready>
    5e4c:	84 c0                	test   %al,%al
    5e4e:	74 06                	je     5e56 <z_impl_device_get_binding+0x3f>
    5e50:	49 39 1c 24          	cmp    %rbx,(%r12)
    5e54:	74 34                	je     5e8a <z_impl_device_get_binding+0x73>
	for (dev = __device_start; dev != __device_end; dev++) {
    5e56:	49 83 c4 30          	add    $0x30,%r12
    5e5a:	eb df                	jmp    5e3b <z_impl_device_get_binding+0x24>
	for (dev = __device_start; dev != __device_end; dev++) {
    5e5c:	49 89 ec             	mov    %rbp,%r12
    5e5f:	4c 3b 25 6a 51 00 00 	cmp    0x516a(%rip),%r12        # afd0 <_GLOBAL_OFFSET_TABLE_+0x1f8>
    5e66:	74 bc                	je     5e24 <z_impl_device_get_binding+0xd>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    5e68:	4c 89 e7             	mov    %r12,%rdi
    5e6b:	e8 91 ff ff ff       	callq  5e01 <z_device_ready>
    5e70:	84 c0                	test   %al,%al
    5e72:	74 10                	je     5e84 <z_impl_device_get_binding+0x6d>
    5e74:	49 8b 34 24          	mov    (%r12),%rsi
    5e78:	48 89 df             	mov    %rbx,%rdi
    5e7b:	e8 b0 c6 ff ff       	callq  2530 <strcmp@plt>
    5e80:	85 c0                	test   %eax,%eax
    5e82:	74 06                	je     5e8a <z_impl_device_get_binding+0x73>
	for (dev = __device_start; dev != __device_end; dev++) {
    5e84:	49 83 c4 30          	add    $0x30,%r12
    5e88:	eb d5                	jmp    5e5f <z_impl_device_get_binding+0x48>
}
    5e8a:	4c 89 e0             	mov    %r12,%rax
    5e8d:	5b                   	pop    %rbx
    5e8e:	5d                   	pop    %rbp
    5e8f:	41 5c                	pop    %r12
    5e91:	c3                   	retq   

0000000000005e92 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    5e92:	f3 0f 1e fa          	endbr64 
    5e96:	50                   	push   %rax
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    5e97:	48 8d 05 c2 7d 00 00 	lea    0x7dc2(%rip),%rax        # dc60 <z_sys_post_kernel>

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    5e9e:	bf 02 00 00 00       	mov    $0x2,%edi
	z_sys_post_kernel = true;
    5ea3:	c6 00 01             	movb   $0x1,(%rax)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    5ea6:	e8 ee fe ff ff       	callq  5d99 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    5eab:	e8 a0 0d 00 00       	callq  6c50 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    5eb0:	bf 03 00 00 00       	mov    $0x3,%edi
    5eb5:	e8 df fe ff ff       	callq  5d99 <z_sys_init_run_level>

	z_init_static_threads();
    5eba:	e8 dc 0c 00 00       	callq  6b9b <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    5ebf:	e8 fd ca ff ff       	callq  29c1 <zephyr_app_main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    5ec4:	48 8d 05 75 7b 00 00 	lea    0x7b75(%rip),%rax        # da40 <z_main_thread>
    5ecb:	80 60 18 fe          	andb   $0xfe,0x18(%rax)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    5ecf:	5a                   	pop    %rdx
    5ed0:	c3                   	retq   

0000000000005ed1 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    5ed1:	f3 0f 1e fa          	endbr64 
    5ed5:	41 55                	push   %r13
    5ed7:	41 54                	push   %r12
    5ed9:	55                   	push   %rbp
    5eda:	53                   	push   %rbx
    5edb:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    5ee2:	48 8d 1d f7 7b 00 00 	lea    0x7bf7(%rip),%rbx        # dae0 <_kernel>
    5ee9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5ef0:	00 00 
    5ef2:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
    5ef9:	00 
    5efa:	31 c0                	xor    %eax,%eax
    5efc:	48 89 e0             	mov    %rsp,%rax
	dummy_thread->base.user_options = K_ESSENTIAL;
    5eff:	66 c7 44 24 18 01 01 	movw   $0x101,0x18(%rsp)
	_current_cpu->current = dummy_thread;
    5f06:	48 89 43 10          	mov    %rax,0x10(%rbx)
#endif
#if defined(CONFIG_MMU) && defined(CONFIG_USERSPACE)
	z_kernel_map_fixup();
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    5f0a:	e8 85 fe ff ff       	callq  5d94 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    5f0f:	31 ff                	xor    %edi,%edi
    5f11:	e8 83 fe ff ff       	callq  5d99 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    5f16:	bf 01 00 00 00       	mov    $0x1,%edi
    5f1b:	e8 79 fe ff ff       	callq  5d99 <z_sys_init_run_level>
	z_sched_init();
    5f20:	e8 af 09 00 00       	callq  68d4 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    5f25:	45 31 c9             	xor    %r9d,%r9d
    5f28:	45 31 c0             	xor    %r8d,%r8d
    5f2b:	ba 00 04 00 00       	mov    $0x400,%edx
	_kernel.ready_q.cache = &z_main_thread;
    5f30:	48 8d 2d 09 7b 00 00 	lea    0x7b09(%rip),%rbp        # da40 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    5f37:	48 8d 05 ce 31 00 00 	lea    0x31ce(%rip),%rax        # 910c <default_cmd+0x10ec>
    5f3e:	48 8d 35 03 66 00 00 	lea    0x6603(%rip),%rsi        # c548 <z_main_stack>
    5f45:	48 8d 0d 46 ff ff ff 	lea    -0xba(%rip),%rcx        # 5e92 <bg_thread_main>
	_kernel.ready_q.cache = &z_main_thread;
    5f4c:	48 89 6b 38          	mov    %rbp,0x38(%rbx)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    5f50:	48 89 ef             	mov    %rbp,%rdi
    5f53:	50                   	push   %rax
    5f54:	6a 01                	pushq  $0x1
    5f56:	6a 00                	pushq  $0x0
    5f58:	6a 00                	pushq  $0x0
    5f5a:	e8 a0 0b 00 00       	callq  6aff <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    5f5f:	80 65 19 fb          	andb   $0xfb,0x19(%rbp)
    5f63:	48 83 c4 20          	add    $0x20,%rsp
	z_ready_thread(&z_main_thread);
    5f67:	48 89 ef             	mov    %rbp,%rdi
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    5f6a:	49 89 c5             	mov    %rax,%r13
	z_ready_thread(&z_main_thread);
    5f6d:	e8 57 08 00 00       	callq  67c9 <z_ready_thread>
	z_setup_new_thread(thread, stack,
    5f72:	6a 00                	pushq  $0x0
    5f74:	45 31 c9             	xor    %r9d,%r9d
    5f77:	49 89 d8             	mov    %rbx,%r8
    5f7a:	6a 01                	pushq  $0x1
    5f7c:	4c 8d 25 1d 7a 00 00 	lea    0x7a1d(%rip),%r12        # d9a0 <z_idle_threads>
    5f83:	ba 00 01 00 00       	mov    $0x100,%edx
    5f88:	48 8d 35 b9 64 00 00 	lea    0x64b9(%rip),%rsi        # c448 <z_idle_stacks>
    5f8f:	6a 0f                	pushq  $0xf
    5f91:	48 8d 0d 18 10 00 00 	lea    0x1018(%rip),%rcx        # 6fb0 <idle>
    5f98:	6a 00                	pushq  $0x0
    5f9a:	4c 89 e7             	mov    %r12,%rdi
    5f9d:	e8 5d 0b 00 00       	callq  6aff <z_setup_new_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    5fa2:	4c 89 63 18          	mov    %r12,0x18(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    5fa6:	4c 89 ee             	mov    %r13,%rsi
    5fa9:	48 89 ef             	mov    %rbp,%rdi
		_kernel.cpus[i].irq_stack =
    5fac:	48 8d 05 95 69 00 00 	lea    0x6995(%rip),%rax        # c948 <z_interrupt_stacks>
		_kernel.cpus[i].id = i;
    5fb3:	c6 43 24 00          	movb   $0x0,0x24(%rbx)
	z_setup_new_thread(thread, stack,
    5fb7:	48 83 c4 20          	add    $0x20,%rsp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    5fbb:	48 8d 15 d0 fe ff ff 	lea    -0x130(%rip),%rdx        # 5e92 <bg_thread_main>
    5fc2:	41 80 64 24 19 fb    	andb   $0xfb,0x19(%r12)
		_kernel.cpus[i].irq_stack =
    5fc8:	48 05 00 08 00 00    	add    $0x800,%rax
    5fce:	48 89 43 08          	mov    %rax,0x8(%rbx)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    5fd2:	48 8d 43 28          	lea    0x28(%rbx),%rax
    5fd6:	48 89 43 28          	mov    %rax,0x28(%rbx)
	list->tail = (sys_dnode_t *)list;
    5fda:	48 89 43 30          	mov    %rax,0x30(%rbx)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    5fde:	e8 fa de ff ff       	callq  3edd <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    5fe3:	ba 27 01 00 00       	mov    $0x127,%edx
    5fe8:	48 8d 35 22 31 00 00 	lea    0x3122(%rip),%rsi        # 9111 <default_cmd+0x10f1>
    5fef:	31 c0                	xor    %eax,%eax
    5ff1:	48 8d 3d bb 22 00 00 	lea    0x22bb(%rip),%rdi        # 82b3 <default_cmd+0x293>
    5ff8:	e8 ef ed ff ff       	callq  4dec <posix_print_error_and_exit>

0000000000005ffd <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
    5ffd:	f3 0f 1e fa          	endbr64 
    6001:	41 57                	push   %r15
    6003:	41 56                	push   %r14
    6005:	49 89 d6             	mov    %rdx,%r14
    6008:	41 55                	push   %r13
    600a:	41 54                	push   %r12
    600c:	49 89 fc             	mov    %rdi,%r12
    600f:	55                   	push   %rbp

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    6010:	48 8d 6f 10          	lea    0x10(%rdi),%rbp
{
    6014:	48 83 ec 10          	sub    $0x10,%rsp
    6018:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
    601d:	e8 33 ea ff ff       	callq  4a55 <posix_irq_lock>

	if (msgq->used_msgs < msgq->max_msgs) {
    6022:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6027:	41 89 c5             	mov    %eax,%r13d
    602a:	41 8b 44 24 18       	mov    0x18(%r12),%eax
    602f:	41 39 44 24 40       	cmp    %eax,0x40(%r12)
    6034:	73 6d                	jae    60a3 <z_impl_k_msgq_put+0xa6>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    6036:	4c 89 e7             	mov    %r12,%rdi
    6039:	e8 49 08 00 00       	callq  6887 <z_unpend_first_thread>
		if (pending_thread != NULL) {
    603e:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    6043:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    6048:	48 85 c0             	test   %rax,%rax
    604b:	74 25                	je     6072 <z_impl_k_msgq_put+0x75>
    604d:	48 8b 78 20          	mov    0x20(%rax),%rdi
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
    6051:	45 31 ff             	xor    %r15d,%r15d
    6054:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
    6056:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
			z_ready_thread(pending_thread);
    605d:	48 89 c7             	mov    %rax,%rdi
    6060:	e8 64 07 00 00       	callq  67c9 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    6065:	44 89 ee             	mov    %r13d,%esi
    6068:	48 89 ef             	mov    %rbp,%rdi
    606b:	e8 5a 02 00 00       	callq  62ca <z_reschedule>
			return 0;
    6070:	eb 71                	jmp    60e3 <z_impl_k_msgq_put+0xe6>
    6072:	49 8b 7c 24 38       	mov    0x38(%r12),%rdi
    6077:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    6079:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    607e:	49 03 44 24 38       	add    0x38(%r12),%rax
    6083:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
    6088:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    608d:	75 0a                	jne    6099 <z_impl_k_msgq_put+0x9c>
				msgq->write_ptr = msgq->buffer_start;
    608f:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    6094:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			}
			msgq->used_msgs++;
    6099:	41 ff 44 24 40       	incl   0x40(%r12)
		}
		result = 0;
    609e:	45 31 ff             	xor    %r15d,%r15d
    60a1:	eb 38                	jmp    60db <z_impl_k_msgq_put+0xde>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for message space to become available */
		result = -ENOMSG;
    60a3:	41 bf d6 ff ff ff    	mov    $0xffffffd6,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    60a9:	4d 85 f6             	test   %r14,%r14
    60ac:	74 2d                	je     60db <z_impl_k_msgq_put+0xde>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
    60ae:	48 8d 05 2b 7a 00 00 	lea    0x7a2b(%rip),%rax        # dae0 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    60b5:	4c 89 f1             	mov    %r14,%rcx
    60b8:	4c 89 e2             	mov    %r12,%rdx
    60bb:	48 89 ef             	mov    %rbp,%rdi
		_current->base.swap_data = (void *) data;
    60be:	48 8b 40 10          	mov    0x10(%rax),%rax
    60c2:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    60c6:	48 83 c4 10          	add    $0x10,%rsp
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    60ca:	44 89 ee             	mov    %r13d,%esi
}
    60cd:	5d                   	pop    %rbp
    60ce:	41 5c                	pop    %r12
    60d0:	41 5d                	pop    %r13
    60d2:	41 5e                	pop    %r14
    60d4:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    60d6:	e9 0c 04 00 00       	jmpq   64e7 <z_pend_curr>
	posix_irq_unlock(key);
    60db:	44 89 ef             	mov    %r13d,%edi
    60de:	e8 80 e9 ff ff       	callq  4a63 <posix_irq_unlock>
}
    60e3:	48 83 c4 10          	add    $0x10,%rsp
    60e7:	44 89 f8             	mov    %r15d,%eax
    60ea:	5d                   	pop    %rbp
    60eb:	41 5c                	pop    %r12
    60ed:	41 5d                	pop    %r13
    60ef:	41 5e                	pop    %r14
    60f1:	41 5f                	pop    %r15
    60f3:	c3                   	retq   

00000000000060f4 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    60f4:	f3 0f 1e fa          	endbr64 
    60f8:	41 57                	push   %r15
    60fa:	41 56                	push   %r14
    60fc:	49 89 d6             	mov    %rdx,%r14
    60ff:	41 55                	push   %r13

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    6101:	4c 8d 6f 10          	lea    0x10(%rdi),%r13
{
    6105:	41 54                	push   %r12
    6107:	49 89 fc             	mov    %rdi,%r12
    610a:	55                   	push   %rbp
    610b:	53                   	push   %rbx
    610c:	48 89 f3             	mov    %rsi,%rbx
    610f:	41 51                	push   %r9
	return posix_irq_lock();
    6111:	e8 3f e9 ff ff       	callq  4a55 <posix_irq_lock>

	if (msgq->used_msgs > 0U) {
    6116:	41 83 7c 24 40 00    	cmpl   $0x0,0x40(%r12)
    611c:	89 c5                	mov    %eax,%ebp
    611e:	0f 84 9f 00 00 00    	je     61c3 <z_impl_k_msgq_get+0xcf>
    6124:	49 8b 74 24 30       	mov    0x30(%r12),%rsi
    6129:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    612e:	48 89 df             	mov    %rbx,%rdi
    6131:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
    6133:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    6138:	49 03 44 24 30       	add    0x30(%r12),%rax
    613d:	49 89 44 24 30       	mov    %rax,0x30(%r12)
		if (msgq->read_ptr == msgq->buffer_end) {
    6142:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    6147:	75 0a                	jne    6153 <z_impl_k_msgq_get+0x5f>
			msgq->read_ptr = msgq->buffer_start;
    6149:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    614e:	49 89 44 24 30       	mov    %rax,0x30(%r12)
		}
		msgq->used_msgs--;
    6153:	41 ff 4c 24 40       	decl   0x40(%r12)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    6158:	4c 89 e7             	mov    %r12,%rdi
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
		}
		result = 0;
    615b:	45 31 ff             	xor    %r15d,%r15d
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    615e:	e8 24 07 00 00       	callq  6887 <z_unpend_first_thread>
    6163:	49 89 c0             	mov    %rax,%r8
		if (pending_thread != NULL) {
    6166:	48 85 c0             	test   %rax,%rax
    6169:	0f 84 8a 00 00 00    	je     61f9 <z_impl_k_msgq_get+0x105>
    616f:	48 8b 70 20          	mov    0x20(%rax),%rsi
    6173:	49 8b 7c 24 38       	mov    0x38(%r12),%rdi
    6178:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    617d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
			msgq->write_ptr += msgq->msg_size;
    617f:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    6184:	49 03 44 24 38       	add    0x38(%r12),%rax
    6189:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
    618e:	49 3b 44 24 28       	cmp    0x28(%r12),%rax
    6193:	75 0a                	jne    619f <z_impl_k_msgq_get+0xab>
				msgq->write_ptr = msgq->buffer_start;
    6195:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    619a:	49 89 44 24 38       	mov    %rax,0x38(%r12)
			msgq->used_msgs++;
    619f:	41 ff 44 24 40       	incl   0x40(%r12)
			z_ready_thread(pending_thread);
    61a4:	4c 89 c7             	mov    %r8,%rdi
			return 0;
    61a7:	45 31 ff             	xor    %r15d,%r15d
    61aa:	41 c7 40 4c 00 00 00 	movl   $0x0,0x4c(%r8)
    61b1:	00 
			z_ready_thread(pending_thread);
    61b2:	e8 12 06 00 00       	callq  67c9 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    61b7:	89 ee                	mov    %ebp,%esi
    61b9:	4c 89 ef             	mov    %r13,%rdi
    61bc:	e8 09 01 00 00       	callq  62ca <z_reschedule>
			return 0;
    61c1:	eb 3d                	jmp    6200 <z_impl_k_msgq_get+0x10c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for a message to become available */
		result = -ENOMSG;
    61c3:	41 bf d6 ff ff ff    	mov    $0xffffffd6,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    61c9:	4d 85 f6             	test   %r14,%r14
    61cc:	74 2b                	je     61f9 <z_impl_k_msgq_get+0x105>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
    61ce:	48 8d 05 0b 79 00 00 	lea    0x790b(%rip),%rax        # dae0 <_kernel>
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    61d5:	4c 89 f1             	mov    %r14,%rcx
    61d8:	4c 89 e2             	mov    %r12,%rdx
    61db:	89 ee                	mov    %ebp,%esi
    61dd:	4c 89 ef             	mov    %r13,%rdi
		_current->base.swap_data = data;
    61e0:	48 8b 40 10          	mov    0x10(%rax),%rax
    61e4:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    61e8:	41 58                	pop    %r8
    61ea:	5b                   	pop    %rbx
    61eb:	5d                   	pop    %rbp
    61ec:	41 5c                	pop    %r12
    61ee:	41 5d                	pop    %r13
    61f0:	41 5e                	pop    %r14
    61f2:	41 5f                	pop    %r15
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    61f4:	e9 ee 02 00 00       	jmpq   64e7 <z_pend_curr>
	posix_irq_unlock(key);
    61f9:	89 ef                	mov    %ebp,%edi
    61fb:	e8 63 e8 ff ff       	callq  4a63 <posix_irq_unlock>
}
    6200:	5a                   	pop    %rdx
    6201:	44 89 f8             	mov    %r15d,%eax
    6204:	5b                   	pop    %rbx
    6205:	5d                   	pop    %rbp
    6206:	41 5c                	pop    %r12
    6208:	41 5d                	pop    %r13
    620a:	41 5e                	pop    %r14
    620c:	41 5f                	pop    %r15
    620e:	c3                   	retq   

000000000000620f <z_sched_prio_cmp>:
 * Do not rely on the actual value returned aside from the above.
 * (Again, like memcmp.)
 */
int32_t z_sched_prio_cmp(struct k_thread *thread_1,
	struct k_thread *thread_2)
{
    620f:	f3 0f 1e fa          	endbr64 
	/* `prio` is <32b, so the below cannot overflow. */
	int32_t b1 = thread_1->base.prio;
    6213:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
	int32_t b2 = thread_2->base.prio;
    6217:	0f be 4e 1a          	movsbl 0x1a(%rsi),%ecx
		 * from UB on overflow to impdef.
		 */
		return (int32_t) (d2 - d1);
	}
#endif
	return 0;
    621b:	31 c0                	xor    %eax,%eax
	if (b1 != b2) {
    621d:	39 ca                	cmp    %ecx,%edx
    621f:	74 04                	je     6225 <z_sched_prio_cmp+0x16>
		return b2 - b1;
    6221:	89 c8                	mov    %ecx,%eax
    6223:	29 d0                	sub    %edx,%eax
}
    6225:	c3                   	retq   

0000000000006226 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    6226:	f3 0f 1e fa          	endbr64 
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    622a:	83 3d 1f 7a 00 00 00 	cmpl   $0x0,0x7a1f(%rip)        # dc50 <slice_time>
    6231:	74 20                	je     6253 <z_reset_time_slice+0x2d>
{
    6233:	50                   	push   %rax
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    6234:	e8 99 d7 ff ff       	callq  39d2 <sys_clock_elapsed>
    6239:	8b 3d 11 7a 00 00    	mov    0x7a11(%rip),%edi        # dc50 <slice_time>
    623f:	48 8d 15 9a 78 00 00 	lea    0x789a(%rip),%rdx        # dae0 <_kernel>
		z_set_timeout_expiry(slice_time, false);
    6246:	31 f6                	xor    %esi,%esi
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    6248:	01 f8                	add    %edi,%eax
    624a:	89 42 20             	mov    %eax,0x20(%rdx)
	}
}
    624d:	5a                   	pop    %rdx
		z_set_timeout_expiry(slice_time, false);
    624e:	e9 22 0c 00 00       	jmpq   6e75 <z_set_timeout_expiry>
    6253:	c3                   	retq   

0000000000006254 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    6254:	f3 0f 1e fa          	endbr64 
    6258:	41 54                	push   %r12
    625a:	41 89 f4             	mov    %esi,%r12d
    625d:	55                   	push   %rbp
    625e:	53                   	push   %rbx
    625f:	89 fb                	mov    %edi,%ebx
	return posix_irq_lock();
    6261:	e8 ef e7 ff ff       	callq  4a55 <posix_irq_lock>
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
    6266:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    626b:	89 c5                	mov    %eax,%ebp
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    626d:	48 8d 05 6c 78 00 00 	lea    0x786c(%rip),%rax        # dae0 <_kernel>
    6274:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    627b:	89 d8                	mov    %ebx,%eax
		t += off;
    627d:	48 83 c0 09          	add    $0x9,%rax
		if (result32 && (t < BIT64(32))) {
    6281:	48 39 d0             	cmp    %rdx,%rax
    6284:	77 0e                	ja     6294 <k_sched_time_slice_set+0x40>
			return ((uint32_t)t) / (from_hz / to_hz);
    6286:	8d 43 09             	lea    0x9(%rbx),%eax
    6289:	b9 0a 00 00 00       	mov    $0xa,%ecx
    628e:	31 d2                	xor    %edx,%edx
    6290:	f7 f1                	div    %ecx
    6292:	eb 0a                	jmp    629e <k_sched_time_slice_set+0x4a>
			return t / (from_hz / to_hz);
    6294:	b9 0a 00 00 00       	mov    $0xa,%ecx
    6299:	31 d2                	xor    %edx,%edx
    629b:	48 f7 f1             	div    %rcx
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    629e:	85 db                	test   %ebx,%ebx
    62a0:	7e 0b                	jle    62ad <k_sched_time_slice_set+0x59>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    62a2:	83 f8 02             	cmp    $0x2,%eax
    62a5:	ba 02 00 00 00       	mov    $0x2,%edx
    62aa:	0f 4c c2             	cmovl  %edx,%eax
		}
		slice_max_prio = prio;
    62ad:	44 89 25 98 79 00 00 	mov    %r12d,0x7998(%rip)        # dc4c <slice_max_prio>
			slice_time = MAX(2, slice_time);
    62b4:	89 05 96 79 00 00    	mov    %eax,0x7996(%rip)        # dc50 <slice_time>
		z_reset_time_slice();
    62ba:	e8 67 ff ff ff       	callq  6226 <z_reset_time_slice>
	}
}
    62bf:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    62c0:	89 ef                	mov    %ebp,%edi
    62c2:	5d                   	pop    %rbp
    62c3:	41 5c                	pop    %r12
    62c5:	e9 99 e7 ff ff       	jmpq   4a63 <posix_irq_unlock>

00000000000062ca <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    62ca:	f3 0f 1e fa          	endbr64 
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    62ce:	48 8d 05 0b 78 00 00 	lea    0x780b(%rip),%rax        # dae0 <_kernel>
	if (resched(key.key) && need_swap()) {
    62d5:	89 f2                	mov    %esi,%edx
{
    62d7:	89 f7                	mov    %esi,%edi
	if (resched(key.key) && need_swap()) {
    62d9:	0b 10                	or     (%rax),%edx
    62db:	75 11                	jne    62ee <z_reschedule+0x24>
    62dd:	48 8b 48 10          	mov    0x10(%rax),%rcx
    62e1:	48 39 48 38          	cmp    %rcx,0x38(%rax)
    62e5:	74 07                	je     62ee <z_reschedule+0x24>
	ret = arch_swap(key);
    62e7:	31 ff                	xor    %edi,%edi
    62e9:	e9 a5 db ff ff       	jmpq   3e93 <arch_swap>
    62ee:	e9 70 e7 ff ff       	jmpq   4a63 <posix_irq_unlock>

00000000000062f3 <z_reschedule_irqlock>:
		k_spin_unlock(lock, key);
	}
}

void z_reschedule_irqlock(uint32_t key)
{
    62f3:	f3 0f 1e fa          	endbr64 
	if (resched(key)) {
    62f7:	48 8d 05 e2 77 00 00 	lea    0x77e2(%rip),%rax        # dae0 <_kernel>
    62fe:	89 fa                	mov    %edi,%edx
    6300:	0b 10                	or     (%rax),%edx
    6302:	75 07                	jne    630b <z_reschedule_irqlock+0x18>
    6304:	31 ff                	xor    %edi,%edi
    6306:	e9 88 db ff ff       	jmpq   3e93 <arch_swap>
    630b:	e9 53 e7 ff ff       	jmpq   4a63 <posix_irq_unlock>

0000000000006310 <z_reschedule_unlocked>:
{
    6310:	50                   	push   %rax
	return posix_irq_lock();
    6311:	e8 3f e7 ff ff       	callq  4a55 <posix_irq_lock>
}
    6316:	5a                   	pop    %rdx
    6317:	89 c7                	mov    %eax,%edi
	(void) z_reschedule_irqlock(arch_irq_lock());
    6319:	e9 d5 ff ff ff       	jmpq   62f3 <z_reschedule_irqlock>

000000000000631e <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
    631e:	f3 0f 1e fa          	endbr64 
    6322:	50                   	push   %rax
    6323:	e8 2d e7 ff ff       	callq  4a55 <posix_irq_lock>
    6328:	89 c7                	mov    %eax,%edi
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    632a:	48 8d 05 af 77 00 00 	lea    0x77af(%rip),%rax        # dae0 <_kernel>
    6331:	48 8b 40 10          	mov    0x10(%rax),%rax
    6335:	fe 48 1b             	decb   0x1b(%rax)
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    6338:	5a                   	pop    %rdx
	posix_irq_unlock(key);
    6339:	e9 25 e7 ff ff       	jmpq   4a63 <posix_irq_unlock>

000000000000633e <z_priq_dumb_remove>:

	sys_dlist_append(pq, &thread->base.qnode_dlist);
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    633e:	f3 0f 1e fa          	endbr64 
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    6342:	48 8b 56 08          	mov    0x8(%rsi),%rdx
	sys_dnode_t *const next = node->next;
    6346:	48 8b 06             	mov    (%rsi),%rax

	prev->next = next;
    6349:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
    634c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    6350:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	node->prev = NULL;
    6357:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
    635e:	00 
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    635f:	c3                   	retq   

0000000000006360 <unpend_thread_no_timeout>:
{
    6360:	53                   	push   %rbx
    6361:	48 89 fb             	mov    %rdi,%rbx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
    6364:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    6368:	48 89 de             	mov    %rbx,%rsi
    636b:	e8 ce ff ff ff       	callq  633e <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    6370:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
	thread->base.pended_on = NULL;
    6374:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    637b:	00 
}
    637c:	5b                   	pop    %rbx
    637d:	c3                   	retq   

000000000000637e <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    637e:	f3 0f 1e fa          	endbr64 
	return list->head == list;
    6382:	48 8b 07             	mov    (%rdi),%rax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
    6385:	48 85 c0             	test   %rax,%rax
    6388:	74 05                	je     638f <z_priq_dumb_best+0x11>
    638a:	48 39 c7             	cmp    %rax,%rdi
    638d:	75 02                	jne    6391 <z_priq_dumb_best+0x13>
	struct k_thread *thread = NULL;
    638f:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    6391:	c3                   	retq   

0000000000006392 <update_cache>:
{
    6392:	41 54                	push   %r12
    6394:	41 89 fc             	mov    %edi,%r12d
    6397:	55                   	push   %rbp
	thread = _priq_run_best(&_kernel.ready_q.runq);
    6398:	48 8d 2d 41 77 00 00 	lea    0x7741(%rip),%rbp        # dae0 <_kernel>
{
    639f:	53                   	push   %rbx
	thread = _priq_run_best(&_kernel.ready_q.runq);
    63a0:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    63a4:	e8 d5 ff ff ff       	callq  637e <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    63a9:	48 89 c3             	mov    %rax,%rbx
    63ac:	48 85 c0             	test   %rax,%rax
    63af:	75 04                	jne    63b5 <update_cache+0x23>
    63b1:	48 8b 5d 18          	mov    0x18(%rbp),%rbx
	if (preempt_ok != 0) {
    63b5:	48 8b 45 10          	mov    0x10(%rbp),%rax
    63b9:	45 85 e4             	test   %r12d,%r12d
    63bc:	75 13                	jne    63d1 <update_cache+0x3f>
	if (z_is_thread_prevented_from_running(_current)) {
    63be:	f6 40 19 1f          	testb  $0x1f,0x19(%rax)
    63c2:	75 0d                	jne    63d1 <update_cache+0x3f>
	if (is_preempt(_current) || is_metairq(thread)) {
    63c4:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
    63c9:	76 06                	jbe    63d1 <update_cache+0x3f>
		_kernel.ready_q.cache = _current;
    63cb:	48 89 45 38          	mov    %rax,0x38(%rbp)
    63cf:	eb 0e                	jmp    63df <update_cache+0x4d>
		if (thread != _current) {
    63d1:	48 39 c3             	cmp    %rax,%rbx
    63d4:	74 05                	je     63db <update_cache+0x49>
			z_reset_time_slice();
    63d6:	e8 4b fe ff ff       	callq  6226 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    63db:	48 89 5d 38          	mov    %rbx,0x38(%rbp)
}
    63df:	5b                   	pop    %rbx
    63e0:	5d                   	pop    %rbp
    63e1:	41 5c                	pop    %r12
    63e3:	c3                   	retq   

00000000000063e4 <unready_thread>:
{
    63e4:	55                   	push   %rbp
    63e5:	53                   	push   %rbx
    63e6:	48 89 fb             	mov    %rdi,%rbx
    63e9:	52                   	push   %rdx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    63ea:	8a 47 19             	mov    0x19(%rdi),%al
	return (thread->base.thread_state & state) != 0U;
    63ed:	48 8d 2d ec 76 00 00 	lea    0x76ec(%rip),%rbp        # dae0 <_kernel>
	if (z_is_thread_queued(thread)) {
    63f4:	84 c0                	test   %al,%al
    63f6:	79 12                	jns    640a <unready_thread+0x26>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    63f8:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    63fb:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    63fe:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    6401:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    6405:	e8 34 ff ff ff       	callq  633e <z_priq_dumb_remove>
	update_cache(thread == _current);
    640a:	31 ff                	xor    %edi,%edi
    640c:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
}
    6410:	58                   	pop    %rax
	update_cache(thread == _current);
    6411:	40 0f 94 c7          	sete   %dil
}
    6415:	5b                   	pop    %rbx
    6416:	5d                   	pop    %rbp
	update_cache(thread == _current);
    6417:	e9 76 ff ff ff       	jmpq   6392 <update_cache>

000000000000641c <add_to_waitq_locked>:
{
    641c:	41 54                	push   %r12
    641e:	55                   	push   %rbp
    641f:	48 89 f5             	mov    %rsi,%rbp
    6422:	53                   	push   %rbx
    6423:	48 89 fb             	mov    %rdi,%rbx
	unready_thread(thread);
    6426:	e8 b9 ff ff ff       	callq  63e4 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    642b:	80 4b 19 02          	orb    $0x2,0x19(%rbx)
	if (wait_q != NULL) {
    642f:	48 85 ed             	test   %rbp,%rbp
    6432:	74 5a                	je     648e <add_to_waitq_locked+0x72>
    6434:	4c 8b 65 00          	mov    0x0(%rbp),%r12
		thread->base.pended_on = wait_q;
    6438:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    643c:	4d 85 e4             	test   %r12,%r12
    643f:	74 05                	je     6446 <add_to_waitq_locked+0x2a>
    6441:	4c 39 e5             	cmp    %r12,%rbp
    6444:	75 14                	jne    645a <add_to_waitq_locked+0x3e>
	sys_dnode_t *const tail = list->tail;
    6446:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = list;
    644a:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = tail;
    644d:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    6451:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    6454:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    6458:	eb 34                	jmp    648e <add_to_waitq_locked+0x72>
		if (z_sched_prio_cmp(thread, t) > 0) {
    645a:	4c 89 e6             	mov    %r12,%rsi
    645d:	48 89 df             	mov    %rbx,%rdi
    6460:	e8 aa fd ff ff       	callq  620f <z_sched_prio_cmp>
    6465:	85 c0                	test   %eax,%eax
    6467:	7e 16                	jle    647f <add_to_waitq_locked+0x63>
	sys_dnode_t *const prev = successor->prev;
    6469:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
    646e:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = prev;
    6471:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    6475:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    6478:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
    647d:	eb 0f                	jmp    648e <add_to_waitq_locked+0x72>
	return (node == list->tail) ? NULL : node->next;
    647f:	4c 3b 65 08          	cmp    0x8(%rbp),%r12
    6483:	74 c1                	je     6446 <add_to_waitq_locked+0x2a>
    6485:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6489:	4d 85 e4             	test   %r12,%r12
    648c:	eb b6                	jmp    6444 <add_to_waitq_locked+0x28>
}
    648e:	5b                   	pop    %rbx
    648f:	5d                   	pop    %rbp
    6490:	41 5c                	pop    %r12
    6492:	c3                   	retq   

0000000000006493 <pend>:
{
    6493:	55                   	push   %rbp
    6494:	53                   	push   %rbx
    6495:	48 89 fb             	mov    %rdi,%rbx
    6498:	48 83 ec 18          	sub    $0x18,%rsp
    649c:	48 89 14 24          	mov    %rdx,(%rsp)
    64a0:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	return posix_irq_lock();
    64a5:	e8 ab e5 ff ff       	callq  4a55 <posix_irq_lock>
		add_to_waitq_locked(thread, wait_q);
    64aa:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    64af:	48 89 df             	mov    %rbx,%rdi
    64b2:	89 c5                	mov    %eax,%ebp
    64b4:	e8 63 ff ff ff       	callq  641c <add_to_waitq_locked>
	posix_irq_unlock(key);
    64b9:	89 ef                	mov    %ebp,%edi
    64bb:	e8 a3 e5 ff ff       	callq  4a63 <posix_irq_unlock>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    64c0:	48 8b 14 24          	mov    (%rsp),%rdx
    64c4:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    64c8:	74 16                	je     64e0 <pend+0x4d>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    64ca:	48 8d 35 74 03 00 00 	lea    0x374(%rip),%rsi        # 6845 <z_thread_timeout>
}
    64d1:	48 83 c4 18          	add    $0x18,%rsp
    64d5:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
    64d9:	5b                   	pop    %rbx
    64da:	5d                   	pop    %rbp
    64db:	e9 37 08 00 00       	jmpq   6d17 <z_add_timeout>
    64e0:	48 83 c4 18          	add    $0x18,%rsp
    64e4:	5b                   	pop    %rbx
    64e5:	5d                   	pop    %rbp
    64e6:	c3                   	retq   

00000000000064e7 <z_pend_curr>:
{
    64e7:	f3 0f 1e fa          	endbr64 
	pend(_current, wait_q, timeout);
    64eb:	48 8d 05 ee 75 00 00 	lea    0x75ee(%rip),%rax        # dae0 <_kernel>
{
    64f2:	55                   	push   %rbp
    64f3:	89 f5                	mov    %esi,%ebp
    64f5:	48 89 d6             	mov    %rdx,%rsi
    64f8:	48 89 ca             	mov    %rcx,%rdx
	pend(_current, wait_q, timeout);
    64fb:	48 8b 78 10          	mov    0x10(%rax),%rdi
    64ff:	e8 8f ff ff ff       	callq  6493 <pend>
    6504:	89 ef                	mov    %ebp,%edi
}
    6506:	5d                   	pop    %rbp
    6507:	e9 87 d9 ff ff       	jmpq   3e93 <arch_swap>

000000000000650c <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
    650c:	41 55                	push   %r13
    650e:	41 54                	push   %r12
    6510:	55                   	push   %rbp
    6511:	53                   	push   %rbx
    6512:	48 89 fb             	mov    %rdi,%rbx
    6515:	50                   	push   %rax
		return 0;
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);

	expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    6516:	e8 89 0a 00 00       	callq  6fa4 <sys_clock_tick_get_32>
    651b:	89 c5                	mov    %eax,%ebp
	return posix_irq_lock();
    651d:	e8 33 e5 ff ff       	callq  4a55 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
    6522:	4c 8d 2d b7 75 00 00 	lea    0x75b7(%rip),%r13        # dae0 <_kernel>
    6529:	41 89 c4             	mov    %eax,%r12d
    652c:	49 8b 7d 10          	mov    0x10(%r13),%rdi
    6530:	e8 af fe ff ff       	callq  63e4 <unready_thread>
    6535:	49 8b 45 10          	mov    0x10(%r13),%rax
    6539:	48 8d 35 05 03 00 00 	lea    0x305(%rip),%rsi        # 6845 <z_thread_timeout>
    6540:	48 89 da             	mov    %rbx,%rdx

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    6543:	01 eb                	add    %ebp,%ebx
    6545:	48 8d 78 28          	lea    0x28(%rax),%rdi
    6549:	e8 c9 07 00 00       	callq  6d17 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    654e:	49 8b 45 10          	mov    0x10(%r13),%rax
    6552:	44 89 e7             	mov    %r12d,%edi
	thread->base.thread_state |= _THREAD_SUSPENDED;
    6555:	80 48 19 10          	orb    $0x10,0x19(%rax)
    6559:	e8 35 d9 ff ff       	callq  3e93 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    655e:	e8 41 0a 00 00       	callq  6fa4 <sys_clock_tick_get_32>
	if (ticks > 0) {
    6563:	ba 00 00 00 00       	mov    $0x0,%edx
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    6568:	89 c0                	mov    %eax,%eax
    656a:	48 29 c3             	sub    %rax,%rbx
    656d:	48 89 d8             	mov    %rbx,%rax
    6570:	48 0f 48 c2          	cmovs  %rdx,%rax
		return ticks;
	}
#endif

	return 0;
}
    6574:	5a                   	pop    %rdx
    6575:	5b                   	pop    %rbx
    6576:	5d                   	pop    %rbp
    6577:	41 5c                	pop    %r12
    6579:	41 5d                	pop    %r13
    657b:	c3                   	retq   

000000000000657c <z_impl_k_thread_suspend>:
{
    657c:	f3 0f 1e fa          	endbr64 
    6580:	41 54                	push   %r12
    6582:	55                   	push   %rbp
    6583:	53                   	push   %rbx
    6584:	48 89 fb             	mov    %rdi,%rbx
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    6587:	48 83 c7 28          	add    $0x28,%rdi
    658b:	e8 a3 08 00 00       	callq  6e33 <z_abort_timeout>
    6590:	e8 c0 e4 ff ff       	callq  4a55 <posix_irq_lock>
    6595:	48 8d 2d 44 75 00 00 	lea    0x7544(%rip),%rbp        # dae0 <_kernel>
    659c:	41 89 c4             	mov    %eax,%r12d
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    659f:	8a 43 19             	mov    0x19(%rbx),%al
		if (z_is_thread_queued(thread)) {
    65a2:	84 c0                	test   %al,%al
    65a4:	79 12                	jns    65b8 <z_impl_k_thread_suspend+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    65a6:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    65a9:	48 89 de             	mov    %rbx,%rsi
    65ac:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    65b0:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    65b3:	e8 86 fd ff ff       	callq  633e <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    65b8:	80 4b 19 10          	orb    $0x10,0x19(%rbx)
		update_cache(thread == _current);
    65bc:	31 ff                	xor    %edi,%edi
    65be:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    65c2:	40 0f 94 c7          	sete   %dil
    65c6:	e8 c7 fd ff ff       	callq  6392 <update_cache>
	posix_irq_unlock(key);
    65cb:	44 89 e7             	mov    %r12d,%edi
    65ce:	e8 90 e4 ff ff       	callq  4a63 <posix_irq_unlock>
	if (thread == _current) {
    65d3:	48 39 5d 10          	cmp    %rbx,0x10(%rbp)
    65d7:	75 09                	jne    65e2 <z_impl_k_thread_suspend+0x66>
}
    65d9:	5b                   	pop    %rbx
    65da:	5d                   	pop    %rbp
    65db:	41 5c                	pop    %r12
		z_reschedule_unlocked();
    65dd:	e9 2e fd ff ff       	jmpq   6310 <z_reschedule_unlocked>
}
    65e2:	5b                   	pop    %rbx
    65e3:	5d                   	pop    %rbp
    65e4:	41 5c                	pop    %r12
    65e6:	c3                   	retq   

00000000000065e7 <k_sched_unlock>:
{
    65e7:	f3 0f 1e fa          	endbr64 
    65eb:	55                   	push   %rbp
	return posix_irq_lock();
    65ec:	e8 64 e4 ff ff       	callq  4a55 <posix_irq_lock>
		update_cache(0);
    65f1:	31 ff                	xor    %edi,%edi
    65f3:	89 c5                	mov    %eax,%ebp
		++_current->base.sched_locked;
    65f5:	48 8d 05 e4 74 00 00 	lea    0x74e4(%rip),%rax        # dae0 <_kernel>
    65fc:	48 8b 40 10          	mov    0x10(%rax),%rax
    6600:	fe 40 1b             	incb   0x1b(%rax)
		update_cache(0);
    6603:	e8 8a fd ff ff       	callq  6392 <update_cache>
	posix_irq_unlock(key);
    6608:	89 ef                	mov    %ebp,%edi
    660a:	e8 54 e4 ff ff       	callq  4a63 <posix_irq_unlock>
}
    660f:	5d                   	pop    %rbp
	z_reschedule_unlocked();
    6610:	e9 fb fc ff ff       	jmpq   6310 <z_reschedule_unlocked>

0000000000006615 <move_thread_to_end_of_prio_q>:
{
    6615:	41 54                	push   %r12
    6617:	4c 8d 25 c2 74 00 00 	lea    0x74c2(%rip),%r12        # dae0 <_kernel>
    661e:	55                   	push   %rbp
    661f:	53                   	push   %rbx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    6620:	8a 47 19             	mov    0x19(%rdi),%al
    6623:	48 89 fb             	mov    %rdi,%rbx
	if (z_is_thread_queued(thread)) {
    6626:	84 c0                	test   %al,%al
    6628:	79 13                	jns    663d <move_thread_to_end_of_prio_q+0x28>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    662a:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
    662d:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6630:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
    6633:	49 8d 7c 24 40       	lea    0x40(%r12),%rdi
    6638:	e8 01 fd ff ff       	callq  633e <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    663d:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	return list->head == list;
    6641:	49 8b 6c 24 40       	mov    0x40(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6646:	48 85 ed             	test   %rbp,%rbp
    6649:	74 0a                	je     6655 <move_thread_to_end_of_prio_q+0x40>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    664b:	49 8d 44 24 40       	lea    0x40(%r12),%rax
    6650:	48 39 c5             	cmp    %rax,%rbp
    6653:	75 1b                	jne    6670 <move_thread_to_end_of_prio_q+0x5b>
	sys_dnode_t *const tail = list->tail;
    6655:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	node->next = list;
    665a:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
    665f:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    6662:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    6666:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    6669:	49 89 5c 24 48       	mov    %rbx,0x48(%r12)
}
    666e:	eb 33                	jmp    66a3 <move_thread_to_end_of_prio_q+0x8e>
		if (z_sched_prio_cmp(thread, t) > 0) {
    6670:	48 89 ee             	mov    %rbp,%rsi
    6673:	48 89 df             	mov    %rbx,%rdi
    6676:	e8 94 fb ff ff       	callq  620f <z_sched_prio_cmp>
    667b:	85 c0                	test   %eax,%eax
    667d:	7e 14                	jle    6693 <move_thread_to_end_of_prio_q+0x7e>
	sys_dnode_t *const prev = successor->prev;
    667f:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    6683:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = prev;
    6686:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    668a:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    668d:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    6691:	eb 10                	jmp    66a3 <move_thread_to_end_of_prio_q+0x8e>
	return (node == list->tail) ? NULL : node->next;
    6693:	49 39 6c 24 48       	cmp    %rbp,0x48(%r12)
    6698:	74 bb                	je     6655 <move_thread_to_end_of_prio_q+0x40>
    669a:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    669e:	48 85 ed             	test   %rbp,%rbp
    66a1:	eb b0                	jmp    6653 <move_thread_to_end_of_prio_q+0x3e>
	update_cache(thread == _current);
    66a3:	31 ff                	xor    %edi,%edi
    66a5:	49 39 5c 24 10       	cmp    %rbx,0x10(%r12)
}
    66aa:	5b                   	pop    %rbx
	update_cache(thread == _current);
    66ab:	40 0f 94 c7          	sete   %dil
}
    66af:	5d                   	pop    %rbp
    66b0:	41 5c                	pop    %r12
	update_cache(thread == _current);
    66b2:	e9 db fc ff ff       	jmpq   6392 <update_cache>

00000000000066b7 <z_time_slice>:
{
    66b7:	f3 0f 1e fa          	endbr64 
    66bb:	55                   	push   %rbp
    66bc:	53                   	push   %rbx
    66bd:	89 fb                	mov    %edi,%ebx
    66bf:	52                   	push   %rdx
	return posix_irq_lock();
    66c0:	e8 90 e3 ff ff       	callq  4a55 <posix_irq_lock>
	if (slice_time && sliceable(_current)) {
    66c5:	83 3d 84 75 00 00 00 	cmpl   $0x0,0x7584(%rip)        # dc50 <slice_time>
    66cc:	89 c5                	mov    %eax,%ebp
    66ce:	48 8d 05 0b 74 00 00 	lea    0x740b(%rip),%rax        # dae0 <_kernel>
    66d5:	74 40                	je     6717 <z_time_slice+0x60>
    66d7:	48 8b 78 10          	mov    0x10(%rax),%rdi
		&& !z_is_idle_thread_object(thread);
    66db:	66 83 7f 1a 7f       	cmpw   $0x7f,0x1a(%rdi)
    66e0:	77 35                	ja     6717 <z_time_slice+0x60>
		&& !z_is_thread_prevented_from_running(thread)
    66e2:	f6 47 19 1f          	testb  $0x1f,0x19(%rdi)
    66e6:	75 2f                	jne    6717 <z_time_slice+0x60>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    66e8:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
		&& !z_is_idle_thread_object(thread);
    66ec:	39 15 5a 75 00 00    	cmp    %edx,0x755a(%rip)        # dc4c <slice_max_prio>
    66f2:	7f 23                	jg     6717 <z_time_slice+0x60>
    66f4:	48 3b 3d ad 48 00 00 	cmp    0x48ad(%rip),%rdi        # afa8 <_GLOBAL_OFFSET_TABLE_+0x1d0>
    66fb:	74 1a                	je     6717 <z_time_slice+0x60>
		if (ticks >= _current_cpu->slice_ticks) {
    66fd:	8b 50 20             	mov    0x20(%rax),%edx
    6700:	39 da                	cmp    %ebx,%edx
    6702:	7f 0c                	jg     6710 <z_time_slice+0x59>
			move_thread_to_end_of_prio_q(_current);
    6704:	e8 0c ff ff ff       	callq  6615 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    6709:	e8 18 fb ff ff       	callq  6226 <z_reset_time_slice>
    670e:	eb 0e                	jmp    671e <z_time_slice+0x67>
			_current_cpu->slice_ticks -= ticks;
    6710:	29 da                	sub    %ebx,%edx
    6712:	89 50 20             	mov    %edx,0x20(%rax)
    6715:	eb 07                	jmp    671e <z_time_slice+0x67>
		_current_cpu->slice_ticks = 0;
    6717:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
}
    671e:	58                   	pop    %rax
	posix_irq_unlock(key);
    671f:	89 ef                	mov    %ebp,%edi
    6721:	5b                   	pop    %rbx
    6722:	5d                   	pop    %rbp
    6723:	e9 3b e3 ff ff       	jmpq   4a63 <posix_irq_unlock>

0000000000006728 <ready_thread>:
    6728:	8a 47 19             	mov    0x19(%rdi),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    672b:	84 c0                	test   %al,%al
    672d:	0f 88 95 00 00 00    	js     67c8 <ready_thread+0xa0>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    6733:	a8 1f                	test   $0x1f,%al
    6735:	0f 85 8d 00 00 00    	jne    67c8 <ready_thread+0xa0>
{
    673b:	41 54                	push   %r12
    673d:	55                   	push   %rbp
    673e:	53                   	push   %rbx
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    673f:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
    6744:	48 89 fb             	mov    %rdi,%rbx
    6747:	75 7a                	jne    67c3 <ready_thread+0x9b>
	return list->head == list;
    6749:	4c 8d 25 90 73 00 00 	lea    0x7390(%rip),%r12        # dae0 <_kernel>
	thread->base.thread_state |= _THREAD_QUEUED;
    6750:	83 c8 80             	or     $0xffffff80,%eax
    6753:	88 47 19             	mov    %al,0x19(%rdi)
    6756:	49 8b 6c 24 40       	mov    0x40(%r12),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    675b:	48 85 ed             	test   %rbp,%rbp
    675e:	74 0a                	je     676a <ready_thread+0x42>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6760:	49 8d 44 24 40       	lea    0x40(%r12),%rax
    6765:	48 39 c5             	cmp    %rax,%rbp
    6768:	75 1b                	jne    6785 <ready_thread+0x5d>
	sys_dnode_t *const tail = list->tail;
    676a:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	node->next = list;
    676f:	49 8d 54 24 40       	lea    0x40(%r12),%rdx
    6774:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    6777:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    677b:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    677e:	49 89 5c 24 48       	mov    %rbx,0x48(%r12)
}
    6783:	eb 33                	jmp    67b8 <ready_thread+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
    6785:	48 89 ee             	mov    %rbp,%rsi
    6788:	48 89 df             	mov    %rbx,%rdi
    678b:	e8 7f fa ff ff       	callq  620f <z_sched_prio_cmp>
    6790:	85 c0                	test   %eax,%eax
    6792:	7e 14                	jle    67a8 <ready_thread+0x80>
	sys_dnode_t *const prev = successor->prev;
    6794:	48 8b 45 08          	mov    0x8(%rbp),%rax
	node->next = successor;
    6798:	48 89 2b             	mov    %rbp,(%rbx)
	node->prev = prev;
    679b:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    679f:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    67a2:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
}
    67a6:	eb 10                	jmp    67b8 <ready_thread+0x90>
	return (node == list->tail) ? NULL : node->next;
    67a8:	49 39 6c 24 48       	cmp    %rbp,0x48(%r12)
    67ad:	74 bb                	je     676a <ready_thread+0x42>
    67af:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    67b3:	48 85 ed             	test   %rbp,%rbp
    67b6:	eb b0                	jmp    6768 <ready_thread+0x40>
}
    67b8:	5b                   	pop    %rbx
		update_cache(0);
    67b9:	31 ff                	xor    %edi,%edi
}
    67bb:	5d                   	pop    %rbp
    67bc:	41 5c                	pop    %r12
		update_cache(0);
    67be:	e9 cf fb ff ff       	jmpq   6392 <update_cache>
}
    67c3:	5b                   	pop    %rbx
    67c4:	5d                   	pop    %rbp
    67c5:	41 5c                	pop    %r12
    67c7:	c3                   	retq   
    67c8:	c3                   	retq   

00000000000067c9 <z_ready_thread>:
{
    67c9:	f3 0f 1e fa          	endbr64 
    67cd:	55                   	push   %rbp
    67ce:	48 83 ec 10          	sub    $0x10,%rsp
    67d2:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    67d7:	e8 79 e2 ff ff       	callq  4a55 <posix_irq_lock>
			ready_thread(thread);
    67dc:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    67e1:	89 c5                	mov    %eax,%ebp
    67e3:	e8 40 ff ff ff       	callq  6728 <ready_thread>
}
    67e8:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    67ec:	89 ef                	mov    %ebp,%edi
    67ee:	5d                   	pop    %rbp
    67ef:	e9 6f e2 ff ff       	jmpq   4a63 <posix_irq_unlock>

00000000000067f4 <z_sched_start>:
{
    67f4:	f3 0f 1e fa          	endbr64 
    67f8:	41 54                	push   %r12
    67fa:	48 83 ec 10          	sub    $0x10,%rsp
    67fe:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    6803:	e8 4d e2 ff ff       	callq  4a55 <posix_irq_lock>
	if (z_has_thread_started(thread)) {
    6808:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    680d:	41 89 c4             	mov    %eax,%r12d
    6810:	8a 47 19             	mov    0x19(%rdi),%al
    6813:	a8 04                	test   $0x4,%al
    6815:	75 0e                	jne    6825 <z_sched_start+0x31>
}
    6817:	48 83 c4 10          	add    $0x10,%rsp
	posix_irq_unlock(key);
    681b:	44 89 e7             	mov    %r12d,%edi
    681e:	41 5c                	pop    %r12
    6820:	e9 3e e2 ff ff       	jmpq   4a63 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6825:	83 e0 fb             	and    $0xfffffffb,%eax
    6828:	88 47 19             	mov    %al,0x19(%rdi)
	ready_thread(thread);
    682b:	e8 f8 fe ff ff       	callq  6728 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    6830:	48 8d 3d 2a 74 00 00 	lea    0x742a(%rip),%rdi        # dc61 <sched_spinlock>
}
    6837:	48 83 c4 10          	add    $0x10,%rsp
	z_reschedule(&sched_spinlock, key);
    683b:	44 89 e6             	mov    %r12d,%esi
}
    683e:	41 5c                	pop    %r12
	z_reschedule(&sched_spinlock, key);
    6840:	e9 85 fa ff ff       	jmpq   62ca <z_reschedule>

0000000000006845 <z_thread_timeout>:
{
    6845:	f3 0f 1e fa          	endbr64 
    6849:	41 54                	push   %r12
    684b:	55                   	push   %rbp
    684c:	53                   	push   %rbx
    684d:	48 89 fb             	mov    %rdi,%rbx
	return posix_irq_lock();
    6850:	e8 00 e2 ff ff       	callq  4a55 <posix_irq_lock>
    6855:	89 c5                	mov    %eax,%ebp
		if (!killed) {
    6857:	f6 43 f1 28          	testb  $0x28,-0xf(%rbx)
    685b:	75 1f                	jne    687c <z_thread_timeout+0x37>
			if (thread->base.pended_on != NULL) {
    685d:	48 83 7b e8 00       	cmpq   $0x0,-0x18(%rbx)
	struct k_thread *thread = CONTAINER_OF(timeout,
    6862:	4c 8d 63 d8          	lea    -0x28(%rbx),%r12
			if (thread->base.pended_on != NULL) {
    6866:	74 08                	je     6870 <z_thread_timeout+0x2b>
				unpend_thread_no_timeout(thread);
    6868:	4c 89 e7             	mov    %r12,%rdi
    686b:	e8 f0 fa ff ff       	callq  6360 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    6870:	80 63 f1 eb          	andb   $0xeb,-0xf(%rbx)
			ready_thread(thread);
    6874:	4c 89 e7             	mov    %r12,%rdi
    6877:	e8 ac fe ff ff       	callq  6728 <ready_thread>
}
    687c:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    687d:	89 ef                	mov    %ebp,%edi
    687f:	5d                   	pop    %rbp
    6880:	41 5c                	pop    %r12
    6882:	e9 dc e1 ff ff       	jmpq   4a63 <posix_irq_unlock>

0000000000006887 <z_unpend_first_thread>:
{
    6887:	f3 0f 1e fa          	endbr64 
    688b:	41 54                	push   %r12
    688d:	55                   	push   %rbp
    688e:	48 83 ec 18          	sub    $0x18,%rsp
    6892:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    6897:	e8 b9 e1 ff ff       	callq  4a55 <posix_irq_lock>
		thread = _priq_wait_best(&wait_q->waitq);
    689c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    68a1:	89 c5                	mov    %eax,%ebp
    68a3:	e8 d6 fa ff ff       	callq  637e <z_priq_dumb_best>
    68a8:	49 89 c4             	mov    %rax,%r12
		if (thread != NULL) {
    68ab:	48 85 c0             	test   %rax,%rax
    68ae:	74 12                	je     68c2 <z_unpend_first_thread+0x3b>
			unpend_thread_no_timeout(thread);
    68b0:	48 89 c7             	mov    %rax,%rdi
    68b3:	e8 a8 fa ff ff       	callq  6360 <unpend_thread_no_timeout>
    68b8:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
    68bd:	e8 71 05 00 00       	callq  6e33 <z_abort_timeout>
	posix_irq_unlock(key);
    68c2:	89 ef                	mov    %ebp,%edi
    68c4:	e8 9a e1 ff ff       	callq  4a63 <posix_irq_unlock>
}
    68c9:	48 83 c4 18          	add    $0x18,%rsp
    68cd:	4c 89 e0             	mov    %r12,%rax
    68d0:	5d                   	pop    %rbp
    68d1:	41 5c                	pop    %r12
    68d3:	c3                   	retq   

00000000000068d4 <z_sched_init>:
{
    68d4:	f3 0f 1e fa          	endbr64 
	list->head = (sys_dnode_t *)list;
    68d8:	48 8d 05 01 72 00 00 	lea    0x7201(%rip),%rax        # dae0 <_kernel>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    68df:	31 f6                	xor    %esi,%esi
    68e1:	31 ff                	xor    %edi,%edi
    68e3:	48 8d 50 40          	lea    0x40(%rax),%rdx
    68e7:	48 89 50 40          	mov    %rdx,0x40(%rax)
	list->tail = (sys_dnode_t *)list;
    68eb:	48 89 50 48          	mov    %rdx,0x48(%rax)
    68ef:	e9 60 f9 ff ff       	jmpq   6254 <k_sched_time_slice_set>

00000000000068f4 <z_impl_k_yield>:
{
    68f4:	f3 0f 1e fa          	endbr64 
    68f8:	41 55                	push   %r13
    68fa:	41 54                	push   %r12
    68fc:	55                   	push   %rbp
    68fd:	53                   	push   %rbx
    68fe:	52                   	push   %rdx
	if (!z_is_idle_thread_object(_current)) {
    68ff:	48 8d 2d da 71 00 00 	lea    0x71da(%rip),%rbp        # dae0 <_kernel>
    6906:	48 8d 05 93 70 00 00 	lea    0x7093(%rip),%rax        # d9a0 <z_idle_threads>
    690d:	48 39 45 10          	cmp    %rax,0x10(%rbp)
    6911:	0f 84 8e 00 00 00    	je     69a5 <z_impl_k_yield+0xb1>
	return posix_irq_lock();
    6917:	e8 39 e1 ff ff       	callq  4a55 <posix_irq_lock>
			dequeue_thread(&_kernel.ready_q.runq,
    691c:	48 8b 75 10          	mov    0x10(%rbp),%rsi
		_priq_run_remove(pq, thread);
    6920:	48 8d 7d 40          	lea    0x40(%rbp),%rdi
    6924:	41 89 c5             	mov    %eax,%r13d
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6927:	80 66 19 7f          	andb   $0x7f,0x19(%rsi)
		_priq_run_remove(pq, thread);
    692b:	e8 0e fa ff ff       	callq  633e <z_priq_dumb_remove>
		queue_thread(&_kernel.ready_q.runq, _current);
    6930:	48 8b 5d 10          	mov    0x10(%rbp),%rbx
	thread->base.thread_state |= _THREAD_QUEUED;
    6934:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	return list->head == list;
    6938:	4c 8b 65 40          	mov    0x40(%rbp),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    693c:	4d 85 e4             	test   %r12,%r12
    693f:	74 09                	je     694a <z_impl_k_yield+0x56>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6941:	48 8d 45 40          	lea    0x40(%rbp),%rax
    6945:	49 39 c4             	cmp    %rax,%r12
    6948:	75 18                	jne    6962 <z_impl_k_yield+0x6e>
	sys_dnode_t *const tail = list->tail;
    694a:	48 8b 45 48          	mov    0x48(%rbp),%rax
	node->next = list;
    694e:	48 8d 55 40          	lea    0x40(%rbp),%rdx
    6952:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    6955:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    6959:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    695c:	48 89 5d 48          	mov    %rbx,0x48(%rbp)
}
    6960:	eb 34                	jmp    6996 <z_impl_k_yield+0xa2>
		if (z_sched_prio_cmp(thread, t) > 0) {
    6962:	4c 89 e6             	mov    %r12,%rsi
    6965:	48 89 df             	mov    %rbx,%rdi
    6968:	e8 a2 f8 ff ff       	callq  620f <z_sched_prio_cmp>
    696d:	85 c0                	test   %eax,%eax
    696f:	7e 16                	jle    6987 <z_impl_k_yield+0x93>
	sys_dnode_t *const prev = successor->prev;
    6971:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = successor;
    6976:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = prev;
    6979:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = node;
    697d:	48 89 18             	mov    %rbx,(%rax)
	successor->prev = node;
    6980:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
    6985:	eb 0f                	jmp    6996 <z_impl_k_yield+0xa2>
	return (node == list->tail) ? NULL : node->next;
    6987:	4c 39 65 48          	cmp    %r12,0x48(%rbp)
    698b:	74 bd                	je     694a <z_impl_k_yield+0x56>
    698d:	4d 8b 24 24          	mov    (%r12),%r12
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6991:	4d 85 e4             	test   %r12,%r12
    6994:	eb b2                	jmp    6948 <z_impl_k_yield+0x54>
		update_cache(1);
    6996:	bf 01 00 00 00       	mov    $0x1,%edi
    699b:	e8 f2 f9 ff ff       	callq  6392 <update_cache>
    69a0:	44 89 ef             	mov    %r13d,%edi
    69a3:	eb 07                	jmp    69ac <z_impl_k_yield+0xb8>
    69a5:	e8 ab e0 ff ff       	callq  4a55 <posix_irq_lock>
    69aa:	89 c7                	mov    %eax,%edi
}
    69ac:	58                   	pop    %rax
    69ad:	5b                   	pop    %rbx
    69ae:	5d                   	pop    %rbp
    69af:	41 5c                	pop    %r12
    69b1:	41 5d                	pop    %r13
    69b3:	e9 db d4 ff ff       	jmpq   3e93 <arch_swap>

00000000000069b8 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    69b8:	f3 0f 1e fa          	endbr64 
    69bc:	51                   	push   %rcx

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    69bd:	48 83 ff ff          	cmp    $0xffffffffffffffff,%rdi
    69c1:	75 15                	jne    69d8 <z_impl_k_sleep+0x20>
		k_thread_suspend(_current);
    69c3:	48 8d 05 16 71 00 00 	lea    0x7116(%rip),%rax        # dae0 <_kernel>
    69ca:	48 8b 78 10          	mov    0x10(%rax),%rdi
	z_impl_k_thread_suspend(thread);
    69ce:	e8 a9 fb ff ff       	callq  657c <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    69d3:	83 c8 ff             	or     $0xffffffff,%eax
}
    69d6:	eb 16                	jmp    69ee <z_impl_k_sleep+0x36>
	if (ticks == 0) {
    69d8:	48 85 ff             	test   %rdi,%rdi
    69db:	75 09                	jne    69e6 <z_impl_k_sleep+0x2e>
	z_impl_k_yield();
    69dd:	e8 12 ff ff ff       	callq  68f4 <z_impl_k_yield>
		return 0;
    69e2:	31 c0                	xor    %eax,%eax
}
    69e4:	eb 05                	jmp    69eb <z_impl_k_sleep+0x33>
    69e6:	e8 21 fb ff ff       	callq  650c <z_tick_sleep.part.0>

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
    69eb:	6b c0 0a             	imul   $0xa,%eax,%eax
}
    69ee:	5a                   	pop    %rdx
    69ef:	c3                   	retq   

00000000000069f0 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
    69f0:	f3 0f 1e fa          	endbr64 
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    69f4:	48 8d 05 e5 70 00 00 	lea    0x70e5(%rip),%rax        # dae0 <_kernel>

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    69fb:	48 8b 40 10          	mov    0x10(%rax),%rax
}
    69ff:	c3                   	retq   

0000000000006a00 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    6a00:	f3 0f 1e fa          	endbr64 
    6a04:	41 55                	push   %r13
    6a06:	41 54                	push   %r12
    6a08:	55                   	push   %rbp
    6a09:	53                   	push   %rbx
    6a0a:	48 89 fb             	mov    %rdi,%rbx
    6a0d:	52                   	push   %rdx
    6a0e:	e8 42 e0 ff ff       	callq  4a55 <posix_irq_lock>
    6a13:	41 89 c4             	mov    %eax,%r12d
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    6a16:	8a 43 19             	mov    0x19(%rbx),%al
    6a19:	a8 08                	test   $0x8,%al
    6a1b:	0f 85 9b 00 00 00    	jne    6abc <z_thread_abort+0xbc>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    6a21:	89 c2                	mov    %eax,%edx
    6a23:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
    6a26:	80 ca 08             	or     $0x8,%dl
    6a29:	78 05                	js     6a30 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    6a2b:	88 53 19             	mov    %dl,0x19(%rbx)
    6a2e:	eb 1c                	jmp    6a4c <z_thread_abort+0x4c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6a30:	83 e0 5f             	and    $0x5f,%eax
		_priq_run_remove(pq, thread);
    6a33:	48 89 de             	mov    %rbx,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6a36:	83 c8 08             	or     $0x8,%eax
    6a39:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
    6a3c:	48 8d 05 9d 70 00 00 	lea    0x709d(%rip),%rax        # dae0 <_kernel>
    6a43:	48 8d 78 40          	lea    0x40(%rax),%rdi
    6a47:	e8 f2 f8 ff ff       	callq  633e <z_priq_dumb_remove>
		if (thread->base.pended_on != NULL) {
    6a4c:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
    6a51:	74 08                	je     6a5b <z_thread_abort+0x5b>
			unpend_thread_no_timeout(thread);
    6a53:	48 89 df             	mov    %rbx,%rdi
    6a56:	e8 05 f9 ff ff       	callq  6360 <unpend_thread_no_timeout>
    6a5b:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    6a5f:	4c 8d 6b 60          	lea    0x60(%rbx),%r13
    6a63:	e8 cb 03 00 00       	callq  6e33 <z_abort_timeout>
	return list->head == list;
    6a68:	48 8b 6b 60          	mov    0x60(%rbx),%rbp
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    6a6c:	48 85 ed             	test   %rbp,%rbp
    6a6f:	74 27                	je     6a98 <z_thread_abort+0x98>
    6a71:	4c 39 ed             	cmp    %r13,%rbp
    6a74:	74 22                	je     6a98 <z_thread_abort+0x98>
		unpend_thread_no_timeout(thread);
    6a76:	48 89 ef             	mov    %rbp,%rdi
    6a79:	e8 e2 f8 ff ff       	callq  6360 <unpend_thread_no_timeout>
    6a7e:	48 8d 7d 28          	lea    0x28(%rbp),%rdi
    6a82:	e8 ac 03 00 00       	callq  6e33 <z_abort_timeout>
	thread->callee_saved.retval = value;
    6a87:	c7 45 4c 00 00 00 00 	movl   $0x0,0x4c(%rbp)
		ready_thread(thread);
    6a8e:	48 89 ef             	mov    %rbp,%rdi
    6a91:	e8 92 fc ff ff       	callq  6728 <ready_thread>
    6a96:	eb d0                	jmp    6a68 <z_thread_abort+0x68>
		update_cache(1);
    6a98:	bf 01 00 00 00       	mov    $0x1,%edi
    6a9d:	e8 f0 f8 ff ff       	callq  6392 <update_cache>
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
    6aa2:	48 8d 05 37 70 00 00 	lea    0x7037(%rip),%rax        # dae0 <_kernel>
    6aa9:	48 39 58 10          	cmp    %rbx,0x10(%rax)
    6aad:	75 0d                	jne    6abc <z_thread_abort+0xbc>
    6aaf:	83 38 00             	cmpl   $0x0,(%rax)
    6ab2:	75 08                	jne    6abc <z_thread_abort+0xbc>
    6ab4:	44 89 e7             	mov    %r12d,%edi
    6ab7:	e8 d7 d3 ff ff       	callq  3e93 <arch_swap>
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    6abc:	58                   	pop    %rax
	posix_irq_unlock(key);
    6abd:	44 89 e7             	mov    %r12d,%edi
    6ac0:	5b                   	pop    %rbx
    6ac1:	5d                   	pop    %rbp
    6ac2:	41 5c                	pop    %r12
    6ac4:	41 5d                	pop    %r13
    6ac6:	e9 98 df ff ff       	jmpq   4a63 <posix_irq_unlock>

0000000000006acb <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    6acb:	f3 0f 1e fa          	endbr64 
	z_sched_start(thread);
    6acf:	e9 20 fd ff ff       	jmpq   67f4 <z_sched_start>

0000000000006ad4 <z_init_thread_base>:
}
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    6ad4:	f3 0f 1e fa          	endbr64 
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    6ad8:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    6adf:	00 
	thread_base->user_options = (uint8_t)options;
    6ae0:	88 4f 18             	mov    %cl,0x18(%rdi)
	thread_base->thread_state = (uint8_t)initial_state;
    6ae3:	88 57 19             	mov    %dl,0x19(%rdi)

	thread_base->prio = priority;
    6ae6:	40 88 77 1a          	mov    %sil,0x1a(%rdi)

	thread_base->sched_locked = 0U;
    6aea:	c6 47 1b 00          	movb   $0x0,0x1b(%rdi)
	node->next = NULL;
    6aee:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
    6af5:	00 
	node->prev = NULL;
    6af6:	48 c7 47 30 00 00 00 	movq   $0x0,0x30(%rdi)
    6afd:	00 
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    6afe:	c3                   	retq   

0000000000006aff <z_setup_new_thread>:
{
    6aff:	f3 0f 1e fa          	endbr64 
    6b03:	41 55                	push   %r13
	sys_dlist_init(&w->waitq);
    6b05:	48 8d 47 60          	lea    0x60(%rdi),%rax
    6b09:	49 89 cd             	mov    %rcx,%r13
    6b0c:	41 54                	push   %r12
    6b0e:	49 89 d4             	mov    %rdx,%r12
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    6b11:	ba 04 00 00 00       	mov    $0x4,%edx
{
    6b16:	55                   	push   %rbp
    6b17:	48 89 f5             	mov    %rsi,%rbp
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    6b1a:	49 83 c4 07          	add    $0x7,%r12
{
    6b1e:	53                   	push   %rbx
    6b1f:	48 89 fb             	mov    %rdi,%rbx
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    6b22:	49 83 e4 f8          	and    $0xfffffffffffffff8,%r12
	stack_ptr = (char *)stack + stack_obj_size;
    6b26:	49 01 ec             	add    %rbp,%r12
{
    6b29:	48 83 ec 18          	sub    $0x18,%rsp
	list->head = (sys_dnode_t *)list;
    6b2d:	48 89 47 60          	mov    %rax,0x60(%rdi)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    6b31:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
    6b35:	8b 74 24 48          	mov    0x48(%rsp),%esi
	list->tail = (sys_dnode_t *)list;
    6b39:	48 89 47 68          	mov    %rax,0x68(%rdi)
{
    6b3d:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    6b42:	4c 89 0c 24          	mov    %r9,(%rsp)
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    6b46:	e8 89 ff ff ff       	callq  6ad4 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6b4b:	4c 89 e9             	mov    %r13,%rcx
    6b4e:	4c 89 e2             	mov    %r12,%rdx
    6b51:	48 89 ee             	mov    %rbp,%rsi
    6b54:	50                   	push   %rax
    6b55:	48 89 df             	mov    %rbx,%rdi
    6b58:	ff 74 24 48          	pushq  0x48(%rsp)
    6b5c:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
    6b61:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    6b66:	e8 91 d3 ff ff       	callq  3efc <arch_new_thread>
	if (!_current) {
    6b6b:	48 8d 05 6e 6f 00 00 	lea    0x6f6e(%rip),%rax        # dae0 <_kernel>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6b72:	5a                   	pop    %rdx
	new_thread->init_data = NULL;
    6b73:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    6b7a:	00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6b7b:	59                   	pop    %rcx
	if (!_current) {
    6b7c:	48 8b 40 10          	mov    0x10(%rax),%rax
    6b80:	48 85 c0             	test   %rax,%rax
    6b83:	74 04                	je     6b89 <z_setup_new_thread+0x8a>
	new_thread->resource_pool = _current->resource_pool;
    6b85:	48 8b 40 78          	mov    0x78(%rax),%rax
	return stack_ptr;
    6b89:	48 89 43 78          	mov    %rax,0x78(%rbx)
}
    6b8d:	48 83 c4 18          	add    $0x18,%rsp
    6b91:	4c 89 e0             	mov    %r12,%rax
    6b94:	5b                   	pop    %rbx
    6b95:	5d                   	pop    %rbp
    6b96:	41 5c                	pop    %r12
    6b98:	41 5d                	pop    %r13
    6b9a:	c3                   	retq   

0000000000006b9b <z_init_static_threads>:
{
    6b9b:	f3 0f 1e fa          	endbr64 
    6b9f:	55                   	push   %rbp
    6ba0:	53                   	push   %rbx
    6ba1:	52                   	push   %rdx
	_FOREACH_STATIC_THREAD(thread_data) {
    6ba2:	48 8d 1d 5f 66 00 00 	lea    0x665f(%rip),%rbx        # d208 <_k_thread_data_processing_tid>
    6ba9:	48 89 dd             	mov    %rbx,%rbp
    6bac:	48 3b 1d fd 43 00 00 	cmp    0x43fd(%rip),%rbx        # afb0 <_GLOBAL_OFFSET_TABLE_+0x1d8>
    6bb3:	73 3a                	jae    6bef <z_init_static_threads+0x54>
		z_setup_new_thread(
    6bb5:	4c 8b 4b 28          	mov    0x28(%rbx),%r9
    6bb9:	4c 8b 43 20          	mov    0x20(%rbx),%r8
    6bbd:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    6bc1:	8b 53 10             	mov    0x10(%rbx),%edx
    6bc4:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    6bc8:	ff 73 50             	pushq  0x50(%rbx)
    6bcb:	8b 43 3c             	mov    0x3c(%rbx),%eax
    6bce:	50                   	push   %rax
    6bcf:	8b 43 38             	mov    0x38(%rbx),%eax
    6bd2:	50                   	push   %rax
    6bd3:	ff 73 30             	pushq  0x30(%rbx)
    6bd6:	48 8b 3b             	mov    (%rbx),%rdi
    6bd9:	e8 21 ff ff ff       	callq  6aff <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    6bde:	48 8b 03             	mov    (%rbx),%rax
		z_setup_new_thread(
    6be1:	48 83 c4 20          	add    $0x20,%rsp
		thread_data->init_thread->init_data = thread_data;
    6be5:	48 89 58 58          	mov    %rbx,0x58(%rax)
	_FOREACH_STATIC_THREAD(thread_data) {
    6be9:	48 83 c3 58          	add    $0x58,%rbx
    6bed:	eb bd                	jmp    6bac <z_init_static_threads+0x11>
	k_sched_lock();
    6bef:	e8 2a f7 ff ff       	callq  631e <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    6bf4:	48 89 eb             	mov    %rbp,%rbx
					    K_MSEC(thread_data->init_delay));
    6bf7:	31 ed                	xor    %ebp,%ebp
	_FOREACH_STATIC_THREAD(thread_data) {
    6bf9:	48 3b 1d b0 43 00 00 	cmp    0x43b0(%rip),%rbx        # afb0 <_GLOBAL_OFFSET_TABLE_+0x1d8>
    6c00:	73 46                	jae    6c48 <z_init_static_threads+0xad>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    6c02:	8b 43 40             	mov    0x40(%rbx),%eax
    6c05:	83 f8 ff             	cmp    $0xffffffff,%eax
    6c08:	74 38                	je     6c42 <z_init_static_threads+0xa7>
					    K_MSEC(thread_data->init_delay));
    6c0a:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
    6c0c:	48 8b 3b             	mov    (%rbx),%rdi
					    K_MSEC(thread_data->init_delay));
    6c0f:	0f 48 c5             	cmovs  %ebp,%eax
    6c12:	48 63 c8             	movslq %eax,%rcx
		t += off;
    6c15:	48 8d 41 09          	lea    0x9(%rcx),%rax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    6c19:	48 85 c9             	test   %rcx,%rcx
    6c1c:	75 07                	jne    6c25 <z_init_static_threads+0x8a>
	z_impl_k_thread_start(thread);
    6c1e:	e8 a8 fe ff ff       	callq  6acb <z_impl_k_thread_start>
}
    6c23:	eb 1d                	jmp    6c42 <z_init_static_threads+0xa7>
			return t / (from_hz / to_hz);
    6c25:	b9 0a 00 00 00       	mov    $0xa,%ecx
    6c2a:	31 d2                	xor    %edx,%edx
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    6c2c:	48 8d 35 12 fc ff ff 	lea    -0x3ee(%rip),%rsi        # 6845 <z_thread_timeout>
    6c33:	48 83 c7 28          	add    $0x28,%rdi
    6c37:	48 f7 f1             	div    %rcx
    6c3a:	48 89 c2             	mov    %rax,%rdx
    6c3d:	e8 d5 00 00 00       	callq  6d17 <z_add_timeout>
	_FOREACH_STATIC_THREAD(thread_data) {
    6c42:	48 83 c3 58          	add    $0x58,%rbx
    6c46:	eb b1                	jmp    6bf9 <z_init_static_threads+0x5e>
}
    6c48:	58                   	pop    %rax
    6c49:	5b                   	pop    %rbx
    6c4a:	5d                   	pop    %rbp
	k_sched_unlock();
    6c4b:	e9 97 f9 ff ff       	jmpq   65e7 <k_sched_unlock>

0000000000006c50 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    6c50:	f3 0f 1e fa          	endbr64 
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    6c54:	48 8d 15 16 21 00 00 	lea    0x2116(%rip),%rdx        # 8d71 <default_cmd+0xd51>
    6c5b:	48 8d 35 d0 24 00 00 	lea    0x24d0(%rip),%rsi        # 9132 <default_cmd+0x1112>
    6c62:	31 c0                	xor    %eax,%eax
    6c64:	48 8d 3d e8 24 00 00 	lea    0x24e8(%rip),%rdi        # 9153 <default_cmd+0x1133>
    6c6b:	e9 5e be ff ff       	jmpq   2ace <printk>

0000000000006c70 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    6c70:	83 3d dd 6f 00 00 00 	cmpl   $0x0,0x6fdd(%rip)        # dc54 <announce_remaining>
    6c77:	75 05                	jne    6c7e <elapsed+0xe>
    6c79:	e9 54 cd ff ff       	jmpq   39d2 <sys_clock_elapsed>
}
    6c7e:	31 c0                	xor    %eax,%eax
    6c80:	c3                   	retq   

0000000000006c81 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    6c81:	48 8b 07             	mov    (%rdi),%rax
    6c84:	48 85 ff             	test   %rdi,%rdi
    6c87:	74 16                	je     6c9f <remove_timeout+0x1e>
	return (node == list->tail) ? NULL : node->next;
    6c89:	48 3b 3d 88 47 00 00 	cmp    0x4788(%rip),%rdi        # b418 <timeout_list+0x8>
    6c90:	74 0d                	je     6c9f <remove_timeout+0x1e>
	if (next(t) != NULL) {
    6c92:	48 85 c0             	test   %rax,%rax
    6c95:	74 08                	je     6c9f <remove_timeout+0x1e>
		next(t)->dticks += t->dticks;
    6c97:	48 8b 57 18          	mov    0x18(%rdi),%rdx
    6c9b:	48 01 50 18          	add    %rdx,0x18(%rax)
	sys_dnode_t *const prev = node->prev;
    6c9f:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	prev->next = next;
    6ca3:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
    6ca6:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
    6caa:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
    6cb1:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    6cb8:	00 
}
    6cb9:	c3                   	retq   

0000000000006cba <next_timeout>:

static int32_t next_timeout(void)
{
    6cba:	53                   	push   %rbx
	return list->head == list;
    6cbb:	48 8b 1d 4e 47 00 00 	mov    0x474e(%rip),%rbx        # b410 <timeout_list>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6cc2:	48 8d 05 47 47 00 00 	lea    0x4747(%rip),%rax        # b410 <timeout_list>
    6cc9:	48 39 c3             	cmp    %rax,%rbx
    6ccc:	75 02                	jne    6cd0 <next_timeout+0x16>
    6cce:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    6cd0:	e8 9b ff ff ff       	callq  6c70 <elapsed>
    6cd5:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
    6cd7:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    6cdc:	48 85 db             	test   %rbx,%rbx
    6cdf:	74 21                	je     6d02 <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    6ce1:	48 63 c2             	movslq %edx,%rax
    6ce4:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    6ce8:	48 29 c2             	sub    %rax,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    6ceb:	31 c0                	xor    %eax,%eax
    6ced:	48 85 d2             	test   %rdx,%rdx
    6cf0:	7e 10                	jle    6d02 <next_timeout+0x48>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    6cf2:	48 81 fa ff ff ff 7f 	cmp    $0x7fffffff,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
    6cf9:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    6cfe:	48 0f 4e c2          	cmovle %rdx,%rax

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    6d02:	48 8d 15 d7 6d 00 00 	lea    0x6dd7(%rip),%rdx        # dae0 <_kernel>
    6d09:	8b 52 20             	mov    0x20(%rdx),%edx
    6d0c:	85 d2                	test   %edx,%edx
    6d0e:	74 05                	je     6d15 <next_timeout+0x5b>
    6d10:	39 d0                	cmp    %edx,%eax
    6d12:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    6d15:	5b                   	pop    %rbx
    6d16:	c3                   	retq   

0000000000006d17 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    6d17:	f3 0f 1e fa          	endbr64 
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    6d1b:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    6d1f:	0f 84 0d 01 00 00    	je     6e32 <z_add_timeout+0x11b>
{
    6d25:	41 56                	push   %r14
    6d27:	49 89 f6             	mov    %rsi,%r14
    6d2a:	41 55                	push   %r13
    6d2c:	49 89 d5             	mov    %rdx,%r13
    6d2f:	41 54                	push   %r12
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    6d31:	49 c7 c4 fe ff ff ff 	mov    $0xfffffffffffffffe,%r12
{
    6d38:	55                   	push   %rbp
	k_ticks_t ticks = timeout.ticks + 1;
    6d39:	48 8d 6a 01          	lea    0x1(%rdx),%rbp
{
    6d3d:	53                   	push   %rbx
    6d3e:	48 89 fb             	mov    %rdi,%rbx
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    6d41:	49 39 ec             	cmp    %rbp,%r12
    6d44:	78 17                	js     6d5d <z_add_timeout+0x46>
		ticks = Z_TICK_ABS(timeout.ticks) - (curr_tick + elapsed());
    6d46:	e8 25 ff ff ff       	callq  6c70 <elapsed>
    6d4b:	4c 89 e5             	mov    %r12,%rbp
    6d4e:	48 2b 2d bb 6e 00 00 	sub    0x6ebb(%rip),%rbp        # dc10 <curr_tick>
    6d55:	4c 29 ed             	sub    %r13,%rbp
    6d58:	48 98                	cltq   
    6d5a:	48 29 c5             	sub    %rax,%rbp
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    6d5d:	4c 89 73 10          	mov    %r14,0x10(%rbx)
	return posix_irq_lock();
    6d61:	e8 ef dc ff ff       	callq  4a55 <posix_irq_lock>
    6d66:	41 89 c4             	mov    %eax,%r12d
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    6d69:	e8 02 ff ff ff       	callq  6c70 <elapsed>
	ticks = MAX(1, ticks);
    6d6e:	48 85 ed             	test   %rbp,%rbp
    6d71:	ba 01 00 00 00       	mov    $0x1,%edx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    6d76:	48 8b 3d 9b 46 00 00 	mov    0x469b(%rip),%rdi        # b418 <timeout_list+0x8>
    6d7d:	48 0f 4e ea          	cmovle %rdx,%rbp
		to->dticks = ticks + elapsed();
    6d81:	48 98                	cltq   
	return list->head == list;
    6d83:	48 8d 15 86 46 00 00 	lea    0x4686(%rip),%rdx        # b410 <timeout_list>
    6d8a:	48 01 c5             	add    %rax,%rbp
    6d8d:	48 8b 05 7c 46 00 00 	mov    0x467c(%rip),%rax        # b410 <timeout_list>
    6d94:	48 89 6b 18          	mov    %rbp,0x18(%rbx)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6d98:	48 39 d0             	cmp    %rdx,%rax
    6d9b:	74 3e                	je     6ddb <z_add_timeout+0xc4>
		for (t = first(); t != NULL; t = next(t)) {
    6d9d:	48 85 c0             	test   %rax,%rax
    6da0:	74 39                	je     6ddb <z_add_timeout+0xc4>
			if (t->dticks > to->dticks) {
    6da2:	48 8b 70 18          	mov    0x18(%rax),%rsi
    6da6:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
    6daa:	48 39 ce             	cmp    %rcx,%rsi
    6dad:	7e 1b                	jle    6dca <z_add_timeout+0xb3>
				t->dticks -= to->dticks;
    6daf:	48 29 ce             	sub    %rcx,%rsi
	sys_dnode_t *const prev = successor->prev;
    6db2:	48 8b 48 08          	mov    0x8(%rax),%rcx
    6db6:	48 89 70 18          	mov    %rsi,0x18(%rax)
	node->prev = prev;
    6dba:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	node->next = successor;
    6dbe:	48 89 03             	mov    %rax,(%rbx)
	prev->next = node;
    6dc1:	48 89 19             	mov    %rbx,(%rcx)
	successor->prev = node;
    6dc4:	48 89 58 08          	mov    %rbx,0x8(%rax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    6dc8:	eb 29                	jmp    6df3 <z_add_timeout+0xdc>
			to->dticks -= t->dticks;
    6dca:	48 29 f1             	sub    %rsi,%rcx
    6dcd:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
	return (node == list->tail) ? NULL : node->next;
    6dd1:	48 39 f8             	cmp    %rdi,%rax
    6dd4:	74 05                	je     6ddb <z_add_timeout+0xc4>
    6dd6:	48 8b 00             	mov    (%rax),%rax
    6dd9:	eb c2                	jmp    6d9d <z_add_timeout+0x86>
	sys_dnode_t *const tail = list->tail;
    6ddb:	48 8b 05 36 46 00 00 	mov    0x4636(%rip),%rax        # b418 <timeout_list+0x8>
	node->next = list;
    6de2:	48 89 13             	mov    %rdx,(%rbx)
	node->prev = tail;
    6de5:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
    6de9:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
    6dec:	48 89 1d 25 46 00 00 	mov    %rbx,0x4625(%rip)        # b418 <timeout_list+0x8>
	return list->head == list;
    6df3:	48 8b 05 16 46 00 00 	mov    0x4616(%rip),%rax        # b410 <timeout_list>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    6dfa:	48 39 c3             	cmp    %rax,%rbx
    6dfd:	75 23                	jne    6e22 <z_add_timeout+0x10b>
    6dff:	48 39 d0             	cmp    %rdx,%rax
    6e02:	74 1e                	je     6e22 <z_add_timeout+0x10b>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    6e04:	e8 b1 fe ff ff       	callq  6cba <next_timeout>
    6e09:	89 c7                	mov    %eax,%edi

			if (next_time == 0 ||
    6e0b:	85 c0                	test   %eax,%eax
    6e0d:	74 0c                	je     6e1b <z_add_timeout+0x104>
			    _current_cpu->slice_ticks != next_time) {
    6e0f:	48 8d 05 ca 6c 00 00 	lea    0x6cca(%rip),%rax        # dae0 <_kernel>
			if (next_time == 0 ||
    6e16:	39 78 20             	cmp    %edi,0x20(%rax)
    6e19:	74 07                	je     6e22 <z_add_timeout+0x10b>
				sys_clock_set_timeout(next_time, false);
    6e1b:	31 f6                	xor    %esi,%esi
    6e1d:	e8 89 cb ff ff       	callq  39ab <sys_clock_set_timeout>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    6e22:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    6e23:	44 89 e7             	mov    %r12d,%edi
    6e26:	5d                   	pop    %rbp
    6e27:	41 5c                	pop    %r12
    6e29:	41 5d                	pop    %r13
    6e2b:	41 5e                	pop    %r14
    6e2d:	e9 31 dc ff ff       	jmpq   4a63 <posix_irq_unlock>
    6e32:	c3                   	retq   

0000000000006e33 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    6e33:	f3 0f 1e fa          	endbr64 
    6e37:	41 54                	push   %r12
    6e39:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
    6e3f:	48 83 ec 10          	sub    $0x10,%rsp
    6e43:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
	return posix_irq_lock();
    6e48:	e8 08 dc ff ff       	callq  4a55 <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    6e4d:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    6e52:	41 89 c0             	mov    %eax,%r8d
    6e55:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    6e59:	74 08                	je     6e63 <z_abort_timeout+0x30>
			remove_timeout(to);
    6e5b:	e8 21 fe ff ff       	callq  6c81 <remove_timeout>
			ret = 0;
    6e60:	45 31 e4             	xor    %r12d,%r12d
	posix_irq_unlock(key);
    6e63:	44 89 c7             	mov    %r8d,%edi
    6e66:	e8 f8 db ff ff       	callq  4a63 <posix_irq_unlock>
		}
	}

	return ret;
}
    6e6b:	48 83 c4 10          	add    $0x10,%rsp
    6e6f:	44 89 e0             	mov    %r12d,%eax
    6e72:	41 5c                	pop    %r12
    6e74:	c3                   	retq   

0000000000006e75 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    6e75:	f3 0f 1e fa          	endbr64 
    6e79:	41 54                	push   %r12
    6e7b:	55                   	push   %rbp
    6e7c:	89 fd                	mov    %edi,%ebp
    6e7e:	53                   	push   %rbx
    6e7f:	89 f3                	mov    %esi,%ebx
	return posix_irq_lock();
    6e81:	e8 cf db ff ff       	callq  4a55 <posix_irq_lock>
    6e86:	41 89 c4             	mov    %eax,%r12d
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    6e89:	e8 2c fe ff ff       	callq  6cba <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
    6e8e:	83 f8 ff             	cmp    $0xffffffff,%eax
    6e91:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
    6e94:	39 e8                	cmp    %ebp,%eax
    6e96:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    6e99:	08 d1                	or     %dl,%cl
    6e9b:	74 14                	je     6eb1 <z_set_timeout_expiry+0x3c>
    6e9d:	83 f8 01             	cmp    $0x1,%eax
    6ea0:	7e 0f                	jle    6eb1 <z_set_timeout_expiry+0x3c>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    6ea2:	39 e8                	cmp    %ebp,%eax
    6ea4:	89 ef                	mov    %ebp,%edi
    6ea6:	0f b6 f3             	movzbl %bl,%esi
    6ea9:	0f 4e f8             	cmovle %eax,%edi
    6eac:	e8 fa ca ff ff       	callq  39ab <sys_clock_set_timeout>
		}
	}
}
    6eb1:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    6eb2:	44 89 e7             	mov    %r12d,%edi
    6eb5:	5d                   	pop    %rbp
    6eb6:	41 5c                	pop    %r12
    6eb8:	e9 a6 db ff ff       	jmpq   4a63 <posix_irq_unlock>

0000000000006ebd <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    6ebd:	f3 0f 1e fa          	endbr64 
    6ec1:	41 54                	push   %r12
    6ec3:	4c 8d 25 46 45 00 00 	lea    0x4546(%rip),%r12        # b410 <timeout_list>
    6eca:	55                   	push   %rbp
    6ecb:	53                   	push   %rbx
    6ecc:	89 fb                	mov    %edi,%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    6ece:	e8 e4 f7 ff ff       	callq  66b7 <z_time_slice>
	return posix_irq_lock();
    6ed3:	e8 7d db ff ff       	callq  4a55 <posix_irq_lock>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    6ed8:	89 1d 76 6d 00 00    	mov    %ebx,0x6d76(%rip)        # dc54 <announce_remaining>
    6ede:	89 c5                	mov    %eax,%ebp
    6ee0:	48 63 15 6d 6d 00 00 	movslq 0x6d6d(%rip),%rdx        # dc54 <announce_remaining>
    6ee7:	49 8b 1c 24          	mov    (%r12),%rbx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    6eeb:	48 8b 35 1e 6d 00 00 	mov    0x6d1e(%rip),%rsi        # dc10 <curr_tick>
    6ef2:	48 89 d1             	mov    %rdx,%rcx

	while (first() != NULL && first()->dticks <= announce_remaining) {
    6ef5:	48 85 db             	test   %rbx,%rbx
    6ef8:	74 50                	je     6f4a <sys_clock_announce+0x8d>
    6efa:	4c 39 e3             	cmp    %r12,%rbx
    6efd:	74 4b                	je     6f4a <sys_clock_announce+0x8d>
    6eff:	48 8b 43 18          	mov    0x18(%rbx),%rax
    6f03:	48 39 d0             	cmp    %rdx,%rax
    6f06:	7f 3b                	jg     6f43 <sys_clock_announce+0x86>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
    6f08:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    6f0f:	00 
		curr_tick += dt;
    6f10:	48 63 d0             	movslq %eax,%rdx
		announce_remaining -= dt;
    6f13:	29 c1                	sub    %eax,%ecx
		remove_timeout(t);
    6f15:	48 89 df             	mov    %rbx,%rdi
		curr_tick += dt;
    6f18:	48 01 f2             	add    %rsi,%rdx
		announce_remaining -= dt;
    6f1b:	89 0d 33 6d 00 00    	mov    %ecx,0x6d33(%rip)        # dc54 <announce_remaining>
		curr_tick += dt;
    6f21:	48 89 15 e8 6c 00 00 	mov    %rdx,0x6ce8(%rip)        # dc10 <curr_tick>
		remove_timeout(t);
    6f28:	e8 54 fd ff ff       	callq  6c81 <remove_timeout>
	posix_irq_unlock(key);
    6f2d:	89 ef                	mov    %ebp,%edi
    6f2f:	e8 2f db ff ff       	callq  4a63 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    6f34:	48 89 df             	mov    %rbx,%rdi
    6f37:	ff 53 10             	callq  *0x10(%rbx)
	return posix_irq_lock();
    6f3a:	e8 16 db ff ff       	callq  4a55 <posix_irq_lock>
    6f3f:	89 c5                	mov    %eax,%ebp
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    6f41:	eb 9d                	jmp    6ee0 <sys_clock_announce+0x23>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    6f43:	48 29 d0             	sub    %rdx,%rax
    6f46:	48 89 43 18          	mov    %rax,0x18(%rbx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    6f4a:	c7 05 00 6d 00 00 00 	movl   $0x0,0x6d00(%rip)        # dc54 <announce_remaining>
    6f51:	00 00 00 
	curr_tick += announce_remaining;
    6f54:	48 01 f2             	add    %rsi,%rdx
    6f57:	48 89 15 b2 6c 00 00 	mov    %rdx,0x6cb2(%rip)        # dc10 <curr_tick>

	sys_clock_set_timeout(next_timeout(), false);
    6f5e:	e8 57 fd ff ff       	callq  6cba <next_timeout>
    6f63:	31 f6                	xor    %esi,%esi
    6f65:	89 c7                	mov    %eax,%edi
    6f67:	e8 3f ca ff ff       	callq  39ab <sys_clock_set_timeout>

	k_spin_unlock(&timeout_lock, key);
}
    6f6c:	5b                   	pop    %rbx
	posix_irq_unlock(key);
    6f6d:	89 ef                	mov    %ebp,%edi
    6f6f:	5d                   	pop    %rbp
    6f70:	41 5c                	pop    %r12
    6f72:	e9 ec da ff ff       	jmpq   4a63 <posix_irq_unlock>

0000000000006f77 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    6f77:	f3 0f 1e fa          	endbr64 
    6f7b:	41 54                	push   %r12
    6f7d:	55                   	push   %rbp
    6f7e:	50                   	push   %rax
	return posix_irq_lock();
    6f7f:	e8 d1 da ff ff       	callq  4a55 <posix_irq_lock>
    6f84:	89 c5                	mov    %eax,%ebp
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    6f86:	e8 47 ca ff ff       	callq  39d2 <sys_clock_elapsed>
	posix_irq_unlock(key);
    6f8b:	89 ef                	mov    %ebp,%edi
    6f8d:	41 89 c4             	mov    %eax,%r12d
    6f90:	4c 03 25 79 6c 00 00 	add    0x6c79(%rip),%r12        # dc10 <curr_tick>
    6f97:	e8 c7 da ff ff       	callq  4a63 <posix_irq_unlock>
	}
	return t;
}
    6f9c:	4c 89 e0             	mov    %r12,%rax
    6f9f:	5a                   	pop    %rdx
    6fa0:	5d                   	pop    %rbp
    6fa1:	41 5c                	pop    %r12
    6fa3:	c3                   	retq   

0000000000006fa4 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    6fa4:	f3 0f 1e fa          	endbr64 
    6fa8:	50                   	push   %rax
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    6fa9:	e8 c9 ff ff ff       	callq  6f77 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    6fae:	5a                   	pop    %rdx
    6faf:	c3                   	retq   

0000000000006fb0 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    6fb0:	f3 0f 1e fa          	endbr64 
    6fb4:	50                   	push   %rax
	return posix_irq_lock();
    6fb5:	e8 9b da ff ff       	callq  4a55 <posix_irq_lock>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    6fba:	e8 2f ca ff ff       	callq  39ee <arch_cpu_idle>
    6fbf:	eb f4                	jmp    6fb5 <idle+0x5>

0000000000006fc1 <k_heap_init>:
#include <ksched.h>
#include <wait_q.h>
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
    6fc1:	f3 0f 1e fa          	endbr64 
    6fc5:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = (sys_dnode_t *)list;
    6fc9:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
    6fcd:	48 89 47 20          	mov    %rax,0x20(%rdi)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    6fd1:	e9 7f bc ff ff       	jmpq   2c55 <sys_heap_init>

0000000000006fd6 <statics_init>:
}

static int statics_init(const struct device *unused)
{
    6fd6:	f3 0f 1e fa          	endbr64 
    6fda:	53                   	push   %rbx
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    6fdb:	48 8d 1d 2e 63 00 00 	lea    0x632e(%rip),%rbx        # d310 <uart_msgq>
    6fe2:	48 3b 1d cf 3f 00 00 	cmp    0x3fcf(%rip),%rbx        # afb8 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    6fe9:	73 16                	jae    7001 <statics_init+0x2b>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    6feb:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    6fef:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    6ff3:	48 89 df             	mov    %rbx,%rdi
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    6ff6:	48 83 c3 28          	add    $0x28,%rbx
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    6ffa:	e8 c2 ff ff ff       	callq  6fc1 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    6fff:	eb e1                	jmp    6fe2 <statics_init+0xc>
	}
	return 0;
}
    7001:	31 c0                	xor    %eax,%eax
    7003:	5b                   	pop    %rbx
    7004:	c3                   	retq   

0000000000007005 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
    7005:	f3 0f 1e fa          	endbr64 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
    7009:	c3                   	retq   

Disassembly of section .fini:

000000000000700c <_fini>:
    700c:	f3 0f 1e fa          	endbr64 
    7010:	48 83 ec 08          	sub    $0x8,%rsp
    7014:	48 83 c4 08          	add    $0x8,%rsp
    7018:	c3                   	retq   
